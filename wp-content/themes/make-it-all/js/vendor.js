/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 57);
/******/ })
/************************************************************************/
/******/ ({

/***/ 20:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
} ( function( $ ) {

$.ui = $.ui || {};

return $.ui.version = "1.12.1";

} ) );


/***/ }),

/***/ 28:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(24) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
} ( function( $ ) {
return $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

} ) );


/***/ }),

/***/ 29:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(24) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

return $.widget;

} ) );


/***/ }),

/***/ 57:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(58);


/***/ }),

/***/ 58:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.$ = window.jQuery = __webpack_require__(20);

// Datepicker
__webpack_require__(59);

// Timepicker
__webpack_require__(60);
__webpack_require__(63);

// Bootstrap
window.Popper = __webpack_require__(64);
__webpack_require__(66);
__webpack_require__(67);

// Metrics
__webpack_require__(68);

// Turbolinks
window.Turbolinks = __webpack_require__(69);

// https://stackoverflow.com/a/8407771/2957677
// Modified by /1549818 to support dot notation
(function ($) {
	$.fn.serializeObject = function () {
		var shouldValidate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		var self = this,
		    json = {},
		    push_counters = {},
		    patterns = {
			"validate": /^[a-zA-Z][a-zA-Z0-9_]*(?:[\[\.](?:\d*|[a-zA-Z0-9_]+)[\]]?)*$/,
			"key": /[a-zA-Z0-9_]+|(?=\[\])/g,
			"push": /^$/,
			"fixed": /^\d+$/,
			"named": /^[a-zA-Z0-9_]+$/
		},
		    isValid = true,
		    $fields = $(this).find('input, select, textarea').not('input[type=radio]:not(:checked)'); // filters out non-checked radio fields

		this.build = function (base, key, value) {
			base[key] = value;
			return base;
		};

		this.push_counter = function (key) {
			if (push_counters[key] === undefined) {
				push_counters[key] = 0;
			}

			return push_counters[key]++;
		};

		if (shouldValidate) {
			$('.invalid-feedback').remove();
			$('.is-valid, .is-invalid, .card-header.red-highlight, .card-header.green-highlight').removeClass('is-valid is-invalid red-highlight green-highlight');

			clearTimeout(validationTimeout);

			validationTimeout = setTimeout(function () {
				$('.is-valid, .is-invalid, .card-header.red-highlight, .card-header.green-highlight').removeClass('is-valid is-invalid red-highlight green-highlight');
				$('.invalid-feedback').fadeOut(250, function () {
					$(this).remove();
				});
			}, 15000);
		}

		$fields.not(':disabled').map(function () {
			// skip invalid keys
			if (!patterns.validate.test(this.name)) {
				return;
			}

			var k,
			    keys = this.name.match(patterns.key),
			    merge = this.value,
			    reverse_key = this.name,
			    validation_rules = this.attributes.hasOwnProperty('validation') ? this.attributes.validation.value : null;

			if (shouldValidate && validation_rules !== null) {
				var response = $(this).validate();

				if (isValid) {
					isValid = response;
				}
			}

			while ((k = keys.pop()) !== undefined) {

				// adjust reverse_key
				reverse_key = reverse_key.replace(new RegExp("\\[" + k + "\\]$"), '');

				// push
				if (k.match(patterns.push)) {
					merge = self.build({}, self.push_counter(reverse_key), merge);
				}

				// fixed or named
				else if (k.match(patterns.fixed) || k.match(patterns.named)) {
						merge = self.build({}, k, merge);
					}
			}

			json = $.extend(true, json, merge);
		});

		json.isValid = function () {
			return isValid;
		};

		if (shouldValidate) {
			$(this).find('.card:not(.existing) .is-valid').closest('.card').find('.card-header').addClass('green-highlight'); // highlight all cards green first
			$(this).find('.card:not(.existing) .is-invalid').closest('.card').find('.card-header').removeClass('green-highlight').addClass('red-highlight'); // highlight any cards with errors in them

			// open accordion with error
			if ($(this).find('.view-accordion.fa-chevron-down').first().closest('.card-header.green-highlight').length === 1) {
				$(this).find('.card-header.red-highlight .view-accordion').click();
			}
		}

		return json;
	};

	$.fn.validate = function () {
		var $this = $(this),
		    value = $this.val(),
		    validationRules = $this.attr('validation').split('|'),
		    failedRules = [];

		for (var _i = 0; _i < validationRules.length; _i++) {
			var rule = validationRules[_i];

			switch (rule) {
				case "nullable":
					if (value === null || value === '') {
						validationRules = []; // break out of for
					}

					break;
				case (rule.match(/required/) || {}).input:
					if (value === null || value === '') {
						if (rule.split(':').length === 1) {
							failedRules.push('This field is required.');
						} else {
							failedRules.push(rule.split(':')[1]); // custom message can be attached to required
						}

						validationRules = []; // break out of for
					}

					break;
				case "integer":
					if (value.length > 0 && (isNaN(parseInt(value)) || !isFinite(value))) {
						failedRules.push('This field must be an whole number.');
					}

					break;
				case (rule.match(/max:/) || {}).input:
					if (value.length > 0 && value.length > Number(rule.split(':')[1])) {
						failedRules.push('This field must have less than ' + (Number(rule.split(':')[1]) + 1) + ' characters.');
					}

					break;
				case (rule.match(/min:/) || {}).input:
					if (value.length < Number(rule.split(':')[1])) {
						failedRules.push('This field must have at least ' + rule.split(':')[1] + ' characters.');
					}

					break;
				case (rule.match(/in:/) || {}).input:
					if (value.length > 0 && rule.split(':')[1].split(',').indexOf(value) === -1) {
						failedRules.push('This field must contain one of the following: ' + rule.split(':')[1].split(',') + '.');
					}

					break;
				case (rule.match(/not:/) || {}).input:
					if (value === rule.split(':')[1].split(/'/)[1]) {
						failedRules.push('This field has an invalid value.');
					}

					break;
				case (rule.match(/requires:/) || {}).input:
					if ($this.closest('form').find('input[name="' + rule.split(':')[1] + '"]').val() === '') {
						failedRules.push('This field is required.');
					}

					break;
				case "email":
					if (!/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(value)) {
						failedRules.push('This field must be an email.');
					}

					break;
				case "phone":
					if (!/^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/im.test(value.replace(' ', ''))) {
						failedRules.push('This field must be a phone number.');
					}

					break;
			}
		}

		if ($this.is('select')) {
			// style support for bootstrap-select
			if ($this.hasClass('add-hardware-device')) {
				if ($this.closest('.affected-items-section').find('.affected-items').find('li[data-type="hardware"]').length === 0) {
					failedRules.push('Add at least one hardware device.');
				}
			}

			$this = $this.siblings('button.dropdown-toggle');
		}

		if (failedRules.length > 0) {
			$this.addClass('is-invalid');

			if (!$this.parent().is('.assigned-to-options')) {
				var $invalidFeedback = $('<div class="invalid-feedback">');

				for (var i = 0; i < failedRules.length; i++) {
					$invalidFeedback.append(failedRules[i] + (i >= 1 ? '<br />' : ''));
				}

				$this.closest('.form-group').append($invalidFeedback);
			}

			return false;
		}

		$this.addClass('is-valid');

		return true;
	};
})(jQuery);

/**
 * Resolve a dot notation path string through an object
 * From https://stackoverflow.com/a/22129960/1549818
 */
Object.resolve = function (path, obj) {
	return path.split('.').reduce(function (prev, curr) {
		return prev ? prev[curr] : undefined;
	}, obj || self);
};

/***/ }),

/***/ 59:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// jscs:disable maximumLineLength
/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
/*!
 * jQuery UI Datepicker 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Datepicker
//>>group: Widgets
//>>description: Displays a calendar from an input or inline for selecting dates.
//>>docs: http://api.jqueryui.com/datepicker/
//>>demos: http://jqueryui.com/datepicker/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/datepicker.css
//>>css.theme: ../../themes/base/theme.css

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(20),
			__webpack_require__(24),
			__webpack_require__(28)
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

$.extend( $.ui, { datepicker: { version: "1.12.1" } } );

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {

		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {

			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[ "" ] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: [ "January","February","March","April","May","June",
			"July","August","September","October","November","December" ], // Names of months for drop-down and formatting
		monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
		dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
		dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
		dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend( this._defaults, this.regional[ "" ] );
	this.regional.en = $.extend( true, {}, this.regional[ "" ] );
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
}

$.extend( Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function( settings ) {
		datepicker_extendRemove( this._defaults, settings || {} );
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function( target, settings ) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = ( nodeName === "div" || nodeName === "span" );
		if ( !target.id ) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst( $( target ), inline );
		inst.settings = $.extend( {}, settings || {} );
		if ( nodeName === "input" ) {
			this._connectDatepicker( target, inst );
		} else if ( inline ) {
			this._inlineDatepicker( target, inst );
		}
	},

	/* Create a new instance object. */
	_newInst: function( target, inline ) {
		var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
		return { id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: ( !inline ? this.dpDiv : // presentation div
			datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function( target, inst ) {
		var input = $( target );
		inst.append = $( [] );
		inst.trigger = $( [] );
		if ( input.hasClass( this.markerClassName ) ) {
			return;
		}
		this._attachments( input, inst );
		input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
			on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
		this._autoSize( inst );
		$.data( target, "datepicker", inst );

		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function( input, inst ) {
		var showOn, buttonText, buttonImage,
			appendText = this._get( inst, "appendText" ),
			isRTL = this._get( inst, "isRTL" );

		if ( inst.append ) {
			inst.append.remove();
		}
		if ( appendText ) {
			inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
			input[ isRTL ? "before" : "after" ]( inst.append );
		}

		input.off( "focus", this._showDatepicker );

		if ( inst.trigger ) {
			inst.trigger.remove();
		}

		showOn = this._get( inst, "showOn" );
		if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
			input.on( "focus", this._showDatepicker );
		}
		if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
			buttonText = this._get( inst, "buttonText" );
			buttonImage = this._get( inst, "buttonImage" );
			inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
				$( "<img/>" ).addClass( this._triggerClass ).
					attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
				$( "<button type='button'></button>" ).addClass( this._triggerClass ).
					html( !buttonImage ? buttonText : $( "<img/>" ).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText } ) ) );
			input[ isRTL ? "before" : "after" ]( inst.trigger );
			inst.trigger.on( "click", function() {
				if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
					$.datepicker._hideDatepicker();
				} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker( input[ 0 ] );
				} else {
					$.datepicker._showDatepicker( input[ 0 ] );
				}
				return false;
			} );
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function( inst ) {
		if ( this._get( inst, "autoSize" ) && !inst.inline ) {
			var findMax, max, maxI, i,
				date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
				dateFormat = this._get( inst, "dateFormat" );

			if ( dateFormat.match( /[DM]/ ) ) {
				findMax = function( names ) {
					max = 0;
					maxI = 0;
					for ( i = 0; i < names.length; i++ ) {
						if ( names[ i ].length > max ) {
							max = names[ i ].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
					"monthNames" : "monthNamesShort" ) ) ) );
				date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
					"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
			}
			inst.input.attr( "size", this._formatDate( inst, date ).length );
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function( target, inst ) {
		var divSpan = $( target );
		if ( divSpan.hasClass( this.markerClassName ) ) {
			return;
		}
		divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
		$.data( target, "datepicker", inst );
		this._setDate( inst, this._getDefaultDate( inst ), true );
		this._updateDatepicker( inst );
		this._updateAlternate( inst );

		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}

		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function( input, date, onSelect, settings, pos ) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if ( !inst ) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $( "<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>" );
			this._dialogInput.on( "keydown", this._doKeyDown );
			$( "body" ).append( this._dialogInput );
			inst = this._dialogInst = this._newInst( this._dialogInput, false );
			inst.settings = {};
			$.data( this._dialogInput[ 0 ], "datepicker", inst );
		}
		datepicker_extendRemove( inst.settings, settings || {} );
		date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
		this._dialogInput.val( date );

		this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
		if ( !this._pos ) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
		}

		// Move input on screen for focus, but hidden behind dialog
		this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass( this._dialogClass );
		this._showDatepicker( this._dialogInput[ 0 ] );
		if ( $.blockUI ) {
			$.blockUI( this.dpDiv );
		}
		$.data( this._dialogInput[ 0 ], "datepicker", inst );
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function( target ) {
		var nodeName,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData( target, "datepicker" );
		if ( nodeName === "input" ) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass( this.markerClassName ).
				off( "focus", this._showDatepicker ).
				off( "keydown", this._doKeyDown ).
				off( "keypress", this._doKeyPress ).
				off( "keyup", this._doKeyUp );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			$target.removeClass( this.markerClassName ).empty();
		}

		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = false;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = false; } ).end().
				filter( "img" ).css( { opacity: "1.0", cursor: "" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().removeClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", false );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = true;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = true; } ).end().
				filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().addClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", true );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
		this._disabledInputs[ this._disabledInputs.length ] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function( target ) {
		if ( !target ) {
			return false;
		}
		for ( var i = 0; i < this._disabledInputs.length; i++ ) {
			if ( this._disabledInputs[ i ] === target ) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function( target ) {
		try {
			return $.data( target, "datepicker" );
		}
		catch ( err ) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function( target, name, value ) {
		var settings, date, minDate, maxDate,
			inst = this._getInst( target );

		if ( arguments.length === 2 && typeof name === "string" ) {
			return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
				( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
				this._get( inst, name ) ) : null ) );
		}

		settings = name || {};
		if ( typeof name === "string" ) {
			settings = {};
			settings[ name ] = value;
		}

		if ( inst ) {
			if ( this._curInst === inst ) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker( target, true );
			minDate = this._getMinMaxDate( inst, "min" );
			maxDate = this._getMinMaxDate( inst, "max" );
			datepicker_extendRemove( inst.settings, settings );

			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
				inst.settings.minDate = this._formatDate( inst, minDate );
			}
			if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
				inst.settings.maxDate = this._formatDate( inst, maxDate );
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker( target );
				} else {
					this._enableDatepicker( target );
				}
			}
			this._attachments( $( target ), inst );
			this._autoSize( inst );
			this._setDate( inst, date );
			this._updateAlternate( inst );
			this._updateDatepicker( inst );
		}
	},

	// Change method deprecated
	_changeDatepicker: function( target, name, value ) {
		this._optionDatepicker( target, name, value );
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function( target ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._updateDatepicker( inst );
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function( target, date ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._setDate( inst, date );
			this._updateDatepicker( inst );
			this._updateAlternate( inst );
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function( target, noDefault ) {
		var inst = this._getInst( target );
		if ( inst && !inst.inline ) {
			this._setDateFromField( inst, noDefault );
		}
		return ( inst ? this._getDate( inst ) : null );
	},

	/* Handle keystrokes. */
	_doKeyDown: function( event ) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst( event.target ),
			handled = true,
			isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );

		inst._keyEvent = true;
		if ( $.datepicker._datepickerShowing ) {
			switch ( event.keyCode ) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv );
						if ( sel[ 0 ] ) {
							$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
						}

						onSelect = $.datepicker._get( inst, "onSelect" );
						if ( onSelect ) {
							dateStr = $.datepicker._formatDate( inst );

							// Trigger custom callback
							onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							-$.datepicker._get( inst, "stepBigMonths" ) :
							-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							+$.datepicker._get( inst, "stepBigMonths" ) :
							+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // next month/year on page down/+ ctrl
				case 35: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._clearDate( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._gotoToday( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// -1 day on ctrl or command +left
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								-$.datepicker._get( inst, "stepBigMonths" ) :
								-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +left on Mac
						break;
				case 38: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, -7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// +1 day on ctrl or command +right
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								+$.datepicker._get( inst, "stepBigMonths" ) :
								+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +right
						break;
				case 40: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, +7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker( this );
		} else {
			handled = false;
		}

		if ( handled ) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function( event ) {
		var chars, chr,
			inst = $.datepicker._getInst( event.target );

		if ( $.datepicker._get( inst, "constrainInput" ) ) {
			chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
			chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
			return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function( event ) {
		var date,
			inst = $.datepicker._getInst( event.target );

		if ( inst.input.val() !== inst.lastVal ) {
			try {
				date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
					( inst.input ? inst.input.val() : null ),
					$.datepicker._getFormatConfig( inst ) );

				if ( date ) { // only if valid
					$.datepicker._setDateFromField( inst );
					$.datepicker._updateAlternate( inst );
					$.datepicker._updateDatepicker( inst );
				}
			}
			catch ( err ) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function( input ) {
		input = input.target || input;
		if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
			input = $( "input", input.parentNode )[ 0 ];
		}

		if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst( input );
		if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
			$.datepicker._curInst.dpDiv.stop( true, true );
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
			}
		}

		beforeShow = $.datepicker._get( inst, "beforeShow" );
		beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
		if ( beforeShowSettings === false ) {
			return;
		}
		datepicker_extendRemove( inst.settings, beforeShowSettings );

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField( inst );

		if ( $.datepicker._inDialog ) { // hide cursor
			input.value = "";
		}
		if ( !$.datepicker._pos ) { // position below input
			$.datepicker._pos = $.datepicker._findPos( input );
			$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$( input ).parents().each( function() {
			isFixed |= $( this ).css( "position" ) === "fixed";
			return !isFixed;
		} );

		offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
		$.datepicker._pos = null;

		//to avoid flashes on Firefox
		inst.dpDiv.empty();

		// determine sizing offscreen
		inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
		$.datepicker._updateDatepicker( inst );

		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset( inst, offset, isFixed );
		inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
			"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
			left: offset.left + "px", top: offset.top + "px" } );

		if ( !inst.inline ) {
			showAnim = $.datepicker._get( inst, "showAnim" );
			duration = $.datepicker._get( inst, "duration" );
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
			} else {
				inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.trigger( "focus" );
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function( inst ) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append( this._generateHTML( inst ) );
		this._attachHandlers( inst );

		var origyearshtml,
			numMonths = this._getNumberOfMonths( inst ),
			cols = numMonths[ 1 ],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
		if ( cols > 1 ) {
			inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
		}
		inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-multi" );
		inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-rtl" );

		if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.trigger( "focus" );
		}

		// Deffered render of the years select (to avoid flashes on Firefox)
		if ( inst.yearshtml ) {
			origyearshtml = inst.yearshtml;
			setTimeout( function() {

				//assure that inst.yearshtml didn't change.
				if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
					inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
				}
				origyearshtml = inst.yearshtml = null;
			}, 0 );
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function( inst, offset, isFixed ) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
			viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );

		offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
		offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
		offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;

		// Now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
			Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
		offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
			Math.abs( dpHeight + inputHeight ) : 0 );

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function( obj ) {
		var position,
			inst = this._getInst( obj ),
			isRTL = this._get( inst, "isRTL" );

		while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
			obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
		}

		position = $( obj ).offset();
		return [ position.left, position.top ];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function( input ) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
			return;
		}

		if ( this._datepickerShowing ) {
			showAnim = this._get( inst, "showAnim" );
			duration = this._get( inst, "duration" );
			postProcess = function() {
				$.datepicker._tidyDialog( inst );
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
			} else {
				inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
					( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
			}

			if ( !showAnim ) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get( inst, "onClose" );
			if ( onClose ) {
				onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
			}

			this._lastInput = null;
			if ( this._inDialog ) {
				this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
				if ( $.blockUI ) {
					$.unblockUI();
					$( "body" ).append( this.dpDiv );
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function( inst ) {
		inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function( event ) {
		if ( !$.datepicker._curInst ) {
			return;
		}

		var $target = $( event.target ),
			inst = $.datepicker._getInst( $target[ 0 ] );

		if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
				$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
				!$target.hasClass( $.datepicker.markerClassName ) &&
				!$target.closest( "." + $.datepicker._triggerClass ).length &&
				$.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
			( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function( id, offset, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}
		this._adjustInstDate( inst, offset +
			( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
			period );
		this._updateDatepicker( inst );
	},

	/* Action for current link. */
	_gotoToday: function( id ) {
		var date,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function( id, select, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
		inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
			parseInt( select.options[ select.selectedIndex ].value, 10 );

		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a day. */
	_selectDay: function( id, month, year, td ) {
		var inst,
			target = $( id );

		if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}

		inst = this._getInst( target[ 0 ] );
		inst.selectedDay = inst.currentDay = $( "a", td ).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate( id, this._formatDate( inst,
			inst.currentDay, inst.currentMonth, inst.currentYear ) );
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function( id ) {
		var target = $( id );
		this._selectDate( target, "" );
	},

	/* Update the input field with the selected date. */
	_selectDate: function( id, dateStr ) {
		var onSelect,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
		if ( inst.input ) {
			inst.input.val( dateStr );
		}
		this._updateAlternate( inst );

		onSelect = this._get( inst, "onSelect" );
		if ( onSelect ) {
			onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
		} else if ( inst.input ) {
			inst.input.trigger( "change" ); // fire the change event
		}

		if ( inst.inline ) {
			this._updateDatepicker( inst );
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[ 0 ];
			if ( typeof( inst.input[ 0 ] ) !== "object" ) {
				inst.input.trigger( "focus" ); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function( inst ) {
		var altFormat, date, dateStr,
			altField = this._get( inst, "altField" );

		if ( altField ) { // update alternate field too
			altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
			date = this._getDate( inst );
			dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
			$( altField ).val( dateStr );
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function( date ) {
		var day = date.getDay();
		return [ ( day > 0 && day < 6 ), "" ];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function( date ) {
		var time,
			checkDate = new Date( date.getTime() );

		// Find Thursday of this week starting on Monday
		checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );

		time = checkDate.getTime();
		checkDate.setMonth( 0 ); // Compare with Jan 1
		checkDate.setDate( 1 );
		return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function( format, value, settings ) {
		if ( format == null || value == null ) {
			throw "Invalid arguments";
		}

		value = ( typeof value === "object" ? value.toString() : value + "" );
		if ( value === "" ) {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
			shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Extract a number from the string value
			getNumber = function( match ) {
				var isDoubled = lookAhead( match ),
					size = ( match === "@" ? 14 : ( match === "!" ? 20 :
					( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
					minSize = ( match === "y" ? size : 1 ),
					digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
					num = value.substring( iValue ).match( digits );
				if ( !num ) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[ 0 ].length;
				return parseInt( num[ 0 ], 10 );
			},

			// Extract a name from the string value and convert to an index
			getName = function( match, shortNames, longNames ) {
				var index = -1,
					names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
						return [ [ k, v ] ];
					} ).sort( function( a, b ) {
						return -( a[ 1 ].length - b[ 1 ].length );
					} );

				$.each( names, function( i, pair ) {
					var name = pair[ 1 ];
					if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
						index = pair[ 0 ];
						iValue += name.length;
						return false;
					}
				} );
				if ( index !== -1 ) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},

			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d":
						day = getNumber( "d" );
						break;
					case "D":
						getName( "D", dayNamesShort, dayNames );
						break;
					case "o":
						doy = getNumber( "o" );
						break;
					case "m":
						month = getNumber( "m" );
						break;
					case "M":
						month = getName( "M", monthNamesShort, monthNames );
						break;
					case "y":
						year = getNumber( "y" );
						break;
					case "@":
						date = new Date( getNumber( "@" ) );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if ( lookAhead( "'" ) ) {
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if ( iValue < value.length ) {
			extra = value.substr( iValue );
			if ( !/^\s+/.test( extra ) ) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if ( year === -1 ) {
			year = new Date().getFullYear();
		} else if ( year < 100 ) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				( year <= shortYearCutoff ? 0 : -100 );
		}

		if ( doy > -1 ) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth( year, month - 1 );
				if ( day <= dim ) {
					break;
				}
				month++;
				day -= dim;
			} while ( true );
		}

		date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
		if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
		Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function( format, date, settings ) {
		if ( !date ) {
			return "";
		}

		var iFormat,
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Format a number, with leading zero if necessary
			formatNumber = function( match, value, len ) {
				var num = "" + value;
				if ( lookAhead( match ) ) {
					while ( num.length < len ) {
						num = "0" + num;
					}
				}
				return num;
			},

			// Format a name, short or long as requested
			formatName = function( match, value, shortNames, longNames ) {
				return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
			},
			output = "",
			literal = false;

		if ( date ) {
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						output += format.charAt( iFormat );
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d":
							output += formatNumber( "d", date.getDate(), 2 );
							break;
						case "D":
							output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
							break;
						case "o":
							output += formatNumber( "o",
								Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
							break;
						case "m":
							output += formatNumber( "m", date.getMonth() + 1, 2 );
							break;
						case "M":
							output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
							break;
						case "y":
							output += ( lookAhead( "y" ) ? date.getFullYear() :
								( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if ( lookAhead( "'" ) ) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt( iFormat );
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function( format ) {
		var iFormat,
			chars = "",
			literal = false,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					chars += format.charAt( iFormat );
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if ( lookAhead( "'" ) ) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt( iFormat );
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function( inst, name ) {
		return inst.settings[ name ] !== undefined ?
			inst.settings[ name ] : this._defaults[ name ];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function( inst, noDefault ) {
		if ( inst.input.val() === inst.lastVal ) {
			return;
		}

		var dateFormat = this._get( inst, "dateFormat" ),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate( inst ),
			date = defaultDate,
			settings = this._getFormatConfig( inst );

		try {
			date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
		} catch ( event ) {
			dates = ( noDefault ? "" : dates );
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = ( dates ? date.getDate() : 0 );
		inst.currentMonth = ( dates ? date.getMonth() : 0 );
		inst.currentYear = ( dates ? date.getFullYear() : 0 );
		this._adjustInstDate( inst );
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function( inst ) {
		return this._restrictMinMax( inst,
			this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function( inst, date, defaultDate ) {
		var offsetNumeric = function( offset ) {
				var date = new Date();
				date.setDate( date.getDate() + offset );
				return date;
			},
			offsetString = function( offset ) {
				try {
					return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
						offset, $.datepicker._getFormatConfig( inst ) );
				}
				catch ( e ) {

					// Ignore
				}

				var date = ( offset.toLowerCase().match( /^c/ ) ?
					$.datepicker._getDate( inst ) : null ) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec( offset );

				while ( matches ) {
					switch ( matches[ 2 ] || "d" ) {
						case "d" : case "D" :
							day += parseInt( matches[ 1 ], 10 ); break;
						case "w" : case "W" :
							day += parseInt( matches[ 1 ], 10 ) * 7; break;
						case "m" : case "M" :
							month += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
						case "y": case "Y" :
							year += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
					}
					matches = pattern.exec( offset );
				}
				return new Date( year, month, day );
			},
			newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
				( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );

		newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
		if ( newDate ) {
			newDate.setHours( 0 );
			newDate.setMinutes( 0 );
			newDate.setSeconds( 0 );
			newDate.setMilliseconds( 0 );
		}
		return this._daylightSavingAdjust( newDate );
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function( date ) {
		if ( !date ) {
			return null;
		}
		date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function( inst, date, noChange ) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
			this._notifyChange( inst );
		}
		this._adjustInstDate( inst );
		if ( inst.input ) {
			inst.input.val( clear ? "" : this._formatDate( inst ) );
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function( inst ) {
		var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
			this._daylightSavingAdjust( new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function( inst ) {
		var stepMonths = this._get( inst, "stepMonths" ),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find( "[data-handler]" ).map( function() {
			var handler = {
				prev: function() {
					$.datepicker._adjustDate( id, -stepMonths, "M" );
				},
				next: function() {
					$.datepicker._adjustDate( id, +stepMonths, "M" );
				},
				hide: function() {
					$.datepicker._hideDatepicker();
				},
				today: function() {
					$.datepicker._gotoToday( id );
				},
				selectDay: function() {
					$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
					return false;
				},
				selectMonth: function() {
					$.datepicker._selectMonthYear( id, this, "M" );
					return false;
				},
				selectYear: function() {
					$.datepicker._selectMonthYear( id, this, "Y" );
					return false;
				}
			};
			$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
		} );
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function( inst ) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
			isRTL = this._get( inst, "isRTL" ),
			showButtonPanel = this._get( inst, "showButtonPanel" ),
			hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
			navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
			numMonths = this._getNumberOfMonths( inst ),
			showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
			stepMonths = this._get( inst, "stepMonths" ),
			isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
			currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
				new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if ( drawMonth < 0 ) {
			drawMonth += 12;
			drawYear--;
		}
		if ( maxDate ) {
			maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
				maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
			maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
			while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
				drawMonth--;
				if ( drawMonth < 0 ) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get( inst, "prevText" );
		prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );

		nextText = this._get( inst, "nextText" );
		nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );

		currentText = this._get( inst, "currentText" );
		gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
		currentText = ( !navigationAsDateFormat ? currentText :
			this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );

		controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get( inst, "closeText" ) + "</button>" : "" );

		buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
			( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";

		firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
		firstDay = ( isNaN( firstDay ) ? 0 : firstDay );

		showWeek = this._get( inst, "showWeek" );
		dayNames = this._get( inst, "dayNames" );
		dayNamesMin = this._get( inst, "dayNamesMin" );
		monthNames = this._get( inst, "monthNames" );
		monthNamesShort = this._get( inst, "monthNamesShort" );
		beforeShowDay = this._get( inst, "beforeShowDay" );
		showOtherMonths = this._get( inst, "showOtherMonths" );
		selectOtherMonths = this._get( inst, "selectOtherMonths" );
		defaultDate = this._getDefaultDate( inst );
		html = "";

		for ( row = 0; row < numMonths[ 0 ]; row++ ) {
			group = "";
			this.maxRows = 4;
			for ( col = 0; col < numMonths[ 1 ]; col++ ) {
				selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
				cornerClass = " ui-corner-all";
				calender = "";
				if ( isMultiMonth ) {
					calender += "<div class='ui-datepicker-group";
					if ( numMonths[ 1 ] > 1 ) {
						switch ( col ) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
							case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
					( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
					this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
				for ( dow = 0; dow < 7; dow++ ) { // days of the week
					day = ( dow + firstDay ) % 7;
					thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
						"<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
				if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
					inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
				}
				leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
				curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
				numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
				for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
					calender += "<tr>";
					tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
					for ( dow = 0; dow < 7; dow++ ) { // create date picker days
						daySettings = ( beforeShowDay ?
							beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
						otherMonth = ( printDate.getMonth() !== drawMonth );
						unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
							( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
						tbody += "<td class='" +
							( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
							( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
							( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
							( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?

							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "" ) + // highlight selected day
							( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
							( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
							( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
							( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
							( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
							( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
							( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
							( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
							( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
						printDate.setDate( printDate.getDate() + 1 );
						printDate = this._daylightSavingAdjust( printDate );
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if ( drawMonth > 11 ) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
							( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort ) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get( inst, "changeMonth" ),
			changeYear = this._get( inst, "changeYear" ),
			showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// Month selection
		if ( secondary || !changeMonth ) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
		} else {
			inMinYear = ( minDate && minDate.getFullYear() === drawYear );
			inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++ ) {
				if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
					monthHtml += "<option value='" + month + "'" +
						( month === drawMonth ? " selected='selected'" : "" ) +
						">" + monthNamesShort[ month ] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if ( !showMonthAfterYear ) {
			html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
		}

		// Year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if ( secondary || !changeYear ) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {

				// determine range of years to display
				years = this._get( inst, "yearRange" ).split( ":" );
				thisYear = new Date().getFullYear();
				determineYear = function( value ) {
					var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
						( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
						parseInt( value, 10 ) ) );
					return ( isNaN( year ) ? thisYear : year );
				};
				year = determineYear( years[ 0 ] );
				endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
				year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
				endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for ( ; year <= endYear; year++ ) {
					inst.yearshtml += "<option value='" + year + "'" +
						( year === drawYear ? " selected='selected'" : "" ) +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get( inst, "yearSuffix" );
		if ( showMonthAfterYear ) {
			html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function( inst, offset, period ) {
		var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
			month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
			day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
			date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if ( period === "M" || period === "Y" ) {
			this._notifyChange( inst );
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function( inst, date ) {
		var minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			newDate = ( minDate && date < minDate ? minDate : date );
		return ( maxDate && newDate > maxDate ? maxDate : newDate );
	},

	/* Notify change of month/year. */
	_notifyChange: function( inst ) {
		var onChange = this._get( inst, "onChangeMonthYear" );
		if ( onChange ) {
			onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
				[ inst.selectedYear, inst.selectedMonth + 1, inst ] );
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function( inst ) {
		var numMonths = this._get( inst, "numberOfMonths" );
		return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function( inst, minMax ) {
		return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function( year, month ) {
		return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function( year, month ) {
		return new Date( year, month, 1 ).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function( inst, offset, curYear, curMonth ) {
		var numMonths = this._getNumberOfMonths( inst ),
			date = this._daylightSavingAdjust( new Date( curYear,
			curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );

		if ( offset < 0 ) {
			date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
		}
		return this._isInRange( inst, date );
	},

	/* Is the given date in the accepted range? */
	_isInRange: function( inst, date ) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			minYear = null,
			maxYear = null,
			years = this._get( inst, "yearRange" );
			if ( years ) {
				yearSplit = years.split( ":" );
				currentYear = new Date().getFullYear();
				minYear = parseInt( yearSplit[ 0 ], 10 );
				maxYear = parseInt( yearSplit[ 1 ], 10 );
				if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
					minYear += currentYear;
				}
				if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
					maxYear += currentYear;
				}
			}

		return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
			( !maxDate || date.getTime() <= maxDate.getTime() ) &&
			( !minYear || date.getFullYear() >= minYear ) &&
			( !maxYear || date.getFullYear() <= maxYear ) );
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function( inst ) {
		var shortYearCutoff = this._get( inst, "shortYearCutoff" );
		shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
		return { shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
			monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
	},

	/* Format the given date for display. */
	_formatDate: function( inst, day, month, year ) {
		if ( !day ) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = ( day ? ( typeof day === "object" ? day :
			this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
			this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
		return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
	}
} );

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover( dpDiv ) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.on( "mouseout", selector, function() {
			$( this ).removeClass( "ui-state-hover" );
			if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-prev-hover" );
			}
			if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-next-hover" );
			}
		} )
		.on( "mouseover", selector, datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
		$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
		$( this ).addClass( "ui-state-hover" );
		if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-prev-hover" );
		}
		if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-next-hover" );
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove( target, props ) {
	$.extend( target, props );
	for ( var name in props ) {
		if ( props[ name ] == null ) {
			target[ name ] = props[ name ];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function( options ) {

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if ( !$.datepicker.initialized ) {
		$( document ).on( "mousedown", $.datepicker._checkExternalClick );
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
		$( "body" ).append( $.datepicker.dpDiv );
	}

	var otherArgs = Array.prototype.slice.call( arguments, 1 );
	if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	return this.each( function() {
		typeof options === "string" ?
			$.datepicker[ "_" + options + "Datepicker" ].
				apply( $.datepicker, [ this ].concat( otherArgs ) ) :
			$.datepicker._attachDatepicker( this, options );
	} );
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.12.1";

return $.datepicker;

} ) );


/***/ }),

/***/ 60:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Slider 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slider
//>>group: Widgets
//>>description: Displays a flexible slider with ranges and accessibility via keyboard.
//>>docs: http://api.jqueryui.com/slider/
//>>demos: http://jqueryui.com/slider/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/slider.css
//>>css.theme: ../../themes/base/theme.css

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(20),
			__webpack_require__(61),
			__webpack_require__(28),
			__webpack_require__(24),
			__webpack_require__(29)
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

return $.widget( "ui.slider", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		classes: {
			"ui-slider": "ui-corner-all",
			"ui-slider-handle": "ui-corner-all",

			// Note: ui-widget-header isn't the most fittingly semantic framework class for this
			// element, but worked best visually with a variety of themes
			"ui-slider-range": "ui-corner-all ui-widget-header"
		},
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// Callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// Number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();
		this._calculateNewMax();

		this._addClass( "ui-slider ui-slider-" + this.orientation,
			"ui-widget ui-widget-content" );

		this._refresh();

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ),
			handle = "<span tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );

		this.handle = this.handles.eq( 0 );

		this.handles.each( function( i ) {
			$( this )
				.data( "ui-slider-handle-index", i )
				.attr( "tabIndex", 0 );
		} );
	},

	_createRange: function() {
		var options = this.options;

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[ 0 ], options.values[ 0 ] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice( 0 );
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div>" )
					.appendTo( this.element );

				this._addClass( this.range, "ui-slider-range" );
			} else {
				this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );

				// Handle range switching from true to min/max
				this.range.css( {
					"left": "",
					"bottom": ""
				} );
			}
			if ( options.range === "min" || options.range === "max" ) {
				this._addClass( this.range, "ui-slider-range-" + options.range );
			}
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each( function( i ) {
			var thisDistance = Math.abs( normValue - that.values( i ) );
			if ( ( distance > thisDistance ) ||
				( distance === thisDistance &&
					( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		} );

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		this._addClass( closestHandle, null, "ui-state-active" );
		closestHandle.trigger( "focus" );

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -
				( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +
				( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this._removeClass( this.handles, null, "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left -
				( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top -
				( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_uiHash: function( index, value, values ) {
		var uiHash = {
			handle: this.handles[ index ],
			handleIndex: index,
			value: value !== undefined ? value : this.value()
		};

		if ( this._hasMultipleValues() ) {
			uiHash.value = value !== undefined ? value : this.values( index );
			uiHash.values = values || this.values();
		}

		return uiHash;
	},

	_hasMultipleValues: function() {
		return this.options.values && this.options.values.length;
	},

	_start: function( event, index ) {
		return this._trigger( "start", event, this._uiHash( index ) );
	},

	_slide: function( event, index, newVal ) {
		var allowed, otherVal,
			currentValue = this.value(),
			newValues = this.values();

		if ( this._hasMultipleValues() ) {
			otherVal = this.values( index ? 0 : 1 );
			currentValue = this.values( index );

			if ( this.options.values.length === 2 && this.options.range === true ) {
				newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );
			}

			newValues[ index ] = newVal;
		}

		if ( newVal === currentValue ) {
			return;
		}

		allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );

		// A slide can be canceled by returning false from the slide callback
		if ( allowed === false ) {
			return;
		}

		if ( this._hasMultipleValues() ) {
			this.values( index, newVal );
		} else {
			this.value( newVal );
		}
	},

	_stop: function( event, index ) {
		this._trigger( "stop", event, this._uiHash( index ) );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;
			this._trigger( "change", event, this._uiHash( index ) );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this._hasMultipleValues() ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this._removeClass( "ui-slider-horizontal ui-slider-vertical" )
					._addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				if ( this.options.range ) {
					this._refreshRange( value );
				}

				// Reset positioning from previous orientation
				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();

				// Start from the last handle to prevent unreachable handles (#9046)
				for ( i = valsLength - 1; i >= 0; i-- ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "step":
			case "min":
			case "max":
				this._animateOff = true;
				this._calculateNewMax();
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this._hasMultipleValues() ) {

			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i += 1 ) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// Returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = ( val - this._valueMin() ) % step,
			alignValue = val - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed( 5 ) );
	},

	_calculateNewMax: function() {
		var max = this.options.max,
			min = this._valueMin(),
			step = this.options.step,
			aboveMin = Math.round( ( max - min ) / step ) * step;
		max = aboveMin + min;
		if ( max > this.options.max ) {

			//If max is not divisible by step, rounding off may increase its value
			max -= step;
		}
		this.max = parseFloat( max.toFixed( this._precision() ) );
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.max;
	},

	_refreshRange: function( orientation ) {
		if ( orientation === "vertical" ) {
			this.range.css( { "width": "", "left": "" } );
		}
		if ( orientation === "horizontal" ) {
			this.range.css( { "height": "", "bottom": "" } );
		}
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this._hasMultipleValues() ) {
			this.handles.each( function( i ) {
				valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -
					that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								left: valPercent + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								width: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								bottom: ( valPercent ) + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								height: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					}
				}
				lastValPercent = valPercent;
			} );
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						this._addClass( $( event.target ), null, "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this._hasMultipleValues() ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				this._removeClass( $( event.target ), null, "ui-state-active" );
			}
		}
	}
} );

} ) );


/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(20),
			__webpack_require__(62),
			__webpack_require__(24),
			__webpack_require__(29)
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

var mouseHandled = false;
$( document ).on( "mouseup", function() {
	mouseHandled = false;
} );

return $.widget( "ui.mouse", {
	version: "1.12.1",
	options: {
		cancel: "input, textarea, button, select, option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.on( "mousedown." + this.widgetName, function( event ) {
				return that._mouseDown( event );
			} )
			.on( "click." + this.widgetName, function( event ) {
				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
					$.removeData( event.target, that.widgetName + ".preventClickEvent" );
					event.stopImmediatePropagation();
					return false;
				}
			} );

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off( "." + this.widgetName );
		if ( this._mouseMoveDelegate ) {
			this.document
				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );
		}
	},

	_mouseDown: function( event ) {

		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// We may have missed mouseup (out of window)
		( this._mouseStarted && this._mouseUp( event ) );

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = ( event.which === 1 ),

			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
				$( event.target ).closest( this.options.cancel ).length : false );
		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if ( !this.mouseDelayMet ) {
			this._mouseDelayTimer = setTimeout( function() {
				that.mouseDelayMet = true;
			}, this.options.delay );
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted = ( this._mouseStart( event ) !== false );
			if ( !this._mouseStarted ) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
			$.removeData( event.target, this.widgetName + ".preventClickEvent" );
		}

		// These delegates are required to keep context
		this._mouseMoveDelegate = function( event ) {
			return that._mouseMove( event );
		};
		this._mouseUpDelegate = function( event ) {
			return that._mouseUp( event );
		};

		this.document
			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function( event ) {

		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {

			// IE mouseup check - mouseup happened when mouse was out of window
			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
					!event.button ) {
				return this._mouseUp( event );

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {

				// Support: Safari <=8 - 9
				// Safari sets which to 0 if you press any of the following keys
				// during a drag (#14461)
				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
					this.ignoreMissingWhich = true;
				} else if ( !this.ignoreMissingWhich ) {
					return this._mouseUp( event );
				}
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if ( this._mouseStarted ) {
			this._mouseDrag( event );
			return event.preventDefault();
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted =
				( this._mouseStart( this._mouseDownEvent, event ) !== false );
			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
		}

		return !this._mouseStarted;
	},

	_mouseUp: function( event ) {
		this.document
			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if ( this._mouseStarted ) {
			this._mouseStarted = false;

			if ( event.target === this._mouseDownEvent.target ) {
				$.data( event.target, this.widgetName + ".preventClickEvent", true );
			}

			this._mouseStop( event );
		}

		if ( this._mouseDelayTimer ) {
			clearTimeout( this._mouseDelayTimer );
			delete this._mouseDelayTimer;
		}

		this.ignoreMissingWhich = false;
		mouseHandled = false;
		event.preventDefault();
	},

	_mouseDistanceMet: function( event ) {
		return ( Math.max(
				Math.abs( this._mouseDownEvent.pageX - event.pageX ),
				Math.abs( this._mouseDownEvent.pageY - event.pageY )
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function( /* event */ ) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function( /* event */ ) {},
	_mouseDrag: function( /* event */ ) {},
	_mouseStop: function( /* event */ ) {},
	_mouseCapture: function( /* event */ ) { return true; }
} );

} ) );


/***/ }),

/***/ 62:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(24) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
} ( function( $ ) {

// This file is deprecated
return $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
} ) );


/***/ }),

/***/ 63:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! jQuery Timepicker Addon - v1.6.3 - 2016-04-20
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2016 Trent Richardson; Licensed MIT */
(function ($) {

	/*
 * Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
 */
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
 * Extend jQueryUI, get it started with our version number
 */
	$.extend($.ui, {
		timepicker: {
			version: "1.6.3"
		}
	});

	/*
 * Timepicker manager.
 * Use the singleton instance of this class, $.timepicker, to interact with the time picker.
 * Settings for (groups of) time pickers are maintained in an instance object,
 * allowing multiple different settings on the same page.
 */
	var Timepicker = function Timepicker() {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			timeOnlyShowDate: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			maxTime: null,
			minTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			altRedirectFocus: true,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			oneLine: false,
			defaultValue: null,
			parse: 'strict',
			afterInject: null
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		maxTime: null,
		minTime: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour', 'minute', 'second', 'millisec', 'microsec'],
		support: {},
		control: null,

		/*
  * Override the default settings for all instances of the time picker.
  * @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
  * @return {Object} the manager object
  */
		setDefaults: function setDefaults(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
  * Create a new Timepicker instance
  */
		_newInst: function _newInst($input, opts) {
			var tp_inst = new Timepicker(),
			    inlineSettings = {},
			    fns = {},
			    overrides,
			    i;

			for (var attrName in this._defaults) {
				if (this._defaults.hasOwnProperty(attrName)) {
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

			overrides = {
				beforeShow: function beforeShow(input, dp_inst) {
					if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
						return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
					}
				},
				onChangeMonthYear: function onChangeMonthYear(year, month, dp_inst) {
					// Update the time as well : this prevents the time from disappearing from the $input field.
					// tp_inst._updateDateTime(dp_inst);
					if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
						tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
					}
				},
				onClose: function onClose(dateText, dp_inst) {
					if (tp_inst.timeDefined === true && $input.val() !== '') {
						tp_inst._updateDateTime(dp_inst);
					}
					if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
						tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
					}
				}
			};
			for (i in overrides) {
				if (overrides.hasOwnProperty(i)) {
					fns[i] = opts[i] || this._defaults[i] || null;
				}
			}

			tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
				evnts: fns,
				timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
			});
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(tp_inst._defaults.timeFormat + (tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : '') + (tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : ''));

			// controlType is string - key to our this._controls
			if (typeof tp_inst._defaults.controlType === 'string') {
				if (tp_inst._defaults.controlType === 'slider' && typeof $.ui.slider === 'undefined') {
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else {
					tp_inst.control = tp_inst._defaults.controlType;
				}

			// prep the timezone options
			var timezoneList = [-720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl = timezoneList.length,
			    tzi = 0,
			    tzv = null;
			if (tzl > 0 && _typeof(timezoneList[0]) !== 'object') {
				for (; tzi < tzl; tzi++) {
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : new Date().getTimezoneOffset() * -1;
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin : tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin : tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin : tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin : tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin : tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (tp_inst._defaults.altField) {
				tp_inst.$altInput = $(tp_inst._defaults.altField);
				if (tp_inst._defaults.altRedirectFocus === true) {
					tp_inst.$altInput.css({
						cursor: 'pointer'
					}).focus(function () {
						$input.trigger("focus");
					});
				}
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function () {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
  * add our sliders to the calendar
  */
		_addTimePicker: function _addTimePicker(dp_inst) {
			var currDT = $.trim(this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val());

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
			this._afterInject();
		},

		/*
  * parse the time string from input value or _setTime
  */
		_parseTime: function _parseTime(timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
  * Handle callback option after injecting timepicker
  */
		_afterInject: function _afterInject() {
			var o = this.inst.settings;
			if ($.isFunction(o.afterInject)) {
				o.afterInject.call(this);
			}
		},

		/*
  * generate and inject html for timepicker into ui datepicker
  */
		_injectTimePicker: function _injectTimePicker() {
			var $dp = this.inst.dpDiv,
			    o = this.inst.settings,
			    tp_inst = this,
			    litem = '',
			    uitem = '',
			    show = null,
			    max = {},
			    gridSize = {},
			    size = null,
			    i = 0,
			    l = 0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' ui_tpicker_unit_hide',
				    html = '<div class="ui-timepicker-div' + (o.isRTL ? ' ui-timepicker-rtl' : '') + (o.oneLine && o.controlType === 'select' ? ' ui-timepicker-oneLine' : '') + '"><dl>' + '<dt class="ui_tpicker_time_label' + (o.showTime ? '' : noDisplay) + '">' + o.timeText + '</dt>' + '<dd class="ui_tpicker_time ' + (o.showTime ? '' : noDisplay) + '"><input class="ui_tpicker_time_input" ' + (o.timeInput ? '' : 'disabled') + '/></dd>';

				// Create the markup
				for (i = 0, l = this.units.length; i < l; i++) {
					litem = this.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt(o[litem + 'Max'] - (o[litem + 'Max'] - o[litem + 'Min']) % o['step' + uitem], 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_' + litem + '_label' + (show ? '' : noDisplay) + '">' + o[litem + 'Text'] + '</dt>' + '<dd class="ui_tpicker_' + litem + (show ? '' : noDisplay) + '"><div class="ui_tpicker_' + litem + '_slider' + (show ? '' : noDisplay) + '"></div>';

					if (show && o[litem + 'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if (litem === 'hour') {
							for (var h = o[litem + 'Min']; h <= max[litem]; h += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm ? 'hht' : 'HH', { hour: h }, o);
								html += '<td data-for="' + litem + '">' + tmph + '</td>';
							}
						} else {
							for (var m = o[litem + 'Min']; m <= max[litem]; m += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="' + litem + '">' + (m < 10 ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}

				// Timezone
				var showTz = o.showTimezone !== null ? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label' + (showTz ? '' : noDisplay) + '">' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone' + (showTz ? '' : noDisplay) + '"></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}

				// add sliders, adjust grids, add events
				for (i = 0, l = tp_inst.units.length; i < l; i++) {
					litem = tp_inst.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// add the slider
					tp_inst[litem + '_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_' + litem + '_slider'), litem, tp_inst[litem], o[litem + 'Min'], max[litem], o['step' + uitem]);

					// adjust the grid and add click event
					if (show && o[litem + 'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem + 'Grid'] / (max[litem] - o[litem + 'Min']);
						$tp.find('.ui_tpicker_' + litem + ' table').css({
							width: size + "%",
							marginLeft: o.isRTL ? '0' : size / (-2 * gridSize[litem]) + "%",
							marginRight: o.isRTL ? size / (-2 * gridSize[litem]) + "%" : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function (e) {
							var $t = $(this),
							    h = $t.html(),
							    n = parseInt(h.replace(/[^0-9]/g), 10),
							    ap = h.replace(/[^apm]/ig),
							    f = $t.data('for'); // loses scope, so we use data-for

							if (f === 'hour') {
								if (ap.indexOf('p') !== -1 && n < 12) {
									n += 12;
								} else {
									if (ap.indexOf('a') !== -1 && n === 12) {
										n = 0;
									}
								}
							}

							tp_inst.control.value(tp_inst, tp_inst[f + '_slider'], litem, n);

							tp_inst._onTimeChange();
							tp_inst._onSelectHandler();
						}).css({
							cursor: 'pointer',
							width: 100 / gridSize[litem] + '%',
							textAlign: 'center',
							overflow: 'hidden'
						});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function (val, idx) {
					return $("<option />").val((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.value : val).text((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.label : val);
				}));
				if (typeof this.timezone !== "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12).getTimezoneOffset() * -1;
					if (local_timezone === this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof this.hour !== "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function () {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
					tp_inst._afterInject();
				});
				// End timezone options

				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time_input');
				this.$timeObj.change(function () {
					var timeFormat = tp_inst.inst.settings.timeFormat;
					var parsedTime = $.datepicker.parseTime(timeFormat, this.value);
					var update = new Date();
					if (parsedTime) {
						update.setHours(parsedTime.hour);
						update.setMinutes(parsedTime.minute);
						update.setSeconds(parsedTime.second);
						$.datepicker._setTime(tp_inst.inst, update);
					} else {
						this.value = tp_inst.formattedTime;
						this.blur();
					}
				});

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
					    rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;

					setTimeout(function () {
						// fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function () {
									var $g = $(this),
									    oldWidth = $g.outerWidth(),
									    oldMarginLeft = $g.css(rtl ? 'marginRight' : 'marginLeft').toString().replace('%', ''),
									    newWidth = oldWidth - sliderAccessWidth,
									    newMarginLeft = oldMarginLeft * newWidth / oldWidth + '%',
									    css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl ? 'marginRight' : 'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

				tp_inst._limitMinMaxDateTime(this.inst, true);
			}
		},

		/*
  * This function tries to limit the ability to go outside the
  * min/max date range
  */
		_limitMinMaxDateTime: function _limitMinMaxDateTime(dp_inst, adjustSliders) {
			var o = this._defaults,
			    dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
				    minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if (this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
				    maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (dp_inst.settings.minTime !== null) {
				var tempMinTime = new Date("01/01/1970 " + dp_inst.settings.minTime);
				if (this.hour < tempMinTime.getHours()) {
					this.hour = this._defaults.hourMin = tempMinTime.getHours();
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else if (this.hour === tempMinTime.getHours() && this.minute < tempMinTime.getMinutes()) {
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else {
					if (this._defaults.hourMin < tempMinTime.getHours()) {
						this._defaults.hourMin = tempMinTime.getHours();
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else if (this._defaults.hourMin === tempMinTime.getHours() === this.hour && this._defaults.minuteMin < tempMinTime.getMinutes()) {
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else {
						this._defaults.minuteMin = 0;
					}
				}
			}

			if (dp_inst.settings.maxTime !== null) {
				var tempMaxTime = new Date("01/01/1970 " + dp_inst.settings.maxTime);
				if (this.hour > tempMaxTime.getHours()) {
					this.hour = this._defaults.hourMax = tempMaxTime.getHours();
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else if (this.hour === tempMaxTime.getHours() && this.minute > tempMaxTime.getMinutes()) {
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else {
					if (this._defaults.hourMax > tempMaxTime.getHours()) {
						this._defaults.hourMax = tempMaxTime.getHours();
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else if (this._defaults.hourMax === tempMaxTime.getHours() === this.hour && this._defaults.minuteMax > tempMaxTime.getMinutes()) {
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else {
						this._defaults.minuteMax = 59;
					}
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10),
				    minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10),
				    secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10),
				    millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10),
				    microsecMax = parseInt(this._defaults.microsecMax - (this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec, 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax, step: this._defaults.stepHour });
					this.control.value(this, this.hour_slider, 'hour', this.hour - this.hour % this._defaults.stepHour);
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax, step: this._defaults.stepMinute });
					this.control.value(this, this.minute_slider, 'minute', this.minute - this.minute % this._defaults.stepMinute);
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax, step: this._defaults.stepSecond });
					this.control.value(this, this.second_slider, 'second', this.second - this.second % this._defaults.stepSecond);
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax, step: this._defaults.stepMillisec });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - this.millisec % this._defaults.stepMillisec);
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax, step: this._defaults.stepMicrosec });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - this.microsec % this._defaults.stepMicrosec);
				}
			}
		},

		/*
  * when a slider moves, set the internal time...
  * on time change is also called when the time is updated in the text field
  */
		_onTimeChange: function _onTimeChange() {
			if (!this._defaults.showTimepicker) {
				return;
			}
			var hour = this.hour_slider ? this.control.value(this, this.hour_slider, 'hour') : false,
			    minute = this.minute_slider ? this.control.value(this, this.minute_slider, 'minute') : false,
			    second = this.second_slider ? this.control.value(this, this.second_slider, 'second') : false,
			    millisec = this.millisec_slider ? this.control.value(this, this.millisec_slider, 'millisec') : false,
			    microsec = this.microsec_slider ? this.control.value(this, this.microsec_slider, 'microsec') : false,
			    timezone = this.timezone_select ? this.timezone_select.val() : false,
			    o = this._defaults,
			    pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
			    pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if ((typeof hour === 'undefined' ? 'undefined' : _typeof(hour)) === 'object') {
				hour = false;
			}
			if ((typeof minute === 'undefined' ? 'undefined' : _typeof(minute)) === 'object') {
				minute = false;
			}
			if ((typeof second === 'undefined' ? 'undefined' : _typeof(second)) === 'object') {
				second = false;
			}
			if ((typeof millisec === 'undefined' ? 'undefined' : _typeof(millisec)) === 'object') {
				millisec = false;
			}
			if ((typeof microsec === 'undefined' ? 'undefined' : _typeof(microsec)) === 'object') {
				microsec = false;
			}
			if ((typeof timezone === 'undefined' ? 'undefined' : _typeof(timezone)) === 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}
			if (timezone !== false) {
				timezone = timezone.toString();
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = hour !== parseInt(this.hour, 10) || // sliders should all be numeric
			minute !== parseInt(this.minute, 10) || second !== parseInt(this.second, 10) || millisec !== parseInt(this.millisec, 10) || microsec !== parseInt(this.microsec, 10) || this.ampm.length > 0 && hour < 12 !== ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1) || this.timezone !== null && timezone !== this.timezone.toString() // could be numeric or "EST" format, so use toString()
			;

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if (pickerTimeFormat === o.timeFormat) {
					this.$timeObj.val(this.formattedTime + pickerTimeSuffix);
				} else {
					this.$timeObj.val($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
				if (this.$timeObj[0].setSelectionRange) {
					var sPos = this.$timeObj[0].selectionStart;
					var ePos = this.$timeObj[0].selectionEnd;
					this.$timeObj[0].setSelectionRange(sPos, ePos);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
				//this.$input.focus(); // may automatically open the picker on setDate
			}
		},

		/*
  * call custom onSelect.
  * bind to sliders slidestop, and grid click.
  */
		_onSelectHandler: function _onSelectHandler() {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
  * update our input with the new date time..
  */
		_updateDateTime: function _updateDateTime(dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dtTmp = dp_inst.currentYear > 0 ? new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay),
			    dt = $.datepicker._daylightSavingAdjust(dtTmp),

			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
			dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
			    formatCfg = $.datepicker._getFormatConfig(dp_inst),
			    timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, dt === null ? new Date() : dt, formatCfg);
			var formattedDateTime = this.formattedDate;

			// if a slider was changed but datepicker doesn't have a value yet, set it
			if (dp_inst.lastVal === "") {
				dp_inst.currentYear = dp_inst.selectedYear;
				dp_inst.currentMonth = dp_inst.selectedMonth;
				dp_inst.currentDay = dp_inst.selectedDay;
			}

			/*
   * remove following lines to force every changes in date picker to change the input value
   * Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker.
   * If the user manually empty the value in the input field, the date picker will never change selected value.
   */
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === false) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable) || this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === true) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
				    altSeparator = this._defaults.altSeparator !== null ? this._defaults.altSeparator : this._defaults.separator,
				    altTimeSuffix = this._defaults.altTimeSuffix !== null ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;

				if (!this._defaults.timeOnly) {
					if (this._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, dt === null ? new Date() : dt, formatCfg);
					} else {
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime) {
						altFormattedDateTime += altSeparator;
					}
				}

				if (this._defaults.altTimeFormat !== null) {
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				} else {
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function _onFocus() {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
				    tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
  * Small abstraction to control types
  * We can add more, just be sure to follow the pattern: create, options, value
  */
		_controls: {
			// slider methods
			slider: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl ? val * -1 : val,
						min: rtl ? max * -1 : min,
						max: rtl ? min * -1 : max,
						step: step,
						slide: function slide(event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value);
							tp_inst._onTimeChange();
						},
						stop: function stop(event, ui) {
							tp_inst._onSelectHandler();
						}
					});
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					if (tp_inst._defaults.isRTL) {
						if (typeof opts === 'string') {
							if (opts === 'min' || opts === 'max') {
								if (val !== undefined) {
									return obj.slider(opts, val * -1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min,
						    max = opts.max;
						opts.min = opts.max = null;
						if (min !== undefined) {
							opts.max = min * -1;
						}
						if (max !== undefined) {
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if (typeof opts === 'string' && val !== undefined) {
						return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function value(tp_inst, obj, unit, val) {
					if (tp_inst._defaults.isRTL) {
						if (val !== undefined) {
							return obj.slider('value', val * -1);
						}
						return Math.abs(obj.slider('value'));
					}
					if (val !== undefined) {
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">',
					    format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for (var i = min; i <= max; i += step) {
						sel += '<option value="' + i + '"' + (i === val ? ' selected' : '') + '>';
						if (unit === 'hour') {
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig, '')), { hour: i }, tp_inst._defaults);
						} else if (unit === 'millisec' || unit === 'microsec' || i >= 10) {
							sel += i;
						} else {
							sel += '0' + i.toString();
						}
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function (e) {
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
						tp_inst._afterInject();
					});

					return obj;
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					var o = {},
					    $t = obj.children('select');
					if (typeof opts === 'string') {
						if (val === undefined) {
							return $t.data(opts);
						}
						o[opts] = val;
					} else {
						o = opts;
					}
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min >= 0 ? o.min : $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function value(tp_inst, obj, unit, val) {
					var $t = obj.children('select');
					if (val !== undefined) {
						return $t.val(val);
					}
					return $t.val();
				}
			} // end _controls

		} });

	$.fn.extend({
		/*
  * shorthand just to use timepicker.
  */
		timepicker: function timepicker(o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function () {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
  * extend timepicker to datepicker
  */
		datetimepicker: function datetimepicker(o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof o === 'string') {
				if (o === 'getDate' || o === 'option' && tmp_args.length === 2 && typeof tmp_args[1] === 'string') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function () {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function () {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
 * Public Utility to parse date and time
 */
	$.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRes.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
 * Public utility to parse time
 */
	$.datepicker.parseTime = function (timeFormat, timeString, options) {
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
		    iso8601 = timeFormat.replace(/\'.*?\'/g, '').indexOf('Z') !== -1;

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function strictParse(f, s, o) {

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function getPatternAmpm(amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function (val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function getFormatPositions(timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
				    orders = {
					h: -1,
					m: -1,
					s: -1,
					l: -1,
					c: -1,
					t: -1,
					z: -1
				};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] === -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
				var ml = match.length;
				switch (match.charAt(0).toLowerCase()) {
					case 'h':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'm':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 's':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'l':
						return '(\\d?\\d?\\d)';
					case 'c':
						return '(\\d?\\d?\\d)';
					case 'z':
						return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
					case 't':
						return getPatternAmpm(o.amNames, o.pmNames);
					default:
						// literal escaped in quotes
						return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) {
							return "\\" + m;
						}) + ')?';
				}
			}).replace(/\s/g, '\\s?') + o.timeSuffix + '$',
			    order = getFormatPositions(f),
			    ampm = '',
			    treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), $.map(o.amNames, function (x, i) {
							return x.toUpperCase();
						})) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm === 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm === 'AM' && treg[order.h] === '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm === 'PM' && treg[order.h] !== '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}

				return resTime;
			}
			return false;
		}; // end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function looseParse(f, s, o) {
			try {
				var d = new Date('2012-01-01 ' + s);
				if (isNaN(d.getTime())) {
					d = new Date('2012-01-01T' + s);
					if (isNaN(d.getTime())) {
						d = new Date('01/01/2012 ' + s);
						if (isNaN(d.getTime())) {
							throw "Unable to parse time with native Date: " + s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset() * -1
				};
			} catch (err) {
				try {
					return strictParse(f, s, o);
				} catch (err2) {
					$.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
				}
			}
			return false;
		}; // end looseParse

		if (typeof o.parse === "function") {
			return o.parse(timeFormat, timeString, o);
		}
		if (o.parse === 'loose') {
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/**
  * Public utility to format the time
  * @param {string} format format of the time
  * @param {Object} time Object not a Date for timezones
  * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
  * @returns {string} the formatted time
  */
	$.datepicker.formatTime = function (format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null
		}, time);

		var tmptime = format,
		    ampmName = options.amNames[0],
		    hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
			switch (match) {
				case 'HH':
					return ('0' + hour).slice(-2);
				case 'H':
					return hour;
				case 'hh':
					return ('0' + convert24to12(hour)).slice(-2);
				case 'h':
					return convert24to12(hour);
				case 'mm':
					return ('0' + time.minute).slice(-2);
				case 'm':
					return time.minute;
				case 'ss':
					return ('0' + time.second).slice(-2);
				case 's':
					return time.second;
				case 'l':
					return ('00' + time.millisec).slice(-3);
				case 'c':
					return ('00' + time.microsec).slice(-3);
				case 'z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, false);
				case 'Z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, true);
				case 'T':
					return ampmName.charAt(0).toUpperCase();
				case 'TT':
					return ampmName.toUpperCase();
				case 't':
					return ampmName.charAt(0).toLowerCase();
				case 'tt':
					return ampmName.toLowerCase();
				default:
					return match.replace(/'/g, "");
			}
		});

		return tmptime;
	};

	/*
 * the bad hack :/ override datepicker so it doesn't close on select
 // inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
 */
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function (id, dateStr) {
		var inst = this._getInst($(id)[0]),
		    tp_inst = this._get(inst, 'timepicker'),
		    was_inline;

		if (tp_inst && inst.settings.showTimepicker) {
			tp_inst._limitMinMaxDateTime(inst, true);
			was_inline = inst.inline;
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = was_inline;
			inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
 * second bad hack :/ override datepicker so it triggers an event when changing the input field
 * and does not redraw the datepicker on every selectDate event
 */
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function (inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input) {
			return;
		}

		if (typeof inst.stay_open !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
 * third bad hack :/ override datepicker so it allows spaces and colon in the input field
 */
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
				    tz = tp_inst._defaults.showTimezone !== null ? tp_inst._defaults.showTimezone : tp_inst.support.timezone,
				    dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
				    datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, '').replace(/TT/g, ampm ? 'APM' : '').replace(/Tt/g, ampm ? 'AaPpMm' : '').replace(/tT/g, ampm ? 'AaPpMm' : '').replace(/T/g, ampm ? 'AP' : '').replace(/tt/g, ampm ? 'apm' : '').replace(/t/g, ampm ? 'ap' : '') + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tz ? tp_inst._defaults.timezoneList.join('') : '') + tp_inst._defaults.amNames.join('') + tp_inst._defaults.pmNames.join('') + dateChars,
				    chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1;
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
 * Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
 * Update any alternate field to synchronise with the main field.
 */
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	$.datepicker._updateAlternate = function (inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var altField = tp_inst._defaults.altField;
			if (altField) {
				// update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
				    date = this._getDate(inst),
				    formatCfg = $.datepicker._getFormatConfig(inst),
				    altFormattedDateTime = '',
				    altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator,
				    altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
				    altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;

				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null) {
					if (tp_inst._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					} else {
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val(inst.input.val() ? altFormattedDateTime : "");
			}
		} else {
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
 * Override key up event to sync manual input changes.
 */
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
 * override "Today" button to also grab the time and set it to input field.
 */
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function (id) {
		var inst = this._getInst($(id)[0]);
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		if (!tp_inst) {
			return;
		}

		var tzoffset = $.timepicker.timezoneOffsetNumber(tp_inst.timezone);
		var now = new Date();
		now.setMinutes(now.getMinutes() + now.getTimezoneOffset() + parseInt(tzoffset, 10));
		this._setTime(inst, now);
		this._setDate(inst, now);
		tp_inst._onSelectHandler();
	};

	/*
 * Disable & enable the Time in the datetimepicker
 */
	$.datepicker._disableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = false;
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = true;
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create our own set time function
 */
	$.datepicker._setTime = function (inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times..
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create new public method to set only time, callable as $().datepicker('setTime', date)
 */
	$.datepicker._setTimeDatepicker = function (target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date === "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
					tp_date.setMicroseconds(date.getMicroseconds());
				}
				if (tp_date.toString() === 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}
	};

	/*
 * override setDate() to allow setting time too within Date object
 */
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function (target, _date) {
		var inst = this._getInst(target);
		var date = _date;
		if (!inst) {
			return;
		}

		if (typeof _date === 'string') {
			date = new Date(_date);
			if (!date.getTime()) {
				this._base_setDateDatepicker.apply(this, arguments);
				date = $(target).datepicker('getDate');
			}
		}

		var tp_inst = this._get(inst, 'timepicker');
		var tp_date;
		if (date instanceof Date) {
			tp_date = new Date(date.getTime());
			tp_date.setMicroseconds(date.getMicroseconds());
		} else {
			tp_date = date;
		}

		// This is important if you are using the timezone option, javascript's Date
		// object will only return the timezone offset for the current locale, so we
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if (tp_inst && tp_date) {
			// look out for DST if tz wasn't specified
			if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
				tp_inst.timezone = tp_date.getTimezoneOffset() * -1;
			}
			date = $.timepicker.timezoneAdjust(date, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()), tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, $.timepicker.timezoneOffsetString(-tp_date.getTimezoneOffset()), tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
 * override getDate() to allow getting time too within Date object
 */
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function (target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if (inst.lastVal === undefined) {
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);

			var currDT = null;

			if (tp_inst.$altInput && tp_inst._defaults.altFieldTimeOnly) {
				currDT = tp_inst.$input.val() + ' ' + tp_inst.$altInput.val();
			} else if (tp_inst.$input.get(0).tagName !== 'INPUT' && tp_inst.$altInput) {
				/**
     * in case the datetimepicker has been applied to a non-input tag for inline UI,
     * and the user has not configured the plugin to display only time in altInput,
     * pick current date time from the altInput (and hope for the best, for now, until "ER1" is applied)
     *
     * @todo ER1. Since altInput can have a totally difference format, convert it to standard format by reading input format from "altFormat" and "altTimeFormat" option values
     */
				currDT = tp_inst.$altInput.val();
			} else {
				currDT = tp_inst.$input.val();
			}

			if (date && tp_inst._parseTime(currDT, !inst.settings.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date
				// object will only return the timezone offset for the current locale, so we
				// adjust it accordingly.  If not using timezone option this won't matter..
				if (tp_inst.timezone != null) {
					// look out for DST if tz wasn't specified
					if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
						tp_inst.timezone = date.getTimezoneOffset() * -1;
					}
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()));
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
 * override parseDate() because UI 1.8.14 throws an error about "Extra characters"
 * An option in datapicker to ignore extra format characters would be nicer.
 */
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function (format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(':') - 2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
 * override formatDate to set date with time to the input
 */
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function (inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
 * override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
 */
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function (target, name, value) {
		var inst = this._getInst(target),
		    name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
			    max = null,
			    onselect = null,
			    overrides = tp_inst._defaults.evnts,
			    fns = {},
			    prop,
			    ret,
			    oldVal,
			    $target;
			if (typeof name === 'string') {
				// if min/max was set with the string
				if (name === 'minDate' || name === 'minDateTime') {
					min = value;
				} else if (name === 'maxDate' || name === 'maxDateTime') {
					max = value;
				} else if (name === 'onSelect') {
					onselect = value;
				} else if (overrides.hasOwnProperty(name)) {
					if (typeof value === 'undefined') {
						return overrides[name];
					}
					fns[name] = value;
					name_clone = {}; //empty results in exiting function after overrides updated
				}
			} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
				//if min/max was set with the JSON
				if (name.minDate) {
					min = name.minDate;
				} else if (name.minDateTime) {
					min = name.minDateTime;
				} else if (name.maxDate) {
					max = name.maxDate;
				} else if (name.maxDateTime) {
					max = name.maxDateTime;
				}
				for (prop in overrides) {
					if (overrides.hasOwnProperty(prop) && name[prop]) {
						fns[prop] = name[prop];
					}
				}
			}
			for (prop in fns) {
				if (fns.hasOwnProperty(prop)) {
					overrides[prop] = fns[prop];
					if (!name_clone) {
						name_clone = $.extend({}, name);
					}
					delete name_clone[prop];
				}
			}
			if (name_clone && isEmptyObject(name_clone)) {
				return;
			}
			if (min) {
				//if min was set
				if (min === 0) {
					min = new Date();
				} else {
					min = new Date(min);
				}
				tp_inst._defaults.minDate = min;
				tp_inst._defaults.minDateTime = min;
			} else if (max) {
				//if max was set
				if (max === 0) {
					max = new Date();
				} else {
					max = new Date(max);
				}
				tp_inst._defaults.maxDate = max;
				tp_inst._defaults.maxDateTime = max;
			} else if (onselect) {
				tp_inst._defaults.onSelect = onselect;
			}

			// Datepicker will override our date when we call _base_optionDatepicker when
			// calling minDate/maxDate, so we will first grab the value, call
			// _base_optionDatepicker, then set our value back.
			if (min || max) {
				$target = $(target);
				oldVal = $target.datetimepicker('getDate');
				ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
				$target.datetimepicker('setDate', oldVal);
				return ret;
			}
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};

	/*
 * jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
 * it will return false for all objects
 */
	var isEmptyObject = function isEmptyObject(obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/*
 * jQuery extend now ignores nulls!
 */
	var extendRemove = function extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
 * Determine by the time format which units are supported
 * Returns an object of booleans for each unit
 */
	var detectSupport = function detectSupport(timeFormat) {
		var tf = timeFormat.replace(/'.*?'/g, '').toLowerCase(),
		    // removes literals
		isIn = function isIn(f, t) {
			// does the format contain the token?
			return f.indexOf(t) !== -1 ? true : false;
		};
		return {
			hour: isIn(tf, 'h'),
			minute: isIn(tf, 'm'),
			second: isIn(tf, 's'),
			millisec: isIn(tf, 'l'),
			microsec: isIn(tf, 'c'),
			timezone: isIn(tf, 'z'),
			ampm: isIn(tf, 't') && isIn(timeFormat, 'h'),
			iso8601: isIn(timeFormat, 'Z')
		};
	};

	/*
 * Converts 24 hour format into 12 hour
 * Returns 12 hour without leading 0
 */
	var convert24to12 = function convert24to12(hour) {
		hour %= 12;

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	var computeEffectiveSetting = function computeEffectiveSetting(settings, property) {
		return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
	};

	/*
 * Splits datetime string into date and time substrings.
 * Throws exception when date can't be parsed
 * Returns {dateString: dateString, timeString: timeString}
 */
	var splitDateTime = function splitDateTime(dateTimeString, timeSettings) {
		// The idea is to get the number separator occurrences in datetime and the time format requested (since time has
		// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
		var separator = computeEffectiveSetting(timeSettings, 'separator'),
		    format = computeEffectiveSetting(timeSettings, 'timeFormat'),
		    timeParts = format.split(separator),
		    // how many occurrences of separator may be in our format?
		timePartsLen = timeParts.length,
		    allParts = dateTimeString.split(separator),
		    allPartsLen = allParts.length;

		if (allPartsLen > 1) {
			return {
				dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
				timeString: allParts.splice(0, timePartsLen).join(separator)
			};
		}

		return {
			dateString: dateTimeString,
			timeString: ''
		};
	};

	/*
 * Internal function to parse datetime interval
 * Returns: {date: Date, timeObj: Object}, where
 *   date - parsed date without time (type Date)
 *   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
 */
	var parseDateTimeInternal = function parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date, parts, parsedTime;

		parts = splitDateTime(dateTimeString, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings);

		if (parts.timeString === '') {
			return {
				date: date
			};
		}

		parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings);

		if (!parsedTime) {
			throw 'Wrong time format';
		}

		return {
			date: date,
			timeObj: parsedTime
		};
	};

	/*
 * Internal function to set timezone_select to the local timezone
 */
	var selectLocalTimezone = function selectLocalTimezone(tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = date || new Date();
			tp_inst.timezone_select.val(-now.getTimezoneOffset());
		}
	};

	/*
 * Create a Singleton Instance
 */
	$.timepicker = new Timepicker();

	/**
  * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
  * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
  * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
  * @return {string}
  */
	$.timepicker.timezoneOffsetString = function (tzMinutes, iso8601) {
		if (isNaN(tzMinutes) || tzMinutes > 840 || tzMinutes < -720) {
			return tzMinutes;
		}

		var off = tzMinutes,
		    minutes = off % 60,
		    hours = (off - minutes) / 60,
		    iso = iso8601 ? ':' : '',
		    tz = (off >= 0 ? '+' : '-') + ('0' + Math.abs(hours)).slice(-2) + iso + ('0' + Math.abs(minutes)).slice(-2);

		if (tz === '+00:00') {
			return 'Z';
		}
		return tz;
	};

	/**
  * Get the number in minutes that represents a timezone string
  * @param  {string} tzString formatted like "+0500", "-1245", "Z"
  * @return {number} the offset minutes or the original string if it doesn't match expectations
  */
	$.timepicker.timezoneOffsetNumber = function (tzString) {
		var normalized = tzString.toString().replace(':', ''); // excuse any iso8601, end up with "+1245"

		if (normalized.toUpperCase() === 'Z') {
			// if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if (!/^(\-|\+)\d{4}$/.test(normalized)) {
			// possibly a user defined tz, so just give it back
			return parseInt(tzString, 10);
		}

		return (normalized.substr(0, 1) === '-' ? -1 : 1) * ( // plus or minus
		parseInt(normalized.substr(1, 2), 10) * 60 + // hours (converted to minutes)
		parseInt(normalized.substr(3, 2), 10)); // minutes
	};

	/**
  * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
  * @param  {Date} date
  * @param  {string} fromTimezone formatted like "+0500", "-1245"
  * @param  {string} toTimezone formatted like "+0500", "-1245"
  * @return {Date}
  */
	$.timepicker.timezoneAdjust = function (date, fromTimezone, toTimezone) {
		var fromTz = $.timepicker.timezoneOffsetNumber(fromTimezone);
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if (!isNaN(toTz)) {
			date.setMinutes(date.getMinutes() + -fromTz - -toTz);
		}
		return date;
	};

	/**
  * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * n.b. The input value must be correctly formatted (reformatting is not supported)
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the timepicker() call
  * @return {jQuery}
  */
	$.timepicker.timeRange = function (startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
  * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @return {jQuery}
  */
	$.timepicker.datetimeRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
  * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.dateRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
  * Calls `method` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.handleRange = function (method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {}, // options for start picker
			end: {} // options for end picker
		}, options);

		// for the mean time this fixes an issue with calling getDate with timepicker()
		var timeOnly = false;
		if (method === 'timepicker') {
			timeOnly = true;
			method = 'datetimepicker';
		}

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
			    enddt = endTime[method]('getDate'),
			    changeddt = changed[method]('getDate');

			if (startdt !== null) {
				var minDate = new Date(startdt.getTime()),
				    maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if (options.minInterval > 0 && minDate > enddt) {
					// minInterval check
					endTime[method]('setDate', minDate);
				} else if (options.maxInterval > 0 && maxDate < enddt) {
					// max interval check
					endTime[method]('setDate', maxDate);
				} else if (startdt > enddt) {
					other[method]('setDate', changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if (date !== null && options.minInterval > 0) {
				if (option === 'minDate') {
					date.setMilliseconds(date.getMilliseconds() + options.minInterval);
				}
				if (option === 'maxDate') {
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}

			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}

		$.fn[method].call(startTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);

		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
  * Log error or data to the console during error or debugging
  * @param  {Object} err pass any type object to log to the console during error or debugging
  * @return {void}
  */
	$.timepicker.log = function () {
		// Older IE (9, maybe 10) throw error on accessing `window.console.log.apply`, so check first.
		if (window.console && window.console.log && window.console.log.apply) {
			window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
		}
	};

	/*
  * Add util object to allow access to private methods for testability.
  */
	$.timepicker._util = {
		_extendRemove: extendRemove,
		_isEmptyObject: isEmptyObject,
		_convert24to12: convert24to12,
		_detectSupport: detectSupport,
		_selectLocalTimezone: selectLocalTimezone,
		_computeEffectiveSetting: computeEffectiveSetting,
		_splitDateTime: splitDateTime,
		_parseDateTimeInternal: parseDateTimeInternal
	};

	/*
 * Microsecond support
 */
	if (!Date.prototype.getMicroseconds) {
		Date.prototype.microseconds = 0;
		Date.prototype.getMicroseconds = function () {
			return this.microseconds;
		};
		Date.prototype.setMicroseconds = function (m) {
			this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1000));
			this.microseconds = m % 1000;
			return this;
		};
	}

	/*
 * Keep up with the version
 */
	$.timepicker.version = "1.6.3";
})(window.jQuery);

/***/ }),

/***/ 64:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.11.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Popper = factory();
})(undefined, function () {
  'use strict';

  var nativeHints = ['native code', '[object MutationObserverConstructor]'];

  /**
   * Determine if a function is implemented natively (as opposed to a polyfill).
   * @method
   * @memberof Popper.Utils
   * @argument {Function | undefined} fn the function to check
   * @returns {Boolean}
   */
  var isNative = function isNative(fn) {
    return nativeHints.some(function (hint) {
      return (fn || '').toString().indexOf(hint) > -1;
    });
  };

  var isBrowser = typeof window !== 'undefined';
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }

  function microtaskDebounce(fn) {
    var scheduled = false;
    var i = 0;
    var elem = document.createElement('span');

    // MutationObserver provides a mechanism for scheduling microtasks, which
    // are scheduled *before* the next task. This gives us a way to debounce
    // a function but ensure it's called *before* the next paint.
    var observer = new MutationObserver(function () {
      fn();
      scheduled = false;
    });

    observer.observe(elem, { attributes: true });

    return function () {
      if (!scheduled) {
        scheduled = true;
        elem.setAttribute('x-index', i);
        i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8
      }
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  // It's common for MutationObserver polyfills to be seen in the wild, however
  // these rely on Mutation Events which only occur when an element is connected
  // to the DOM. The algorithm used in this module does not use a connected element,
  // and so we must ensure that a *native* MutationObserver is available.
  var supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);

  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */
  var debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {
      return window.document.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent(getParentNode(element));
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    // NOTE: 1 DOM access here
    var offsetParent = element && element.offsetParent;
    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return window.document.documentElement;
    }

    // .offsetParent will return the closest TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return window.document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = window.document.documentElement;
      var scrollingElement = window.document.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];
  }

  /**
   * Tells if you are running Internet Explorer 10
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean} isIE10
   */
  var isIE10 = undefined;

  var isIE10$1 = function isIE10$1() {
    if (isIE10 === undefined) {
      isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
    }
    return isIE10;
  };

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], html['client' + axis], html['offset' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
  }

  function getWindowSizes() {
    var body = window.document.body;
    var html = window.document.documentElement;
    var computedStyle = isIE10$1() && window.getComputedStyle(html);

    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    if (isIE10$1()) {
      try {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } catch (err) {}
    } else {
      rect = element.getBoundingClientRect();
    }

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');

      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var isIE10 = isIE10$1();
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = +styles.borderTopWidth.split('px')[0];
    var borderLeftWidth = +styles.borderLeftWidth.split('px')[0];

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = +styles.marginTop.split('px')[0];
      var marginLeft = +styles.marginLeft.split('px')[0];

      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var html = window.document.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = getScroll(html);
    var scrollLeft = getScroll(html, 'left');

    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };

    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    return isFixed(getParentNode(element));
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    // NOTE: 1 DOM access here
    var boundaries = { top: 0, left: 0 };
    var offsetParent = findCommonOffsetParent(popper, reference);

    // Handle viewport case
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(popper));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = window.document.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = window.document.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    boundaries.left += padding;
    boundaries.top += padding;
    boundaries.right -= padding;
    boundaries.bottom -= padding;

    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };

    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var commonOffsetParent = findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

    modifiersToRun.forEach(function (modifier) {
      if (modifier.function) {
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier.function || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);

        data = fn(data, modifier);
      }
    });

    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length - 1; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof window.document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroy the popper
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.left = '';
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? window : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    window.addEventListener('resize', state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    window.removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger onUpdate callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      window.cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if the arrow style has been computed, apply the arrow style
    if (data.offsets.arrow) {
      setStyles(data.arrowElement, data.offsets.arrow);
    }

    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: 'absolute' });

    return options;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
      position: popper.position
    };

    // floor sides to avoid blurry text
    var offsets = {
      left: Math.floor(popper.left),
      top: Math.floor(popper.top),
      bottom: Math.floor(popper.bottom),
      right: Math.floor(popper.right)
    };

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      top = -offsetParentRect.height + offsets.bottom;
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      left = -offsetParentRect.width + offsets.right;
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
      'x-placement': data.placement
    };

    // Update attributes and styles of `data`
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);

    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow(data, options) {
    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var side = isVertical ? 'top' : 'left';
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    var sideValue = center - getClientRect(data.offsets.popper)[side];

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = {};
    data.offsets.arrow[side] = Math.round(sideValue);
    data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node

    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-right` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);

      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

      // flip the variation if required
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : '');

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };

    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;

      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };

      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unitless, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the height.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * An scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper this makes sure the popper has always a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier, can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near eachothers
     * without leaving any gap between the two. Expecially useful when the arrow is
     * enabled and you want to assure it to point to its reference element.
     * It cares only about the first axis, you can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjuction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations).
       */
      behavior: 'flip',
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position,
       * the popper will never be placed outside of the defined boundaries
       * (except if keepTogether is enabled)
       */
      boundariesElement: 'viewport'
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define you own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: undefined
    }
  };

  /**
   * The `dataObject` is an object containing all the informations used by Popper.js
   * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overriden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass as 3rd argument an object with the same
   * structure of this object, example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults = {
    /**
     * Popper's placement
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Whether events (resize, scroll) are initially enabled
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated, this callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js
     * @prop {modifiers}
     */
    modifiers: modifiers
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */

  // Utils
  // Methods
  var Popper = function () {
    /**
     * Create a new Popper.js instance
     * @class Popper
     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper.
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference.jquery ? reference[0] : reference;
      this.popper = popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });

      // fire the first update to position the popper in the right place
      this.update();

      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedule an update, it will run on the next UI update available
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */

  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  return Popper;
});
//# sourceMappingURL=popper.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(65)))

/***/ }),

/***/ 65:
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 66:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Bootstrap v4.0.0-beta (https://getbootstrap.com)
 * Copyright 2011-2017 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
}

(function ($) {
  var version = $.fn.jquery.split(' ')[0].split('.');
  if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] >= 4) {
    throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
  }
})(jQuery);

(function () {
  var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Util = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Private TransitionEnd Helpers
     * ------------------------------------------------------------------------
     */

    var transition = false;

    var MAX_UID = 1000000;

    var TransitionEndEvent = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'

      // shoutout AngusCroll (https://goo.gl/pxwQGp)
    };function toType(obj) {
      return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
    }

    function isElement(obj) {
      return (obj[0] || obj).nodeType;
    }

    function getSpecialTransitionEndEvent() {
      return {
        bindType: transition.end,
        delegateType: transition.end,
        handle: function handle(event) {
          if ($(event.target).is(this)) {
            return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
          }
          return undefined;
        }
      };
    }

    function transitionEndTest() {
      if (window.QUnit) {
        return false;
      }

      var el = document.createElement('bootstrap');

      for (var name in TransitionEndEvent) {
        if (el.style[name] !== undefined) {
          return {
            end: TransitionEndEvent[name]
          };
        }
      }

      return false;
    }

    function transitionEndEmulator(duration) {
      var _this = this;

      var called = false;

      $(this).one(Util.TRANSITION_END, function () {
        called = true;
      });

      setTimeout(function () {
        if (!called) {
          Util.triggerTransitionEnd(_this);
        }
      }, duration);

      return this;
    }

    function setTransitionEndSupport() {
      transition = transitionEndTest();

      $.fn.emulateTransitionEnd = transitionEndEmulator;

      if (Util.supportsTransitionEnd()) {
        $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
      }
    }

    /**
     * --------------------------------------------------------------------------
     * Public Util Api
     * --------------------------------------------------------------------------
     */

    var Util = {

      TRANSITION_END: 'bsTransitionEnd',

      getUID: function getUID(prefix) {
        do {
          // eslint-disable-next-line no-bitwise
          prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
        } while (document.getElementById(prefix));
        return prefix;
      },
      getSelectorFromElement: function getSelectorFromElement(element) {
        var selector = element.getAttribute('data-target');
        if (!selector || selector === '#') {
          selector = element.getAttribute('href') || '';
        }

        try {
          var $selector = $(selector);
          return $selector.length > 0 ? selector : null;
        } catch (error) {
          return null;
        }
      },
      reflow: function reflow(element) {
        return element.offsetHeight;
      },
      triggerTransitionEnd: function triggerTransitionEnd(element) {
        $(element).trigger(transition.end);
      },
      supportsTransitionEnd: function supportsTransitionEnd() {
        return Boolean(transition);
      },
      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
        for (var property in configTypes) {
          if (configTypes.hasOwnProperty(property)) {
            var expectedTypes = configTypes[property];
            var value = config[property];
            var valueType = value && isElement(value) ? 'element' : toType(value);

            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new Error(componentName.toUpperCase() + ': ' + ('Option "' + property + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
            }
          }
        }
      }
    };

    setTransitionEndSupport();

    return Util;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Alert = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'alert';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.alert';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 150;

    var Selector = {
      DISMISS: '[data-dismiss="alert"]'
    };

    var Event = {
      CLOSE: 'close' + EVENT_KEY,
      CLOSED: 'closed' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      ALERT: 'alert',
      FADE: 'fade',
      SHOW: 'show'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Alert = function () {
      function Alert(element) {
        _classCallCheck(this, Alert);

        this._element = element;
      }

      // getters

      // public

      Alert.prototype.close = function close(element) {
        element = element || this._element;

        var rootElement = this._getRootElement(element);
        var customEvent = this._triggerCloseEvent(rootElement);

        if (customEvent.isDefaultPrevented()) {
          return;
        }

        this._removeElement(rootElement);
      };

      Alert.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        this._element = null;
      };

      // private

      Alert.prototype._getRootElement = function _getRootElement(element) {
        var selector = Util.getSelectorFromElement(element);
        var parent = false;

        if (selector) {
          parent = $(selector)[0];
        }

        if (!parent) {
          parent = $(element).closest('.' + ClassName.ALERT)[0];
        }

        return parent;
      };

      Alert.prototype._triggerCloseEvent = function _triggerCloseEvent(element) {
        var closeEvent = $.Event(Event.CLOSE);

        $(element).trigger(closeEvent);
        return closeEvent;
      };

      Alert.prototype._removeElement = function _removeElement(element) {
        var _this2 = this;

        $(element).removeClass(ClassName.SHOW);

        if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {
          this._destroyElement(element);
          return;
        }

        $(element).one(Util.TRANSITION_END, function (event) {
          return _this2._destroyElement(element, event);
        }).emulateTransitionEnd(TRANSITION_DURATION);
      };

      Alert.prototype._destroyElement = function _destroyElement(element) {
        $(element).detach().trigger(Event.CLOSED).remove();
      };

      // static

      Alert._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $element = $(this);
          var data = $element.data(DATA_KEY);

          if (!data) {
            data = new Alert(this);
            $element.data(DATA_KEY, data);
          }

          if (config === 'close') {
            data[config](this);
          }
        });
      };

      Alert._handleDismiss = function _handleDismiss(alertInstance) {
        return function (event) {
          if (event) {
            event.preventDefault();
          }

          alertInstance.close(this);
        };
      };

      _createClass(Alert, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }]);

      return Alert;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Alert._jQueryInterface;
    $.fn[NAME].Constructor = Alert;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Alert._jQueryInterface;
    };

    return Alert;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Button = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'button';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.button';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];

    var ClassName = {
      ACTIVE: 'active',
      BUTTON: 'btn',
      FOCUS: 'focus'
    };

    var Selector = {
      DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
      DATA_TOGGLE: '[data-toggle="buttons"]',
      INPUT: 'input',
      ACTIVE: '.active',
      BUTTON: '.btn'
    };

    var Event = {
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,
      FOCUS_BLUR_DATA_API: 'focus' + EVENT_KEY + DATA_API_KEY + ' ' + ('blur' + EVENT_KEY + DATA_API_KEY)

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Button = function () {
      function Button(element) {
        _classCallCheck(this, Button);

        this._element = element;
      }

      // getters

      // public

      Button.prototype.toggle = function toggle() {
        var triggerChangeEvent = true;
        var addAriaPressed = true;
        var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];

        if (rootElement) {
          var input = $(this._element).find(Selector.INPUT)[0];

          if (input) {
            if (input.type === 'radio') {
              if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {
                triggerChangeEvent = false;
              } else {
                var activeElement = $(rootElement).find(Selector.ACTIVE)[0];

                if (activeElement) {
                  $(activeElement).removeClass(ClassName.ACTIVE);
                }
              }
            }

            if (triggerChangeEvent) {
              if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
                return;
              }
              input.checked = !$(this._element).hasClass(ClassName.ACTIVE);
              $(input).trigger('change');
            }

            input.focus();
            addAriaPressed = false;
          }
        }

        if (addAriaPressed) {
          this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));
        }

        if (triggerChangeEvent) {
          $(this._element).toggleClass(ClassName.ACTIVE);
        }
      };

      Button.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        this._element = null;
      };

      // static

      Button._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);

          if (!data) {
            data = new Button(this);
            $(this).data(DATA_KEY, data);
          }

          if (config === 'toggle') {
            data[config]();
          }
        });
      };

      _createClass(Button, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }]);

      return Button;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
      event.preventDefault();

      var button = event.target;

      if (!$(button).hasClass(ClassName.BUTTON)) {
        button = $(button).closest(Selector.BUTTON);
      }

      Button._jQueryInterface.call($(button), 'toggle');
    }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
      var button = $(event.target).closest(Selector.BUTTON)[0];
      $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Button._jQueryInterface;
    $.fn[NAME].Constructor = Button;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Button._jQueryInterface;
    };

    return Button;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Carousel = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'carousel';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.carousel';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 600;
    var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key
    var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key
    var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

    var Default = {
      interval: 5000,
      keyboard: true,
      slide: false,
      pause: 'hover',
      wrap: true
    };

    var DefaultType = {
      interval: '(number|boolean)',
      keyboard: 'boolean',
      slide: '(boolean|string)',
      pause: '(string|boolean)',
      wrap: 'boolean'
    };

    var Direction = {
      NEXT: 'next',
      PREV: 'prev',
      LEFT: 'left',
      RIGHT: 'right'
    };

    var Event = {
      SLIDE: 'slide' + EVENT_KEY,
      SLID: 'slid' + EVENT_KEY,
      KEYDOWN: 'keydown' + EVENT_KEY,
      MOUSEENTER: 'mouseenter' + EVENT_KEY,
      MOUSELEAVE: 'mouseleave' + EVENT_KEY,
      TOUCHEND: 'touchend' + EVENT_KEY,
      LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      CAROUSEL: 'carousel',
      ACTIVE: 'active',
      SLIDE: 'slide',
      RIGHT: 'carousel-item-right',
      LEFT: 'carousel-item-left',
      NEXT: 'carousel-item-next',
      PREV: 'carousel-item-prev',
      ITEM: 'carousel-item'
    };

    var Selector = {
      ACTIVE: '.active',
      ACTIVE_ITEM: '.active.carousel-item',
      ITEM: '.carousel-item',
      NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
      INDICATORS: '.carousel-indicators',
      DATA_SLIDE: '[data-slide], [data-slide-to]',
      DATA_RIDE: '[data-ride="carousel"]'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Carousel = function () {
      function Carousel(element, config) {
        _classCallCheck(this, Carousel);

        this._items = null;
        this._interval = null;
        this._activeElement = null;

        this._isPaused = false;
        this._isSliding = false;

        this.touchTimeout = null;

        this._config = this._getConfig(config);
        this._element = $(element)[0];
        this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];

        this._addEventListeners();
      }

      // getters

      // public

      Carousel.prototype.next = function next() {
        if (!this._isSliding) {
          this._slide(Direction.NEXT);
        }
      };

      Carousel.prototype.nextWhenVisible = function nextWhenVisible() {
        // Don't call next when the page isn't visible
        if (!document.hidden) {
          this.next();
        }
      };

      Carousel.prototype.prev = function prev() {
        if (!this._isSliding) {
          this._slide(Direction.PREV);
        }
      };

      Carousel.prototype.pause = function pause(event) {
        if (!event) {
          this._isPaused = true;
        }

        if ($(this._element).find(Selector.NEXT_PREV)[0] && Util.supportsTransitionEnd()) {
          Util.triggerTransitionEnd(this._element);
          this.cycle(true);
        }

        clearInterval(this._interval);
        this._interval = null;
      };

      Carousel.prototype.cycle = function cycle(event) {
        if (!event) {
          this._isPaused = false;
        }

        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }

        if (this._config.interval && !this._isPaused) {
          this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
        }
      };

      Carousel.prototype.to = function to(index) {
        var _this3 = this;

        this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];

        var activeIndex = this._getItemIndex(this._activeElement);

        if (index > this._items.length - 1 || index < 0) {
          return;
        }

        if (this._isSliding) {
          $(this._element).one(Event.SLID, function () {
            return _this3.to(index);
          });
          return;
        }

        if (activeIndex === index) {
          this.pause();
          this.cycle();
          return;
        }

        var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

        this._slide(direction, this._items[index]);
      };

      Carousel.prototype.dispose = function dispose() {
        $(this._element).off(EVENT_KEY);
        $.removeData(this._element, DATA_KEY);

        this._items = null;
        this._config = null;
        this._element = null;
        this._interval = null;
        this._isPaused = null;
        this._isSliding = null;
        this._activeElement = null;
        this._indicatorsElement = null;
      };

      // private

      Carousel.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      Carousel.prototype._addEventListeners = function _addEventListeners() {
        var _this4 = this;

        if (this._config.keyboard) {
          $(this._element).on(Event.KEYDOWN, function (event) {
            return _this4._keydown(event);
          });
        }

        if (this._config.pause === 'hover') {
          $(this._element).on(Event.MOUSEENTER, function (event) {
            return _this4.pause(event);
          }).on(Event.MOUSELEAVE, function (event) {
            return _this4.cycle(event);
          });
          if ('ontouchstart' in document.documentElement) {
            // if it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
            $(this._element).on(Event.TOUCHEND, function () {
              _this4.pause();
              if (_this4.touchTimeout) {
                clearTimeout(_this4.touchTimeout);
              }
              _this4.touchTimeout = setTimeout(function (event) {
                return _this4.cycle(event);
              }, TOUCHEVENT_COMPAT_WAIT + _this4._config.interval);
            });
          }
        }
      };

      Carousel.prototype._keydown = function _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }

        switch (event.which) {
          case ARROW_LEFT_KEYCODE:
            event.preventDefault();
            this.prev();
            break;
          case ARROW_RIGHT_KEYCODE:
            event.preventDefault();
            this.next();
            break;
          default:
            return;
        }
      };

      Carousel.prototype._getItemIndex = function _getItemIndex(element) {
        this._items = $.makeArray($(element).parent().find(Selector.ITEM));
        return this._items.indexOf(element);
      };

      Carousel.prototype._getItemByDirection = function _getItemByDirection(direction, activeElement) {
        var isNextDirection = direction === Direction.NEXT;
        var isPrevDirection = direction === Direction.PREV;
        var activeIndex = this._getItemIndex(activeElement);
        var lastItemIndex = this._items.length - 1;
        var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

        if (isGoingToWrap && !this._config.wrap) {
          return activeElement;
        }

        var delta = direction === Direction.PREV ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this._items.length;

        return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
      };

      Carousel.prototype._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
        var targetIndex = this._getItemIndex(relatedTarget);
        var fromIndex = this._getItemIndex($(this._element).find(Selector.ACTIVE_ITEM)[0]);
        var slideEvent = $.Event(Event.SLIDE, {
          relatedTarget: relatedTarget,
          direction: eventDirectionName,
          from: fromIndex,
          to: targetIndex
        });

        $(this._element).trigger(slideEvent);

        return slideEvent;
      };

      Carousel.prototype._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
        if (this._indicatorsElement) {
          $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);

          var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

          if (nextIndicator) {
            $(nextIndicator).addClass(ClassName.ACTIVE);
          }
        }
      };

      Carousel.prototype._slide = function _slide(direction, element) {
        var _this5 = this;

        var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];
        var activeElementIndex = this._getItemIndex(activeElement);
        var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);
        var nextElementIndex = this._getItemIndex(nextElement);
        var isCycling = Boolean(this._interval);

        var directionalClassName = void 0;
        var orderClassName = void 0;
        var eventDirectionName = void 0;

        if (direction === Direction.NEXT) {
          directionalClassName = ClassName.LEFT;
          orderClassName = ClassName.NEXT;
          eventDirectionName = Direction.LEFT;
        } else {
          directionalClassName = ClassName.RIGHT;
          orderClassName = ClassName.PREV;
          eventDirectionName = Direction.RIGHT;
        }

        if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {
          this._isSliding = false;
          return;
        }

        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
        if (slideEvent.isDefaultPrevented()) {
          return;
        }

        if (!activeElement || !nextElement) {
          // some weirdness is happening, so we bail
          return;
        }

        this._isSliding = true;

        if (isCycling) {
          this.pause();
        }

        this._setActiveIndicatorElement(nextElement);

        var slidEvent = $.Event(Event.SLID, {
          relatedTarget: nextElement,
          direction: eventDirectionName,
          from: activeElementIndex,
          to: nextElementIndex
        });

        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.SLIDE)) {

          $(nextElement).addClass(orderClassName);

          Util.reflow(nextElement);

          $(activeElement).addClass(directionalClassName);
          $(nextElement).addClass(directionalClassName);

          $(activeElement).one(Util.TRANSITION_END, function () {
            $(nextElement).removeClass(directionalClassName + ' ' + orderClassName).addClass(ClassName.ACTIVE);

            $(activeElement).removeClass(ClassName.ACTIVE + ' ' + orderClassName + ' ' + directionalClassName);

            _this5._isSliding = false;

            setTimeout(function () {
              return $(_this5._element).trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          $(activeElement).removeClass(ClassName.ACTIVE);
          $(nextElement).addClass(ClassName.ACTIVE);

          this._isSliding = false;
          $(this._element).trigger(slidEvent);
        }

        if (isCycling) {
          this.cycle();
        }
      };

      // static

      Carousel._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = $.extend({}, Default, $(this).data());

          if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {
            $.extend(_config, config);
          }

          var action = typeof config === 'string' ? config : _config.slide;

          if (!data) {
            data = new Carousel(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'number') {
            data.to(config);
          } else if (typeof action === 'string') {
            if (data[action] === undefined) {
              throw new Error('No method named "' + action + '"');
            }
            data[action]();
          } else if (_config.interval) {
            data.pause();
            data.cycle();
          }
        });
      };

      Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
        var selector = Util.getSelectorFromElement(this);

        if (!selector) {
          return;
        }

        var target = $(selector)[0];

        if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {
          return;
        }

        var config = $.extend({}, $(target).data(), $(this).data());
        var slideIndex = this.getAttribute('data-slide-to');

        if (slideIndex) {
          config.interval = false;
        }

        Carousel._jQueryInterface.call($(target), config);

        if (slideIndex) {
          $(target).data(DATA_KEY).to(slideIndex);
        }

        event.preventDefault();
      };

      _createClass(Carousel, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return Carousel;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);

    $(window).on(Event.LOAD_DATA_API, function () {
      $(Selector.DATA_RIDE).each(function () {
        var $carousel = $(this);
        Carousel._jQueryInterface.call($carousel, $carousel.data());
      });
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Carousel._jQueryInterface;
    $.fn[NAME].Constructor = Carousel;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Carousel._jQueryInterface;
    };

    return Carousel;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Collapse = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'collapse';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.collapse';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 600;

    var Default = {
      toggle: true,
      parent: ''
    };

    var DefaultType = {
      toggle: 'boolean',
      parent: 'string'
    };

    var Event = {
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      SHOW: 'show',
      COLLAPSE: 'collapse',
      COLLAPSING: 'collapsing',
      COLLAPSED: 'collapsed'
    };

    var Dimension = {
      WIDTH: 'width',
      HEIGHT: 'height'
    };

    var Selector = {
      ACTIVES: '.show, .collapsing',
      DATA_TOGGLE: '[data-toggle="collapse"]'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Collapse = function () {
      function Collapse(element, config) {
        _classCallCheck(this, Collapse);

        this._isTransitioning = false;
        this._element = element;
        this._config = this._getConfig(config);
        this._triggerArray = $.makeArray($('[data-toggle="collapse"][href="#' + element.id + '"],' + ('[data-toggle="collapse"][data-target="#' + element.id + '"]')));
        var tabToggles = $(Selector.DATA_TOGGLE);
        for (var i = 0; i < tabToggles.length; i++) {
          var elem = tabToggles[i];
          var selector = Util.getSelectorFromElement(elem);
          if (selector !== null && $(selector).filter(element).length > 0) {
            this._triggerArray.push(elem);
          }
        }

        this._parent = this._config.parent ? this._getParent() : null;

        if (!this._config.parent) {
          this._addAriaAndCollapsedClass(this._element, this._triggerArray);
        }

        if (this._config.toggle) {
          this.toggle();
        }
      }

      // getters

      // public

      Collapse.prototype.toggle = function toggle() {
        if ($(this._element).hasClass(ClassName.SHOW)) {
          this.hide();
        } else {
          this.show();
        }
      };

      Collapse.prototype.show = function show() {
        var _this6 = this;

        if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {
          return;
        }

        var actives = void 0;
        var activesData = void 0;

        if (this._parent) {
          actives = $.makeArray($(this._parent).children().children(Selector.ACTIVES));
          if (!actives.length) {
            actives = null;
          }
        }

        if (actives) {
          activesData = $(actives).data(DATA_KEY);
          if (activesData && activesData._isTransitioning) {
            return;
          }
        }

        var startEvent = $.Event(Event.SHOW);
        $(this._element).trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
          return;
        }

        if (actives) {
          Collapse._jQueryInterface.call($(actives), 'hide');
          if (!activesData) {
            $(actives).data(DATA_KEY, null);
          }
        }

        var dimension = this._getDimension();

        $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);

        this._element.style[dimension] = 0;

        if (this._triggerArray.length) {
          $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
        }

        this.setTransitioning(true);

        var complete = function complete() {
          $(_this6._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);

          _this6._element.style[dimension] = '';

          _this6.setTransitioning(false);

          $(_this6._element).trigger(Event.SHOWN);
        };

        if (!Util.supportsTransitionEnd()) {
          complete();
          return;
        }

        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        var scrollSize = 'scroll' + capitalizedDimension;

        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);

        this._element.style[dimension] = this._element[scrollSize] + 'px';
      };

      Collapse.prototype.hide = function hide() {
        var _this7 = this;

        if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {
          return;
        }

        var startEvent = $.Event(Event.HIDE);
        $(this._element).trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
          return;
        }

        var dimension = this._getDimension();

        this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + 'px';

        Util.reflow(this._element);

        $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

        if (this._triggerArray.length) {
          for (var i = 0; i < this._triggerArray.length; i++) {
            var trigger = this._triggerArray[i];
            var selector = Util.getSelectorFromElement(trigger);
            if (selector !== null) {
              var $elem = $(selector);
              if (!$elem.hasClass(ClassName.SHOW)) {
                $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
              }
            }
          }
        }

        this.setTransitioning(true);

        var complete = function complete() {
          _this7.setTransitioning(false);
          $(_this7._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
        };

        this._element.style[dimension] = '';

        if (!Util.supportsTransitionEnd()) {
          complete();
          return;
        }

        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      };

      Collapse.prototype.setTransitioning = function setTransitioning(isTransitioning) {
        this._isTransitioning = isTransitioning;
      };

      Collapse.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);

        this._config = null;
        this._parent = null;
        this._element = null;
        this._triggerArray = null;
        this._isTransitioning = null;
      };

      // private

      Collapse.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);
        config.toggle = Boolean(config.toggle); // coerce string values
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      Collapse.prototype._getDimension = function _getDimension() {
        var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
        return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
      };

      Collapse.prototype._getParent = function _getParent() {
        var _this8 = this;

        var parent = $(this._config.parent)[0];
        var selector = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';

        $(parent).find(selector).each(function (i, element) {
          _this8._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
        });

        return parent;
      };

      Collapse.prototype._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
        if (element) {
          var isOpen = $(element).hasClass(ClassName.SHOW);

          if (triggerArray.length) {
            $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
          }
        }
      };

      // static

      Collapse._getTargetFromElement = function _getTargetFromElement(element) {
        var selector = Util.getSelectorFromElement(element);
        return selector ? $(selector)[0] : null;
      };

      Collapse._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data(DATA_KEY);
          var _config = $.extend({}, Default, $this.data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);

          if (!data && _config.toggle && /show|hide/.test(config)) {
            _config.toggle = false;
          }

          if (!data) {
            data = new Collapse(this, _config);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Collapse, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return Collapse;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      if (!/input|textarea/i.test(event.target.tagName)) {
        event.preventDefault();
      }

      var $trigger = $(this);
      var selector = Util.getSelectorFromElement(this);
      $(selector).each(function () {
        var $target = $(this);
        var data = $target.data(DATA_KEY);
        var config = data ? 'toggle' : $trigger.data();
        Collapse._jQueryInterface.call($target, config);
      });
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Collapse._jQueryInterface;
    $.fn[NAME].Constructor = Collapse;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Collapse._jQueryInterface;
    };

    return Collapse;
  }(jQuery);

  /* global Popper */

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Dropdown = function ($) {

    /**
     * Check for Popper dependency
     * Popper - https://popper.js.org
     */
    if (typeof Popper === 'undefined') {
      throw new Error('Bootstrap dropdown require Popper.js (https://popper.js.org)');
    }

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'dropdown';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.dropdown';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
    var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key
    var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key
    var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key
    var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key
    var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)
    var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + '|' + ARROW_DOWN_KEYCODE + '|' + ESCAPE_KEYCODE);

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      CLICK: 'click' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,
      KEYDOWN_DATA_API: 'keydown' + EVENT_KEY + DATA_API_KEY,
      KEYUP_DATA_API: 'keyup' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      DISABLED: 'disabled',
      SHOW: 'show',
      DROPUP: 'dropup',
      MENURIGHT: 'dropdown-menu-right',
      MENULEFT: 'dropdown-menu-left'
    };

    var Selector = {
      DATA_TOGGLE: '[data-toggle="dropdown"]',
      FORM_CHILD: '.dropdown form',
      MENU: '.dropdown-menu',
      NAVBAR_NAV: '.navbar-nav',
      VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled)'
    };

    var AttachmentMap = {
      TOP: 'top-start',
      TOPEND: 'top-end',
      BOTTOM: 'bottom-start',
      BOTTOMEND: 'bottom-end'
    };

    var Default = {
      placement: AttachmentMap.BOTTOM,
      offset: 0,
      flip: true
    };

    var DefaultType = {
      placement: 'string',
      offset: '(number|string)',
      flip: 'boolean'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Dropdown = function () {
      function Dropdown(element, config) {
        _classCallCheck(this, Dropdown);

        this._element = element;
        this._popper = null;
        this._config = this._getConfig(config);
        this._menu = this._getMenuElement();
        this._inNavbar = this._detectNavbar();

        this._addEventListeners();
      }

      // getters

      // public

      Dropdown.prototype.toggle = function toggle() {
        if (this._element.disabled || $(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this._element);
        var isActive = $(this._menu).hasClass(ClassName.SHOW);

        Dropdown._clearMenus();

        if (isActive) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = $.Event(Event.SHOW, relatedTarget);

        $(parent).trigger(showEvent);

        if (showEvent.isDefaultPrevented()) {
          return;
        }

        var element = this._element;
        // for dropup with alignment we use the parent as popper container
        if ($(parent).hasClass(ClassName.DROPUP)) {
          if ($(this._menu).hasClass(ClassName.MENULEFT) || $(this._menu).hasClass(ClassName.MENURIGHT)) {
            element = parent;
          }
        }
        this._popper = new Popper(element, this._menu, this._getPopperConfig());

        // if this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ('ontouchstart' in document.documentElement && !$(parent).closest(Selector.NAVBAR_NAV).length) {
          $('body').children().on('mouseover', null, $.noop);
        }

        this._element.focus();
        this._element.setAttribute('aria-expanded', true);

        $(this._menu).toggleClass(ClassName.SHOW);
        $(parent).toggleClass(ClassName.SHOW).trigger($.Event(Event.SHOWN, relatedTarget));
      };

      Dropdown.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        $(this._element).off(EVENT_KEY);
        this._element = null;
        this._menu = null;
        if (this._popper !== null) {
          this._popper.destroy();
        }
        this._popper = null;
      };

      Dropdown.prototype.update = function update() {
        this._inNavbar = this._detectNavbar();
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      };

      // private

      Dropdown.prototype._addEventListeners = function _addEventListeners() {
        var _this9 = this;

        $(this._element).on(Event.CLICK, function (event) {
          event.preventDefault();
          event.stopPropagation();
          _this9.toggle();
        });
      };

      Dropdown.prototype._getConfig = function _getConfig(config) {
        var elementData = $(this._element).data();
        if (elementData.placement !== undefined) {
          elementData.placement = AttachmentMap[elementData.placement.toUpperCase()];
        }

        config = $.extend({}, this.constructor.Default, $(this._element).data(), config);

        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);

        return config;
      };

      Dropdown.prototype._getMenuElement = function _getMenuElement() {
        if (!this._menu) {
          var parent = Dropdown._getParentFromElement(this._element);
          this._menu = $(parent).find(Selector.MENU)[0];
        }
        return this._menu;
      };

      Dropdown.prototype._getPlacement = function _getPlacement() {
        var $parentDropdown = $(this._element).parent();
        var placement = this._config.placement;

        // Handle dropup
        if ($parentDropdown.hasClass(ClassName.DROPUP) || this._config.placement === AttachmentMap.TOP) {
          placement = AttachmentMap.TOP;
          if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
            placement = AttachmentMap.TOPEND;
          }
        } else if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
          placement = AttachmentMap.BOTTOMEND;
        }
        return placement;
      };

      Dropdown.prototype._detectNavbar = function _detectNavbar() {
        return $(this._element).closest('.navbar').length > 0;
      };

      Dropdown.prototype._getPopperConfig = function _getPopperConfig() {
        var popperConfig = {
          placement: this._getPlacement(),
          modifiers: {
            offset: {
              offset: this._config.offset
            },
            flip: {
              enabled: this._config.flip
            }

            // Disable Popper.js for Dropdown in Navbar
          } };if (this._inNavbar) {
          popperConfig.modifiers.applyStyle = {
            enabled: !this._inNavbar
          };
        }
        return popperConfig;
      };

      // static

      Dropdown._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;

          if (!data) {
            data = new Dropdown(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      Dropdown._clearMenus = function _clearMenus(event) {
        if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
          return;
        }

        var toggles = $.makeArray($(Selector.DATA_TOGGLE));
        for (var i = 0; i < toggles.length; i++) {
          var parent = Dropdown._getParentFromElement(toggles[i]);
          var context = $(toggles[i]).data(DATA_KEY);
          var relatedTarget = {
            relatedTarget: toggles[i]
          };

          if (!context) {
            continue;
          }

          var dropdownMenu = context._menu;
          if (!$(parent).hasClass(ClassName.SHOW)) {
            continue;
          }

          if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
            continue;
          }

          var hideEvent = $.Event(Event.HIDE, relatedTarget);
          $(parent).trigger(hideEvent);
          if (hideEvent.isDefaultPrevented()) {
            continue;
          }

          // if this is a touch-enabled device we remove the extra
          // empty mouseover listeners we added for iOS support
          if ('ontouchstart' in document.documentElement) {
            $('body').children().off('mouseover', null, $.noop);
          }

          toggles[i].setAttribute('aria-expanded', 'false');

          $(dropdownMenu).removeClass(ClassName.SHOW);
          $(parent).removeClass(ClassName.SHOW).trigger($.Event(Event.HIDDEN, relatedTarget));
        }
      };

      Dropdown._getParentFromElement = function _getParentFromElement(element) {
        var parent = void 0;
        var selector = Util.getSelectorFromElement(element);

        if (selector) {
          parent = $(selector)[0];
        }

        return parent || element.parentNode;
      };

      Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
        if (!REGEXP_KEYDOWN.test(event.which) || /button/i.test(event.target.tagName) && event.which === SPACE_KEYCODE || /input|textarea/i.test(event.target.tagName)) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this);
        var isActive = $(parent).hasClass(ClassName.SHOW);

        if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {

          if (event.which === ESCAPE_KEYCODE) {
            var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];
            $(toggle).trigger('focus');
          }

          $(this).trigger('click');
          return;
        }

        var items = $(parent).find(Selector.VISIBLE_ITEMS).get();

        if (!items.length) {
          return;
        }

        var index = items.indexOf(event.target);

        if (event.which === ARROW_UP_KEYCODE && index > 0) {
          // up
          index--;
        }

        if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
          // down
          index++;
        }

        if (index < 0) {
          index = 0;
        }

        items[index].focus();
      };

      _createClass(Dropdown, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }, {
        key: 'DefaultType',
        get: function get() {
          return DefaultType;
        }
      }]);

      return Dropdown;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + ' ' + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();
      event.stopPropagation();
      Dropdown._jQueryInterface.call($(this), 'toggle');
    }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
      e.stopPropagation();
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Dropdown._jQueryInterface;
    $.fn[NAME].Constructor = Dropdown;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Dropdown._jQueryInterface;
    };

    return Dropdown;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Modal = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'modal';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.modal';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 300;
    var BACKDROP_TRANSITION_DURATION = 150;
    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

    var Default = {
      backdrop: true,
      keyboard: true,
      focus: true,
      show: true
    };

    var DefaultType = {
      backdrop: '(boolean|string)',
      keyboard: 'boolean',
      focus: 'boolean',
      show: 'boolean'
    };

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      FOCUSIN: 'focusin' + EVENT_KEY,
      RESIZE: 'resize' + EVENT_KEY,
      CLICK_DISMISS: 'click.dismiss' + EVENT_KEY,
      KEYDOWN_DISMISS: 'keydown.dismiss' + EVENT_KEY,
      MOUSEUP_DISMISS: 'mouseup.dismiss' + EVENT_KEY,
      MOUSEDOWN_DISMISS: 'mousedown.dismiss' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
      BACKDROP: 'modal-backdrop',
      OPEN: 'modal-open',
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      DIALOG: '.modal-dialog',
      DATA_TOGGLE: '[data-toggle="modal"]',
      DATA_DISMISS: '[data-dismiss="modal"]',
      FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
      NAVBAR_TOGGLER: '.navbar-toggler'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Modal = function () {
      function Modal(element, config) {
        _classCallCheck(this, Modal);

        this._config = this._getConfig(config);
        this._element = element;
        this._dialog = $(element).find(Selector.DIALOG)[0];
        this._backdrop = null;
        this._isShown = false;
        this._isBodyOverflowing = false;
        this._ignoreBackdropClick = false;
        this._originalBodyPadding = 0;
        this._scrollbarWidth = 0;
      }

      // getters

      // public

      Modal.prototype.toggle = function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      };

      Modal.prototype.show = function show(relatedTarget) {
        var _this10 = this;

        if (this._isTransitioning) {
          return;
        }

        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
          this._isTransitioning = true;
        }

        var showEvent = $.Event(Event.SHOW, {
          relatedTarget: relatedTarget
        });

        $(this._element).trigger(showEvent);

        if (this._isShown || showEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = true;

        this._checkScrollbar();
        this._setScrollbar();

        $(document.body).addClass(ClassName.OPEN);

        this._setEscapeEvent();
        this._setResizeEvent();

        $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
          return _this10.hide(event);
        });

        $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
          $(_this10._element).one(Event.MOUSEUP_DISMISS, function (event) {
            if ($(event.target).is(_this10._element)) {
              _this10._ignoreBackdropClick = true;
            }
          });
        });

        this._showBackdrop(function () {
          return _this10._showElement(relatedTarget);
        });
      };

      Modal.prototype.hide = function hide(event) {
        var _this11 = this;

        if (event) {
          event.preventDefault();
        }

        if (this._isTransitioning || !this._isShown) {
          return;
        }

        var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

        if (transition) {
          this._isTransitioning = true;
        }

        var hideEvent = $.Event(Event.HIDE);

        $(this._element).trigger(hideEvent);

        if (!this._isShown || hideEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = false;

        this._setEscapeEvent();
        this._setResizeEvent();

        $(document).off(Event.FOCUSIN);

        $(this._element).removeClass(ClassName.SHOW);

        $(this._element).off(Event.CLICK_DISMISS);
        $(this._dialog).off(Event.MOUSEDOWN_DISMISS);

        if (transition) {

          $(this._element).one(Util.TRANSITION_END, function (event) {
            return _this11._hideModal(event);
          }).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          this._hideModal();
        }
      };

      Modal.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);

        $(window, document, this._element, this._backdrop).off(EVENT_KEY);

        this._config = null;
        this._element = null;
        this._dialog = null;
        this._backdrop = null;
        this._isShown = null;
        this._isBodyOverflowing = null;
        this._ignoreBackdropClick = null;
        this._scrollbarWidth = null;
      };

      Modal.prototype.handleUpdate = function handleUpdate() {
        this._adjustDialog();
      };

      // private

      Modal.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      Modal.prototype._showElement = function _showElement(relatedTarget) {
        var _this12 = this;

        var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
          // don't move modals dom position
          document.body.appendChild(this._element);
        }

        this._element.style.display = 'block';
        this._element.removeAttribute('aria-hidden');
        this._element.scrollTop = 0;

        if (transition) {
          Util.reflow(this._element);
        }

        $(this._element).addClass(ClassName.SHOW);

        if (this._config.focus) {
          this._enforceFocus();
        }

        var shownEvent = $.Event(Event.SHOWN, {
          relatedTarget: relatedTarget
        });

        var transitionComplete = function transitionComplete() {
          if (_this12._config.focus) {
            _this12._element.focus();
          }
          _this12._isTransitioning = false;
          $(_this12._element).trigger(shownEvent);
        };

        if (transition) {
          $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          transitionComplete();
        }
      };

      Modal.prototype._enforceFocus = function _enforceFocus() {
        var _this13 = this;

        $(document).off(Event.FOCUSIN) // guard against infinite focus loop
        .on(Event.FOCUSIN, function (event) {
          if (document !== event.target && _this13._element !== event.target && !$(_this13._element).has(event.target).length) {
            _this13._element.focus();
          }
        });
      };

      Modal.prototype._setEscapeEvent = function _setEscapeEvent() {
        var _this14 = this;

        if (this._isShown && this._config.keyboard) {
          $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
            if (event.which === ESCAPE_KEYCODE) {
              event.preventDefault();
              _this14.hide();
            }
          });
        } else if (!this._isShown) {
          $(this._element).off(Event.KEYDOWN_DISMISS);
        }
      };

      Modal.prototype._setResizeEvent = function _setResizeEvent() {
        var _this15 = this;

        if (this._isShown) {
          $(window).on(Event.RESIZE, function (event) {
            return _this15.handleUpdate(event);
          });
        } else {
          $(window).off(Event.RESIZE);
        }
      };

      Modal.prototype._hideModal = function _hideModal() {
        var _this16 = this;

        this._element.style.display = 'none';
        this._element.setAttribute('aria-hidden', true);
        this._isTransitioning = false;
        this._showBackdrop(function () {
          $(document.body).removeClass(ClassName.OPEN);
          _this16._resetAdjustments();
          _this16._resetScrollbar();
          $(_this16._element).trigger(Event.HIDDEN);
        });
      };

      Modal.prototype._removeBackdrop = function _removeBackdrop() {
        if (this._backdrop) {
          $(this._backdrop).remove();
          this._backdrop = null;
        }
      };

      Modal.prototype._showBackdrop = function _showBackdrop(callback) {
        var _this17 = this;

        var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';

        if (this._isShown && this._config.backdrop) {
          var doAnimate = Util.supportsTransitionEnd() && animate;

          this._backdrop = document.createElement('div');
          this._backdrop.className = ClassName.BACKDROP;

          if (animate) {
            $(this._backdrop).addClass(animate);
          }

          $(this._backdrop).appendTo(document.body);

          $(this._element).on(Event.CLICK_DISMISS, function (event) {
            if (_this17._ignoreBackdropClick) {
              _this17._ignoreBackdropClick = false;
              return;
            }
            if (event.target !== event.currentTarget) {
              return;
            }
            if (_this17._config.backdrop === 'static') {
              _this17._element.focus();
            } else {
              _this17.hide();
            }
          });

          if (doAnimate) {
            Util.reflow(this._backdrop);
          }

          $(this._backdrop).addClass(ClassName.SHOW);

          if (!callback) {
            return;
          }

          if (!doAnimate) {
            callback();
            return;
          }

          $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
        } else if (!this._isShown && this._backdrop) {
          $(this._backdrop).removeClass(ClassName.SHOW);

          var callbackRemove = function callbackRemove() {
            _this17._removeBackdrop();
            if (callback) {
              callback();
            }
          };

          if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
            $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
          } else {
            callbackRemove();
          }
        } else if (callback) {
          callback();
        }
      };

      // ----------------------------------------------------------------------
      // the following methods are used to handle overflowing modals
      // todo (fat): these should probably be refactored out of modal.js
      // ----------------------------------------------------------------------

      Modal.prototype._adjustDialog = function _adjustDialog() {
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

        if (!this._isBodyOverflowing && isModalOverflowing) {
          this._element.style.paddingLeft = this._scrollbarWidth + 'px';
        }

        if (this._isBodyOverflowing && !isModalOverflowing) {
          this._element.style.paddingRight = this._scrollbarWidth + 'px';
        }
      };

      Modal.prototype._resetAdjustments = function _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
      };

      Modal.prototype._checkScrollbar = function _checkScrollbar() {
        this._isBodyOverflowing = document.body.clientWidth < window.innerWidth;
        this._scrollbarWidth = this._getScrollbarWidth();
      };

      Modal.prototype._setScrollbar = function _setScrollbar() {
        var _this18 = this;

        if (this._isBodyOverflowing) {
          // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
          //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set

          // Adjust fixed content padding
          $(Selector.FIXED_CONTENT).each(function (index, element) {
            var actualPadding = $(element)[0].style.paddingRight;
            var calculatedPadding = $(element).css('padding-right');
            $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this18._scrollbarWidth + 'px');
          });

          // Adjust navbar-toggler margin
          $(Selector.NAVBAR_TOGGLER).each(function (index, element) {
            var actualMargin = $(element)[0].style.marginRight;
            var calculatedMargin = $(element).css('margin-right');
            $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this18._scrollbarWidth + 'px');
          });

          // Adjust body padding
          var actualPadding = document.body.style.paddingRight;
          var calculatedPadding = $('body').css('padding-right');
          $('body').data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + 'px');
        }
      };

      Modal.prototype._resetScrollbar = function _resetScrollbar() {
        // Restore fixed content padding
        $(Selector.FIXED_CONTENT).each(function (index, element) {
          var padding = $(element).data('padding-right');
          if (typeof padding !== 'undefined') {
            $(element).css('padding-right', padding).removeData('padding-right');
          }
        });

        // Restore navbar-toggler margin
        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {
          var margin = $(element).data('margin-right');
          if (typeof margin !== 'undefined') {
            $(element).css('margin-right', margin).removeData('margin-right');
          }
        });

        // Restore body padding
        var padding = $('body').data('padding-right');
        if (typeof padding !== 'undefined') {
          $('body').css('padding-right', padding).removeData('padding-right');
        }
      };

      Modal.prototype._getScrollbarWidth = function _getScrollbarWidth() {
        // thx d.walsh
        var scrollDiv = document.createElement('div');
        scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      };

      // static

      Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = $.extend({}, Modal.Default, $(this).data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);

          if (!data) {
            data = new Modal(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config](relatedTarget);
          } else if (_config.show) {
            data.show(relatedTarget);
          }
        });
      };

      _createClass(Modal, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return Modal;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      var _this19 = this;

      var target = void 0;
      var selector = Util.getSelectorFromElement(this);

      if (selector) {
        target = $(selector)[0];
      }

      var config = $(target).data(DATA_KEY) ? 'toggle' : $.extend({}, $(target).data(), $(this).data());

      if (this.tagName === 'A' || this.tagName === 'AREA') {
        event.preventDefault();
      }

      var $target = $(target).one(Event.SHOW, function (showEvent) {
        if (showEvent.isDefaultPrevented()) {
          // only register focus restorer if modal will actually get shown
          return;
        }

        $target.one(Event.HIDDEN, function () {
          if ($(_this19).is(':visible')) {
            _this19.focus();
          }
        });
      });

      Modal._jQueryInterface.call($(target), config, this);
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Modal._jQueryInterface;
    $.fn[NAME].Constructor = Modal;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Modal._jQueryInterface;
    };

    return Modal;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var ScrollSpy = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'scrollspy';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.scrollspy';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];

    var Default = {
      offset: 10,
      method: 'auto',
      target: ''
    };

    var DefaultType = {
      offset: 'number',
      method: 'string',
      target: '(string|element)'
    };

    var Event = {
      ACTIVATE: 'activate' + EVENT_KEY,
      SCROLL: 'scroll' + EVENT_KEY,
      LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      DROPDOWN_ITEM: 'dropdown-item',
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active'
    };

    var Selector = {
      DATA_SPY: '[data-spy="scroll"]',
      ACTIVE: '.active',
      NAV_LIST_GROUP: '.nav, .list-group',
      NAV_LINKS: '.nav-link',
      LIST_ITEMS: '.list-group-item',
      DROPDOWN: '.dropdown',
      DROPDOWN_ITEMS: '.dropdown-item',
      DROPDOWN_TOGGLE: '.dropdown-toggle'
    };

    var OffsetMethod = {
      OFFSET: 'offset',
      POSITION: 'position'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var ScrollSpy = function () {
      function ScrollSpy(element, config) {
        var _this20 = this;

        _classCallCheck(this, ScrollSpy);

        this._element = element;
        this._scrollElement = element.tagName === 'BODY' ? window : element;
        this._config = this._getConfig(config);
        this._selector = this._config.target + ' ' + Selector.NAV_LINKS + ',' + (this._config.target + ' ' + Selector.LIST_ITEMS + ',') + (this._config.target + ' ' + Selector.DROPDOWN_ITEMS);
        this._offsets = [];
        this._targets = [];
        this._activeTarget = null;
        this._scrollHeight = 0;

        $(this._scrollElement).on(Event.SCROLL, function (event) {
          return _this20._process(event);
        });

        this.refresh();
        this._process();
      }

      // getters

      // public

      ScrollSpy.prototype.refresh = function refresh() {
        var _this21 = this;

        var autoMethod = this._scrollElement !== this._scrollElement.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;

        var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;

        var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;

        this._offsets = [];
        this._targets = [];

        this._scrollHeight = this._getScrollHeight();

        var targets = $.makeArray($(this._selector));

        targets.map(function (element) {
          var target = void 0;
          var targetSelector = Util.getSelectorFromElement(element);

          if (targetSelector) {
            target = $(targetSelector)[0];
          }

          if (target) {
            var targetBCR = target.getBoundingClientRect();
            if (targetBCR.width || targetBCR.height) {
              // todo (fat): remove sketch reliance on jQuery position/offset
              return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
            }
          }
          return null;
        }).filter(function (item) {
          return item;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).forEach(function (item) {
          _this21._offsets.push(item[0]);
          _this21._targets.push(item[1]);
        });
      };

      ScrollSpy.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        $(this._scrollElement).off(EVENT_KEY);

        this._element = null;
        this._scrollElement = null;
        this._config = null;
        this._selector = null;
        this._offsets = null;
        this._targets = null;
        this._activeTarget = null;
        this._scrollHeight = null;
      };

      // private

      ScrollSpy.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);

        if (typeof config.target !== 'string') {
          var id = $(config.target).attr('id');
          if (!id) {
            id = Util.getUID(NAME);
            $(config.target).attr('id', id);
          }
          config.target = '#' + id;
        }

        Util.typeCheckConfig(NAME, config, DefaultType);

        return config;
      };

      ScrollSpy.prototype._getScrollTop = function _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
      };

      ScrollSpy.prototype._getScrollHeight = function _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      };

      ScrollSpy.prototype._getOffsetHeight = function _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
      };

      ScrollSpy.prototype._process = function _process() {
        var scrollTop = this._getScrollTop() + this._config.offset;
        var scrollHeight = this._getScrollHeight();
        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

        if (this._scrollHeight !== scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          var target = this._targets[this._targets.length - 1];

          if (this._activeTarget !== target) {
            this._activate(target);
          }
          return;
        }

        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
          this._activeTarget = null;
          this._clear();
          return;
        }

        for (var i = this._offsets.length; i--;) {
          var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (this._offsets[i + 1] === undefined || scrollTop < this._offsets[i + 1]);

          if (isActiveTarget) {
            this._activate(this._targets[i]);
          }
        }
      };

      ScrollSpy.prototype._activate = function _activate(target) {
        this._activeTarget = target;

        this._clear();

        var queries = this._selector.split(',');
        queries = queries.map(function (selector) {
          return selector + '[data-target="' + target + '"],' + (selector + '[href="' + target + '"]');
        });

        var $link = $(queries.join(','));

        if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
          $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
          $link.addClass(ClassName.ACTIVE);
        } else {
          // Set triggered link as active
          $link.addClass(ClassName.ACTIVE);
          // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ', ' + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE);
        }

        $(this._scrollElement).trigger(Event.ACTIVATE, {
          relatedTarget: target
        });
      };

      ScrollSpy.prototype._clear = function _clear() {
        $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
      };

      // static

      ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;

          if (!data) {
            data = new ScrollSpy(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(ScrollSpy, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return ScrollSpy;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(window).on(Event.LOAD_DATA_API, function () {
      var scrollSpys = $.makeArray($(Selector.DATA_SPY));

      for (var i = scrollSpys.length; i--;) {
        var $spy = $(scrollSpys[i]);
        ScrollSpy._jQueryInterface.call($spy, $spy.data());
      }
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = ScrollSpy._jQueryInterface;
    $.fn[NAME].Constructor = ScrollSpy;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return ScrollSpy._jQueryInterface;
    };

    return ScrollSpy;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Tab = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'tab';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.tab';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 150;

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active',
      DISABLED: 'disabled',
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      DROPDOWN: '.dropdown',
      NAV_LIST_GROUP: '.nav, .list-group',
      ACTIVE: '.active',
      DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
      DROPDOWN_TOGGLE: '.dropdown-toggle',
      DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Tab = function () {
      function Tab(element) {
        _classCallCheck(this, Tab);

        this._element = element;
      }

      // getters

      // public

      Tab.prototype.show = function show() {
        var _this22 = this;

        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var target = void 0;
        var previous = void 0;
        var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];
        var selector = Util.getSelectorFromElement(this._element);

        if (listElement) {
          previous = $.makeArray($(listElement).find(Selector.ACTIVE));
          previous = previous[previous.length - 1];
        }

        var hideEvent = $.Event(Event.HIDE, {
          relatedTarget: this._element
        });

        var showEvent = $.Event(Event.SHOW, {
          relatedTarget: previous
        });

        if (previous) {
          $(previous).trigger(hideEvent);
        }

        $(this._element).trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
          return;
        }

        if (selector) {
          target = $(selector)[0];
        }

        this._activate(this._element, listElement);

        var complete = function complete() {
          var hiddenEvent = $.Event(Event.HIDDEN, {
            relatedTarget: _this22._element
          });

          var shownEvent = $.Event(Event.SHOWN, {
            relatedTarget: previous
          });

          $(previous).trigger(hiddenEvent);
          $(_this22._element).trigger(shownEvent);
        };

        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      };

      Tab.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        this._element = null;
      };

      // private

      Tab.prototype._activate = function _activate(element, container, callback) {
        var _this23 = this;

        var active = $(container).find(Selector.ACTIVE)[0];
        var isTransitioning = callback && Util.supportsTransitionEnd() && active && $(active).hasClass(ClassName.FADE);

        var complete = function complete() {
          return _this23._transitionComplete(element, active, isTransitioning, callback);
        };

        if (active && isTransitioning) {
          $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          complete();
        }

        if (active) {
          $(active).removeClass(ClassName.SHOW);
        }
      };

      Tab.prototype._transitionComplete = function _transitionComplete(element, active, isTransitioning, callback) {
        if (active) {
          $(active).removeClass(ClassName.ACTIVE);

          var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

          if (dropdownChild) {
            $(dropdownChild).removeClass(ClassName.ACTIVE);
          }

          active.setAttribute('aria-expanded', false);
        }

        $(element).addClass(ClassName.ACTIVE);
        element.setAttribute('aria-expanded', true);

        if (isTransitioning) {
          Util.reflow(element);
          $(element).addClass(ClassName.SHOW);
        } else {
          $(element).removeClass(ClassName.FADE);
        }

        if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {

          var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];
          if (dropdownElement) {
            $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
          }

          element.setAttribute('aria-expanded', true);
        }

        if (callback) {
          callback();
        }
      };

      // static

      Tab._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data(DATA_KEY);

          if (!data) {
            data = new Tab(this);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Tab, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }]);

      return Tab;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();
      Tab._jQueryInterface.call($(this), 'show');
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Tab._jQueryInterface;
    $.fn[NAME].Constructor = Tab;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tab._jQueryInterface;
    };

    return Tab;
  }(jQuery);

  /* global Popper */

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Tooltip = function ($) {

    /**
     * Check for Popper dependency
     * Popper - https://popper.js.org
     */
    if (typeof Popper === 'undefined') {
      throw new Error('Bootstrap tooltips require Popper.js (https://popper.js.org)');
    }

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'tooltip';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.tooltip';
    var EVENT_KEY = '.' + DATA_KEY;
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 150;
    var CLASS_PREFIX = 'bs-tooltip';
    var BSCLS_PREFIX_REGEX = new RegExp('(^|\\s)' + CLASS_PREFIX + '\\S+', 'g');

    var DefaultType = {
      animation: 'boolean',
      template: 'string',
      title: '(string|element|function)',
      trigger: 'string',
      delay: '(number|object)',
      html: 'boolean',
      selector: '(string|boolean)',
      placement: '(string|function)',
      offset: '(number|string)',
      container: '(string|element|boolean)',
      fallbackPlacement: '(string|array)'
    };

    var AttachmentMap = {
      AUTO: 'auto',
      TOP: 'top',
      RIGHT: 'right',
      BOTTOM: 'bottom',
      LEFT: 'left'
    };

    var Default = {
      animation: true,
      template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
      trigger: 'hover focus',
      title: '',
      delay: 0,
      html: false,
      selector: false,
      placement: 'top',
      offset: 0,
      container: false,
      fallbackPlacement: 'flip'
    };

    var HoverState = {
      SHOW: 'show',
      OUT: 'out'
    };

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      INSERTED: 'inserted' + EVENT_KEY,
      CLICK: 'click' + EVENT_KEY,
      FOCUSIN: 'focusin' + EVENT_KEY,
      FOCUSOUT: 'focusout' + EVENT_KEY,
      MOUSEENTER: 'mouseenter' + EVENT_KEY,
      MOUSELEAVE: 'mouseleave' + EVENT_KEY
    };

    var ClassName = {
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      TOOLTIP: '.tooltip',
      TOOLTIP_INNER: '.tooltip-inner',
      ARROW: '.arrow'
    };

    var Trigger = {
      HOVER: 'hover',
      FOCUS: 'focus',
      CLICK: 'click',
      MANUAL: 'manual'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Tooltip = function () {
      function Tooltip(element, config) {
        _classCallCheck(this, Tooltip);

        // private
        this._isEnabled = true;
        this._timeout = 0;
        this._hoverState = '';
        this._activeTrigger = {};
        this._popper = null;

        // protected
        this.element = element;
        this.config = this._getConfig(config);
        this.tip = null;

        this._setListeners();
      }

      // getters

      // public

      Tooltip.prototype.enable = function enable() {
        this._isEnabled = true;
      };

      Tooltip.prototype.disable = function disable() {
        this._isEnabled = false;
      };

      Tooltip.prototype.toggleEnabled = function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      };

      Tooltip.prototype.toggle = function toggle(event) {
        if (event) {
          var dataKey = this.constructor.DATA_KEY;
          var context = $(event.currentTarget).data(dataKey);

          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $(event.currentTarget).data(dataKey, context);
          }

          context._activeTrigger.click = !context._activeTrigger.click;

          if (context._isWithActiveTrigger()) {
            context._enter(null, context);
          } else {
            context._leave(null, context);
          }
        } else {

          if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
            this._leave(null, this);
            return;
          }

          this._enter(null, this);
        }
      };

      Tooltip.prototype.dispose = function dispose() {
        clearTimeout(this._timeout);

        $.removeData(this.element, this.constructor.DATA_KEY);

        $(this.element).off(this.constructor.EVENT_KEY);
        $(this.element).closest('.modal').off('hide.bs.modal');

        if (this.tip) {
          $(this.tip).remove();
        }

        this._isEnabled = null;
        this._timeout = null;
        this._hoverState = null;
        this._activeTrigger = null;
        if (this._popper !== null) {
          this._popper.destroy();
        }
        this._popper = null;

        this.element = null;
        this.config = null;
        this.tip = null;
      };

      Tooltip.prototype.show = function show() {
        var _this24 = this;

        if ($(this.element).css('display') === 'none') {
          throw new Error('Please use show on visible elements');
        }

        var showEvent = $.Event(this.constructor.Event.SHOW);
        if (this.isWithContent() && this._isEnabled) {
          $(this.element).trigger(showEvent);

          var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);

          if (showEvent.isDefaultPrevented() || !isInTheDom) {
            return;
          }

          var tip = this.getTipElement();
          var tipId = Util.getUID(this.constructor.NAME);

          tip.setAttribute('id', tipId);
          this.element.setAttribute('aria-describedby', tipId);

          this.setContent();

          if (this.config.animation) {
            $(tip).addClass(ClassName.FADE);
          }

          var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

          var attachment = this._getAttachment(placement);
          this.addAttachmentClass(attachment);

          var container = this.config.container === false ? document.body : $(this.config.container);

          $(tip).data(this.constructor.DATA_KEY, this);

          if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
            $(tip).appendTo(container);
          }

          $(this.element).trigger(this.constructor.Event.INSERTED);

          this._popper = new Popper(this.element, tip, {
            placement: attachment,
            modifiers: {
              offset: {
                offset: this.config.offset
              },
              flip: {
                behavior: this.config.fallbackPlacement
              },
              arrow: {
                element: Selector.ARROW
              }
            },
            onCreate: function onCreate(data) {
              if (data.originalPlacement !== data.placement) {
                _this24._handlePopperPlacementChange(data);
              }
            },
            onUpdate: function onUpdate(data) {
              _this24._handlePopperPlacementChange(data);
            }
          });

          $(tip).addClass(ClassName.SHOW);

          // if this is a touch-enabled device we add extra
          // empty mouseover listeners to the body's immediate children;
          // only needed because of broken event delegation on iOS
          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
          if ('ontouchstart' in document.documentElement) {
            $('body').children().on('mouseover', null, $.noop);
          }

          var complete = function complete() {
            if (_this24.config.animation) {
              _this24._fixTransition();
            }
            var prevHoverState = _this24._hoverState;
            _this24._hoverState = null;

            $(_this24.element).trigger(_this24.constructor.Event.SHOWN);

            if (prevHoverState === HoverState.OUT) {
              _this24._leave(null, _this24);
            }
          };

          if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
            $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
          } else {
            complete();
          }
        }
      };

      Tooltip.prototype.hide = function hide(callback) {
        var _this25 = this;

        var tip = this.getTipElement();
        var hideEvent = $.Event(this.constructor.Event.HIDE);
        var complete = function complete() {
          if (_this25._hoverState !== HoverState.SHOW && tip.parentNode) {
            tip.parentNode.removeChild(tip);
          }

          _this25._cleanTipClass();
          _this25.element.removeAttribute('aria-describedby');
          $(_this25.element).trigger(_this25.constructor.Event.HIDDEN);
          if (_this25._popper !== null) {
            _this25._popper.destroy();
          }

          if (callback) {
            callback();
          }
        };

        $(this.element).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          return;
        }

        $(tip).removeClass(ClassName.SHOW);

        // if this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ('ontouchstart' in document.documentElement) {
          $('body').children().off('mouseover', null, $.noop);
        }

        this._activeTrigger[Trigger.CLICK] = false;
        this._activeTrigger[Trigger.FOCUS] = false;
        this._activeTrigger[Trigger.HOVER] = false;

        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {

          $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          complete();
        }

        this._hoverState = '';
      };

      Tooltip.prototype.update = function update() {
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      };

      // protected

      Tooltip.prototype.isWithContent = function isWithContent() {
        return Boolean(this.getTitle());
      };

      Tooltip.prototype.addAttachmentClass = function addAttachmentClass(attachment) {
        $(this.getTipElement()).addClass(CLASS_PREFIX + '-' + attachment);
      };

      Tooltip.prototype.getTipElement = function getTipElement() {
        return this.tip = this.tip || $(this.config.template)[0];
      };

      Tooltip.prototype.setContent = function setContent() {
        var $tip = $(this.getTipElement());
        this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
        $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);
      };

      Tooltip.prototype.setElementContent = function setElementContent($element, content) {
        var html = this.config.html;
        if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && (content.nodeType || content.jquery)) {
          // content is a DOM node or a jQuery
          if (html) {
            if (!$(content).parent().is($element)) {
              $element.empty().append(content);
            }
          } else {
            $element.text($(content).text());
          }
        } else {
          $element[html ? 'html' : 'text'](content);
        }
      };

      Tooltip.prototype.getTitle = function getTitle() {
        var title = this.element.getAttribute('data-original-title');

        if (!title) {
          title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
        }

        return title;
      };

      // private

      Tooltip.prototype._getAttachment = function _getAttachment(placement) {
        return AttachmentMap[placement.toUpperCase()];
      };

      Tooltip.prototype._setListeners = function _setListeners() {
        var _this26 = this;

        var triggers = this.config.trigger.split(' ');

        triggers.forEach(function (trigger) {
          if (trigger === 'click') {
            $(_this26.element).on(_this26.constructor.Event.CLICK, _this26.config.selector, function (event) {
              return _this26.toggle(event);
            });
          } else if (trigger !== Trigger.MANUAL) {
            var eventIn = trigger === Trigger.HOVER ? _this26.constructor.Event.MOUSEENTER : _this26.constructor.Event.FOCUSIN;
            var eventOut = trigger === Trigger.HOVER ? _this26.constructor.Event.MOUSELEAVE : _this26.constructor.Event.FOCUSOUT;

            $(_this26.element).on(eventIn, _this26.config.selector, function (event) {
              return _this26._enter(event);
            }).on(eventOut, _this26.config.selector, function (event) {
              return _this26._leave(event);
            });
          }

          $(_this26.element).closest('.modal').on('hide.bs.modal', function () {
            return _this26.hide();
          });
        });

        if (this.config.selector) {
          this.config = $.extend({}, this.config, {
            trigger: 'manual',
            selector: ''
          });
        } else {
          this._fixTitle();
        }
      };

      Tooltip.prototype._fixTitle = function _fixTitle() {
        var titleType = _typeof(this.element.getAttribute('data-original-title'));
        if (this.element.getAttribute('title') || titleType !== 'string') {
          this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
          this.element.setAttribute('title', '');
        }
      };

      Tooltip.prototype._enter = function _enter(event, context) {
        var dataKey = this.constructor.DATA_KEY;

        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
        }

        if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
          context._hoverState = HoverState.SHOW;
          return;
        }

        clearTimeout(context._timeout);

        context._hoverState = HoverState.SHOW;

        if (!context.config.delay || !context.config.delay.show) {
          context.show();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.SHOW) {
            context.show();
          }
        }, context.config.delay.show);
      };

      Tooltip.prototype._leave = function _leave(event, context) {
        var dataKey = this.constructor.DATA_KEY;

        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
        }

        if (context._isWithActiveTrigger()) {
          return;
        }

        clearTimeout(context._timeout);

        context._hoverState = HoverState.OUT;

        if (!context.config.delay || !context.config.delay.hide) {
          context.hide();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.OUT) {
            context.hide();
          }
        }, context.config.delay.hide);
      };

      Tooltip.prototype._isWithActiveTrigger = function _isWithActiveTrigger() {
        for (var trigger in this._activeTrigger) {
          if (this._activeTrigger[trigger]) {
            return true;
          }
        }

        return false;
      };

      Tooltip.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, this.constructor.Default, $(this.element).data(), config);

        if (config.delay && typeof config.delay === 'number') {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }

        if (config.title && typeof config.title === 'number') {
          config.title = config.title.toString();
        }

        if (config.content && typeof config.content === 'number') {
          config.content = config.content.toString();
        }

        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);

        return config;
      };

      Tooltip.prototype._getDelegateConfig = function _getDelegateConfig() {
        var config = {};

        if (this.config) {
          for (var key in this.config) {
            if (this.constructor.Default[key] !== this.config[key]) {
              config[key] = this.config[key];
            }
          }
        }

        return config;
      };

      Tooltip.prototype._cleanTipClass = function _cleanTipClass() {
        var $tip = $(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      };

      Tooltip.prototype._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
        this._cleanTipClass();
        this.addAttachmentClass(this._getAttachment(data.placement));
      };

      Tooltip.prototype._fixTransition = function _fixTransition() {
        var tip = this.getTipElement();
        var initConfigAnimation = this.config.animation;
        if (tip.getAttribute('x-placement') !== null) {
          return;
        }
        $(tip).removeClass(ClassName.FADE);
        this.config.animation = false;
        this.hide();
        this.show();
        this.config.animation = initConfigAnimation;
      };

      // static

      Tooltip._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;

          if (!data && /dispose|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Tooltip(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Tooltip, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }, {
        key: 'NAME',
        get: function get() {
          return NAME;
        }
      }, {
        key: 'DATA_KEY',
        get: function get() {
          return DATA_KEY;
        }
      }, {
        key: 'Event',
        get: function get() {
          return Event;
        }
      }, {
        key: 'EVENT_KEY',
        get: function get() {
          return EVENT_KEY;
        }
      }, {
        key: 'DefaultType',
        get: function get() {
          return DefaultType;
        }
      }]);

      return Tooltip;
    }();

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Tooltip._jQueryInterface;
    $.fn[NAME].Constructor = Tooltip;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tooltip._jQueryInterface;
    };

    return Tooltip;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Popover = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'popover';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.popover';
    var EVENT_KEY = '.' + DATA_KEY;
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var CLASS_PREFIX = 'bs-popover';
    var BSCLS_PREFIX_REGEX = new RegExp('(^|\\s)' + CLASS_PREFIX + '\\S+', 'g');

    var Default = $.extend({}, Tooltip.Default, {
      placement: 'right',
      trigger: 'click',
      content: '',
      template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
    });

    var DefaultType = $.extend({}, Tooltip.DefaultType, {
      content: '(string|element|function)'
    });

    var ClassName = {
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      TITLE: '.popover-header',
      CONTENT: '.popover-body'
    };

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      INSERTED: 'inserted' + EVENT_KEY,
      CLICK: 'click' + EVENT_KEY,
      FOCUSIN: 'focusin' + EVENT_KEY,
      FOCUSOUT: 'focusout' + EVENT_KEY,
      MOUSEENTER: 'mouseenter' + EVENT_KEY,
      MOUSELEAVE: 'mouseleave' + EVENT_KEY

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Popover = function (_Tooltip) {
      _inherits(Popover, _Tooltip);

      function Popover() {
        _classCallCheck(this, Popover);

        return _possibleConstructorReturn(this, _Tooltip.apply(this, arguments));
      }

      // overrides

      Popover.prototype.isWithContent = function isWithContent() {
        return this.getTitle() || this._getContent();
      };

      Popover.prototype.addAttachmentClass = function addAttachmentClass(attachment) {
        $(this.getTipElement()).addClass(CLASS_PREFIX + '-' + attachment);
      };

      Popover.prototype.getTipElement = function getTipElement() {
        return this.tip = this.tip || $(this.config.template)[0];
      };

      Popover.prototype.setContent = function setContent() {
        var $tip = $(this.getTipElement());

        // we use append for html objects to maintain js events
        this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
        this.setElementContent($tip.find(Selector.CONTENT), this._getContent());

        $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);
      };

      // private

      Popover.prototype._getContent = function _getContent() {
        return this.element.getAttribute('data-content') || (typeof this.config.content === 'function' ? this.config.content.call(this.element) : this.config.content);
      };

      Popover.prototype._cleanTipClass = function _cleanTipClass() {
        var $tip = $(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      };

      // static

      Popover._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;

          if (!data && /destroy|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Popover(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Popover, null, [{
        key: 'VERSION',

        // getters

        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }, {
        key: 'NAME',
        get: function get() {
          return NAME;
        }
      }, {
        key: 'DATA_KEY',
        get: function get() {
          return DATA_KEY;
        }
      }, {
        key: 'Event',
        get: function get() {
          return Event;
        }
      }, {
        key: 'EVENT_KEY',
        get: function get() {
          return EVENT_KEY;
        }
      }, {
        key: 'DefaultType',
        get: function get() {
          return DefaultType;
        }
      }]);

      return Popover;
    }(Tooltip);

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Popover._jQueryInterface;
    $.fn[NAME].Constructor = Popover;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Popover._jQueryInterface;
    };

    return Popover;
  }(jQuery);
})();

/***/ }),

/***/ 67:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e, t) {
     true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (e) {
        return t(e);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = t(require("jquery")) : t(e.jQuery);
}(undefined, function (e) {
    !function (e) {
        "use strict";

        function t(t) {
            var i = [{
                re: /[\xC0-\xC6]/g,
                ch: "A"
            }, {
                re: /[\xE0-\xE6]/g,
                ch: "a"
            }, {
                re: /[\xC8-\xCB]/g,
                ch: "E"
            }, {
                re: /[\xE8-\xEB]/g,
                ch: "e"
            }, {
                re: /[\xCC-\xCF]/g,
                ch: "I"
            }, {
                re: /[\xEC-\xEF]/g,
                ch: "i"
            }, {
                re: /[\xD2-\xD6]/g,
                ch: "O"
            }, {
                re: /[\xF2-\xF6]/g,
                ch: "o"
            }, {
                re: /[\xD9-\xDC]/g,
                ch: "U"
            }, {
                re: /[\xF9-\xFC]/g,
                ch: "u"
            }, {
                re: /[\xC7-\xE7]/g,
                ch: "c"
            }, {
                re: /[\xD1]/g,
                ch: "N"
            }, {
                re: /[\xF1]/g,
                ch: "n"
            }];
            return e.each(i, function () {
                t = t ? t.replace(this.re, this.ch) : "";
            }), t;
        }

        function i(t) {
            var i = arguments,
                n = t;
            [].shift.apply(i);
            var s,
                o = this.each(function () {
                var t = e(this);
                if (t.is("select")) {
                    var o = t.data("selectpicker"),
                        a = "object" == (typeof n === "undefined" ? "undefined" : _typeof(n)) && n;
                    if (o) {
                        if (a) for (var l in a) {
                            a.hasOwnProperty(l) && (o.options[l] = a[l]);
                        }
                    } else {
                        var r = e.extend({}, h.DEFAULTS, e.fn.selectpicker.defaults || {}, t.data(), a);
                        r.template = e.extend({}, h.DEFAULTS.template, e.fn.selectpicker.defaults ? e.fn.selectpicker.defaults.template : {}, t.data().template, a.template), t.data("selectpicker", o = new h(this, r));
                    }
                    "string" == typeof n && (s = o[n] instanceof Function ? o[n].apply(o, i) : o.options[n]);
                }
            });
            return "undefined" != typeof s ? s : o;
        }
        String.prototype.includes || !function () {
            var e = {}.toString,
                t = function () {
                try {
                    var e = {},
                        t = Object.defineProperty,
                        i = t(e, e, e) && t;
                } catch (n) {}
                return i;
            }(),
                i = "".indexOf,
                n = function n(t) {
                if (null == this) throw new TypeError();
                var n = String(this);
                if (t && "[object RegExp]" == e.call(t)) throw new TypeError();
                var s = n.length,
                    o = String(t),
                    a = o.length,
                    l = arguments.length > 1 ? arguments[1] : void 0,
                    r = l ? Number(l) : 0;
                r != r && (r = 0);
                var d = Math.min(Math.max(r, 0), s);
                return a + d > s ? !1 : -1 != i.call(n, o, r);
            };
            t ? t(String.prototype, "includes", {
                value: n,
                configurable: !0,
                writable: !0
            }) : String.prototype.includes = n;
        }(), String.prototype.startsWith || !function () {
            var e = function () {
                try {
                    var e = {},
                        t = Object.defineProperty,
                        i = t(e, e, e) && t;
                } catch (n) {}
                return i;
            }(),
                t = {}.toString,
                i = function i(e) {
                if (null == this) throw new TypeError();
                var i = String(this);
                if (e && "[object RegExp]" == t.call(e)) throw new TypeError();
                var n = i.length,
                    s = String(e),
                    o = s.length,
                    a = arguments.length > 1 ? arguments[1] : void 0,
                    l = a ? Number(a) : 0;
                l != l && (l = 0);
                var r = Math.min(Math.max(l, 0), n);
                if (o + r > n) return !1;
                for (var d = -1; ++d < o;) {
                    if (i.charCodeAt(r + d) != s.charCodeAt(d)) return !1;
                }return !0;
            };
            e ? e(String.prototype, "startsWith", {
                value: i,
                configurable: !0,
                writable: !0
            }) : String.prototype.startsWith = i;
        }(), Object.keys || (Object.keys = function (e, t, i) {
            i = [];
            for (t in e) {
                i.hasOwnProperty.call(e, t) && i.push(t);
            }return i;
        });
        var n = {
            useDefault: !1,
            _set: e.valHooks.select.set
        };
        e.valHooks.select.set = function (t, i) {
            return i && !n.useDefault && e(t).data("selected", !0), n._set.apply(this, arguments);
        };
        var s = null;
        e.fn.triggerNative = function (e) {
            this[0];
            this.trigger(e);
        }, e.expr.pseudos.icontains = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.text()).toString().toUpperCase();
            return o.includes(n[3].toUpperCase());
        }, e.expr.pseudos.ibegins = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.text()).toString().toUpperCase();
            return o.startsWith(n[3].toUpperCase());
        }, e.expr.pseudos.aicontains = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.data("normalizedText") || s.text()).toString().toUpperCase();
            return o.includes(n[3].toUpperCase());
        }, e.expr.pseudos.aibegins = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.data("normalizedText") || s.text()).toString().toUpperCase();
            return o.startsWith(n[3].toUpperCase());
        };
        var o = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        },
            a = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#x27;": "'",
            "&#x60;": "`"
        },
            l = function l(e) {
            var t = function t(_t) {
                return e[_t];
            },
                i = "(?:" + Object.keys(e).join("|") + ")",
                n = RegExp(i),
                s = RegExp(i, "g");
            return function (e) {
                return e = null == e ? "" : "" + e, n.test(e) ? e.replace(s, t) : e;
            };
        },
            r = l(o),
            d = l(a),
            h = function h(t, i) {
            n.useDefault || (e.valHooks.select.set = n._set, n.useDefault = !0), this.$element = e(t), this.$newElement = null, this.$button = null, this.$menu = null, this.$lis = null, this.options = i, null === this.options.title && (this.options.title = this.$element.attr("title"));
            var s = this.options.windowPadding;
            "number" == typeof s && (this.options.windowPadding = [s, s, s, s]), this.val = h.prototype.val, this.render = h.prototype.render, this.refresh = h.prototype.refresh, this.setStyle = h.prototype.setStyle, this.selectAll = h.prototype.selectAll, this.deselectAll = h.prototype.deselectAll, this.destroy = h.prototype.destroy, this.remove = h.prototype.remove, this.show = h.prototype.show, this.hide = h.prototype.hide, this.init();
        };
        h.VERSION = "1.12.2", h.DEFAULTS = {
            noneSelectedText: "Nothing selected",
            noneResultsText: "No results matched {0}",
            countSelectedText: function countSelectedText(e, t) {
                return 1 == e ? "{0} item selected" : "{0} items selected";
            },
            maxOptionsText: function maxOptionsText(e, t) {
                return [1 == e ? "Limit reached ({n} item max)" : "Limit reached ({n} items max)", 1 == t ? "Group limit reached ({n} item max)" : "Group limit reached ({n} items max)"];
            },
            selectAllText: "Select All",
            deselectAllText: "Deselect All",
            doneButton: !1,
            doneButtonText: "Close",
            multipleSeparator: ", ",
            styleBase: "btn",
            style: "btn-default btn-light",
            size: "auto",
            title: null,
            selectedTextFormat: "values",
            width: !1,
            container: !1,
            hideDisabled: !1,
            showSubtext: !1,
            showIcon: !0,
            showContent: !0,
            dropupAuto: !0,
            header: !1,
            liveSearch: !1,
            liveSearchPlaceholder: null,
            liveSearchNormalize: !1,
            liveSearchStyle: "contains",
            actionsBox: !1,
            iconBase: "fa",
            tickIcon: "fa-check",
            showTick: !1,
            template: {
                caret: '<span class="caret"></span>'
            },
            maxOptions: !1,
            mobile: !1,
            selectOnTab: !1,
            dropdownAlignRight: !1,
            windowPadding: 0
        }, h.prototype = {
            constructor: h,
            init: function init() {
                var t = this,
                    i = this.$element.attr("id");
                this.$element.addClass("bs-select-hidden"), this.liObj = {}, this.multiple = this.$element.prop("multiple"), this.autofocus = this.$element.prop("autofocus"), this.$newElement = this.createView(), this.$element.after(this.$newElement).appendTo(this.$newElement), this.$button = this.$newElement.children("button"), this.$menu = this.$newElement.children(".dropdown-menu"), this.$menuInner = this.$menu.children(".inner"), this.$searchbox = this.$menu.find("input"), this.$element.removeClass("bs-select-hidden"), this.options.dropdownAlignRight === !0 && this.$menu.addClass("dropdown-menu-right"), "undefined" != typeof i && (this.$button.attr("data-id", i), e('label[for="' + i + '"]').click(function (e) {
                    e.preventDefault(), t.$button.focus();
                })), this.checkDisabled(), this.clickListener(), this.options.liveSearch && this.liveSearchListener(), this.render(), this.setStyle(), this.setWidth(), this.options.container && this.selectPosition(), this.$menu.data("this", this), this.$newElement.data("this", this), this.options.mobile && this.mobile(), this.$newElement.on({
                    "hide.bs.dropdown": function hideBsDropdown(e) {
                        t.$menuInner.attr("aria-expanded", !1), t.$element.trigger("hide.bs.select", e);
                    },
                    "hidden.bs.dropdown": function hiddenBsDropdown(e) {
                        t.$element.trigger("hidden.bs.select", e);
                    },
                    "show.bs.dropdown": function showBsDropdown(e) {
                        t.$menuInner.attr("aria-expanded", !0), t.$element.trigger("show.bs.select", e);
                    },
                    "shown.bs.dropdown": function shownBsDropdown(e) {
                        t.$element.trigger("shown.bs.select", e);
                    }
                }), t.$element[0].hasAttribute("required") && this.$element.on("invalid", function () {
                    t.$button.addClass("bs-invalid").focus(), t.$element.on({
                        "focus.bs.select": function focusBsSelect() {
                            t.$button.focus(), t.$element.off("focus.bs.select");
                        },
                        "shown.bs.select": function shownBsSelect() {
                            t.$element.val(t.$element.val()).off("shown.bs.select");
                        },
                        "rendered.bs.select": function renderedBsSelect() {
                            this.validity.valid && t.$button.removeClass("bs-invalid"), t.$element.off("rendered.bs.select");
                        }
                    });
                }), setTimeout(function () {
                    t.$element.trigger("loaded.bs.select");
                });
            },
            createDropdown: function createDropdown() {
                var t = this.multiple || this.options.showTick ? " show-tick" : "",
                    i = this.$element.parent().hasClass("input-group") ? " input-group-btn" : "",
                    n = this.autofocus ? " autofocus" : "",
                    s = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + "</div>" : "",
                    o = this.options.liveSearch ? '<div class="bs-searchbox"><input type="text" class="form-control" autocomplete="off"' + (null === this.options.liveSearchPlaceholder ? "" : ' placeholder="' + r(this.options.liveSearchPlaceholder) + '"') + ' role="textbox" aria-label="Search"></div>' : "",
                    a = this.multiple && this.options.actionsBox ? '<div class="bs-actionsbox"><div class="btn-group btn-group-sm btn-block"><button type="button" class="actions-btn bs-select-all btn btn-default btn-light">' + this.options.selectAllText + '</button><button type="button" class="actions-btn bs-deselect-all btn btn-default btn-light">' + this.options.deselectAllText + "</button></div></div>" : "",
                    l = this.multiple && this.options.doneButton ? '<div class="bs-donebutton"><div class="btn-group btn-block"><button type="button" class="btn btn-sm btn-default btn-light">' + this.options.doneButtonText + "</button></div></div>" : "",
                    d = '<div class="btn-group bootstrap-select' + t + i + '"><button type="button" class="' + this.options.styleBase + ' dropdown-toggle" data-toggle="dropdown"' + n + ' role="button"><span class="filter-option pull-left"></span>&nbsp;<span class="bs-caret">' + this.options.template.caret + '</span></button><div class="dropdown-menu open" role="combobox">' + s + o + a + '<div class="dropdown-menu inner" role="listbox" aria-expanded="false"></div>' + l + "</div></div>";
                return e(d);
            },
            createView: function createView() {
                var e = this.createDropdown(),
                    t = this.createLi();
                return e.find("div.inner")[0].innerHTML = t, e;
            },
            reloadLi: function reloadLi() {
                var e = this.createLi();
                this.$menuInner[0].innerHTML = e;
            },
            createLi: function createLi() {
                var i = this,
                    n = [],
                    s = 0,
                    o = document.createElement("option"),
                    a = -1,
                    l = function l(e, t, i, n) {
                    return i = "dropdown-item " + (i || ""), "<a" + ("undefined" != typeof i && "" !== i ? ' class="' + i + '"' : "") + ("undefined" != typeof t && null !== t ? ' data-original-index="' + t + '"' : "") + ("undefined" != typeof n && null !== n ? 'data-optgroup="' + n + '"' : "") + ">" + e + "</a>";
                },
                    d = function d(n, s, o, a) {
                    return s = "dropdown-item-inner " + (s || ""), '<span tabindex="0"' + ("undefined" != typeof s ? ' class="' + s + '"' : "") + (o ? ' style="' + o + '"' : "") + (i.options.liveSearchNormalize ? ' data-normalized-text="' + t(r(e(n).html())) + '"' : "") + ("undefined" != typeof a || null !== a ? ' data-tokens="' + a + '"' : "") + ' role="option">' + n + '<span class="' + i.options.iconBase + " " + i.options.tickIcon + ' check-mark"></span></span>';
                };
                if (this.options.title && !this.multiple && (a--, !this.$element.find(".bs-title-option").length)) {
                    var h = this.$element[0];
                    o.className = "bs-title-option", o.innerHTML = this.options.title, o.value = "", h.insertBefore(o, h.firstChild);
                    var c = e(h.options[h.selectedIndex]);
                    void 0 === c.attr("selected") && void 0 === this.$element.data("selected") && (o.selected = !0);
                }
                var p = this.$element.find("option");
                return p.each(function (t) {
                    var o = e(this);
                    if (a++, !o.hasClass("bs-title-option")) {
                        var h,
                            c = this.className || "",
                            u = r(this.style.cssText),
                            f = o.data("content") ? o.data("content") : o.html(),
                            m = o.data("tokens") ? o.data("tokens") : null,
                            g = "undefined" != typeof o.data("subtext") ? '<small class="text-muted">' + o.data("subtext") + "</small>" : "",
                            b = "undefined" != typeof o.data("icon") ? '<span class="' + i.options.iconBase + " " + o.data("icon") + '"></span> ' : "",
                            v = o.parent(),
                            $ = "OPTGROUP" === v[0].tagName,
                            x = $ && v[0].disabled,
                            w = this.disabled || x;
                        if ("" !== b && w && (b = "<span>" + b + "</span>"), i.options.hideDisabled && (w && !$ || x)) return h = o.data("prevHiddenIndex"), o.next().data("prevHiddenIndex", void 0 !== h ? h : t), void a--;
                        if (o.data("content") || (f = b + '<span class="text">' + f + g + "</span>"), $ && o.data("divider") !== !0) {
                            if (i.options.hideDisabled && w) {
                                if (void 0 === v.data("allOptionsDisabled")) {
                                    var y = v.children();
                                    v.data("allOptionsDisabled", y.filter(":disabled").length === y.length);
                                }
                                if (v.data("allOptionsDisabled")) return void a--;
                            }
                            var C = " " + v[0].className || "";
                            if (0 === o.index()) {
                                s += 1;
                                var S = v[0].label,
                                    k = "undefined" != typeof v.data("subtext") ? '<small class="text-muted">' + v.data("subtext") + "</small>" : "",
                                    I = v.data("icon") ? '<span class="' + i.options.iconBase + " " + v.data("icon") + '"></span> ' : "";
                                S = I + '<span class="text">' + r(S) + k + "</span>", 0 !== t && n.length > 0 && (a++, n.push(l("", null, "divider", s + "div"))), a++, n.push(l(S, null, "dropdown-header" + C, s));
                            }
                            if (i.options.hideDisabled && w) return void a--;
                            n.push(l(d(f, "opt " + c + C, u, m), t, "", s));
                        } else if (o.data("divider") === !0) n.push(l("", t, "divider"));else if (o.data("hidden") === !0) h = o.data("prevHiddenIndex"), o.next().data("prevHiddenIndex", void 0 !== h ? h : t), n.push(l(d(f, c, u, m), t, "hidden is-hidden"));else {
                            var T = this.previousElementSibling && "OPTGROUP" === this.previousElementSibling.tagName;
                            if (!T && i.options.hideDisabled && (h = o.data("prevHiddenIndex"), void 0 !== h)) {
                                var E = p.eq(h)[0].previousElementSibling;
                                E && "OPTGROUP" === E.tagName && !E.disabled && (T = !0);
                            }
                            T && (a++, n.push(l("", null, "divider", s + "div"))), n.push(l(d(f, c, u, m), t));
                        }
                        i.liObj[t] = a;
                    }
                }), this.multiple || 0 !== this.$element.find("option:selected").length || this.options.title || this.$element.find("option").eq(0).prop("selected", !0).attr("selected", "selected"), n.join("");
            },
            findLis: function findLis() {
                return null == this.$lis && (this.$lis = this.$menu.find("a")), this.$lis;
            },
            render: function render(t) {
                var i,
                    n = this,
                    s = this.$element.find("option");
                t !== !1 && s.each(function (e) {
                    var t = n.findLis().eq(n.liObj[e]);
                    n.setDisabled(e, this.disabled || "OPTGROUP" === this.parentNode.tagName && this.parentNode.disabled, t), n.setSelected(e, this.selected, t);
                }), this.togglePlaceholder(), this.tabIndex();
                var o = s.map(function () {
                    if (this.selected) {
                        if (n.options.hideDisabled && (this.disabled || "OPTGROUP" === this.parentNode.tagName && this.parentNode.disabled)) return;
                        var t,
                            i = e(this),
                            s = i.data("icon") && n.options.showIcon ? '<i class="' + n.options.iconBase + " " + i.data("icon") + '"></i> ' : "";
                        return t = n.options.showSubtext && i.data("subtext") && !n.multiple ? ' <small class="text-muted">' + i.data("subtext") + "</small>" : "", "undefined" != typeof i.attr("title") ? i.attr("title") : i.data("content") && n.options.showContent ? i.data("content").toString() : s + i.html() + t;
                    }
                }).toArray(),
                    a = this.multiple ? o.join(this.options.multipleSeparator) : o[0];
                if (this.multiple && this.options.selectedTextFormat.indexOf("count") > -1) {
                    var l = this.options.selectedTextFormat.split(">");
                    if (l.length > 1 && o.length > l[1] || 1 == l.length && o.length >= 2) {
                        i = this.options.hideDisabled ? ", [disabled]" : "";
                        var r = s.not('[data-divider="true"], [data-hidden="true"]' + i).length,
                            h = "function" == typeof this.options.countSelectedText ? this.options.countSelectedText(o.length, r) : this.options.countSelectedText;
                        a = h.replace("{0}", o.length.toString()).replace("{1}", r.toString());
                    }
                }
                void 0 == this.options.title && (this.options.title = this.$element.attr("title")), "static" == this.options.selectedTextFormat && (a = this.options.title), a || (a = "undefined" != typeof this.options.title ? this.options.title : this.options.noneSelectedText), this.$button.attr("title", d(e.trim(a.replace(/<[^>]*>?/g, "")))), this.$button.children(".filter-option").html(a), this.$element.trigger("rendered.bs.select");
            },
            setStyle: function setStyle(e, t) {
                this.$element.attr("class") && this.$newElement.addClass(this.$element.attr("class").replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ""));
                var i = e ? e : this.options.style;
                "add" == t ? this.$button.addClass(i) : "remove" == t ? this.$button.removeClass(i) : (this.$button.removeClass(this.options.style), this.$button.addClass(i));
            },
            liHeight: function liHeight(t) {
                if (t || this.options.size !== !1 && !this.sizeInfo) {
                    var i = document.createElement("div"),
                        n = document.createElement("div"),
                        s = document.createElement("ul"),
                        o = document.createElement("a"),
                        a = document.createElement("a"),
                        l = document.createElement("span"),
                        r = document.createElement("span"),
                        d = this.options.header && this.$menu.find(".popover-title").length > 0 ? this.$menu.find(".popover-title")[0].cloneNode(!0) : null,
                        h = this.options.liveSearch ? document.createElement("div") : null,
                        c = this.options.actionsBox && this.multiple && this.$menu.find(".bs-actionsbox").length > 0 ? this.$menu.find(".bs-actionsbox")[0].cloneNode(!0) : null,
                        p = this.options.doneButton && this.multiple && this.$menu.find(".bs-donebutton").length > 0 ? this.$menu.find(".bs-donebutton")[0].cloneNode(!0) : null;
                    if (r.className = "text", i.className = this.$menu[0].parentNode.className + " show open", n.className = "dropdown-menu open show", s.className = "dropdown-menu inner", o.className = "divider", l.className = "dropdown-item-inner", r.appendChild(document.createTextNode("Inner text")), l.appendChild(r), a.appendChild(l), s.appendChild(a), s.appendChild(o), d && n.appendChild(d), h) {
                        var u = document.createElement("input");
                        h.className = "bs-searchbox", u.className = "form-control", h.appendChild(u), n.appendChild(h);
                    }
                    c && n.appendChild(c), n.appendChild(s), p && n.appendChild(p), i.appendChild(n), document.body.appendChild(i);
                    var f = l.offsetHeight,
                        m = d ? d.offsetHeight : 0,
                        g = h ? h.offsetHeight : 0,
                        b = c ? c.offsetHeight : 0,
                        v = p ? p.offsetHeight : 0,
                        $ = e(o).outerHeight(!0),
                        x = "function" == typeof getComputedStyle ? getComputedStyle(n) : !1,
                        w = x ? null : e(n),
                        y = {
                        vert: parseInt(x ? x.paddingTop : w.css("paddingTop")) + parseInt(x ? x.paddingBottom : w.css("paddingBottom")) + parseInt(x ? x.borderTopWidth : w.css("borderTopWidth")) + parseInt(x ? x.borderBottomWidth : w.css("borderBottomWidth")),
                        horiz: parseInt(x ? x.paddingLeft : w.css("paddingLeft")) + parseInt(x ? x.paddingRight : w.css("paddingRight")) + parseInt(x ? x.borderLeftWidth : w.css("borderLeftWidth")) + parseInt(x ? x.borderRightWidth : w.css("borderRightWidth"))
                    },
                        C = {
                        vert: y.vert + parseInt(x ? x.marginTop : w.css("marginTop")) + parseInt(x ? x.marginBottom : w.css("marginBottom")) + 2,
                        horiz: y.horiz + parseInt(x ? x.marginLeft : w.css("marginLeft")) + parseInt(x ? x.marginRight : w.css("marginRight")) + 2
                    };
                    document.body.removeChild(i), this.sizeInfo = {
                        liHeight: f,
                        headerHeight: m,
                        searchHeight: g,
                        actionsHeight: b,
                        doneButtonHeight: v,
                        dividerHeight: $,
                        menuPadding: y,
                        menuExtras: C
                    };
                }
            },
            setSize: function setSize() {
                if (this.findLis(), this.liHeight(), this.options.header && this.$menu.css("padding-top", 0), this.options.size !== !1) {
                    var t,
                        i,
                        n,
                        s,
                        o,
                        a,
                        l,
                        r,
                        d = this,
                        h = this.$menu,
                        c = this.$menuInner,
                        p = e(window),
                        u = this.$newElement[0].offsetHeight,
                        f = this.$newElement[0].offsetWidth,
                        m = this.sizeInfo.liHeight,
                        g = this.sizeInfo.headerHeight,
                        b = this.sizeInfo.searchHeight,
                        v = this.sizeInfo.actionsHeight,
                        $ = this.sizeInfo.doneButtonHeight,
                        x = this.sizeInfo.dividerHeight,
                        w = this.sizeInfo.menuPadding,
                        y = this.sizeInfo.menuExtras,
                        C = this.options.hideDisabled ? ".disabled" : "",
                        S = function S() {
                        var t,
                            i = d.$newElement.offset(),
                            n = e(d.options.container);
                        d.options.container && !n.is("body") ? (t = n.offset(), t.top += parseInt(n.css("borderTopWidth")), t.left += parseInt(n.css("borderLeftWidth"))) : t = {
                            top: 0,
                            left: 0
                        };
                        var s = d.options.windowPadding;
                        o = i.top - t.top - p.scrollTop(), a = p.height() - o - u - t.top - s[2], l = i.left - t.left - p.scrollLeft(), r = p.width() - l - f - t.left - s[1], o -= s[0], l -= s[3];
                    };
                    if (S(), "auto" === this.options.size) {
                        var k = function k() {
                            var p,
                                u = function u(t, i) {
                                return function (n) {
                                    return i ? n.classList ? n.classList.contains(t) : e(n).hasClass(t) : !(n.classList ? n.classList.contains(t) : e(n).hasClass(t));
                                };
                            },
                                x = d.$menuInner[0].getElementsByTagName("a"),
                                C = Array.prototype.filter ? Array.prototype.filter.call(x, u("hidden", !1)) : d.$lis.not(".hidden"),
                                k = Array.prototype.filter ? Array.prototype.filter.call(C, u("dropdown-header", !0)) : C.filter(".dropdown-header");
                            S(), t = a - y.vert, i = r - y.horiz, d.options.container ? (h.data("height") || h.data("height", h.height()), n = h.data("height"), h.data("width") || h.data("width", h.width()), s = h.data("width")) : (n = h.height(), s = h.width()), d.options.dropupAuto && d.$newElement.toggleClass("dropup", o > a && t - y.vert < n), d.$newElement.hasClass("dropup") && (t = o - y.vert), "auto" === d.options.dropdownAlignRight && h.toggleClass("dropdown-menu-right", l > r && i - y.horiz < s - f), p = C.length + k.length > 3 ? 3 * m + y.vert - 2 : 0, h.css({
                                "max-height": t + "px",
                                overflow: "hidden",
                                "min-height": p + g + b + v + $ + "px"
                            }), c.css({
                                "max-height": t - g - b - v - $ - w.vert + "px",
                                "overflow-y": "auto",
                                "min-height": Math.max(p - w.vert, 0) + "px"
                            });
                        };
                        k(), this.$searchbox.off("input.getSize propertychange.getSize").on("input.getSize propertychange.getSize", k), p.off("resize.getSize scroll.getSize").on("resize.getSize scroll.getSize", k);
                    } else if (this.options.size && "auto" != this.options.size && this.$lis.not(C).length > this.options.size) {
                        var I = this.$lis.not(".divider").not(C).children().slice(0, this.options.size).last().parent().index(),
                            T = this.$lis.slice(0, I + 1).filter(".divider").length;
                        t = m * this.options.size + T * x + w.vert, d.options.container ? (h.data("height") || h.data("height", h.height()), n = h.data("height")) : n = h.height(), d.options.dropupAuto && this.$newElement.toggleClass("dropup", o > a && t - y.vert < n), h.css({
                            "max-height": t + g + b + v + $ + "px",
                            overflow: "hidden",
                            "min-height": ""
                        }), c.css({
                            "max-height": t - w.vert + "px",
                            "overflow-y": "auto",
                            "min-height": ""
                        });
                    }
                }
            },
            setWidth: function setWidth() {
                if ("auto" === this.options.width) {
                    this.$menu.css("min-width", "0");
                    var e = this.$menu.parent().clone().appendTo("body"),
                        t = this.options.container ? this.$newElement.clone().appendTo("body") : e,
                        i = e.children(".dropdown-menu").outerWidth(),
                        n = t.css("width", "auto").children("button").outerWidth();
                    e.remove(), t.remove(), this.$newElement.css("width", Math.max(i, n) + "px");
                } else "fit" === this.options.width ? (this.$menu.css("min-width", ""), this.$newElement.css("width", "").addClass("fit-width")) : this.options.width ? (this.$menu.css("min-width", ""), this.$newElement.css("width", this.options.width)) : (this.$menu.css("min-width", ""), this.$newElement.css("width", ""));
                this.$newElement.hasClass("fit-width") && "fit" !== this.options.width && this.$newElement.removeClass("fit-width");
            },
            selectPosition: function selectPosition() {
                this.$bsContainer = e('<div class="bs-container" />');
                var t,
                    i,
                    n,
                    s = this,
                    o = e(this.options.container),
                    a = function a(e) {
                    s.$bsContainer.addClass(e.attr("class").replace(/form-control|fit-width/gi, "")).toggleClass("dropup", e.hasClass("dropup")), t = e.offset(), o.is("body") ? i = {
                        top: 0,
                        left: 0
                    } : (i = o.offset(), i.top += parseInt(o.css("borderTopWidth")) - o.scrollTop(), i.left += parseInt(o.css("borderLeftWidth")) - o.scrollLeft()), n = e.hasClass("dropup") ? 0 : e[0].offsetHeight, s.$bsContainer.css({
                        top: t.top - i.top + n,
                        left: t.left - i.left,
                        width: e[0].offsetWidth
                    });
                };
                this.$button.on("click", function () {
                    var t = e(this);
                    s.isDisabled() || (a(s.$newElement), s.$bsContainer.appendTo(s.options.container).toggleClass("open", !t.hasClass("open")).append(s.$menu));
                }), e(window).on("resize scroll", function () {
                    a(s.$newElement);
                }), this.$element.on("hide.bs.select", function () {
                    s.$menu.data("height", s.$menu.height()), s.$bsContainer.detach();
                });
            },
            setSelected: function setSelected(e, t, i) {
                i || (this.togglePlaceholder(), i = this.findLis().eq(this.liObj[e])), i.toggleClass("selected", t).find("span.dropdown-item-inner").attr("aria-selected", t);
            },
            setDisabled: function setDisabled(e, t, i) {
                i || (i = this.findLis().eq(this.liObj[e])), t ? i.addClass("disabled").children("span.dropdown-item-inner").attr("href", "#").attr("tabindex", -1).attr("aria-disabled", !0) : i.removeClass("disabled").children("span.dropdown-item-inner").removeAttr("href").attr("tabindex", 0).attr("aria-disabled", !1);
            },
            isDisabled: function isDisabled() {
                return this.$element[0].disabled;
            },
            checkDisabled: function checkDisabled() {
                var e = this;
                this.isDisabled() ? (this.$newElement.addClass("disabled"), this.$button.addClass("disabled").attr("tabindex", -1).attr("aria-disabled", !0)) : (this.$button.hasClass("disabled") && (this.$newElement.removeClass("disabled"), this.$button.removeClass("disabled").attr("aria-disabled", !1)), -1 != this.$button.attr("tabindex") || this.$element.data("tabindex") || this.$button.removeAttr("tabindex")), this.$button.click(function () {
                    return !e.isDisabled();
                });
            },
            togglePlaceholder: function togglePlaceholder() {
                var e = this.$element.val();
                this.$button.toggleClass("bs-placeholder", null === e || "" === e || e.constructor === Array && 0 === e.length);
            },
            tabIndex: function tabIndex() {
                this.$element.data("tabindex") !== this.$element.attr("tabindex") && -98 !== this.$element.attr("tabindex") && "-98" !== this.$element.attr("tabindex") && (this.$element.data("tabindex", this.$element.attr("tabindex")), this.$button.attr("tabindex", this.$element.data("tabindex"))), this.$element.attr("tabindex", -98);
            },
            clickListener: function clickListener() {
                var t = this,
                    i = e(document);
                i.data("spaceSelect", !1), this.$button.on("keyup", function (e) {
                    /(32)/.test(e.keyCode.toString(10)) && i.data("spaceSelect") && (e.preventDefault(), i.data("spaceSelect", !1));
                }), this.$button.on("click", function () {
                    t.setSize();
                }), this.$element.on("shown.bs.select", function () {
                    if (t.options.liveSearch || t.multiple) {
                        if (!t.multiple) {
                            var e = t.liObj[t.$element[0].selectedIndex];
                            if ("number" != typeof e || t.options.size === !1) return;
                            var i = t.$lis.eq(e)[0].offsetTop - t.$menuInner[0].offsetTop;
                            i = i - t.$menuInner[0].offsetHeight / 2 + t.sizeInfo.liHeight / 2, t.$menuInner[0].scrollTop = i;
                        }
                    } else t.$menuInner.find(".selected a").focus();
                }), this.$menuInner.on("click", "a span.dropdown-item-inner", function (i) {
                    var n = e(this),
                        o = n.parent().data("originalIndex"),
                        a = t.$element.val(),
                        l = t.$element.prop("selectedIndex"),
                        r = !0;
                    if (t.multiple && 1 !== t.options.maxOptions && i.stopPropagation(), i.preventDefault(), !t.isDisabled() && !n.parent().hasClass("disabled")) {
                        var d = t.$element.find("option"),
                            h = d.eq(o),
                            c = h.prop("selected"),
                            p = h.parent("optgroup"),
                            u = t.options.maxOptions,
                            f = p.data("maxOptions") || !1;
                        if (t.multiple) {
                            if (h.prop("selected", !c), t.setSelected(o, !c), n.blur(), u !== !1 || f !== !1) {
                                var m = u < d.filter(":selected").length,
                                    g = f < p.find("option:selected").length;
                                if (u && m || f && g) if (u && 1 == u) d.prop("selected", !1), h.prop("selected", !0), t.$menuInner.find(".selected").removeClass("selected"), t.setSelected(o, !0);else if (f && 1 == f) {
                                    p.find("option:selected").prop("selected", !1), h.prop("selected", !0);
                                    var b = n.parent().data("optgroup");
                                    t.$menuInner.find('[data-optgroup="' + b + '"]').removeClass("selected"), t.setSelected(o, !0);
                                } else {
                                    var v = "string" == typeof t.options.maxOptionsText ? [t.options.maxOptionsText, t.options.maxOptionsText] : t.options.maxOptionsText,
                                        $ = "function" == typeof v ? v(u, f) : v,
                                        x = $[0].replace("{n}", u),
                                        w = $[1].replace("{n}", f),
                                        y = e('<div class="notify"></div>');
                                    $[2] && (x = x.replace("{var}", $[2][u > 1 ? 0 : 1]), w = w.replace("{var}", $[2][f > 1 ? 0 : 1])), h.prop("selected", !1), t.$menu.append(y), u && m && (y.append(e("<div>" + x + "</div>")), r = !1, t.$element.trigger("maxReached.bs.select")), f && g && (y.append(e("<div>" + w + "</div>")), r = !1, t.$element.trigger("maxReachedGrp.bs.select")), setTimeout(function () {
                                        t.setSelected(o, !1);
                                    }, 10), y.delay(750).fadeOut(300, function () {
                                        e(this).remove();
                                    });
                                }
                            }
                        } else d.prop("selected", !1), h.prop("selected", !0), t.$menuInner.find(".selected").removeClass("selected").find("span.dropdown-item-inner").attr("aria-selected", !1), t.setSelected(o, !0);
                        !t.multiple || t.multiple && 1 === t.options.maxOptions ? t.$button.focus() : t.options.liveSearch && t.$searchbox.focus(), r && (a != t.$element.val() && t.multiple || l != t.$element.prop("selectedIndex") && !t.multiple) && (s = [o, h.prop("selected"), c], t.$element.triggerNative("change"));
                    }
                }), this.$menu.on("click", "a.disabled span.dropdown-item-inner , .popover-title, .popover-title :not(.close)", function (i) {
                    i.currentTarget == this && (i.preventDefault(), i.stopPropagation(), t.options.liveSearch && !e(i.target).hasClass("close") ? t.$searchbox.focus() : t.$button.focus());
                }), this.$menuInner.on("click", ".divider, .dropdown-header", function (e) {
                    e.preventDefault(), e.stopPropagation(), t.options.liveSearch ? t.$searchbox.focus() : t.$button.focus();
                }), this.$menu.on("click", ".popover-title .close", function () {
                    t.$button.click();
                }), this.$searchbox.on("click", function (e) {
                    e.stopPropagation();
                }), this.$menu.on("click", ".actions-btn", function (i) {
                    t.options.liveSearch ? t.$searchbox.focus() : t.$button.focus(), i.preventDefault(), i.stopPropagation(), e(this).hasClass("bs-select-all") ? t.selectAll() : t.deselectAll();
                }), this.$element.change(function () {
                    t.render(!1), t.$element.trigger("changed.bs.select", s), s = null;
                });
            },
            liveSearchListener: function liveSearchListener() {
                var i = this,
                    n = e('<li class="no-results"></li>');
                this.$button.on("click.dropdown.data-api", function () {
                    i.$menuInner.find(".active").removeClass("active"), i.$searchbox.val() && (i.$searchbox.val(""), i.$lis.not(".is-hidden").removeClass("hidden"), n.parent().length && n.remove()), i.multiple || i.$menuInner.find(".selected").addClass("active"), setTimeout(function () {
                        i.$searchbox.focus();
                    }, 10);
                }), this.$searchbox.on("click.dropdown.data-api focus.dropdown.data-api touchend.dropdown.data-api", function (e) {
                    e.stopPropagation();
                }), this.$searchbox.on("input propertychange", function () {
                    if (i.$lis.not(".is-hidden").removeClass("hidden"), i.$lis.filter(".active").removeClass("active"), n.remove(), i.$searchbox.val()) {
                        var s,
                            o = i.$lis.not(".is-hidden, .divider, .dropdown-header");
                        if (s = i.options.liveSearchNormalize ? o.not(":a" + i._searchStyle() + '("' + t(i.$searchbox.val()) + '")') : o.not(":" + i._searchStyle() + '("' + i.$searchbox.val() + '")'), s.length === o.length) n.html(i.options.noneResultsText.replace("{0}", '"' + r(i.$searchbox.val()) + '"')), i.$menuInner.append(n), i.$lis.addClass("hidden");else {
                            s.addClass("hidden");
                            var a,
                                l = i.$lis.not(".hidden");
                            l.each(function (t) {
                                var i = e(this);
                                i.hasClass("divider") ? void 0 === a ? i.addClass("hidden") : (a && a.addClass("hidden"), a = i) : i.hasClass("dropdown-header") && l.eq(t + 1).data("optgroup") !== i.data("optgroup") ? i.addClass("hidden") : a = null;
                            }), a && a.addClass("hidden"), o.not(".hidden").first().addClass("active"), i.$menuInner.scrollTop(0);
                        }
                    }
                });
            },
            _searchStyle: function _searchStyle() {
                var e = {
                    begins: "ibegins",
                    startsWith: "ibegins"
                };
                return e[this.options.liveSearchStyle] || "icontains";
            },
            val: function val(e) {
                return "undefined" != typeof e ? (this.$element.val(e), this.render(), this.$element) : this.$element.val();
            },
            changeAll: function changeAll(t) {
                if (this.multiple) {
                    "undefined" == typeof t && (t = !0), this.findLis();
                    var i = this.$element.find("option"),
                        n = this.$lis.not(".divider, .dropdown-header, .disabled, .hidden"),
                        s = n.length,
                        o = [];
                    if (t) {
                        if (n.filter(".selected").length === n.length) return;
                    } else if (0 === n.filter(".selected").length) return;
                    n.toggleClass("selected", t);
                    for (var a = 0; s > a; a++) {
                        var l = n[a].getAttribute("data-original-index");
                        o[o.length] = i.eq(l)[0];
                    }
                    e(o).prop("selected", t), this.render(!1), this.togglePlaceholder(), this.$element.triggerNative("change");
                }
            },
            selectAll: function selectAll() {
                return this.changeAll(!0);
            },
            deselectAll: function deselectAll() {
                return this.changeAll(!1);
            },
            toggle: function toggle(e) {
                e = e || window.event, e && e.stopPropagation(), this.$button.trigger("click");
            },
            keydown: function keydown(t) {
                var i,
                    n,
                    s,
                    o,
                    a = e(this),
                    l = a.is("input") ? a.parent().parent() : a.parent(),
                    r = l.data("this"),
                    d = ":not(.disabled, .hidden, .dropdown-header, .divider)",
                    h = {
                    32: " ",
                    48: "0",
                    49: "1",
                    50: "2",
                    51: "3",
                    52: "4",
                    53: "5",
                    54: "6",
                    55: "7",
                    56: "8",
                    57: "9",
                    59: ";",
                    65: "a",
                    66: "b",
                    67: "c",
                    68: "d",
                    69: "e",
                    70: "f",
                    71: "g",
                    72: "h",
                    73: "i",
                    74: "j",
                    75: "k",
                    76: "l",
                    77: "m",
                    78: "n",
                    79: "o",
                    80: "p",
                    81: "q",
                    82: "r",
                    83: "s",
                    84: "t",
                    85: "u",
                    86: "v",
                    87: "w",
                    88: "x",
                    89: "y",
                    90: "z",
                    96: "0",
                    97: "1",
                    98: "2",
                    99: "3",
                    100: "4",
                    101: "5",
                    102: "6",
                    103: "7",
                    104: "8",
                    105: "9"
                };
                if (o = r.$newElement.hasClass("open"), !o && (t.keyCode >= 48 && t.keyCode <= 57 || t.keyCode >= 96 && t.keyCode <= 105 || t.keyCode >= 65 && t.keyCode <= 90)) return r.options.container ? r.$button.trigger("click") : (r.setSize(), r.$menu.parent().addClass("open"), o = !0), void r.$searchbox.focus();
                if (r.options.liveSearch && /(^9$|27)/.test(t.keyCode.toString(10)) && o && (t.preventDefault(), t.stopPropagation(), r.$menuInner.click(), r.$button.focus()), /(38|40)/.test(t.keyCode.toString(10))) {
                    if (i = r.$lis.filter(d), !i.length) return;
                    n = r.options.liveSearch ? i.index(i.filter(".active")) : i.index(i.find("span.dropdown-item-inner").filter(":focus").parent()), s = r.$menuInner.data("prevIndex"), 38 == t.keyCode ? (!r.options.liveSearch && n != s || -1 == n || n--, 0 > n && (n += i.length)) : 40 == t.keyCode && ((r.options.liveSearch || n == s) && n++, n %= i.length), r.$menuInner.data("prevIndex", n), r.options.liveSearch ? (t.preventDefault(), a.hasClass("dropdown-toggle") || (i.removeClass("active").eq(n).addClass("active").children("span.dropdown-item-inner").focus(), a.focus())) : i.eq(n).children("span.dropdown-item-inner").focus();
                } else if (!a.is("input")) {
                    var c,
                        p,
                        u = [];
                    i = r.$lis.filter(d), i.each(function (i) {
                        e.trim(e(this).children("span.dropdown-item-inner").text().toLowerCase()).substring(0, 1) == h[t.keyCode] && u.push(i);
                    }), c = e(document).data("keycount"), c++, e(document).data("keycount", c), p = e.trim(e(":focus").text().toLowerCase()).substring(0, 1), p != h[t.keyCode] ? (c = 1, e(document).data("keycount", c)) : c >= u.length && (e(document).data("keycount", 0), c > u.length && (c = 1)), i.eq(u[c - 1]).children("span.dropdown-item-inner").focus();
                }
                if ((/(13|32)/.test(t.keyCode.toString(10)) || /(^9$)/.test(t.keyCode.toString(10)) && r.options.selectOnTab) && o) {
                    if (/(32)/.test(t.keyCode.toString(10)) || t.preventDefault(), r.options.liveSearch) /(32)/.test(t.keyCode.toString(10)) || (r.$menuInner.find(".active a").click(), a.focus());else {
                        var f = e(":focus");
                        f.click(), f.focus(), t.preventDefault(), e(document).data("spaceSelect", !0);
                    }
                    e(document).data("keycount", 0);
                }(/(^9$|27)/.test(t.keyCode.toString(10)) && o && (r.multiple || r.options.liveSearch) || /(27)/.test(t.keyCode.toString(10)) && !o) && (r.$menu.parent().removeClass("open"), r.options.container && r.$newElement.removeClass("open"), r.$button.focus());
            },
            mobile: function mobile() {
                this.$element.addClass("mobile-device");
            },
            refresh: function refresh() {
                this.$lis = null, this.liObj = {}, this.reloadLi(), this.render(), this.checkDisabled(), this.liHeight(!0), this.setStyle(), this.setWidth(), this.$lis && this.$searchbox.trigger("propertychange"), this.$element.trigger("refreshed.bs.select");
            },
            hide: function hide() {
                this.$newElement.hide();
            },
            show: function show() {
                this.$newElement.show();
            },
            remove: function remove() {
                this.$newElement.remove(), this.$element.remove();
            },
            destroy: function destroy() {
                this.$newElement.before(this.$element).remove(), this.$bsContainer ? this.$bsContainer.remove() : this.$menu.remove(), this.$element.off(".bs.select").removeData("selectpicker").removeClass("bs-select-hidden selectpicker");
            }
        };
        var c = e.fn.selectpicker;
        e.fn.selectpicker = i, e.fn.selectpicker.Constructor = h, e.fn.selectpicker.noConflict = function () {
            return e.fn.selectpicker = c, this;
        }, e(document).data("keycount", 0).on("keydown.bs.select", '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input', h.prototype.keydown).on("focusin.modal", '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input', function (e) {
            e.stopPropagation();
        }), e(window).on("load.bs.select.data-api", function () {
            e(".selectpicker").each(function () {
                var t = e(this);
                i.call(t, t.data());
            });
        });
    }(e);
});

/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.0
 *
 * Copyright 2017 Nick Downie
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
(function (f) {
	if (( false ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
		module.exports = f();
	} else if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		var g;if (typeof window !== "undefined") {
			g = window;
		} else if (typeof global !== "undefined") {
			g = global;
		} else if (typeof self !== "undefined") {
			g = self;
		} else {
			g = this;
		}g.Chart = f();
	}
})(function () {
	var define, module, exports;return function e(t, n, r) {
		function s(o, u) {
			if (!n[o]) {
				if (!t[o]) {
					var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
				}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
					var n = t[o][1][e];return s(n ? n : e);
				}, l, l.exports, e, t, n, r);
			}return n[o].exports;
		}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
			s(r[o]);
		}return s;
	}({ 1: [function (require, module, exports) {}, {}], 2: [function (require, module, exports) {
			/* MIT license */
			var colorNames = require(6);

			module.exports = {
				getRgba: getRgba,
				getHsla: getHsla,
				getRgb: getRgb,
				getHsl: getHsl,
				getHwb: getHwb,
				getAlpha: getAlpha,

				hexString: hexString,
				rgbString: rgbString,
				rgbaString: rgbaString,
				percentString: percentString,
				percentaString: percentaString,
				hslString: hslString,
				hslaString: hslaString,
				hwbString: hwbString,
				keyword: keyword
			};

			function getRgba(string) {
				if (!string) {
					return;
				}
				var abbr = /^#([a-fA-F0-9]{3})$/i,
				    hex = /^#([a-fA-F0-9]{6})$/i,
				    rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
				    per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
				    keyword = /(\w+)/;

				var rgb = [0, 0, 0],
				    a = 1,
				    match = string.match(abbr);
				if (match) {
					match = match[1];
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = parseInt(match[i] + match[i], 16);
					}
				} else if (match = string.match(hex)) {
					match = match[1];
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
					}
				} else if (match = string.match(rgba)) {
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = parseInt(match[i + 1]);
					}
					a = parseFloat(match[4]);
				} else if (match = string.match(per)) {
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
					}
					a = parseFloat(match[4]);
				} else if (match = string.match(keyword)) {
					if (match[1] == "transparent") {
						return [0, 0, 0, 0];
					}
					rgb = colorNames[match[1]];
					if (!rgb) {
						return;
					}
				}

				for (var i = 0; i < rgb.length; i++) {
					rgb[i] = scale(rgb[i], 0, 255);
				}
				if (!a && a != 0) {
					a = 1;
				} else {
					a = scale(a, 0, 1);
				}
				rgb[3] = a;
				return rgb;
			}

			function getHsla(string) {
				if (!string) {
					return;
				}
				var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
				var match = string.match(hsl);
				if (match) {
					var alpha = parseFloat(match[4]);
					var h = scale(parseInt(match[1]), 0, 360),
					    s = scale(parseFloat(match[2]), 0, 100),
					    l = scale(parseFloat(match[3]), 0, 100),
					    a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
					return [h, s, l, a];
				}
			}

			function getHwb(string) {
				if (!string) {
					return;
				}
				var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
				var match = string.match(hwb);
				if (match) {
					var alpha = parseFloat(match[4]);
					var h = scale(parseInt(match[1]), 0, 360),
					    w = scale(parseFloat(match[2]), 0, 100),
					    b = scale(parseFloat(match[3]), 0, 100),
					    a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
					return [h, w, b, a];
				}
			}

			function getRgb(string) {
				var rgba = getRgba(string);
				return rgba && rgba.slice(0, 3);
			}

			function getHsl(string) {
				var hsla = getHsla(string);
				return hsla && hsla.slice(0, 3);
			}

			function getAlpha(string) {
				var vals = getRgba(string);
				if (vals) {
					return vals[3];
				} else if (vals = getHsla(string)) {
					return vals[3];
				} else if (vals = getHwb(string)) {
					return vals[3];
				}
			}

			// generators
			function hexString(rgb) {
				return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
			}

			function rgbString(rgba, alpha) {
				if (alpha < 1 || rgba[3] && rgba[3] < 1) {
					return rgbaString(rgba, alpha);
				}
				return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
			}

			function rgbaString(rgba, alpha) {
				if (alpha === undefined) {
					alpha = rgba[3] !== undefined ? rgba[3] : 1;
				}
				return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
			}

			function percentString(rgba, alpha) {
				if (alpha < 1 || rgba[3] && rgba[3] < 1) {
					return percentaString(rgba, alpha);
				}
				var r = Math.round(rgba[0] / 255 * 100),
				    g = Math.round(rgba[1] / 255 * 100),
				    b = Math.round(rgba[2] / 255 * 100);

				return "rgb(" + r + "%, " + g + "%, " + b + "%)";
			}

			function percentaString(rgba, alpha) {
				var r = Math.round(rgba[0] / 255 * 100),
				    g = Math.round(rgba[1] / 255 * 100),
				    b = Math.round(rgba[2] / 255 * 100);
				return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
			}

			function hslString(hsla, alpha) {
				if (alpha < 1 || hsla[3] && hsla[3] < 1) {
					return hslaString(hsla, alpha);
				}
				return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
			}

			function hslaString(hsla, alpha) {
				if (alpha === undefined) {
					alpha = hsla[3] !== undefined ? hsla[3] : 1;
				}
				return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
			}

			// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
			// (hwb have alpha optional & 1 is default value)
			function hwbString(hwb, alpha) {
				if (alpha === undefined) {
					alpha = hwb[3] !== undefined ? hwb[3] : 1;
				}
				return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
			}

			function keyword(rgb) {
				return reverseNames[rgb.slice(0, 3)];
			}

			// helpers
			function scale(num, min, max) {
				return Math.min(Math.max(min, num), max);
			}

			function hexDouble(num) {
				var str = num.toString(16).toUpperCase();
				return str.length < 2 ? "0" + str : str;
			}

			//create a list of reverse color names
			var reverseNames = {};
			for (var name in colorNames) {
				reverseNames[colorNames[name]] = name;
			}
		}, { "6": 6 }], 3: [function (require, module, exports) {
			/* MIT license */
			var convert = require(5);
			var string = require(2);

			var Color = function Color(obj) {
				if (obj instanceof Color) {
					return obj;
				}
				if (!(this instanceof Color)) {
					return new Color(obj);
				}

				this.valid = false;
				this.values = {
					rgb: [0, 0, 0],
					hsl: [0, 0, 0],
					hsv: [0, 0, 0],
					hwb: [0, 0, 0],
					cmyk: [0, 0, 0, 0],
					alpha: 1
				};

				// parse Color() argument
				var vals;
				if (typeof obj === 'string') {
					vals = string.getRgba(obj);
					if (vals) {
						this.setValues('rgb', vals);
					} else if (vals = string.getHsla(obj)) {
						this.setValues('hsl', vals);
					} else if (vals = string.getHwb(obj)) {
						this.setValues('hwb', vals);
					}
				} else if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object') {
					vals = obj;
					if (vals.r !== undefined || vals.red !== undefined) {
						this.setValues('rgb', vals);
					} else if (vals.l !== undefined || vals.lightness !== undefined) {
						this.setValues('hsl', vals);
					} else if (vals.v !== undefined || vals.value !== undefined) {
						this.setValues('hsv', vals);
					} else if (vals.w !== undefined || vals.whiteness !== undefined) {
						this.setValues('hwb', vals);
					} else if (vals.c !== undefined || vals.cyan !== undefined) {
						this.setValues('cmyk', vals);
					}
				}
			};

			Color.prototype = {
				isValid: function isValid() {
					return this.valid;
				},
				rgb: function rgb() {
					return this.setSpace('rgb', arguments);
				},
				hsl: function hsl() {
					return this.setSpace('hsl', arguments);
				},
				hsv: function hsv() {
					return this.setSpace('hsv', arguments);
				},
				hwb: function hwb() {
					return this.setSpace('hwb', arguments);
				},
				cmyk: function cmyk() {
					return this.setSpace('cmyk', arguments);
				},

				rgbArray: function rgbArray() {
					return this.values.rgb;
				},
				hslArray: function hslArray() {
					return this.values.hsl;
				},
				hsvArray: function hsvArray() {
					return this.values.hsv;
				},
				hwbArray: function hwbArray() {
					var values = this.values;
					if (values.alpha !== 1) {
						return values.hwb.concat([values.alpha]);
					}
					return values.hwb;
				},
				cmykArray: function cmykArray() {
					return this.values.cmyk;
				},
				rgbaArray: function rgbaArray() {
					var values = this.values;
					return values.rgb.concat([values.alpha]);
				},
				hslaArray: function hslaArray() {
					var values = this.values;
					return values.hsl.concat([values.alpha]);
				},
				alpha: function alpha(val) {
					if (val === undefined) {
						return this.values.alpha;
					}
					this.setValues('alpha', val);
					return this;
				},

				red: function red(val) {
					return this.setChannel('rgb', 0, val);
				},
				green: function green(val) {
					return this.setChannel('rgb', 1, val);
				},
				blue: function blue(val) {
					return this.setChannel('rgb', 2, val);
				},
				hue: function hue(val) {
					if (val) {
						val %= 360;
						val = val < 0 ? 360 + val : val;
					}
					return this.setChannel('hsl', 0, val);
				},
				saturation: function saturation(val) {
					return this.setChannel('hsl', 1, val);
				},
				lightness: function lightness(val) {
					return this.setChannel('hsl', 2, val);
				},
				saturationv: function saturationv(val) {
					return this.setChannel('hsv', 1, val);
				},
				whiteness: function whiteness(val) {
					return this.setChannel('hwb', 1, val);
				},
				blackness: function blackness(val) {
					return this.setChannel('hwb', 2, val);
				},
				value: function value(val) {
					return this.setChannel('hsv', 2, val);
				},
				cyan: function cyan(val) {
					return this.setChannel('cmyk', 0, val);
				},
				magenta: function magenta(val) {
					return this.setChannel('cmyk', 1, val);
				},
				yellow: function yellow(val) {
					return this.setChannel('cmyk', 2, val);
				},
				black: function black(val) {
					return this.setChannel('cmyk', 3, val);
				},

				hexString: function hexString() {
					return string.hexString(this.values.rgb);
				},
				rgbString: function rgbString() {
					return string.rgbString(this.values.rgb, this.values.alpha);
				},
				rgbaString: function rgbaString() {
					return string.rgbaString(this.values.rgb, this.values.alpha);
				},
				percentString: function percentString() {
					return string.percentString(this.values.rgb, this.values.alpha);
				},
				hslString: function hslString() {
					return string.hslString(this.values.hsl, this.values.alpha);
				},
				hslaString: function hslaString() {
					return string.hslaString(this.values.hsl, this.values.alpha);
				},
				hwbString: function hwbString() {
					return string.hwbString(this.values.hwb, this.values.alpha);
				},
				keyword: function keyword() {
					return string.keyword(this.values.rgb, this.values.alpha);
				},

				rgbNumber: function rgbNumber() {
					var rgb = this.values.rgb;
					return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
				},

				luminosity: function luminosity() {
					// http://www.w3.org/TR/WCAG20/#relativeluminancedef
					var rgb = this.values.rgb;
					var lum = [];
					for (var i = 0; i < rgb.length; i++) {
						var chan = rgb[i] / 255;
						lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
					}
					return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
				},

				contrast: function contrast(color2) {
					// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
					var lum1 = this.luminosity();
					var lum2 = color2.luminosity();
					if (lum1 > lum2) {
						return (lum1 + 0.05) / (lum2 + 0.05);
					}
					return (lum2 + 0.05) / (lum1 + 0.05);
				},

				level: function level(color2) {
					var contrastRatio = this.contrast(color2);
					if (contrastRatio >= 7.1) {
						return 'AAA';
					}

					return contrastRatio >= 4.5 ? 'AA' : '';
				},

				dark: function dark() {
					// YIQ equation from http://24ways.org/2010/calculating-color-contrast
					var rgb = this.values.rgb;
					var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
					return yiq < 128;
				},

				light: function light() {
					return !this.dark();
				},

				negate: function negate() {
					var rgb = [];
					for (var i = 0; i < 3; i++) {
						rgb[i] = 255 - this.values.rgb[i];
					}
					this.setValues('rgb', rgb);
					return this;
				},

				lighten: function lighten(ratio) {
					var hsl = this.values.hsl;
					hsl[2] += hsl[2] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				darken: function darken(ratio) {
					var hsl = this.values.hsl;
					hsl[2] -= hsl[2] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				saturate: function saturate(ratio) {
					var hsl = this.values.hsl;
					hsl[1] += hsl[1] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				desaturate: function desaturate(ratio) {
					var hsl = this.values.hsl;
					hsl[1] -= hsl[1] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				whiten: function whiten(ratio) {
					var hwb = this.values.hwb;
					hwb[1] += hwb[1] * ratio;
					this.setValues('hwb', hwb);
					return this;
				},

				blacken: function blacken(ratio) {
					var hwb = this.values.hwb;
					hwb[2] += hwb[2] * ratio;
					this.setValues('hwb', hwb);
					return this;
				},

				greyscale: function greyscale() {
					var rgb = this.values.rgb;
					// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
					var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
					this.setValues('rgb', [val, val, val]);
					return this;
				},

				clearer: function clearer(ratio) {
					var alpha = this.values.alpha;
					this.setValues('alpha', alpha - alpha * ratio);
					return this;
				},

				opaquer: function opaquer(ratio) {
					var alpha = this.values.alpha;
					this.setValues('alpha', alpha + alpha * ratio);
					return this;
				},

				rotate: function rotate(degrees) {
					var hsl = this.values.hsl;
					var hue = (hsl[0] + degrees) % 360;
					hsl[0] = hue < 0 ? 360 + hue : hue;
					this.setValues('hsl', hsl);
					return this;
				},

				/**
     * Ported from sass implementation in C
     * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
     */
				mix: function mix(mixinColor, weight) {
					var color1 = this;
					var color2 = mixinColor;
					var p = weight === undefined ? 0.5 : weight;

					var w = 2 * p - 1;
					var a = color1.alpha() - color2.alpha();

					var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
					var w2 = 1 - w1;

					return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
				},

				toJSON: function toJSON() {
					return this.rgb();
				},

				clone: function clone() {
					// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
					// making the final build way to big to embed in Chart.js. So let's do it manually,
					// assuming that values to clone are 1 dimension arrays containing only numbers,
					// except 'alpha' which is a number.
					var result = new Color();
					var source = this.values;
					var target = result.values;
					var value, type;

					for (var prop in source) {
						if (source.hasOwnProperty(prop)) {
							value = source[prop];
							type = {}.toString.call(value);
							if (type === '[object Array]') {
								target[prop] = value.slice(0);
							} else if (type === '[object Number]') {
								target[prop] = value;
							} else {
								console.error('unexpected color value:', value);
							}
						}
					}

					return result;
				}
			};

			Color.prototype.spaces = {
				rgb: ['red', 'green', 'blue'],
				hsl: ['hue', 'saturation', 'lightness'],
				hsv: ['hue', 'saturation', 'value'],
				hwb: ['hue', 'whiteness', 'blackness'],
				cmyk: ['cyan', 'magenta', 'yellow', 'black']
			};

			Color.prototype.maxes = {
				rgb: [255, 255, 255],
				hsl: [360, 100, 100],
				hsv: [360, 100, 100],
				hwb: [360, 100, 100],
				cmyk: [100, 100, 100, 100]
			};

			Color.prototype.getValues = function (space) {
				var values = this.values;
				var vals = {};

				for (var i = 0; i < space.length; i++) {
					vals[space.charAt(i)] = values[space][i];
				}

				if (values.alpha !== 1) {
					vals.a = values.alpha;
				}

				// {r: 255, g: 255, b: 255, a: 0.4}
				return vals;
			};

			Color.prototype.setValues = function (space, vals) {
				var values = this.values;
				var spaces = this.spaces;
				var maxes = this.maxes;
				var alpha = 1;
				var i;

				this.valid = true;

				if (space === 'alpha') {
					alpha = vals;
				} else if (vals.length) {
					// [10, 10, 10]
					values[space] = vals.slice(0, space.length);
					alpha = vals[space.length];
				} else if (vals[space.charAt(0)] !== undefined) {
					// {r: 10, g: 10, b: 10}
					for (i = 0; i < space.length; i++) {
						values[space][i] = vals[space.charAt(i)];
					}

					alpha = vals.a;
				} else if (vals[spaces[space][0]] !== undefined) {
					// {red: 10, green: 10, blue: 10}
					var chans = spaces[space];

					for (i = 0; i < space.length; i++) {
						values[space][i] = vals[chans[i]];
					}

					alpha = vals.alpha;
				}

				values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

				if (space === 'alpha') {
					return false;
				}

				var capped;

				// cap values of the space prior converting all values
				for (i = 0; i < space.length; i++) {
					capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
					values[space][i] = Math.round(capped);
				}

				// convert to all the other color spaces
				for (var sname in spaces) {
					if (sname !== space) {
						values[sname] = convert[space][sname](values[space]);
					}
				}

				return true;
			};

			Color.prototype.setSpace = function (space, args) {
				var vals = args[0];

				if (vals === undefined) {
					// color.rgb()
					return this.getValues(space);
				}

				// color.rgb(10, 10, 10)
				if (typeof vals === 'number') {
					vals = Array.prototype.slice.call(args);
				}

				this.setValues(space, vals);
				return this;
			};

			Color.prototype.setChannel = function (space, index, val) {
				var svalues = this.values[space];
				if (val === undefined) {
					// color.red()
					return svalues[index];
				} else if (val === svalues[index]) {
					// color.red(color.red())
					return this;
				}

				// color.red(100)
				svalues[index] = val;
				this.setValues(space, svalues);

				return this;
			};

			if (typeof window !== 'undefined') {
				window.Color = Color;
			}

			module.exports = Color;
		}, { "2": 2, "5": 5 }], 4: [function (require, module, exports) {
			/* MIT license */

			module.exports = {
				rgb2hsl: rgb2hsl,
				rgb2hsv: rgb2hsv,
				rgb2hwb: rgb2hwb,
				rgb2cmyk: rgb2cmyk,
				rgb2keyword: rgb2keyword,
				rgb2xyz: rgb2xyz,
				rgb2lab: rgb2lab,
				rgb2lch: rgb2lch,

				hsl2rgb: hsl2rgb,
				hsl2hsv: hsl2hsv,
				hsl2hwb: hsl2hwb,
				hsl2cmyk: hsl2cmyk,
				hsl2keyword: hsl2keyword,

				hsv2rgb: hsv2rgb,
				hsv2hsl: hsv2hsl,
				hsv2hwb: hsv2hwb,
				hsv2cmyk: hsv2cmyk,
				hsv2keyword: hsv2keyword,

				hwb2rgb: hwb2rgb,
				hwb2hsl: hwb2hsl,
				hwb2hsv: hwb2hsv,
				hwb2cmyk: hwb2cmyk,
				hwb2keyword: hwb2keyword,

				cmyk2rgb: cmyk2rgb,
				cmyk2hsl: cmyk2hsl,
				cmyk2hsv: cmyk2hsv,
				cmyk2hwb: cmyk2hwb,
				cmyk2keyword: cmyk2keyword,

				keyword2rgb: keyword2rgb,
				keyword2hsl: keyword2hsl,
				keyword2hsv: keyword2hsv,
				keyword2hwb: keyword2hwb,
				keyword2cmyk: keyword2cmyk,
				keyword2lab: keyword2lab,
				keyword2xyz: keyword2xyz,

				xyz2rgb: xyz2rgb,
				xyz2lab: xyz2lab,
				xyz2lch: xyz2lch,

				lab2xyz: lab2xyz,
				lab2rgb: lab2rgb,
				lab2lch: lab2lch,

				lch2lab: lch2lab,
				lch2xyz: lch2xyz,
				lch2rgb: lch2rgb
			};

			function rgb2hsl(rgb) {
				var r = rgb[0] / 255,
				    g = rgb[1] / 255,
				    b = rgb[2] / 255,
				    min = Math.min(r, g, b),
				    max = Math.max(r, g, b),
				    delta = max - min,
				    h,
				    s,
				    l;

				if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;

				h = Math.min(h * 60, 360);

				if (h < 0) h += 360;

				l = (min + max) / 2;

				if (max == min) s = 0;else if (l <= 0.5) s = delta / (max + min);else s = delta / (2 - max - min);

				return [h, s * 100, l * 100];
			}

			function rgb2hsv(rgb) {
				var r = rgb[0],
				    g = rgb[1],
				    b = rgb[2],
				    min = Math.min(r, g, b),
				    max = Math.max(r, g, b),
				    delta = max - min,
				    h,
				    s,
				    v;

				if (max == 0) s = 0;else s = delta / max * 1000 / 10;

				if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;

				h = Math.min(h * 60, 360);

				if (h < 0) h += 360;

				v = max / 255 * 1000 / 10;

				return [h, s, v];
			}

			function rgb2hwb(rgb) {
				var r = rgb[0],
				    g = rgb[1],
				    b = rgb[2],
				    h = rgb2hsl(rgb)[0],
				    w = 1 / 255 * Math.min(r, Math.min(g, b)),
				    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

				return [h, w * 100, b * 100];
			}

			function rgb2cmyk(rgb) {
				var r = rgb[0] / 255,
				    g = rgb[1] / 255,
				    b = rgb[2] / 255,
				    c,
				    m,
				    y,
				    k;

				k = Math.min(1 - r, 1 - g, 1 - b);
				c = (1 - r - k) / (1 - k) || 0;
				m = (1 - g - k) / (1 - k) || 0;
				y = (1 - b - k) / (1 - k) || 0;
				return [c * 100, m * 100, y * 100, k * 100];
			}

			function rgb2keyword(rgb) {
				return reverseKeywords[JSON.stringify(rgb)];
			}

			function rgb2xyz(rgb) {
				var r = rgb[0] / 255,
				    g = rgb[1] / 255,
				    b = rgb[2] / 255;

				// assume sRGB
				r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
				g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
				b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

				var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
				var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
				var z = r * 0.0193 + g * 0.1192 + b * 0.9505;

				return [x * 100, y * 100, z * 100];
			}

			function rgb2lab(rgb) {
				var xyz = rgb2xyz(rgb),
				    x = xyz[0],
				    y = xyz[1],
				    z = xyz[2],
				    l,
				    a,
				    b;

				x /= 95.047;
				y /= 100;
				z /= 108.883;

				x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
				y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
				z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

				l = 116 * y - 16;
				a = 500 * (x - y);
				b = 200 * (y - z);

				return [l, a, b];
			}

			function rgb2lch(args) {
				return lab2lch(rgb2lab(args));
			}

			function hsl2rgb(hsl) {
				var h = hsl[0] / 360,
				    s = hsl[1] / 100,
				    l = hsl[2] / 100,
				    t1,
				    t2,
				    t3,
				    rgb,
				    val;

				if (s == 0) {
					val = l * 255;
					return [val, val, val];
				}

				if (l < 0.5) t2 = l * (1 + s);else t2 = l + s - l * s;
				t1 = 2 * l - t2;

				rgb = [0, 0, 0];
				for (var i = 0; i < 3; i++) {
					t3 = h + 1 / 3 * -(i - 1);
					t3 < 0 && t3++;
					t3 > 1 && t3--;

					if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;else if (2 * t3 < 1) val = t2;else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;else val = t1;

					rgb[i] = val * 255;
				}

				return rgb;
			}

			function hsl2hsv(hsl) {
				var h = hsl[0],
				    s = hsl[1] / 100,
				    l = hsl[2] / 100,
				    sv,
				    v;

				if (l === 0) {
					// no need to do calc on black
					// also avoids divide by 0 error
					return [0, 0, 0];
				}

				l *= 2;
				s *= l <= 1 ? l : 2 - l;
				v = (l + s) / 2;
				sv = 2 * s / (l + s);
				return [h, sv * 100, v * 100];
			}

			function hsl2hwb(args) {
				return rgb2hwb(hsl2rgb(args));
			}

			function hsl2cmyk(args) {
				return rgb2cmyk(hsl2rgb(args));
			}

			function hsl2keyword(args) {
				return rgb2keyword(hsl2rgb(args));
			}

			function hsv2rgb(hsv) {
				var h = hsv[0] / 60,
				    s = hsv[1] / 100,
				    v = hsv[2] / 100,
				    hi = Math.floor(h) % 6;

				var f = h - Math.floor(h),
				    p = 255 * v * (1 - s),
				    q = 255 * v * (1 - s * f),
				    t = 255 * v * (1 - s * (1 - f)),
				    v = 255 * v;

				switch (hi) {
					case 0:
						return [v, t, p];
					case 1:
						return [q, v, p];
					case 2:
						return [p, v, t];
					case 3:
						return [p, q, v];
					case 4:
						return [t, p, v];
					case 5:
						return [v, p, q];
				}
			}

			function hsv2hsl(hsv) {
				var h = hsv[0],
				    s = hsv[1] / 100,
				    v = hsv[2] / 100,
				    sl,
				    l;

				l = (2 - s) * v;
				sl = s * v;
				sl /= l <= 1 ? l : 2 - l;
				sl = sl || 0;
				l /= 2;
				return [h, sl * 100, l * 100];
			}

			function hsv2hwb(args) {
				return rgb2hwb(hsv2rgb(args));
			}

			function hsv2cmyk(args) {
				return rgb2cmyk(hsv2rgb(args));
			}

			function hsv2keyword(args) {
				return rgb2keyword(hsv2rgb(args));
			}

			// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
			function hwb2rgb(hwb) {
				var h = hwb[0] / 360,
				    wh = hwb[1] / 100,
				    bl = hwb[2] / 100,
				    ratio = wh + bl,
				    i,
				    v,
				    f,
				    n;

				// wh + bl cant be > 1
				if (ratio > 1) {
					wh /= ratio;
					bl /= ratio;
				}

				i = Math.floor(6 * h);
				v = 1 - bl;
				f = 6 * h - i;
				if ((i & 0x01) != 0) {
					f = 1 - f;
				}
				n = wh + f * (v - wh); // linear interpolation

				switch (i) {
					default:
					case 6:
					case 0:
						r = v;g = n;b = wh;break;
					case 1:
						r = n;g = v;b = wh;break;
					case 2:
						r = wh;g = v;b = n;break;
					case 3:
						r = wh;g = n;b = v;break;
					case 4:
						r = n;g = wh;b = v;break;
					case 5:
						r = v;g = wh;b = n;break;
				}

				return [r * 255, g * 255, b * 255];
			}

			function hwb2hsl(args) {
				return rgb2hsl(hwb2rgb(args));
			}

			function hwb2hsv(args) {
				return rgb2hsv(hwb2rgb(args));
			}

			function hwb2cmyk(args) {
				return rgb2cmyk(hwb2rgb(args));
			}

			function hwb2keyword(args) {
				return rgb2keyword(hwb2rgb(args));
			}

			function cmyk2rgb(cmyk) {
				var c = cmyk[0] / 100,
				    m = cmyk[1] / 100,
				    y = cmyk[2] / 100,
				    k = cmyk[3] / 100,
				    r,
				    g,
				    b;

				r = 1 - Math.min(1, c * (1 - k) + k);
				g = 1 - Math.min(1, m * (1 - k) + k);
				b = 1 - Math.min(1, y * (1 - k) + k);
				return [r * 255, g * 255, b * 255];
			}

			function cmyk2hsl(args) {
				return rgb2hsl(cmyk2rgb(args));
			}

			function cmyk2hsv(args) {
				return rgb2hsv(cmyk2rgb(args));
			}

			function cmyk2hwb(args) {
				return rgb2hwb(cmyk2rgb(args));
			}

			function cmyk2keyword(args) {
				return rgb2keyword(cmyk2rgb(args));
			}

			function xyz2rgb(xyz) {
				var x = xyz[0] / 100,
				    y = xyz[1] / 100,
				    z = xyz[2] / 100,
				    r,
				    g,
				    b;

				r = x * 3.2406 + y * -1.5372 + z * -0.4986;
				g = x * -0.9689 + y * 1.8758 + z * 0.0415;
				b = x * 0.0557 + y * -0.2040 + z * 1.0570;

				// assume sRGB
				r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;

				g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;

				b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;

				r = Math.min(Math.max(0, r), 1);
				g = Math.min(Math.max(0, g), 1);
				b = Math.min(Math.max(0, b), 1);

				return [r * 255, g * 255, b * 255];
			}

			function xyz2lab(xyz) {
				var x = xyz[0],
				    y = xyz[1],
				    z = xyz[2],
				    l,
				    a,
				    b;

				x /= 95.047;
				y /= 100;
				z /= 108.883;

				x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
				y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
				z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

				l = 116 * y - 16;
				a = 500 * (x - y);
				b = 200 * (y - z);

				return [l, a, b];
			}

			function xyz2lch(args) {
				return lab2lch(xyz2lab(args));
			}

			function lab2xyz(lab) {
				var l = lab[0],
				    a = lab[1],
				    b = lab[2],
				    x,
				    y,
				    z,
				    y2;

				if (l <= 8) {
					y = l * 100 / 903.3;
					y2 = 7.787 * (y / 100) + 16 / 116;
				} else {
					y = 100 * Math.pow((l + 16) / 116, 3);
					y2 = Math.pow(y / 100, 1 / 3);
				}

				x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);

				z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);

				return [x, y, z];
			}

			function lab2lch(lab) {
				var l = lab[0],
				    a = lab[1],
				    b = lab[2],
				    hr,
				    h,
				    c;

				hr = Math.atan2(b, a);
				h = hr * 360 / 2 / Math.PI;
				if (h < 0) {
					h += 360;
				}
				c = Math.sqrt(a * a + b * b);
				return [l, c, h];
			}

			function lab2rgb(args) {
				return xyz2rgb(lab2xyz(args));
			}

			function lch2lab(lch) {
				var l = lch[0],
				    c = lch[1],
				    h = lch[2],
				    a,
				    b,
				    hr;

				hr = h / 360 * 2 * Math.PI;
				a = c * Math.cos(hr);
				b = c * Math.sin(hr);
				return [l, a, b];
			}

			function lch2xyz(args) {
				return lab2xyz(lch2lab(args));
			}

			function lch2rgb(args) {
				return lab2rgb(lch2lab(args));
			}

			function keyword2rgb(keyword) {
				return cssKeywords[keyword];
			}

			function keyword2hsl(args) {
				return rgb2hsl(keyword2rgb(args));
			}

			function keyword2hsv(args) {
				return rgb2hsv(keyword2rgb(args));
			}

			function keyword2hwb(args) {
				return rgb2hwb(keyword2rgb(args));
			}

			function keyword2cmyk(args) {
				return rgb2cmyk(keyword2rgb(args));
			}

			function keyword2lab(args) {
				return rgb2lab(keyword2rgb(args));
			}

			function keyword2xyz(args) {
				return rgb2xyz(keyword2rgb(args));
			}

			var cssKeywords = {
				aliceblue: [240, 248, 255],
				antiquewhite: [250, 235, 215],
				aqua: [0, 255, 255],
				aquamarine: [127, 255, 212],
				azure: [240, 255, 255],
				beige: [245, 245, 220],
				bisque: [255, 228, 196],
				black: [0, 0, 0],
				blanchedalmond: [255, 235, 205],
				blue: [0, 0, 255],
				blueviolet: [138, 43, 226],
				brown: [165, 42, 42],
				burlywood: [222, 184, 135],
				cadetblue: [95, 158, 160],
				chartreuse: [127, 255, 0],
				chocolate: [210, 105, 30],
				coral: [255, 127, 80],
				cornflowerblue: [100, 149, 237],
				cornsilk: [255, 248, 220],
				crimson: [220, 20, 60],
				cyan: [0, 255, 255],
				darkblue: [0, 0, 139],
				darkcyan: [0, 139, 139],
				darkgoldenrod: [184, 134, 11],
				darkgray: [169, 169, 169],
				darkgreen: [0, 100, 0],
				darkgrey: [169, 169, 169],
				darkkhaki: [189, 183, 107],
				darkmagenta: [139, 0, 139],
				darkolivegreen: [85, 107, 47],
				darkorange: [255, 140, 0],
				darkorchid: [153, 50, 204],
				darkred: [139, 0, 0],
				darksalmon: [233, 150, 122],
				darkseagreen: [143, 188, 143],
				darkslateblue: [72, 61, 139],
				darkslategray: [47, 79, 79],
				darkslategrey: [47, 79, 79],
				darkturquoise: [0, 206, 209],
				darkviolet: [148, 0, 211],
				deeppink: [255, 20, 147],
				deepskyblue: [0, 191, 255],
				dimgray: [105, 105, 105],
				dimgrey: [105, 105, 105],
				dodgerblue: [30, 144, 255],
				firebrick: [178, 34, 34],
				floralwhite: [255, 250, 240],
				forestgreen: [34, 139, 34],
				fuchsia: [255, 0, 255],
				gainsboro: [220, 220, 220],
				ghostwhite: [248, 248, 255],
				gold: [255, 215, 0],
				goldenrod: [218, 165, 32],
				gray: [128, 128, 128],
				green: [0, 128, 0],
				greenyellow: [173, 255, 47],
				grey: [128, 128, 128],
				honeydew: [240, 255, 240],
				hotpink: [255, 105, 180],
				indianred: [205, 92, 92],
				indigo: [75, 0, 130],
				ivory: [255, 255, 240],
				khaki: [240, 230, 140],
				lavender: [230, 230, 250],
				lavenderblush: [255, 240, 245],
				lawngreen: [124, 252, 0],
				lemonchiffon: [255, 250, 205],
				lightblue: [173, 216, 230],
				lightcoral: [240, 128, 128],
				lightcyan: [224, 255, 255],
				lightgoldenrodyellow: [250, 250, 210],
				lightgray: [211, 211, 211],
				lightgreen: [144, 238, 144],
				lightgrey: [211, 211, 211],
				lightpink: [255, 182, 193],
				lightsalmon: [255, 160, 122],
				lightseagreen: [32, 178, 170],
				lightskyblue: [135, 206, 250],
				lightslategray: [119, 136, 153],
				lightslategrey: [119, 136, 153],
				lightsteelblue: [176, 196, 222],
				lightyellow: [255, 255, 224],
				lime: [0, 255, 0],
				limegreen: [50, 205, 50],
				linen: [250, 240, 230],
				magenta: [255, 0, 255],
				maroon: [128, 0, 0],
				mediumaquamarine: [102, 205, 170],
				mediumblue: [0, 0, 205],
				mediumorchid: [186, 85, 211],
				mediumpurple: [147, 112, 219],
				mediumseagreen: [60, 179, 113],
				mediumslateblue: [123, 104, 238],
				mediumspringgreen: [0, 250, 154],
				mediumturquoise: [72, 209, 204],
				mediumvioletred: [199, 21, 133],
				midnightblue: [25, 25, 112],
				mintcream: [245, 255, 250],
				mistyrose: [255, 228, 225],
				moccasin: [255, 228, 181],
				navajowhite: [255, 222, 173],
				navy: [0, 0, 128],
				oldlace: [253, 245, 230],
				olive: [128, 128, 0],
				olivedrab: [107, 142, 35],
				orange: [255, 165, 0],
				orangered: [255, 69, 0],
				orchid: [218, 112, 214],
				palegoldenrod: [238, 232, 170],
				palegreen: [152, 251, 152],
				paleturquoise: [175, 238, 238],
				palevioletred: [219, 112, 147],
				papayawhip: [255, 239, 213],
				peachpuff: [255, 218, 185],
				peru: [205, 133, 63],
				pink: [255, 192, 203],
				plum: [221, 160, 221],
				powderblue: [176, 224, 230],
				purple: [128, 0, 128],
				rebeccapurple: [102, 51, 153],
				red: [255, 0, 0],
				rosybrown: [188, 143, 143],
				royalblue: [65, 105, 225],
				saddlebrown: [139, 69, 19],
				salmon: [250, 128, 114],
				sandybrown: [244, 164, 96],
				seagreen: [46, 139, 87],
				seashell: [255, 245, 238],
				sienna: [160, 82, 45],
				silver: [192, 192, 192],
				skyblue: [135, 206, 235],
				slateblue: [106, 90, 205],
				slategray: [112, 128, 144],
				slategrey: [112, 128, 144],
				snow: [255, 250, 250],
				springgreen: [0, 255, 127],
				steelblue: [70, 130, 180],
				tan: [210, 180, 140],
				teal: [0, 128, 128],
				thistle: [216, 191, 216],
				tomato: [255, 99, 71],
				turquoise: [64, 224, 208],
				violet: [238, 130, 238],
				wheat: [245, 222, 179],
				white: [255, 255, 255],
				whitesmoke: [245, 245, 245],
				yellow: [255, 255, 0],
				yellowgreen: [154, 205, 50]
			};

			var reverseKeywords = {};
			for (var key in cssKeywords) {
				reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
			}
		}, {}], 5: [function (require, module, exports) {
			var conversions = require(4);

			var convert = function convert() {
				return new Converter();
			};

			for (var func in conversions) {
				// export Raw versions
				convert[func + "Raw"] = function (func) {
					// accept array or plain args
					return function (arg) {
						if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
						return conversions[func](arg);
					};
				}(func);

				var pair = /(\w+)2(\w+)/.exec(func),
				    from = pair[1],
				    to = pair[2];

				// export rgb2hsl and ["rgb"]["hsl"]
				convert[from] = convert[from] || {};

				convert[from][to] = convert[func] = function (func) {
					return function (arg) {
						if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);

						var val = conversions[func](arg);
						if (typeof val == "string" || val === undefined) return val; // keyword

						for (var i = 0; i < val.length; i++) {
							val[i] = Math.round(val[i]);
						}return val;
					};
				}(func);
			}

			/* Converter does lazy conversion and caching */
			var Converter = function Converter() {
				this.convs = {};
			};

			/* Either get the values for a space or
     set the values for a space, depending on args */
			Converter.prototype.routeSpace = function (space, args) {
				var values = args[0];
				if (values === undefined) {
					// color.rgb()
					return this.getValues(space);
				}
				// color.rgb(10, 10, 10)
				if (typeof values == "number") {
					values = Array.prototype.slice.call(args);
				}

				return this.setValues(space, values);
			};

			/* Set the values for a space, invalidating cache */
			Converter.prototype.setValues = function (space, values) {
				this.space = space;
				this.convs = {};
				this.convs[space] = values;
				return this;
			};

			/* Get the values for a space. If there's already
     a conversion for the space, fetch it, otherwise
     compute it */
			Converter.prototype.getValues = function (space) {
				var vals = this.convs[space];
				if (!vals) {
					var fspace = this.space,
					    from = this.convs[fspace];
					vals = convert[fspace][space](from);

					this.convs[space] = vals;
				}
				return vals;
			};

			["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
				Converter.prototype[space] = function (vals) {
					return this.routeSpace(space, arguments);
				};
			});

			module.exports = convert;
		}, { "4": 4 }], 6: [function (require, module, exports) {
			'use strict';

			module.exports = {
				"aliceblue": [240, 248, 255],
				"antiquewhite": [250, 235, 215],
				"aqua": [0, 255, 255],
				"aquamarine": [127, 255, 212],
				"azure": [240, 255, 255],
				"beige": [245, 245, 220],
				"bisque": [255, 228, 196],
				"black": [0, 0, 0],
				"blanchedalmond": [255, 235, 205],
				"blue": [0, 0, 255],
				"blueviolet": [138, 43, 226],
				"brown": [165, 42, 42],
				"burlywood": [222, 184, 135],
				"cadetblue": [95, 158, 160],
				"chartreuse": [127, 255, 0],
				"chocolate": [210, 105, 30],
				"coral": [255, 127, 80],
				"cornflowerblue": [100, 149, 237],
				"cornsilk": [255, 248, 220],
				"crimson": [220, 20, 60],
				"cyan": [0, 255, 255],
				"darkblue": [0, 0, 139],
				"darkcyan": [0, 139, 139],
				"darkgoldenrod": [184, 134, 11],
				"darkgray": [169, 169, 169],
				"darkgreen": [0, 100, 0],
				"darkgrey": [169, 169, 169],
				"darkkhaki": [189, 183, 107],
				"darkmagenta": [139, 0, 139],
				"darkolivegreen": [85, 107, 47],
				"darkorange": [255, 140, 0],
				"darkorchid": [153, 50, 204],
				"darkred": [139, 0, 0],
				"darksalmon": [233, 150, 122],
				"darkseagreen": [143, 188, 143],
				"darkslateblue": [72, 61, 139],
				"darkslategray": [47, 79, 79],
				"darkslategrey": [47, 79, 79],
				"darkturquoise": [0, 206, 209],
				"darkviolet": [148, 0, 211],
				"deeppink": [255, 20, 147],
				"deepskyblue": [0, 191, 255],
				"dimgray": [105, 105, 105],
				"dimgrey": [105, 105, 105],
				"dodgerblue": [30, 144, 255],
				"firebrick": [178, 34, 34],
				"floralwhite": [255, 250, 240],
				"forestgreen": [34, 139, 34],
				"fuchsia": [255, 0, 255],
				"gainsboro": [220, 220, 220],
				"ghostwhite": [248, 248, 255],
				"gold": [255, 215, 0],
				"goldenrod": [218, 165, 32],
				"gray": [128, 128, 128],
				"green": [0, 128, 0],
				"greenyellow": [173, 255, 47],
				"grey": [128, 128, 128],
				"honeydew": [240, 255, 240],
				"hotpink": [255, 105, 180],
				"indianred": [205, 92, 92],
				"indigo": [75, 0, 130],
				"ivory": [255, 255, 240],
				"khaki": [240, 230, 140],
				"lavender": [230, 230, 250],
				"lavenderblush": [255, 240, 245],
				"lawngreen": [124, 252, 0],
				"lemonchiffon": [255, 250, 205],
				"lightblue": [173, 216, 230],
				"lightcoral": [240, 128, 128],
				"lightcyan": [224, 255, 255],
				"lightgoldenrodyellow": [250, 250, 210],
				"lightgray": [211, 211, 211],
				"lightgreen": [144, 238, 144],
				"lightgrey": [211, 211, 211],
				"lightpink": [255, 182, 193],
				"lightsalmon": [255, 160, 122],
				"lightseagreen": [32, 178, 170],
				"lightskyblue": [135, 206, 250],
				"lightslategray": [119, 136, 153],
				"lightslategrey": [119, 136, 153],
				"lightsteelblue": [176, 196, 222],
				"lightyellow": [255, 255, 224],
				"lime": [0, 255, 0],
				"limegreen": [50, 205, 50],
				"linen": [250, 240, 230],
				"magenta": [255, 0, 255],
				"maroon": [128, 0, 0],
				"mediumaquamarine": [102, 205, 170],
				"mediumblue": [0, 0, 205],
				"mediumorchid": [186, 85, 211],
				"mediumpurple": [147, 112, 219],
				"mediumseagreen": [60, 179, 113],
				"mediumslateblue": [123, 104, 238],
				"mediumspringgreen": [0, 250, 154],
				"mediumturquoise": [72, 209, 204],
				"mediumvioletred": [199, 21, 133],
				"midnightblue": [25, 25, 112],
				"mintcream": [245, 255, 250],
				"mistyrose": [255, 228, 225],
				"moccasin": [255, 228, 181],
				"navajowhite": [255, 222, 173],
				"navy": [0, 0, 128],
				"oldlace": [253, 245, 230],
				"olive": [128, 128, 0],
				"olivedrab": [107, 142, 35],
				"orange": [255, 165, 0],
				"orangered": [255, 69, 0],
				"orchid": [218, 112, 214],
				"palegoldenrod": [238, 232, 170],
				"palegreen": [152, 251, 152],
				"paleturquoise": [175, 238, 238],
				"palevioletred": [219, 112, 147],
				"papayawhip": [255, 239, 213],
				"peachpuff": [255, 218, 185],
				"peru": [205, 133, 63],
				"pink": [255, 192, 203],
				"plum": [221, 160, 221],
				"powderblue": [176, 224, 230],
				"purple": [128, 0, 128],
				"rebeccapurple": [102, 51, 153],
				"red": [255, 0, 0],
				"rosybrown": [188, 143, 143],
				"royalblue": [65, 105, 225],
				"saddlebrown": [139, 69, 19],
				"salmon": [250, 128, 114],
				"sandybrown": [244, 164, 96],
				"seagreen": [46, 139, 87],
				"seashell": [255, 245, 238],
				"sienna": [160, 82, 45],
				"silver": [192, 192, 192],
				"skyblue": [135, 206, 235],
				"slateblue": [106, 90, 205],
				"slategray": [112, 128, 144],
				"slategrey": [112, 128, 144],
				"snow": [255, 250, 250],
				"springgreen": [0, 255, 127],
				"steelblue": [70, 130, 180],
				"tan": [210, 180, 140],
				"teal": [0, 128, 128],
				"thistle": [216, 191, 216],
				"tomato": [255, 99, 71],
				"turquoise": [64, 224, 208],
				"violet": [238, 130, 238],
				"wheat": [245, 222, 179],
				"white": [255, 255, 255],
				"whitesmoke": [245, 245, 245],
				"yellow": [255, 255, 0],
				"yellowgreen": [154, 205, 50]
			};
		}, {}], 7: [function (require, module, exports) {
			/**
    * @namespace Chart
    */
			var Chart = require(29)();

			Chart.helpers = require(45);

			// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
			require(27)(Chart);

			Chart.defaults = require(25);
			Chart.Element = require(26);
			Chart.elements = require(40);
			Chart.Interaction = require(28);
			Chart.platform = require(48);

			require(31)(Chart);
			require(22)(Chart);
			require(23)(Chart);
			require(24)(Chart);
			require(30)(Chart);
			require(33)(Chart);
			require(32)(Chart);
			require(35)(Chart);

			require(54)(Chart);
			require(52)(Chart);
			require(53)(Chart);
			require(55)(Chart);
			require(56)(Chart);
			require(57)(Chart);

			// Controllers must be loaded after elements
			// See Chart.core.datasetController.dataElementType
			require(15)(Chart);
			require(16)(Chart);
			require(17)(Chart);
			require(18)(Chart);
			require(19)(Chart);
			require(20)(Chart);
			require(21)(Chart);

			require(8)(Chart);
			require(9)(Chart);
			require(10)(Chart);
			require(11)(Chart);
			require(12)(Chart);
			require(13)(Chart);
			require(14)(Chart);

			// Loading built-it plugins
			var plugins = [];

			plugins.push(require(49)(Chart), require(50)(Chart), require(51)(Chart));

			Chart.plugins.register(plugins);

			Chart.platform.initialize();

			module.exports = Chart;
			if (typeof window !== 'undefined') {
				window.Chart = Chart;
			}

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.canvas instead.
    * @namespace Chart.canvasHelpers
    * @deprecated since version 2.6.0
    * @todo remove at version 3
    * @private
    */
			Chart.canvasHelpers = Chart.helpers.canvas;
		}, { "10": 10, "11": 11, "12": 12, "13": 13, "14": 14, "15": 15, "16": 16, "17": 17, "18": 18, "19": 19, "20": 20, "21": 21, "22": 22, "23": 23, "24": 24, "25": 25, "26": 26, "27": 27, "28": 28, "29": 29, "30": 30, "31": 31, "32": 32, "33": 33, "35": 35, "40": 40, "45": 45, "48": 48, "49": 49, "50": 50, "51": 51, "52": 52, "53": 53, "54": 54, "55": 55, "56": 56, "57": 57, "8": 8, "9": 9 }], 8: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Bar = function (context, config) {
					config.type = 'bar';

					return new Chart(context, config);
				};
			};
		}, {}], 9: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Bubble = function (context, config) {
					config.type = 'bubble';
					return new Chart(context, config);
				};
			};
		}, {}], 10: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Doughnut = function (context, config) {
					config.type = 'doughnut';

					return new Chart(context, config);
				};
			};
		}, {}], 11: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Line = function (context, config) {
					config.type = 'line';

					return new Chart(context, config);
				};
			};
		}, {}], 12: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.PolarArea = function (context, config) {
					config.type = 'polarArea';

					return new Chart(context, config);
				};
			};
		}, {}], 13: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Radar = function (context, config) {
					config.type = 'radar';

					return new Chart(context, config);
				};
			};
		}, {}], 14: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {
				Chart.Scatter = function (context, config) {
					config.type = 'scatter';
					return new Chart(context, config);
				};
			};
		}, {}], 15: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('bar', {
				hover: {
					mode: 'label'
				},

				scales: {
					xAxes: [{
						type: 'category',

						// Specific to Bar Controller
						categoryPercentage: 0.8,
						barPercentage: 0.9,

						// offset settings
						offset: true,

						// grid line settings
						gridLines: {
							offsetGridLines: true
						}
					}],

					yAxes: [{
						type: 'linear'
					}]
				}
			});

			defaults._set('horizontalBar', {
				hover: {
					mode: 'index',
					axis: 'y'
				},

				scales: {
					xAxes: [{
						type: 'linear',
						position: 'bottom'
					}],

					yAxes: [{
						position: 'left',
						type: 'category',

						// Specific to Horizontal Bar Controller
						categoryPercentage: 0.8,
						barPercentage: 0.9,

						// offset settings
						offset: true,

						// grid line settings
						gridLines: {
							offsetGridLines: true
						}
					}]
				},

				elements: {
					rectangle: {
						borderSkipped: 'left'
					}
				},

				tooltips: {
					callbacks: {
						title: function title(item, data) {
							// Pick first xLabel for now
							var title = '';

							if (item.length > 0) {
								if (item[0].yLabel) {
									title = item[0].yLabel;
								} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
									title = data.labels[item[0].index];
								}
							}

							return title;
						},

						label: function label(item, data) {
							var datasetLabel = data.datasets[item.datasetIndex].label || '';
							return datasetLabel + ': ' + item.xLabel;
						}
					},
					mode: 'index',
					axis: 'y'
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.bar = Chart.DatasetController.extend({

					dataElementType: elements.Rectangle,

					initialize: function initialize() {
						var me = this;
						var meta;

						Chart.DatasetController.prototype.initialize.apply(me, arguments);

						meta = me.getMeta();
						meta.stack = me.getDataset().stack;
						meta.bar = true;
					},

					update: function update(reset) {
						var me = this;
						var rects = me.getMeta().data;
						var i, ilen;

						me._ruler = me.getRuler();

						for (i = 0, ilen = rects.length; i < ilen; ++i) {
							me.updateElement(rects[i], i, reset);
						}
					},

					updateElement: function updateElement(rectangle, index, reset) {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var dataset = me.getDataset();
						var custom = rectangle.custom || {};
						var rectangleOptions = chart.options.elements.rectangle;

						rectangle._xScale = me.getScaleForId(meta.xAxisID);
						rectangle._yScale = me.getScaleForId(meta.yAxisID);
						rectangle._datasetIndex = me.index;
						rectangle._index = index;

						rectangle._model = {
							datasetLabel: dataset.label,
							label: chart.data.labels[index],
							borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
							backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
							borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
							borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
						};

						me.updateElementGeometry(rectangle, index, reset);

						rectangle.pivot();
					},

					/**
      * @private
      */
					updateElementGeometry: function updateElementGeometry(rectangle, index, reset) {
						var me = this;
						var model = rectangle._model;
						var vscale = me.getValueScale();
						var base = vscale.getBasePixel();
						var horizontal = vscale.isHorizontal();
						var ruler = me._ruler || me.getRuler();
						var vpixels = me.calculateBarValuePixels(me.index, index);
						var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

						model.horizontal = horizontal;
						model.base = reset ? base : vpixels.base;
						model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
						model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
						model.height = horizontal ? ipixels.size : undefined;
						model.width = horizontal ? undefined : ipixels.size;
					},

					/**
      * @private
      */
					getValueScaleId: function getValueScaleId() {
						return this.getMeta().yAxisID;
					},

					/**
      * @private
      */
					getIndexScaleId: function getIndexScaleId() {
						return this.getMeta().xAxisID;
					},

					/**
      * @private
      */
					getValueScale: function getValueScale() {
						return this.getScaleForId(this.getValueScaleId());
					},

					/**
      * @private
      */
					getIndexScale: function getIndexScale() {
						return this.getScaleForId(this.getIndexScaleId());
					},

					/**
      * Returns the effective number of stacks based on groups and bar visibility.
      * @private
      */
					getStackCount: function getStackCount(last) {
						var me = this;
						var chart = me.chart;
						var scale = me.getIndexScale();
						var stacked = scale.options.stacked;
						var ilen = last === undefined ? chart.data.datasets.length : last + 1;
						var stacks = [];
						var i, meta;

						for (i = 0; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
								stacks.push(meta.stack);
							}
						}

						return stacks.length;
					},

					/**
      * Returns the stack index for the given dataset based on groups and bar visibility.
      * @private
      */
					getStackIndex: function getStackIndex(datasetIndex) {
						return this.getStackCount(datasetIndex) - 1;
					},

					/**
      * @private
      */
					getRuler: function getRuler() {
						var me = this;
						var scale = me.getIndexScale();
						var stackCount = me.getStackCount();
						var datasetIndex = me.index;
						var pixels = [];
						var isHorizontal = scale.isHorizontal();
						var start = isHorizontal ? scale.left : scale.top;
						var end = start + (isHorizontal ? scale.width : scale.height);
						var i, ilen;

						for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
							pixels.push(scale.getPixelForValue(null, i, datasetIndex));
						}

						return {
							pixels: pixels,
							start: start,
							end: end,
							stackCount: stackCount,
							scale: scale
						};
					},

					/**
      * Note: pixel values are not clamped to the scale area.
      * @private
      */
					calculateBarValuePixels: function calculateBarValuePixels(datasetIndex, index) {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var scale = me.getValueScale();
						var datasets = chart.data.datasets;
						var value = scale.getRightValue(datasets[datasetIndex].data[index]);
						var stacked = scale.options.stacked;
						var stack = meta.stack;
						var start = 0;
						var i, imeta, ivalue, base, head, size;

						if (stacked || stacked === undefined && stack !== undefined) {
							for (i = 0; i < datasetIndex; ++i) {
								imeta = chart.getDatasetMeta(i);

								if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {

									ivalue = scale.getRightValue(datasets[i].data[index]);
									if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
										start += ivalue;
									}
								}
							}
						}

						base = scale.getPixelForValue(start);
						head = scale.getPixelForValue(start + value);
						size = (head - base) / 2;

						return {
							size: size,
							base: base,
							head: head,
							center: head + size / 2
						};
					},

					/**
      * @private
      */
					calculateBarIndexPixels: function calculateBarIndexPixels(datasetIndex, index, ruler) {
						var me = this;
						var options = ruler.scale.options;
						var stackIndex = me.getStackIndex(datasetIndex);
						var pixels = ruler.pixels;
						var base = pixels[index];
						var length = pixels.length;
						var start = ruler.start;
						var end = ruler.end;
						var leftSampleSize, rightSampleSize, leftCategorySize, rightCategorySize, fullBarSize, size;

						if (length === 1) {
							leftSampleSize = base > start ? base - start : end - base;
							rightSampleSize = base < end ? end - base : base - start;
						} else {
							if (index > 0) {
								leftSampleSize = (base - pixels[index - 1]) / 2;
								if (index === length - 1) {
									rightSampleSize = leftSampleSize;
								}
							}
							if (index < length - 1) {
								rightSampleSize = (pixels[index + 1] - base) / 2;
								if (index === 0) {
									leftSampleSize = rightSampleSize;
								}
							}
						}

						leftCategorySize = leftSampleSize * options.categoryPercentage;
						rightCategorySize = rightSampleSize * options.categoryPercentage;
						fullBarSize = (leftCategorySize + rightCategorySize) / ruler.stackCount;
						size = fullBarSize * options.barPercentage;

						size = Math.min(helpers.valueOrDefault(options.barThickness, size), helpers.valueOrDefault(options.maxBarThickness, Infinity));

						base -= leftCategorySize;
						base += fullBarSize * stackIndex;
						base += (fullBarSize - size) / 2;

						return {
							size: size,
							base: base,
							head: base + size,
							center: base + size / 2
						};
					},

					draw: function draw() {
						var me = this;
						var chart = me.chart;
						var scale = me.getValueScale();
						var rects = me.getMeta().data;
						var dataset = me.getDataset();
						var ilen = rects.length;
						var i = 0;

						helpers.canvas.clipArea(chart.ctx, chart.chartArea);

						for (; i < ilen; ++i) {
							if (!isNaN(scale.getRightValue(dataset.data[i]))) {
								rects[i].draw();
							}
						}

						helpers.canvas.unclipArea(chart.ctx);
					},

					setHoverStyle: function setHoverStyle(rectangle) {
						var dataset = this.chart.data.datasets[rectangle._datasetIndex];
						var index = rectangle._index;
						var custom = rectangle.custom || {};
						var model = rectangle._model;

						model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
					},

					removeHoverStyle: function removeHoverStyle(rectangle) {
						var dataset = this.chart.data.datasets[rectangle._datasetIndex];
						var index = rectangle._index;
						var custom = rectangle.custom || {};
						var model = rectangle._model;
						var rectangleElementOptions = this.chart.options.elements.rectangle;

						model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
						model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
						model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
					}
				});

				Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
					/**
      * @private
      */
					getValueScaleId: function getValueScaleId() {
						return this.getMeta().xAxisID;
					},

					/**
      * @private
      */
					getIndexScaleId: function getIndexScaleId() {
						return this.getMeta().yAxisID;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 16: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('bubble', {
				hover: {
					mode: 'single'
				},

				scales: {
					xAxes: [{
						type: 'linear', // bubble should probably use a linear scale by default
						position: 'bottom',
						id: 'x-axis-0' // need an ID so datasets can reference the scale
					}],
					yAxes: [{
						type: 'linear',
						position: 'left',
						id: 'y-axis-0'
					}]
				},

				tooltips: {
					callbacks: {
						title: function title() {
							// Title doesn't make sense for scatter since we format the data as a point
							return '';
						},
						label: function label(item, data) {
							var datasetLabel = data.datasets[item.datasetIndex].label || '';
							var dataPoint = data.datasets[item.datasetIndex].data[item.index];
							return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
						}
					}
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.bubble = Chart.DatasetController.extend({
					/**
      * @protected
      */
					dataElementType: elements.Point,

					/**
      * @protected
      */
					update: function update(reset) {
						var me = this;
						var meta = me.getMeta();
						var points = meta.data;

						// Update Points
						helpers.each(points, function (point, index) {
							me.updateElement(point, index, reset);
						});
					},

					/**
      * @protected
      */
					updateElement: function updateElement(point, index, reset) {
						var me = this;
						var meta = me.getMeta();
						var custom = point.custom || {};
						var xScale = me.getScaleForId(meta.xAxisID);
						var yScale = me.getScaleForId(meta.yAxisID);
						var options = me._resolveElementOptions(point, index);
						var data = me.getDataset().data[index];
						var dsIndex = me.index;

						var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue((typeof data === "undefined" ? "undefined" : _typeof(data)) === 'object' ? data : NaN, index, dsIndex);
						var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

						point._xScale = xScale;
						point._yScale = yScale;
						point._options = options;
						point._datasetIndex = dsIndex;
						point._index = index;
						point._model = {
							backgroundColor: options.backgroundColor,
							borderColor: options.borderColor,
							borderWidth: options.borderWidth,
							hitRadius: options.hitRadius,
							pointStyle: options.pointStyle,
							radius: reset ? 0 : options.radius,
							skip: custom.skip || isNaN(x) || isNaN(y),
							x: x,
							y: y
						};

						point.pivot();
					},

					/**
      * @protected
      */
					setHoverStyle: function setHoverStyle(point) {
						var model = point._model;
						var options = point._options;

						model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
						model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
						model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
						model.radius = options.radius + options.hoverRadius;
					},

					/**
      * @protected
      */
					removeHoverStyle: function removeHoverStyle(point) {
						var model = point._model;
						var options = point._options;

						model.backgroundColor = options.backgroundColor;
						model.borderColor = options.borderColor;
						model.borderWidth = options.borderWidth;
						model.radius = options.radius;
					},

					/**
      * @private
      */
					_resolveElementOptions: function _resolveElementOptions(point, index) {
						var me = this;
						var chart = me.chart;
						var datasets = chart.data.datasets;
						var dataset = datasets[me.index];
						var custom = point.custom || {};
						var options = chart.options.elements.point;
						var resolve = helpers.options.resolve;
						var data = dataset.data[index];
						var values = {};
						var i, ilen, key;

						// Scriptable options
						var context = {
							chart: chart,
							dataIndex: index,
							dataset: dataset,
							datasetIndex: me.index
						};

						var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle'];

						for (i = 0, ilen = keys.length; i < ilen; ++i) {
							key = keys[i];
							values[key] = resolve([custom[key], dataset[key], options[key]], context, index);
						}

						// Custom radius resolution
						values.radius = resolve([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);

						return values;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 17: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('doughnut', {
				animation: {
					// Boolean - Whether we animate the rotation of the Doughnut
					animateRotate: true,
					// Boolean - Whether we animate scaling the Doughnut from the centre
					animateScale: false
				},
				hover: {
					mode: 'single'
				},
				legendCallback: function legendCallback(chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');

					var data = chart.data;
					var datasets = data.datasets;
					var labels = data.labels;

					if (datasets.length) {
						for (var i = 0; i < datasets[0].data.length; ++i) {
							text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
							if (labels[i]) {
								text.push(labels[i]);
							}
							text.push('</li>');
						}
					}

					text.push('</ul>');
					return text.join('');
				},
				legend: {
					labels: {
						generateLabels: function generateLabels(chart) {
							var data = chart.data;
							if (data.labels.length && data.datasets.length) {
								return data.labels.map(function (label, i) {
									var meta = chart.getDatasetMeta(0);
									var ds = data.datasets[0];
									var arc = meta.data[i];
									var custom = arc && arc.custom || {};
									var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
									var arcOpts = chart.options.elements.arc;
									var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
									var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
									var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

									return {
										text: label,
										fillStyle: fill,
										strokeStyle: stroke,
										lineWidth: bw,
										hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

										// Extra data used for toggling the correct item
										index: i
									};
								});
							}
							return [];
						}
					},

					onClick: function onClick(e, legendItem) {
						var index = legendItem.index;
						var chart = this.chart;
						var i, ilen, meta;

						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							// toggle visibility of index if exists
							if (meta.data[index]) {
								meta.data[index].hidden = !meta.data[index].hidden;
							}
						}

						chart.update();
					}
				},

				// The percentage of the chart that we cut out of the middle.
				cutoutPercentage: 50,

				// The rotation of the chart, where the first data arc begins.
				rotation: Math.PI * -0.5,

				// The total circumference of the chart.
				circumference: Math.PI * 2.0,

				// Need to override these to give a nice default
				tooltips: {
					callbacks: {
						title: function title() {
							return '';
						},
						label: function label(tooltipItem, data) {
							var dataLabel = data.labels[tooltipItem.index];
							var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

							if (helpers.isArray(dataLabel)) {
								// show value on first line of multiline label
								// need to clone because we are changing the value
								dataLabel = dataLabel.slice();
								dataLabel[0] += value;
							} else {
								dataLabel += value;
							}

							return dataLabel;
						}
					}
				}
			});

			defaults._set('pie', helpers.clone(defaults.doughnut));
			defaults._set('pie', {
				cutoutPercentage: 0
			});

			module.exports = function (Chart) {

				Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

					dataElementType: elements.Arc,

					linkScales: helpers.noop,

					// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
					getRingIndex: function getRingIndex(datasetIndex) {
						var ringIndex = 0;

						for (var j = 0; j < datasetIndex; ++j) {
							if (this.chart.isDatasetVisible(j)) {
								++ringIndex;
							}
						}

						return ringIndex;
					},

					update: function update(reset) {
						var me = this;
						var chart = me.chart;
						var chartArea = chart.chartArea;
						var opts = chart.options;
						var arcOpts = opts.elements.arc;
						var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
						var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
						var minSize = Math.min(availableWidth, availableHeight);
						var offset = { x: 0, y: 0 };
						var meta = me.getMeta();
						var cutoutPercentage = opts.cutoutPercentage;
						var circumference = opts.circumference;

						// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
						if (circumference < Math.PI * 2.0) {
							var startAngle = opts.rotation % (Math.PI * 2.0);
							startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
							var endAngle = startAngle + circumference;
							var start = { x: Math.cos(startAngle), y: Math.sin(startAngle) };
							var end = { x: Math.cos(endAngle), y: Math.sin(endAngle) };
							var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
							var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
							var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
							var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
							var cutout = cutoutPercentage / 100.0;
							var min = { x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout)) };
							var max = { x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout)) };
							var size = { width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5 };
							minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
							offset = { x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5 };
						}

						chart.borderWidth = me.getMaxBorderWidth(meta.data);
						chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
						chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
						chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
						chart.offsetX = offset.x * chart.outerRadius;
						chart.offsetY = offset.y * chart.outerRadius;

						meta.total = me.calculateTotal();

						me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
						me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

						helpers.each(meta.data, function (arc, index) {
							me.updateElement(arc, index, reset);
						});
					},

					updateElement: function updateElement(arc, index, reset) {
						var me = this;
						var chart = me.chart;
						var chartArea = chart.chartArea;
						var opts = chart.options;
						var animationOpts = opts.animation;
						var centerX = (chartArea.left + chartArea.right) / 2;
						var centerY = (chartArea.top + chartArea.bottom) / 2;
						var startAngle = opts.rotation; // non reset case handled later
						var endAngle = opts.rotation; // non reset case handled later
						var dataset = me.getDataset();
						var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
						var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
						var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

						helpers.extend(arc, {
							// Utility
							_datasetIndex: me.index,
							_index: index,

							// Desired view properties
							_model: {
								x: centerX + chart.offsetX,
								y: centerY + chart.offsetY,
								startAngle: startAngle,
								endAngle: endAngle,
								circumference: circumference,
								outerRadius: outerRadius,
								innerRadius: innerRadius,
								label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
							}
						});

						var model = arc._model;
						// Resets the visual styles
						this.removeHoverStyle(arc);

						// Set correct angles if not resetting
						if (!reset || !animationOpts.animateRotate) {
							if (index === 0) {
								model.startAngle = opts.rotation;
							} else {
								model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
							}

							model.endAngle = model.startAngle + model.circumference;
						}

						arc.pivot();
					},

					removeHoverStyle: function removeHoverStyle(arc) {
						Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
					},

					calculateTotal: function calculateTotal() {
						var dataset = this.getDataset();
						var meta = this.getMeta();
						var total = 0;
						var value;

						helpers.each(meta.data, function (element, index) {
							value = dataset.data[index];
							if (!isNaN(value) && !element.hidden) {
								total += Math.abs(value);
							}
						});

						/* if (total === 0) {
      	total = NaN;
      }*/

						return total;
					},

					calculateCircumference: function calculateCircumference(value) {
						var total = this.getMeta().total;
						if (total > 0 && !isNaN(value)) {
							return Math.PI * 2.0 * (value / total);
						}
						return 0;
					},

					// gets the max border or hover width to properly scale pie charts
					getMaxBorderWidth: function getMaxBorderWidth(arcs) {
						var max = 0;
						var index = this.index;
						var length = arcs.length;
						var borderWidth;
						var hoverWidth;

						for (var i = 0; i < length; i++) {
							borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
							hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

							max = borderWidth > max ? borderWidth : max;
							max = hoverWidth > max ? hoverWidth : max;
						}
						return max;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 18: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('line', {
				showLines: true,
				spanGaps: false,

				hover: {
					mode: 'label'
				},

				scales: {
					xAxes: [{
						type: 'category',
						id: 'x-axis-0'
					}],
					yAxes: [{
						type: 'linear',
						id: 'y-axis-0'
					}]
				}
			});

			module.exports = function (Chart) {

				function lineEnabled(dataset, options) {
					return helpers.valueOrDefault(dataset.showLine, options.showLines);
				}

				Chart.controllers.line = Chart.DatasetController.extend({

					datasetElementType: elements.Line,

					dataElementType: elements.Point,

					update: function update(reset) {
						var me = this;
						var meta = me.getMeta();
						var line = meta.dataset;
						var points = meta.data || [];
						var options = me.chart.options;
						var lineElementOptions = options.elements.line;
						var scale = me.getScaleForId(meta.yAxisID);
						var i, ilen, custom;
						var dataset = me.getDataset();
						var showLine = lineEnabled(dataset, options);

						// Update Line
						if (showLine) {
							custom = line.custom || {};

							// Compatibility: If the properties are defined with only the old name, use those values
							if (dataset.tension !== undefined && dataset.lineTension === undefined) {
								dataset.lineTension = dataset.tension;
							}

							// Utility
							line._scale = scale;
							line._datasetIndex = me.index;
							// Data
							line._children = points;
							// Model
							line._model = {
								// Appearance
								// The default behavior of lines is to break at null values, according
								// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
								// This option gives lines the ability to span gaps
								spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
								tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
								backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
								borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
								borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
								borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
								borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
								borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
								borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
								fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
								steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
								cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)
							};

							line.pivot();
						}

						// Update Points
						for (i = 0, ilen = points.length; i < ilen; ++i) {
							me.updateElement(points[i], i, reset);
						}

						if (showLine && line._model.tension !== 0) {
							me.updateBezierControlPoints();
						}

						// Now pivot the point for animation
						for (i = 0, ilen = points.length; i < ilen; ++i) {
							points[i].pivot();
						}
					},

					getPointBackgroundColor: function getPointBackgroundColor(point, index) {
						var backgroundColor = this.chart.options.elements.point.backgroundColor;
						var dataset = this.getDataset();
						var custom = point.custom || {};

						if (custom.backgroundColor) {
							backgroundColor = custom.backgroundColor;
						} else if (dataset.pointBackgroundColor) {
							backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
						} else if (dataset.backgroundColor) {
							backgroundColor = dataset.backgroundColor;
						}

						return backgroundColor;
					},

					getPointBorderColor: function getPointBorderColor(point, index) {
						var borderColor = this.chart.options.elements.point.borderColor;
						var dataset = this.getDataset();
						var custom = point.custom || {};

						if (custom.borderColor) {
							borderColor = custom.borderColor;
						} else if (dataset.pointBorderColor) {
							borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
						} else if (dataset.borderColor) {
							borderColor = dataset.borderColor;
						}

						return borderColor;
					},

					getPointBorderWidth: function getPointBorderWidth(point, index) {
						var borderWidth = this.chart.options.elements.point.borderWidth;
						var dataset = this.getDataset();
						var custom = point.custom || {};

						if (!isNaN(custom.borderWidth)) {
							borderWidth = custom.borderWidth;
						} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
							borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
						} else if (!isNaN(dataset.borderWidth)) {
							borderWidth = dataset.borderWidth;
						}

						return borderWidth;
					},

					updateElement: function updateElement(point, index, reset) {
						var me = this;
						var meta = me.getMeta();
						var custom = point.custom || {};
						var dataset = me.getDataset();
						var datasetIndex = me.index;
						var value = dataset.data[index];
						var yScale = me.getScaleForId(meta.yAxisID);
						var xScale = me.getScaleForId(meta.xAxisID);
						var pointOptions = me.chart.options.elements.point;
						var x, y;

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
							dataset.pointRadius = dataset.radius;
						}
						if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
							dataset.pointHitRadius = dataset.hitRadius;
						}

						x = xScale.getPixelForValue((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' ? value : NaN, index, datasetIndex);
						y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

						// Utility
						point._xScale = xScale;
						point._yScale = yScale;
						point._datasetIndex = datasetIndex;
						point._index = index;

						// Desired view properties
						point._model = {
							x: x,
							y: y,
							skip: custom.skip || isNaN(x) || isNaN(y),
							// Appearance
							radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
							pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
							backgroundColor: me.getPointBackgroundColor(point, index),
							borderColor: me.getPointBorderColor(point, index),
							borderWidth: me.getPointBorderWidth(point, index),
							tension: meta.dataset._model ? meta.dataset._model.tension : 0,
							steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
							// Tooltip
							hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
						};
					},

					calculatePointY: function calculatePointY(value, index, datasetIndex) {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var yScale = me.getScaleForId(meta.yAxisID);
						var sumPos = 0;
						var sumNeg = 0;
						var i, ds, dsMeta;

						if (yScale.options.stacked) {
							for (i = 0; i < datasetIndex; i++) {
								ds = chart.data.datasets[i];
								dsMeta = chart.getDatasetMeta(i);
								if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
									var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
									if (stackedRightValue < 0) {
										sumNeg += stackedRightValue || 0;
									} else {
										sumPos += stackedRightValue || 0;
									}
								}
							}

							var rightValue = Number(yScale.getRightValue(value));
							if (rightValue < 0) {
								return yScale.getPixelForValue(sumNeg + rightValue);
							}
							return yScale.getPixelForValue(sumPos + rightValue);
						}

						return yScale.getPixelForValue(value);
					},

					updateBezierControlPoints: function updateBezierControlPoints() {
						var me = this;
						var meta = me.getMeta();
						var area = me.chart.chartArea;
						var points = meta.data || [];
						var i, ilen, point, model, controlPoints;

						// Only consider points that are drawn in case the spanGaps option is used
						if (meta.dataset._model.spanGaps) {
							points = points.filter(function (pt) {
								return !pt._model.skip;
							});
						}

						function capControlPoint(pt, min, max) {
							return Math.max(Math.min(pt, max), min);
						}

						if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
							helpers.splineCurveMonotone(points);
						} else {
							for (i = 0, ilen = points.length; i < ilen; ++i) {
								point = points[i];
								model = point._model;
								controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);
								model.controlPointPreviousX = controlPoints.previous.x;
								model.controlPointPreviousY = controlPoints.previous.y;
								model.controlPointNextX = controlPoints.next.x;
								model.controlPointNextY = controlPoints.next.y;
							}
						}

						if (me.chart.options.elements.line.capBezierPoints) {
							for (i = 0, ilen = points.length; i < ilen; ++i) {
								model = points[i]._model;
								model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
								model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
								model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
								model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
							}
						}
					},

					draw: function draw() {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var points = meta.data || [];
						var area = chart.chartArea;
						var ilen = points.length;
						var i = 0;

						helpers.canvas.clipArea(chart.ctx, area);

						if (lineEnabled(me.getDataset(), chart.options)) {
							meta.dataset.draw();
						}

						helpers.canvas.unclipArea(chart.ctx);

						// Draw the points
						for (; i < ilen; ++i) {
							points[i].draw(area);
						}
					},

					setHoverStyle: function setHoverStyle(point) {
						// Point
						var dataset = this.chart.data.datasets[point._datasetIndex];
						var index = point._index;
						var custom = point.custom || {};
						var model = point._model;

						model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
						model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
					},

					removeHoverStyle: function removeHoverStyle(point) {
						var me = this;
						var dataset = me.chart.data.datasets[point._datasetIndex];
						var index = point._index;
						var custom = point.custom || {};
						var model = point._model;

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
							dataset.pointRadius = dataset.radius;
						}

						model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
						model.backgroundColor = me.getPointBackgroundColor(point, index);
						model.borderColor = me.getPointBorderColor(point, index);
						model.borderWidth = me.getPointBorderWidth(point, index);
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 19: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('polarArea', {
				scale: {
					type: 'radialLinear',
					angleLines: {
						display: false
					},
					gridLines: {
						circular: true
					},
					pointLabels: {
						display: false
					},
					ticks: {
						beginAtZero: true
					}
				},

				// Boolean - Whether to animate the rotation of the chart
				animation: {
					animateRotate: true,
					animateScale: true
				},

				startAngle: -0.5 * Math.PI,
				legendCallback: function legendCallback(chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');

					var data = chart.data;
					var datasets = data.datasets;
					var labels = data.labels;

					if (datasets.length) {
						for (var i = 0; i < datasets[0].data.length; ++i) {
							text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
							if (labels[i]) {
								text.push(labels[i]);
							}
							text.push('</li>');
						}
					}

					text.push('</ul>');
					return text.join('');
				},
				legend: {
					labels: {
						generateLabels: function generateLabels(chart) {
							var data = chart.data;
							if (data.labels.length && data.datasets.length) {
								return data.labels.map(function (label, i) {
									var meta = chart.getDatasetMeta(0);
									var ds = data.datasets[0];
									var arc = meta.data[i];
									var custom = arc.custom || {};
									var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
									var arcOpts = chart.options.elements.arc;
									var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
									var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
									var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

									return {
										text: label,
										fillStyle: fill,
										strokeStyle: stroke,
										lineWidth: bw,
										hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

										// Extra data used for toggling the correct item
										index: i
									};
								});
							}
							return [];
						}
					},

					onClick: function onClick(e, legendItem) {
						var index = legendItem.index;
						var chart = this.chart;
						var i, ilen, meta;

						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							meta.data[index].hidden = !meta.data[index].hidden;
						}

						chart.update();
					}
				},

				// Need to override these to give a nice default
				tooltips: {
					callbacks: {
						title: function title() {
							return '';
						},
						label: function label(item, data) {
							return data.labels[item.index] + ': ' + item.yLabel;
						}
					}
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.polarArea = Chart.DatasetController.extend({

					dataElementType: elements.Arc,

					linkScales: helpers.noop,

					update: function update(reset) {
						var me = this;
						var chart = me.chart;
						var chartArea = chart.chartArea;
						var meta = me.getMeta();
						var opts = chart.options;
						var arcOpts = opts.elements.arc;
						var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
						chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
						chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
						chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

						me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
						me.innerRadius = me.outerRadius - chart.radiusLength;

						meta.count = me.countVisibleElements();

						helpers.each(meta.data, function (arc, index) {
							me.updateElement(arc, index, reset);
						});
					},

					updateElement: function updateElement(arc, index, reset) {
						var me = this;
						var chart = me.chart;
						var dataset = me.getDataset();
						var opts = chart.options;
						var animationOpts = opts.animation;
						var scale = chart.scale;
						var labels = chart.data.labels;

						var circumference = me.calculateCircumference(dataset.data[index]);
						var centerX = scale.xCenter;
						var centerY = scale.yCenter;

						// If there is NaN data before us, we need to calculate the starting angle correctly.
						// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
						var visibleCount = 0;
						var meta = me.getMeta();
						for (var i = 0; i < index; ++i) {
							if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
								++visibleCount;
							}
						}

						// var negHalfPI = -0.5 * Math.PI;
						var datasetStartAngle = opts.startAngle;
						var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
						var startAngle = datasetStartAngle + circumference * visibleCount;
						var endAngle = startAngle + (arc.hidden ? 0 : circumference);

						var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

						helpers.extend(arc, {
							// Utility
							_datasetIndex: me.index,
							_index: index,
							_scale: scale,

							// Desired view properties
							_model: {
								x: centerX,
								y: centerY,
								innerRadius: 0,
								outerRadius: reset ? resetRadius : distance,
								startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
								endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
								label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
							}
						});

						// Apply border and fill style
						me.removeHoverStyle(arc);

						arc.pivot();
					},

					removeHoverStyle: function removeHoverStyle(arc) {
						Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
					},

					countVisibleElements: function countVisibleElements() {
						var dataset = this.getDataset();
						var meta = this.getMeta();
						var count = 0;

						helpers.each(meta.data, function (element, index) {
							if (!isNaN(dataset.data[index]) && !element.hidden) {
								count++;
							}
						});

						return count;
					},

					calculateCircumference: function calculateCircumference(value) {
						var count = this.getMeta().count;
						if (count > 0 && !isNaN(value)) {
							return 2 * Math.PI / count;
						}
						return 0;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 20: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('radar', {
				scale: {
					type: 'radialLinear'
				},
				elements: {
					line: {
						tension: 0 // no bezier in radar
					}
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.radar = Chart.DatasetController.extend({

					datasetElementType: elements.Line,

					dataElementType: elements.Point,

					linkScales: helpers.noop,

					update: function update(reset) {
						var me = this;
						var meta = me.getMeta();
						var line = meta.dataset;
						var points = meta.data;
						var custom = line.custom || {};
						var dataset = me.getDataset();
						var lineElementOptions = me.chart.options.elements.line;
						var scale = me.chart.scale;

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.tension !== undefined && dataset.lineTension === undefined) {
							dataset.lineTension = dataset.tension;
						}

						helpers.extend(meta.dataset, {
							// Utility
							_datasetIndex: me.index,
							_scale: scale,
							// Data
							_children: points,
							_loop: true,
							// Model
							_model: {
								// Appearance
								tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
								backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
								borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
								borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
								fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
								borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
								borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
								borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
								borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle
							}
						});

						meta.dataset.pivot();

						// Update Points
						helpers.each(points, function (point, index) {
							me.updateElement(point, index, reset);
						}, me);

						// Update bezier control points
						me.updateBezierControlPoints();
					},
					updateElement: function updateElement(point, index, reset) {
						var me = this;
						var custom = point.custom || {};
						var dataset = me.getDataset();
						var scale = me.chart.scale;
						var pointElementOptions = me.chart.options.elements.point;
						var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
							dataset.pointRadius = dataset.radius;
						}
						if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
							dataset.pointHitRadius = dataset.hitRadius;
						}

						helpers.extend(point, {
							// Utility
							_datasetIndex: me.index,
							_index: index,
							_scale: scale,

							// Desired view properties
							_model: {
								x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
								y: reset ? scale.yCenter : pointPosition.y,

								// Appearance
								tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
								radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
								backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
								borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
								borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
								pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

								// Tooltip
								hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
							}
						});

						point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);
					},
					updateBezierControlPoints: function updateBezierControlPoints() {
						var chartArea = this.chart.chartArea;
						var meta = this.getMeta();

						helpers.each(meta.data, function (point, index) {
							var model = point._model;
							var controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension);

							// Prevent the bezier going outside of the bounds of the graph
							model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
							model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

							model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
							model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

							// Now pivot the point for animation
							point.pivot();
						});
					},

					setHoverStyle: function setHoverStyle(point) {
						// Point
						var dataset = this.chart.data.datasets[point._datasetIndex];
						var custom = point.custom || {};
						var index = point._index;
						var model = point._model;

						model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
						model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
					},

					removeHoverStyle: function removeHoverStyle(point) {
						var dataset = this.chart.data.datasets[point._datasetIndex];
						var custom = point.custom || {};
						var index = point._index;
						var model = point._model;
						var pointElementOptions = this.chart.options.elements.point;

						model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
						model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
						model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
						model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 21: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);

			defaults._set('scatter', {
				hover: {
					mode: 'single'
				},

				scales: {
					xAxes: [{
						id: 'x-axis-1', // need an ID so datasets can reference the scale
						type: 'linear', // scatter should not use a category axis
						position: 'bottom'
					}],
					yAxes: [{
						id: 'y-axis-1',
						type: 'linear',
						position: 'left'
					}]
				},

				showLines: false,

				tooltips: {
					callbacks: {
						title: function title() {
							return ''; // doesn't make sense for scatter since data are formatted as a point
						},
						label: function label(item) {
							return '(' + item.xLabel + ', ' + item.yLabel + ')';
						}
					}
				}
			});

			module.exports = function (Chart) {

				// Scatter charts use line controllers
				Chart.controllers.scatter = Chart.controllers.line;
			};
		}, { "25": 25 }], 22: [function (require, module, exports) {
			/* global window: false */
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				animation: {
					duration: 1000,
					easing: 'easeOutQuart',
					onProgress: helpers.noop,
					onComplete: helpers.noop
				}
			});

			module.exports = function (Chart) {

				Chart.Animation = Element.extend({
					chart: null, // the animation associated chart instance
					currentStep: 0, // the current animation step
					numSteps: 60, // default number of steps
					easing: '', // the easing to use for this animation
					render: null, // render function used by the animation service

					onAnimationProgress: null, // user specified callback to fire on each step of the animation
					onAnimationComplete: null // user specified callback to fire when the animation finishes
				});

				Chart.animationService = {
					frameDuration: 17,
					animations: [],
					dropFrames: 0,
					request: null,

					/**
      * @param {Chart} chart - The chart to animate.
      * @param {Chart.Animation} animation - The animation that we will animate.
      * @param {Number} duration - The animation duration in ms.
      * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
      */
					addAnimation: function addAnimation(chart, animation, duration, lazy) {
						var animations = this.animations;
						var i, ilen;

						animation.chart = chart;

						if (!lazy) {
							chart.animating = true;
						}

						for (i = 0, ilen = animations.length; i < ilen; ++i) {
							if (animations[i].chart === chart) {
								animations[i] = animation;
								return;
							}
						}

						animations.push(animation);

						// If there are no animations queued, manually kickstart a digest, for lack of a better word
						if (animations.length === 1) {
							this.requestAnimationFrame();
						}
					},

					cancelAnimation: function cancelAnimation(chart) {
						var index = helpers.findIndex(this.animations, function (animation) {
							return animation.chart === chart;
						});

						if (index !== -1) {
							this.animations.splice(index, 1);
							chart.animating = false;
						}
					},

					requestAnimationFrame: function requestAnimationFrame() {
						var me = this;
						if (me.request === null) {
							// Skip animation frame requests until the active one is executed.
							// This can happen when processing mouse events, e.g. 'mousemove'
							// and 'mouseout' events will trigger multiple renders.
							me.request = helpers.requestAnimFrame.call(window, function () {
								me.request = null;
								me.startDigest();
							});
						}
					},

					/**
      * @private
      */
					startDigest: function startDigest() {
						var me = this;
						var startTime = Date.now();
						var framesToDrop = 0;

						if (me.dropFrames > 1) {
							framesToDrop = Math.floor(me.dropFrames);
							me.dropFrames = me.dropFrames % 1;
						}

						me.advance(1 + framesToDrop);

						var endTime = Date.now();

						me.dropFrames += (endTime - startTime) / me.frameDuration;

						// Do we have more stuff to animate?
						if (me.animations.length > 0) {
							me.requestAnimationFrame();
						}
					},

					/**
      * @private
      */
					advance: function advance(count) {
						var animations = this.animations;
						var animation, chart;
						var i = 0;

						while (i < animations.length) {
							animation = animations[i];
							chart = animation.chart;

							animation.currentStep = (animation.currentStep || 0) + count;
							animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

							helpers.callback(animation.render, [chart, animation], chart);
							helpers.callback(animation.onAnimationProgress, [animation], chart);

							if (animation.currentStep >= animation.numSteps) {
								helpers.callback(animation.onAnimationComplete, [animation], chart);
								chart.animating = false;
								animations.splice(i, 1);
							} else {
								++i;
							}
						}
					}
				};

				/**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */
				Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
					get: function get() {
						return this;
					}
				});

				/**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */
				Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
					get: function get() {
						return this.chart;
					},
					set: function set(value) {
						this.chart = value;
					}
				});
			};
		}, { "25": 25, "26": 26, "45": 45 }], 23: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);
			var Interaction = require(28);
			var platform = require(48);

			module.exports = function (Chart) {
				var plugins = Chart.plugins;

				// Create a dictionary of chart types, to allow for extension of existing types
				Chart.types = {};

				// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
				// Destroy method on the chart will remove the instance of the chart from this reference.
				Chart.instances = {};

				// Controllers available for dataset visualization eg. bar, line, slice, etc.
				Chart.controllers = {};

				/**
     * Initializes the given config with global and chart default values.
     */
				function initConfig(config) {
					config = config || {};

					// Do NOT use configMerge() for the data object because this method merges arrays
					// and so would change references to labels and datasets, preventing data updates.
					var data = config.data = config.data || {};
					data.datasets = data.datasets || [];
					data.labels = data.labels || [];

					config.options = helpers.configMerge(defaults.global, defaults[config.type], config.options || {});

					return config;
				}

				/**
     * Updates the config of the chart
     * @param chart {Chart} chart to update the options for
     */
				function updateConfig(chart) {
					var newOptions = chart.options;

					// Update Scale(s) with options
					if (newOptions.scale) {
						chart.scale.options = newOptions.scale;
					} else if (newOptions.scales) {
						newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {
							chart.scales[scaleOptions.id].options = scaleOptions;
						});
					}

					// Tooltip
					chart.tooltip._options = newOptions.tooltips;
				}

				function positionIsHorizontal(position) {
					return position === 'top' || position === 'bottom';
				}

				helpers.extend(Chart.prototype, /** @lends Chart */{
					/**
      * @private
      */
					construct: function construct(item, config) {
						var me = this;

						config = initConfig(config);

						var context = platform.acquireContext(item, config);
						var canvas = context && context.canvas;
						var height = canvas && canvas.height;
						var width = canvas && canvas.width;

						me.id = helpers.uid();
						me.ctx = context;
						me.canvas = canvas;
						me.config = config;
						me.width = width;
						me.height = height;
						me.aspectRatio = height ? width / height : null;
						me.options = config.options;
						me._bufferedRender = false;

						/**
       * Provided for backward compatibility, Chart and Chart.Controller have been merged,
       * the "instance" still need to be defined since it might be called from plugins.
       * @prop Chart#chart
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */
						me.chart = me;
						me.controller = me; // chart.chart.controller #inception

						// Add the chart instance to the global namespace
						Chart.instances[me.id] = me;

						// Define alias to the config data: `chart.data === chart.config.data`
						Object.defineProperty(me, 'data', {
							get: function get() {
								return me.config.data;
							},
							set: function set(value) {
								me.config.data = value;
							}
						});

						if (!context || !canvas) {
							// The given item is not a compatible context2d element, let's return before finalizing
							// the chart initialization but after setting basic chart / controller properties that
							// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
							// https://github.com/chartjs/Chart.js/issues/2807
							console.error("Failed to create chart: can't acquire context from the given item");
							return;
						}

						me.initialize();
						me.update();
					},

					/**
      * @private
      */
					initialize: function initialize() {
						var me = this;

						// Before init plugin notification
						plugins.notify(me, 'beforeInit');

						helpers.retinaScale(me, me.options.devicePixelRatio);

						me.bindEvents();

						if (me.options.responsive) {
							// Initial resize before chart draws (must be silent to preserve initial animations).
							me.resize(true);
						}

						// Make sure scales have IDs and are built before we build any controllers.
						me.ensureScalesHaveIDs();
						me.buildScales();
						me.initToolTip();

						// After init plugin notification
						plugins.notify(me, 'afterInit');

						return me;
					},

					clear: function clear() {
						helpers.canvas.clear(this);
						return this;
					},

					stop: function stop() {
						// Stops any current animation loop occurring
						Chart.animationService.cancelAnimation(this);
						return this;
					},

					resize: function resize(silent) {
						var me = this;
						var options = me.options;
						var canvas = me.canvas;
						var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;

						// the canvas render width and height will be casted to integers so make sure that
						// the canvas display style uses the same integer values to avoid blurring effect.

						// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased
						var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
						var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

						if (me.width === newWidth && me.height === newHeight) {
							return;
						}

						canvas.width = me.width = newWidth;
						canvas.height = me.height = newHeight;
						canvas.style.width = newWidth + 'px';
						canvas.style.height = newHeight + 'px';

						helpers.retinaScale(me, options.devicePixelRatio);

						if (!silent) {
							// Notify any plugins about the resize
							var newSize = { width: newWidth, height: newHeight };
							plugins.notify(me, 'resize', [newSize]);

							// Notify of resize
							if (me.options.onResize) {
								me.options.onResize(me, newSize);
							}

							me.stop();
							me.update(me.options.responsiveAnimationDuration);
						}
					},

					ensureScalesHaveIDs: function ensureScalesHaveIDs() {
						var options = this.options;
						var scalesOptions = options.scales || {};
						var scaleOptions = options.scale;

						helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
							xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
						});

						helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
							yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
						});

						if (scaleOptions) {
							scaleOptions.id = scaleOptions.id || 'scale';
						}
					},

					/**
      * Builds a map of scale ID to scale object for future lookup.
      */
					buildScales: function buildScales() {
						var me = this;
						var options = me.options;
						var scales = me.scales = {};
						var items = [];

						if (options.scales) {
							items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
								return { options: xAxisOptions, dtype: 'category', dposition: 'bottom' };
							}), (options.scales.yAxes || []).map(function (yAxisOptions) {
								return { options: yAxisOptions, dtype: 'linear', dposition: 'left' };
							}));
						}

						if (options.scale) {
							items.push({
								options: options.scale,
								dtype: 'radialLinear',
								isDefault: true,
								dposition: 'chartArea'
							});
						}

						helpers.each(items, function (item) {
							var scaleOptions = item.options;
							var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
							var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
							if (!scaleClass) {
								return;
							}

							if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
								scaleOptions.position = item.dposition;
							}

							var scale = new scaleClass({
								id: scaleOptions.id,
								options: scaleOptions,
								ctx: me.ctx,
								chart: me
							});

							scales[scale.id] = scale;
							scale.mergeTicksOptions();

							// TODO(SB): I think we should be able to remove this custom case (options.scale)
							// and consider it as a regular scale part of the "scales"" map only! This would
							// make the logic easier and remove some useless? custom code.
							if (item.isDefault) {
								me.scale = scale;
							}
						});

						Chart.scaleService.addScalesToLayout(this);
					},

					buildOrUpdateControllers: function buildOrUpdateControllers() {
						var me = this;
						var types = [];
						var newControllers = [];

						helpers.each(me.data.datasets, function (dataset, datasetIndex) {
							var meta = me.getDatasetMeta(datasetIndex);
							var type = dataset.type || me.config.type;

							if (meta.type && meta.type !== type) {
								me.destroyDatasetMeta(datasetIndex);
								meta = me.getDatasetMeta(datasetIndex);
							}
							meta.type = type;

							types.push(meta.type);

							if (meta.controller) {
								meta.controller.updateIndex(datasetIndex);
							} else {
								var ControllerClass = Chart.controllers[meta.type];
								if (ControllerClass === undefined) {
									throw new Error('"' + meta.type + '" is not a chart type.');
								}

								meta.controller = new ControllerClass(me, datasetIndex);
								newControllers.push(meta.controller);
							}
						}, me);

						return newControllers;
					},

					/**
      * Reset the elements of all datasets
      * @private
      */
					resetElements: function resetElements() {
						var me = this;
						helpers.each(me.data.datasets, function (dataset, datasetIndex) {
							me.getDatasetMeta(datasetIndex).controller.reset();
						}, me);
					},

					/**
     * Resets the chart back to it's state before the initial animation
     */
					reset: function reset() {
						this.resetElements();
						this.tooltip.initialize();
					},

					update: function update(config) {
						var me = this;

						if (!config || (typeof config === "undefined" ? "undefined" : _typeof(config)) !== 'object') {
							// backwards compatibility
							config = {
								duration: config,
								lazy: arguments[1]
							};
						}

						updateConfig(me);

						if (plugins.notify(me, 'beforeUpdate') === false) {
							return;
						}

						// In case the entire data object changed
						me.tooltip._data = me.data;

						// Make sure dataset controllers are updated and new controllers are reset
						var newControllers = me.buildOrUpdateControllers();

						// Make sure all dataset controllers have correct meta data counts
						helpers.each(me.data.datasets, function (dataset, datasetIndex) {
							me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
						}, me);

						me.updateLayout();

						// Can only reset the new controllers after the scales have been updated
						helpers.each(newControllers, function (controller) {
							controller.reset();
						});

						me.updateDatasets();

						// Do this before render so that any plugins that need final scale updates can use it
						plugins.notify(me, 'afterUpdate');

						if (me._bufferedRender) {
							me._bufferedRequest = {
								duration: config.duration,
								easing: config.easing,
								lazy: config.lazy
							};
						} else {
							me.render(config);
						}
					},

					/**
      * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
      * hook, in which case, plugins will not be called on `afterLayout`.
      * @private
      */
					updateLayout: function updateLayout() {
						var me = this;

						if (plugins.notify(me, 'beforeLayout') === false) {
							return;
						}

						Chart.layoutService.update(this, this.width, this.height);

						/**
       * Provided for backward compatibility, use `afterLayout` instead.
       * @method IPlugin#afterScaleUpdate
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */
						plugins.notify(me, 'afterScaleUpdate');
						plugins.notify(me, 'afterLayout');
					},

					/**
      * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
      * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
      * @private
      */
					updateDatasets: function updateDatasets() {
						var me = this;

						if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
							return;
						}

						for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
							me.updateDataset(i);
						}

						plugins.notify(me, 'afterDatasetsUpdate');
					},

					/**
      * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
      * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
      * @private
      */
					updateDataset: function updateDataset(index) {
						var me = this;
						var meta = me.getDatasetMeta(index);
						var args = {
							meta: meta,
							index: index
						};

						if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
							return;
						}

						meta.controller.update();

						plugins.notify(me, 'afterDatasetUpdate', [args]);
					},

					render: function render(config) {
						var me = this;

						if (!config || (typeof config === "undefined" ? "undefined" : _typeof(config)) !== 'object') {
							// backwards compatibility
							config = {
								duration: config,
								lazy: arguments[1]
							};
						}

						var duration = config.duration;
						var lazy = config.lazy;

						if (plugins.notify(me, 'beforeRender') === false) {
							return;
						}

						var animationOptions = me.options.animation;
						var onComplete = function onComplete(animation) {
							plugins.notify(me, 'afterRender');
							helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
						};

						if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {
							var animation = new Chart.Animation({
								numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
								easing: config.easing || animationOptions.easing,

								render: function render(chart, animationObject) {
									var easingFunction = helpers.easing.effects[animationObject.easing];
									var currentStep = animationObject.currentStep;
									var stepDecimal = currentStep / animationObject.numSteps;

									chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
								},

								onAnimationProgress: animationOptions.onProgress,
								onAnimationComplete: onComplete
							});

							Chart.animationService.addAnimation(me, animation, duration, lazy);
						} else {
							me.draw();

							// See https://github.com/chartjs/Chart.js/issues/3781
							onComplete(new Chart.Animation({ numSteps: 0, chart: me }));
						}

						return me;
					},

					draw: function draw(easingValue) {
						var me = this;

						me.clear();

						if (helpers.isNullOrUndef(easingValue)) {
							easingValue = 1;
						}

						me.transition(easingValue);

						if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
							return;
						}

						// Draw all the scales
						helpers.each(me.boxes, function (box) {
							box.draw(me.chartArea);
						}, me);

						if (me.scale) {
							me.scale.draw();
						}

						me.drawDatasets(easingValue);

						// Finally draw the tooltip
						me.tooltip.draw();

						plugins.notify(me, 'afterDraw', [easingValue]);
					},

					/**
      * @private
      */
					transition: function transition(easingValue) {
						var me = this;

						for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
							if (me.isDatasetVisible(i)) {
								me.getDatasetMeta(i).controller.transition(easingValue);
							}
						}

						me.tooltip.transition(easingValue);
					},

					/**
      * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
      * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
      * @private
      */
					drawDatasets: function drawDatasets(easingValue) {
						var me = this;

						if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
							return;
						}

						// Draw datasets reversed to support proper line stacking
						for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
							if (me.isDatasetVisible(i)) {
								me.drawDataset(i, easingValue);
							}
						}

						plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
					},

					/**
      * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
      * hook, in which case, plugins will not be called on `afterDatasetDraw`.
      * @private
      */
					drawDataset: function drawDataset(index, easingValue) {
						var me = this;
						var meta = me.getDatasetMeta(index);
						var args = {
							meta: meta,
							index: index,
							easingValue: easingValue
						};

						if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
							return;
						}

						meta.controller.draw(easingValue);

						plugins.notify(me, 'afterDatasetDraw', [args]);
					},

					// Get the single element that was clicked on
					// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
					getElementAtEvent: function getElementAtEvent(e) {
						return Interaction.modes.single(this, e);
					},

					getElementsAtEvent: function getElementsAtEvent(e) {
						return Interaction.modes.label(this, e, { intersect: true });
					},

					getElementsAtXAxis: function getElementsAtXAxis(e) {
						return Interaction.modes['x-axis'](this, e, { intersect: true });
					},

					getElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {
						var method = Interaction.modes[mode];
						if (typeof method === 'function') {
							return method(this, e, options);
						}

						return [];
					},

					getDatasetAtEvent: function getDatasetAtEvent(e) {
						return Interaction.modes.dataset(this, e, { intersect: true });
					},

					getDatasetMeta: function getDatasetMeta(datasetIndex) {
						var me = this;
						var dataset = me.data.datasets[datasetIndex];
						if (!dataset._meta) {
							dataset._meta = {};
						}

						var meta = dataset._meta[me.id];
						if (!meta) {
							meta = dataset._meta[me.id] = {
								type: null,
								data: [],
								dataset: null,
								controller: null,
								hidden: null, // See isDatasetVisible() comment
								xAxisID: null,
								yAxisID: null
							};
						}

						return meta;
					},

					getVisibleDatasetCount: function getVisibleDatasetCount() {
						var count = 0;
						for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
							if (this.isDatasetVisible(i)) {
								count++;
							}
						}
						return count;
					},

					isDatasetVisible: function isDatasetVisible(datasetIndex) {
						var meta = this.getDatasetMeta(datasetIndex);

						// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
						// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
						return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
					},

					generateLegend: function generateLegend() {
						return this.options.legendCallback(this);
					},

					/**
      * @private
      */
					destroyDatasetMeta: function destroyDatasetMeta(datasetIndex) {
						var id = this.id;
						var dataset = this.data.datasets[datasetIndex];
						var meta = dataset._meta && dataset._meta[id];

						if (meta) {
							meta.controller.destroy();
							delete dataset._meta[id];
						}
					},

					destroy: function destroy() {
						var me = this;
						var canvas = me.canvas;
						var i, ilen;

						me.stop();

						// dataset controllers need to cleanup associated data
						for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
							me.destroyDatasetMeta(i);
						}

						if (canvas) {
							me.unbindEvents();
							helpers.canvas.clear(me);
							platform.releaseContext(me.ctx);
							me.canvas = null;
							me.ctx = null;
						}

						plugins.notify(me, 'destroy');

						delete Chart.instances[me.id];
					},

					toBase64Image: function toBase64Image() {
						return this.canvas.toDataURL.apply(this.canvas, arguments);
					},

					initToolTip: function initToolTip() {
						var me = this;
						me.tooltip = new Chart.Tooltip({
							_chart: me,
							_chartInstance: me, // deprecated, backward compatibility
							_data: me.data,
							_options: me.options.tooltips
						}, me);
					},

					/**
      * @private
      */
					bindEvents: function bindEvents() {
						var me = this;
						var listeners = me._listeners = {};
						var listener = function listener() {
							me.eventHandler.apply(me, arguments);
						};

						helpers.each(me.options.events, function (type) {
							platform.addEventListener(me, type, listener);
							listeners[type] = listener;
						});

						// Elements used to detect size change should not be injected for non responsive charts.
						// See https://github.com/chartjs/Chart.js/issues/2210
						if (me.options.responsive) {
							listener = function listener() {
								me.resize();
							};

							platform.addEventListener(me, 'resize', listener);
							listeners.resize = listener;
						}
					},

					/**
      * @private
      */
					unbindEvents: function unbindEvents() {
						var me = this;
						var listeners = me._listeners;
						if (!listeners) {
							return;
						}

						delete me._listeners;
						helpers.each(listeners, function (listener, type) {
							platform.removeEventListener(me, type, listener);
						});
					},

					updateHoverStyle: function updateHoverStyle(elements, mode, enabled) {
						var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
						var element, i, ilen;

						for (i = 0, ilen = elements.length; i < ilen; ++i) {
							element = elements[i];
							if (element) {
								this.getDatasetMeta(element._datasetIndex).controller[method](element);
							}
						}
					},

					/**
      * @private
      */
					eventHandler: function eventHandler(e) {
						var me = this;
						var tooltip = me.tooltip;

						if (plugins.notify(me, 'beforeEvent', [e]) === false) {
							return;
						}

						// Buffer any update calls so that renders do not occur
						me._bufferedRender = true;
						me._bufferedRequest = null;

						var changed = me.handleEvent(e);
						changed |= tooltip && tooltip.handleEvent(e);

						plugins.notify(me, 'afterEvent', [e]);

						var bufferedRequest = me._bufferedRequest;
						if (bufferedRequest) {
							// If we have an update that was triggered, we need to do a normal render
							me.render(bufferedRequest);
						} else if (changed && !me.animating) {
							// If entering, leaving, or changing elements, animate the change via pivot
							me.stop();

							// We only need to render at this point. Updating will cause scales to be
							// recomputed generating flicker & using more memory than necessary.
							me.render(me.options.hover.animationDuration, true);
						}

						me._bufferedRender = false;
						me._bufferedRequest = null;

						return me;
					},

					/**
      * Handle an event
      * @private
      * @param {IEvent} event the event to handle
      * @return {Boolean} true if the chart needs to re-render
      */
					handleEvent: function handleEvent(e) {
						var me = this;
						var options = me.options || {};
						var hoverOptions = options.hover;
						var changed = false;

						me.lastActive = me.lastActive || [];

						// Find Active Elements for hover and tooltips
						if (e.type === 'mouseout') {
							me.active = [];
						} else {
							me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
						}

						// Invoke onHover hook
						// Need to call with native event here to not break backwards compatibility
						helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

						if (e.type === 'mouseup' || e.type === 'click') {
							if (options.onClick) {
								// Use e.native here for backwards compatibility
								options.onClick.call(me, e.native, me.active);
							}
						}

						// Remove styling for last active (even if it may still be active)
						if (me.lastActive.length) {
							me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
						}

						// Built in hover styling
						if (me.active.length && hoverOptions.mode) {
							me.updateHoverStyle(me.active, hoverOptions.mode, true);
						}

						changed = !helpers.arrayEquals(me.active, me.lastActive);

						// Remember Last Actives
						me.lastActive = me.active;

						return changed;
					}
				});

				/**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */
				Chart.Controller = Chart;
			};
		}, { "25": 25, "28": 28, "45": 45, "48": 48 }], 24: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			module.exports = function (Chart) {

				var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

				/**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */
				function listenArrayEvents(array, listener) {
					if (array._chartjs) {
						array._chartjs.listeners.push(listener);
						return;
					}

					Object.defineProperty(array, '_chartjs', {
						configurable: true,
						enumerable: false,
						value: {
							listeners: [listener]
						}
					});

					arrayEvents.forEach(function (key) {
						var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
						var base = array[key];

						Object.defineProperty(array, key, {
							configurable: true,
							enumerable: false,
							value: function value() {
								var args = Array.prototype.slice.call(arguments);
								var res = base.apply(this, args);

								helpers.each(array._chartjs.listeners, function (object) {
									if (typeof object[method] === 'function') {
										object[method].apply(object, args);
									}
								});

								return res;
							}
						});
					});
				}

				/**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */
				function unlistenArrayEvents(array, listener) {
					var stub = array._chartjs;
					if (!stub) {
						return;
					}

					var listeners = stub.listeners;
					var index = listeners.indexOf(listener);
					if (index !== -1) {
						listeners.splice(index, 1);
					}

					if (listeners.length > 0) {
						return;
					}

					arrayEvents.forEach(function (key) {
						delete array[key];
					});

					delete array._chartjs;
				}

				// Base class for all dataset controllers (line, bar, etc)
				Chart.DatasetController = function (chart, datasetIndex) {
					this.initialize(chart, datasetIndex);
				};

				helpers.extend(Chart.DatasetController.prototype, {

					/**
      * Element type used to generate a meta dataset (e.g. Chart.element.Line).
      * @type {Chart.core.element}
      */
					datasetElementType: null,

					/**
      * Element type used to generate a meta data (e.g. Chart.element.Point).
      * @type {Chart.core.element}
      */
					dataElementType: null,

					initialize: function initialize(chart, datasetIndex) {
						var me = this;
						me.chart = chart;
						me.index = datasetIndex;
						me.linkScales();
						me.addElements();
					},

					updateIndex: function updateIndex(datasetIndex) {
						this.index = datasetIndex;
					},

					linkScales: function linkScales() {
						var me = this;
						var meta = me.getMeta();
						var dataset = me.getDataset();

						if (meta.xAxisID === null) {
							meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
						}
						if (meta.yAxisID === null) {
							meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
						}
					},

					getDataset: function getDataset() {
						return this.chart.data.datasets[this.index];
					},

					getMeta: function getMeta() {
						return this.chart.getDatasetMeta(this.index);
					},

					getScaleForId: function getScaleForId(scaleID) {
						return this.chart.scales[scaleID];
					},

					reset: function reset() {
						this.update(true);
					},

					/**
      * @private
      */
					destroy: function destroy() {
						if (this._data) {
							unlistenArrayEvents(this._data, this);
						}
					},

					createMetaDataset: function createMetaDataset() {
						var me = this;
						var type = me.datasetElementType;
						return type && new type({
							_chart: me.chart,
							_datasetIndex: me.index
						});
					},

					createMetaData: function createMetaData(index) {
						var me = this;
						var type = me.dataElementType;
						return type && new type({
							_chart: me.chart,
							_datasetIndex: me.index,
							_index: index
						});
					},

					addElements: function addElements() {
						var me = this;
						var meta = me.getMeta();
						var data = me.getDataset().data || [];
						var metaData = meta.data;
						var i, ilen;

						for (i = 0, ilen = data.length; i < ilen; ++i) {
							metaData[i] = metaData[i] || me.createMetaData(i);
						}

						meta.dataset = meta.dataset || me.createMetaDataset();
					},

					addElementAndReset: function addElementAndReset(index) {
						var element = this.createMetaData(index);
						this.getMeta().data.splice(index, 0, element);
						this.updateElement(element, index, true);
					},

					buildOrUpdateElements: function buildOrUpdateElements() {
						var me = this;
						var dataset = me.getDataset();
						var data = dataset.data || (dataset.data = []);

						// In order to correctly handle data addition/deletion animation (an thus simulate
						// real-time charts), we need to monitor these data modifications and synchronize
						// the internal meta data accordingly.
						if (me._data !== data) {
							if (me._data) {
								// This case happens when the user replaced the data array instance.
								unlistenArrayEvents(me._data, me);
							}

							listenArrayEvents(data, me);
							me._data = data;
						}

						// Re-sync meta data in case the user replaced the data array or if we missed
						// any updates and so make sure that we handle number of datapoints changing.
						me.resyncElements();
					},

					update: helpers.noop,

					transition: function transition(easingValue) {
						var meta = this.getMeta();
						var elements = meta.data || [];
						var ilen = elements.length;
						var i = 0;

						for (; i < ilen; ++i) {
							elements[i].transition(easingValue);
						}

						if (meta.dataset) {
							meta.dataset.transition(easingValue);
						}
					},

					draw: function draw() {
						var meta = this.getMeta();
						var elements = meta.data || [];
						var ilen = elements.length;
						var i = 0;

						if (meta.dataset) {
							meta.dataset.draw();
						}

						for (; i < ilen; ++i) {
							elements[i].draw();
						}
					},

					removeHoverStyle: function removeHoverStyle(element, elementOpts) {
						var dataset = this.chart.data.datasets[element._datasetIndex];
						var index = element._index;
						var custom = element.custom || {};
						var valueOrDefault = helpers.valueAtIndexOrDefault;
						var model = element._model;

						model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
						model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
						model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
					},

					setHoverStyle: function setHoverStyle(element) {
						var dataset = this.chart.data.datasets[element._datasetIndex];
						var index = element._index;
						var custom = element.custom || {};
						var valueOrDefault = helpers.valueAtIndexOrDefault;
						var getHoverColor = helpers.getHoverColor;
						var model = element._model;

						model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
					},

					/**
      * @private
      */
					resyncElements: function resyncElements() {
						var me = this;
						var meta = me.getMeta();
						var data = me.getDataset().data;
						var numMeta = meta.data.length;
						var numData = data.length;

						if (numData < numMeta) {
							meta.data.splice(numData, numMeta - numData);
						} else if (numData > numMeta) {
							me.insertElements(numMeta, numData - numMeta);
						}
					},

					/**
      * @private
      */
					insertElements: function insertElements(start, count) {
						for (var i = 0; i < count; ++i) {
							this.addElementAndReset(start + i);
						}
					},

					/**
      * @private
      */
					onDataPush: function onDataPush() {
						this.insertElements(this.getDataset().data.length - 1, arguments.length);
					},

					/**
      * @private
      */
					onDataPop: function onDataPop() {
						this.getMeta().data.pop();
					},

					/**
      * @private
      */
					onDataShift: function onDataShift() {
						this.getMeta().data.shift();
					},

					/**
      * @private
      */
					onDataSplice: function onDataSplice(start, count) {
						this.getMeta().data.splice(start, count);
						this.insertElements(start, arguments.length - 2);
					},

					/**
      * @private
      */
					onDataUnshift: function onDataUnshift() {
						this.insertElements(0, arguments.length);
					}
				});

				Chart.DatasetController.extend = helpers.inherits;
			};
		}, { "45": 45 }], 25: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			module.exports = {
				/**
     * @private
     */
				_set: function _set(scope, values) {
					return helpers.merge(this[scope] || (this[scope] = {}), values);
				}
			};
		}, { "45": 45 }], 26: [function (require, module, exports) {
			'use strict';

			var color = require(3);
			var helpers = require(45);

			function interpolate(start, view, model, ease) {
				var keys = Object.keys(model);
				var i, ilen, key, actual, origin, target, type, c0, c1;

				for (i = 0, ilen = keys.length; i < ilen; ++i) {
					key = keys[i];

					target = model[key];

					// if a value is added to the model after pivot() has been called, the view
					// doesn't contain it, so let's initialize the view to the target value.
					if (!view.hasOwnProperty(key)) {
						view[key] = target;
					}

					actual = view[key];

					if (actual === target || key[0] === '_') {
						continue;
					}

					if (!start.hasOwnProperty(key)) {
						start[key] = actual;
					}

					origin = start[key];

					type = typeof target === "undefined" ? "undefined" : _typeof(target);

					if (type === (typeof origin === "undefined" ? "undefined" : _typeof(origin))) {
						if (type === 'string') {
							c0 = color(origin);
							if (c0.valid) {
								c1 = color(target);
								if (c1.valid) {
									view[key] = c1.mix(c0, ease).rgbString();
									continue;
								}
							}
						} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
							view[key] = origin + (target - origin) * ease;
							continue;
						}
					}

					view[key] = target;
				}
			}

			var Element = function Element(configuration) {
				helpers.extend(this, configuration);
				this.initialize.apply(this, arguments);
			};

			helpers.extend(Element.prototype, {

				initialize: function initialize() {
					this.hidden = false;
				},

				pivot: function pivot() {
					var me = this;
					if (!me._view) {
						me._view = helpers.clone(me._model);
					}
					me._start = {};
					return me;
				},

				transition: function transition(ease) {
					var me = this;
					var model = me._model;
					var start = me._start;
					var view = me._view;

					// No animation -> No Transition
					if (!model || ease === 1) {
						me._view = model;
						me._start = null;
						return me;
					}

					if (!view) {
						view = me._view = {};
					}

					if (!start) {
						start = me._start = {};
					}

					interpolate(start, view, model, ease);

					return me;
				},

				tooltipPosition: function tooltipPosition() {
					return {
						x: this._model.x,
						y: this._model.y
					};
				},

				hasValue: function hasValue() {
					return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
				}
			});

			Element.extend = helpers.inherits;

			module.exports = Element;
		}, { "3": 3, "45": 45 }], 27: [function (require, module, exports) {
			/* global window: false */
			/* global document: false */
			'use strict';

			var color = require(3);
			var defaults = require(25);
			var helpers = require(45);

			module.exports = function (Chart) {

				// -- Basic js utility methods

				helpers.extend = function (base) {
					var setFn = function setFn(value, key) {
						base[key] = value;
					};
					for (var i = 1, ilen = arguments.length; i < ilen; i++) {
						helpers.each(arguments[i], setFn);
					}
					return base;
				};

				helpers.configMerge = function () /* objects ... */{
					return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
						merger: function merger(key, target, source, options) {
							var tval = target[key] || {};
							var sval = source[key];

							if (key === 'scales') {
								// scale config merging is complex. Add our own function here for that
								target[key] = helpers.scaleMerge(tval, sval);
							} else if (key === 'scale') {
								// used in polar area & radar charts since there is only one scale
								target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
							} else {
								helpers._merger(key, target, source, options);
							}
						}
					});
				};

				helpers.scaleMerge = function () /* objects ... */{
					return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
						merger: function merger(key, target, source, options) {
							if (key === 'xAxes' || key === 'yAxes') {
								var slen = source[key].length;
								var i, type, scale;

								if (!target[key]) {
									target[key] = [];
								}

								for (i = 0; i < slen; ++i) {
									scale = source[key][i];
									type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

									if (i >= target[key].length) {
										target[key].push({});
									}

									if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
										// new/untyped scale or type changed: let's apply the new defaults
										// then merge source scale to correctly overwrite the defaults.
										helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
									} else {
										// scales type are the same
										helpers.merge(target[key][i], scale);
									}
								}
							} else {
								helpers._merger(key, target, source, options);
							}
						}
					});
				};

				helpers.where = function (collection, filterCallback) {
					if (helpers.isArray(collection) && Array.prototype.filter) {
						return collection.filter(filterCallback);
					}
					var filtered = [];

					helpers.each(collection, function (item) {
						if (filterCallback(item)) {
							filtered.push(item);
						}
					});

					return filtered;
				};
				helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
					return array.findIndex(callback, scope);
				} : function (array, callback, scope) {
					scope = scope === undefined ? array : scope;
					for (var i = 0, ilen = array.length; i < ilen; ++i) {
						if (callback.call(scope, array[i], i, array)) {
							return i;
						}
					}
					return -1;
				};
				helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
					// Default to start of the array
					if (helpers.isNullOrUndef(startIndex)) {
						startIndex = -1;
					}
					for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
						var currentItem = arrayToSearch[i];
						if (filterCallback(currentItem)) {
							return currentItem;
						}
					}
				};
				helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
					// Default to end of the array
					if (helpers.isNullOrUndef(startIndex)) {
						startIndex = arrayToSearch.length;
					}
					for (var i = startIndex - 1; i >= 0; i--) {
						var currentItem = arrayToSearch[i];
						if (filterCallback(currentItem)) {
							return currentItem;
						}
					}
				};
				helpers.inherits = function (extensions) {
					// Basic javascript inheritance based on the model created in Backbone.js
					var me = this;
					var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
						return me.apply(this, arguments);
					};

					var Surrogate = function Surrogate() {
						this.constructor = ChartElement;
					};
					Surrogate.prototype = me.prototype;
					ChartElement.prototype = new Surrogate();

					ChartElement.extend = helpers.inherits;

					if (extensions) {
						helpers.extend(ChartElement.prototype, extensions);
					}

					ChartElement.__super__ = me.prototype;

					return ChartElement;
				};
				// -- Math methods
				helpers.isNumber = function (n) {
					return !isNaN(parseFloat(n)) && isFinite(n);
				};
				helpers.almostEquals = function (x, y, epsilon) {
					return Math.abs(x - y) < epsilon;
				};
				helpers.almostWhole = function (x, epsilon) {
					var rounded = Math.round(x);
					return rounded - epsilon < x && rounded + epsilon > x;
				};
				helpers.max = function (array) {
					return array.reduce(function (max, value) {
						if (!isNaN(value)) {
							return Math.max(max, value);
						}
						return max;
					}, Number.NEGATIVE_INFINITY);
				};
				helpers.min = function (array) {
					return array.reduce(function (min, value) {
						if (!isNaN(value)) {
							return Math.min(min, value);
						}
						return min;
					}, Number.POSITIVE_INFINITY);
				};
				helpers.sign = Math.sign ? function (x) {
					return Math.sign(x);
				} : function (x) {
					x = +x; // convert to a number
					if (x === 0 || isNaN(x)) {
						return x;
					}
					return x > 0 ? 1 : -1;
				};
				helpers.log10 = Math.log10 ? function (x) {
					return Math.log10(x);
				} : function (x) {
					return Math.log(x) / Math.LN10;
				};
				helpers.toRadians = function (degrees) {
					return degrees * (Math.PI / 180);
				};
				helpers.toDegrees = function (radians) {
					return radians * (180 / Math.PI);
				};
				// Gets the angle from vertical upright to the point about a centre.
				helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
					var distanceFromXCenter = anglePoint.x - centrePoint.x;
					var distanceFromYCenter = anglePoint.y - centrePoint.y;
					var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

					var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

					if (angle < -0.5 * Math.PI) {
						angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
					}

					return {
						angle: angle,
						distance: radialDistanceFromCenter
					};
				};
				helpers.distanceBetweenPoints = function (pt1, pt2) {
					return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
				};
				helpers.aliasPixel = function (pixelWidth) {
					return pixelWidth % 2 === 0 ? 0 : 0.5;
				};
				helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
					// Props to Rob Spencer at scaled innovation for his post on splining between points
					// http://scaledinnovation.com/analytics/splines/aboutSplines.html

					// This function must also respect "skipped" points

					var previous = firstPoint.skip ? middlePoint : firstPoint;
					var current = middlePoint;
					var next = afterPoint.skip ? middlePoint : afterPoint;

					var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
					var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

					var s01 = d01 / (d01 + d12);
					var s12 = d12 / (d01 + d12);

					// If all points are the same, s01 & s02 will be inf
					s01 = isNaN(s01) ? 0 : s01;
					s12 = isNaN(s12) ? 0 : s12;

					var fa = t * s01; // scaling factor for triangle Ta
					var fb = t * s12;

					return {
						previous: {
							x: current.x - fa * (next.x - previous.x),
							y: current.y - fa * (next.y - previous.y)
						},
						next: {
							x: current.x + fb * (next.x - previous.x),
							y: current.y + fb * (next.y - previous.y)
						}
					};
				};
				helpers.EPSILON = Number.EPSILON || 1e-14;
				helpers.splineCurveMonotone = function (points) {
					// This function calculates Bézier control points in a similar way than |splineCurve|,
					// but preserves monotonicity of the provided data and ensures no local extremums are added
					// between the dataset discrete points due to the interpolation.
					// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

					var pointsWithTangents = (points || []).map(function (point) {
						return {
							model: point._model,
							deltaK: 0,
							mK: 0
						};
					});

					// Calculate slopes (deltaK) and initialize tangents (mK)
					var pointsLen = pointsWithTangents.length;
					var i, pointBefore, pointCurrent, pointAfter;
					for (i = 0; i < pointsLen; ++i) {
						pointCurrent = pointsWithTangents[i];
						if (pointCurrent.model.skip) {
							continue;
						}

						pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
						pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
						if (pointAfter && !pointAfter.model.skip) {
							var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;

							// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
							pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
						}

						if (!pointBefore || pointBefore.model.skip) {
							pointCurrent.mK = pointCurrent.deltaK;
						} else if (!pointAfter || pointAfter.model.skip) {
							pointCurrent.mK = pointBefore.deltaK;
						} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
							pointCurrent.mK = 0;
						} else {
							pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
						}
					}

					// Adjust tangents to ensure monotonic properties
					var alphaK, betaK, tauK, squaredMagnitude;
					for (i = 0; i < pointsLen - 1; ++i) {
						pointCurrent = pointsWithTangents[i];
						pointAfter = pointsWithTangents[i + 1];
						if (pointCurrent.model.skip || pointAfter.model.skip) {
							continue;
						}

						if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
							pointCurrent.mK = pointAfter.mK = 0;
							continue;
						}

						alphaK = pointCurrent.mK / pointCurrent.deltaK;
						betaK = pointAfter.mK / pointCurrent.deltaK;
						squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
						if (squaredMagnitude <= 9) {
							continue;
						}

						tauK = 3 / Math.sqrt(squaredMagnitude);
						pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
						pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
					}

					// Compute control points
					var deltaX;
					for (i = 0; i < pointsLen; ++i) {
						pointCurrent = pointsWithTangents[i];
						if (pointCurrent.model.skip) {
							continue;
						}

						pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
						pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
						if (pointBefore && !pointBefore.model.skip) {
							deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
							pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
							pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
						}
						if (pointAfter && !pointAfter.model.skip) {
							deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
							pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
							pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
						}
					}
				};
				helpers.nextItem = function (collection, index, loop) {
					if (loop) {
						return index >= collection.length - 1 ? collection[0] : collection[index + 1];
					}
					return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
				};
				helpers.previousItem = function (collection, index, loop) {
					if (loop) {
						return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
					}
					return index <= 0 ? collection[0] : collection[index - 1];
				};
				// Implementation of the nice number algorithm used in determining where axis labels will go
				helpers.niceNum = function (range, round) {
					var exponent = Math.floor(helpers.log10(range));
					var fraction = range / Math.pow(10, exponent);
					var niceFraction;

					if (round) {
						if (fraction < 1.5) {
							niceFraction = 1;
						} else if (fraction < 3) {
							niceFraction = 2;
						} else if (fraction < 7) {
							niceFraction = 5;
						} else {
							niceFraction = 10;
						}
					} else if (fraction <= 1.0) {
						niceFraction = 1;
					} else if (fraction <= 2) {
						niceFraction = 2;
					} else if (fraction <= 5) {
						niceFraction = 5;
					} else {
						niceFraction = 10;
					}

					return niceFraction * Math.pow(10, exponent);
				};
				// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
				helpers.requestAnimFrame = function () {
					if (typeof window === 'undefined') {
						return function (callback) {
							callback();
						};
					}
					return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
						return window.setTimeout(callback, 1000 / 60);
					};
				}();
				// -- DOM methods
				helpers.getRelativePosition = function (evt, chart) {
					var mouseX, mouseY;
					var e = evt.originalEvent || evt;
					var canvas = evt.currentTarget || evt.srcElement;
					var boundingRect = canvas.getBoundingClientRect();

					var touches = e.touches;
					if (touches && touches.length > 0) {
						mouseX = touches[0].clientX;
						mouseY = touches[0].clientY;
					} else {
						mouseX = e.clientX;
						mouseY = e.clientY;
					}

					// Scale mouse coordinates into canvas coordinates
					// by following the pattern laid out by 'jerryj' in the comments of
					// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
					var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
					var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
					var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
					var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
					var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
					var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

					// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
					// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
					mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
					mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);

					return {
						x: mouseX,
						y: mouseY
					};
				};

				// Private helper function to convert max-width/max-height values that may be percentages into a number
				function parseMaxStyle(styleValue, node, parentProperty) {
					var valueInPixels;
					if (typeof styleValue === 'string') {
						valueInPixels = parseInt(styleValue, 10);

						if (styleValue.indexOf('%') !== -1) {
							// percentage * size in dimension
							valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
						}
					} else {
						valueInPixels = styleValue;
					}

					return valueInPixels;
				}

				/**
     * Returns if the given value contains an effective constraint.
     * @private
     */
				function isConstrainedValue(value) {
					return value !== undefined && value !== null && value !== 'none';
				}

				// Private helper to get a constraint dimension
				// @param domNode : the node to check the constraint on
				// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
				// @param percentageProperty : property of parent to use when calculating width as a percentage
				// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
				function getConstraintDimension(domNode, maxStyle, percentageProperty) {
					var view = document.defaultView;
					var parentNode = domNode.parentNode;
					var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
					var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
					var hasCNode = isConstrainedValue(constrainedNode);
					var hasCContainer = isConstrainedValue(constrainedContainer);
					var infinity = Number.POSITIVE_INFINITY;

					if (hasCNode || hasCContainer) {
						return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
					}

					return 'none';
				}
				// returns Number or undefined if no constraint
				helpers.getConstraintWidth = function (domNode) {
					return getConstraintDimension(domNode, 'max-width', 'clientWidth');
				};
				// returns Number or undefined if no constraint
				helpers.getConstraintHeight = function (domNode) {
					return getConstraintDimension(domNode, 'max-height', 'clientHeight');
				};
				helpers.getMaximumWidth = function (domNode) {
					var container = domNode.parentNode;
					if (!container) {
						return domNode.clientWidth;
					}

					var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
					var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
					var w = container.clientWidth - paddingLeft - paddingRight;
					var cw = helpers.getConstraintWidth(domNode);
					return isNaN(cw) ? w : Math.min(w, cw);
				};
				helpers.getMaximumHeight = function (domNode) {
					var container = domNode.parentNode;
					if (!container) {
						return domNode.clientHeight;
					}

					var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
					var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
					var h = container.clientHeight - paddingTop - paddingBottom;
					var ch = helpers.getConstraintHeight(domNode);
					return isNaN(ch) ? h : Math.min(h, ch);
				};
				helpers.getStyle = function (el, property) {
					return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
				};
				helpers.retinaScale = function (chart, forceRatio) {
					var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
					if (pixelRatio === 1) {
						return;
					}

					var canvas = chart.canvas;
					var height = chart.height;
					var width = chart.width;

					canvas.height = height * pixelRatio;
					canvas.width = width * pixelRatio;
					chart.ctx.scale(pixelRatio, pixelRatio);

					// If no style has been set on the canvas, the render size is used as display size,
					// making the chart visually bigger, so let's enforce it to the "correct" values.
					// See https://github.com/chartjs/Chart.js/issues/3575
					canvas.style.height = height + 'px';
					canvas.style.width = width + 'px';
				};
				// -- Canvas methods
				helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
					return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
				};
				helpers.longestText = function (ctx, font, arrayOfThings, cache) {
					cache = cache || {};
					var data = cache.data = cache.data || {};
					var gc = cache.garbageCollect = cache.garbageCollect || [];

					if (cache.font !== font) {
						data = cache.data = {};
						gc = cache.garbageCollect = [];
						cache.font = font;
					}

					ctx.font = font;
					var longest = 0;
					helpers.each(arrayOfThings, function (thing) {
						// Undefined strings and arrays should not be measured
						if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
							longest = helpers.measureText(ctx, data, gc, longest, thing);
						} else if (helpers.isArray(thing)) {
							// if it is an array lets measure each element
							// to do maybe simplify this function a bit so we can do this more recursively?
							helpers.each(thing, function (nestedThing) {
								// Undefined strings and arrays should not be measured
								if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
									longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
								}
							});
						}
					});

					var gcLen = gc.length / 2;
					if (gcLen > arrayOfThings.length) {
						for (var i = 0; i < gcLen; i++) {
							delete data[gc[i]];
						}
						gc.splice(0, gcLen);
					}
					return longest;
				};
				helpers.measureText = function (ctx, data, gc, longest, string) {
					var textWidth = data[string];
					if (!textWidth) {
						textWidth = data[string] = ctx.measureText(string).width;
						gc.push(string);
					}
					if (textWidth > longest) {
						longest = textWidth;
					}
					return longest;
				};
				helpers.numberOfLabelLines = function (arrayOfThings) {
					var numberOfLines = 1;
					helpers.each(arrayOfThings, function (thing) {
						if (helpers.isArray(thing)) {
							if (thing.length > numberOfLines) {
								numberOfLines = thing.length;
							}
						}
					});
					return numberOfLines;
				};

				helpers.color = !color ? function (value) {
					console.error('Color.js not found!');
					return value;
				} : function (value) {
					/* global CanvasGradient */
					if (value instanceof CanvasGradient) {
						value = defaults.global.defaultColor;
					}

					return color(value);
				};

				helpers.getHoverColor = function (colorValue) {
					/* global CanvasPattern */
					return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
				};
			};
		}, { "25": 25, "3": 3, "45": 45 }], 28: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			/**
    * Helper function to get relative position for an event
    * @param {Event|IEvent} event - The event to get the position for
    * @param {Chart} chart - The chart
    * @returns {Point} the event position
    */
			function getRelativePosition(e, chart) {
				if (e.native) {
					return {
						x: e.x,
						y: e.y
					};
				}

				return helpers.getRelativePosition(e, chart);
			}

			/**
    * Helper function to traverse all of the visible elements in the chart
    * @param chart {chart} the chart
    * @param handler {Function} the callback to execute for each visible item
    */
			function parseVisibleItems(chart, handler) {
				var datasets = chart.data.datasets;
				var meta, i, j, ilen, jlen;

				for (i = 0, ilen = datasets.length; i < ilen; ++i) {
					if (!chart.isDatasetVisible(i)) {
						continue;
					}

					meta = chart.getDatasetMeta(i);
					for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
						var element = meta.data[j];
						if (!element._view.skip) {
							handler(element);
						}
					}
				}
			}

			/**
    * Helper function to get the items that intersect the event position
    * @param items {ChartElement[]} elements to filter
    * @param position {Point} the point to be nearest to
    * @return {ChartElement[]} the nearest items
    */
			function getIntersectItems(chart, position) {
				var elements = [];

				parseVisibleItems(chart, function (element) {
					if (element.inRange(position.x, position.y)) {
						elements.push(element);
					}
				});

				return elements;
			}

			/**
    * Helper function to get the items nearest to the event position considering all visible items in teh chart
    * @param chart {Chart} the chart to look at elements from
    * @param position {Point} the point to be nearest to
    * @param intersect {Boolean} if true, only consider items that intersect the position
    * @param distanceMetric {Function} function to provide the distance between points
    * @return {ChartElement[]} the nearest items
    */
			function getNearestItems(chart, position, intersect, distanceMetric) {
				var minDistance = Number.POSITIVE_INFINITY;
				var nearestItems = [];

				parseVisibleItems(chart, function (element) {
					if (intersect && !element.inRange(position.x, position.y)) {
						return;
					}

					var center = element.getCenterPoint();
					var distance = distanceMetric(position, center);

					if (distance < minDistance) {
						nearestItems = [element];
						minDistance = distance;
					} else if (distance === minDistance) {
						// Can have multiple items at the same distance in which case we sort by size
						nearestItems.push(element);
					}
				});

				return nearestItems;
			}

			/**
    * Get a distance metric function for two points based on the
    * axis mode setting
    * @param {String} axis the axis mode. x|y|xy
    */
			function getDistanceMetricForAxis(axis) {
				var useX = axis.indexOf('x') !== -1;
				var useY = axis.indexOf('y') !== -1;

				return function (pt1, pt2) {
					var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
					var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
					return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
				};
			}

			function indexMode(chart, e, options) {
				var position = getRelativePosition(e, chart);
				// Default axis for index mode is 'x' to match old behaviour
				options.axis = options.axis || 'x';
				var distanceMetric = getDistanceMetricForAxis(options.axis);
				var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
				var elements = [];

				if (!items.length) {
					return [];
				}

				chart.data.datasets.forEach(function (dataset, datasetIndex) {
					if (chart.isDatasetVisible(datasetIndex)) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var element = meta.data[items[0]._index];

						// don't count items that are skipped (null data)
						if (element && !element._view.skip) {
							elements.push(element);
						}
					}
				});

				return elements;
			}

			/**
    * @interface IInteractionOptions
    */
			/**
    * If true, only consider items that intersect the point
    * @name IInterfaceOptions#boolean
    * @type Boolean
    */

			/**
    * Contains interaction related functions
    * @namespace Chart.Interaction
    */
			module.exports = {
				// Helper function for different modes
				modes: {
					single: function single(chart, e) {
						var position = getRelativePosition(e, chart);
						var elements = [];

						parseVisibleItems(chart, function (element) {
							if (element.inRange(position.x, position.y)) {
								elements.push(element);
								return elements;
							}
						});

						return elements.slice(0, 1);
					},

					/**
      * @function Chart.Interaction.modes.label
      * @deprecated since version 2.4.0
      * @todo remove at version 3
      * @private
      */
					label: indexMode,

					/**
      * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
      * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
      * @function Chart.Interaction.modes.index
      * @since v2.4.0
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use during interaction
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					index: indexMode,

					/**
      * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
      * If the options.intersect is false, we find the nearest item and return the items in that dataset
      * @function Chart.Interaction.modes.dataset
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use during interaction
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					dataset: function dataset(chart, e, options) {
						var position = getRelativePosition(e, chart);
						options.axis = options.axis || 'xy';
						var distanceMetric = getDistanceMetricForAxis(options.axis);
						var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

						if (items.length > 0) {
							items = chart.getDatasetMeta(items[0]._datasetIndex).data;
						}

						return items;
					},

					/**
      * @function Chart.Interaction.modes.x-axis
      * @deprecated since version 2.4.0. Use index mode and intersect == true
      * @todo remove at version 3
      * @private
      */
					'x-axis': function xAxis(chart, e) {
						return indexMode(chart, e, { intersect: true });
					},

					/**
      * Point mode returns all elements that hit test based on the event position
      * of the event
      * @function Chart.Interaction.modes.intersect
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					point: function point(chart, e) {
						var position = getRelativePosition(e, chart);
						return getIntersectItems(chart, position);
					},

					/**
      * nearest mode returns the element closest to the point
      * @function Chart.Interaction.modes.intersect
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					nearest: function nearest(chart, e, options) {
						var position = getRelativePosition(e, chart);
						options.axis = options.axis || 'xy';
						var distanceMetric = getDistanceMetricForAxis(options.axis);
						var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

						// We have multiple items at the same distance from the event. Now sort by smallest
						if (nearestItems.length > 1) {
							nearestItems.sort(function (a, b) {
								var sizeA = a.getArea();
								var sizeB = b.getArea();
								var ret = sizeA - sizeB;

								if (ret === 0) {
									// if equal sort by dataset index
									ret = a._datasetIndex - b._datasetIndex;
								}

								return ret;
							});
						}

						// Return only 1 item
						return nearestItems.slice(0, 1);
					},

					/**
      * x mode returns the elements that hit-test at the current x coordinate
      * @function Chart.Interaction.modes.x
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					x: function x(chart, e, options) {
						var position = getRelativePosition(e, chart);
						var items = [];
						var intersectsItem = false;

						parseVisibleItems(chart, function (element) {
							if (element.inXRange(position.x)) {
								items.push(element);
							}

							if (element.inRange(position.x, position.y)) {
								intersectsItem = true;
							}
						});

						// If we want to trigger on an intersect and we don't have any items
						// that intersect the position, return nothing
						if (options.intersect && !intersectsItem) {
							items = [];
						}
						return items;
					},

					/**
      * y mode returns the elements that hit-test at the current y coordinate
      * @function Chart.Interaction.modes.y
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					y: function y(chart, e, options) {
						var position = getRelativePosition(e, chart);
						var items = [];
						var intersectsItem = false;

						parseVisibleItems(chart, function (element) {
							if (element.inYRange(position.y)) {
								items.push(element);
							}

							if (element.inRange(position.x, position.y)) {
								intersectsItem = true;
							}
						});

						// If we want to trigger on an intersect and we don't have any items
						// that intersect the position, return nothing
						if (options.intersect && !intersectsItem) {
							items = [];
						}
						return items;
					}
				}
			};
		}, { "45": 45 }], 29: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);

			defaults._set('global', {
				responsive: true,
				responsiveAnimationDuration: 0,
				maintainAspectRatio: true,
				events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
				hover: {
					onHover: null,
					mode: 'nearest',
					intersect: true,
					animationDuration: 400
				},
				onClick: null,
				defaultColor: 'rgba(0,0,0,0.1)',
				defaultFontColor: '#666',
				defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
				defaultFontSize: 12,
				defaultFontStyle: 'normal',
				showLines: true,

				// Element defaults defined in element extensions
				elements: {},

				// Layout options such as padding
				layout: {
					padding: {
						top: 0,
						right: 0,
						bottom: 0,
						left: 0
					}
				}
			});

			module.exports = function () {

				// Occupy the global variable of Chart, and create a simple base class
				var Chart = function Chart(item, config) {
					this.construct(item, config);
					return this;
				};

				Chart.Chart = Chart;

				return Chart;
			};
		}, { "25": 25 }], 30: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			module.exports = function (Chart) {

				function filterByPosition(array, position) {
					return helpers.where(array, function (v) {
						return v.position === position;
					});
				}

				function sortByWeight(array, reverse) {
					array.forEach(function (v, i) {
						v._tmpIndex_ = i;
						return v;
					});
					array.sort(function (a, b) {
						var v0 = reverse ? b : a;
						var v1 = reverse ? a : b;
						return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
					});
					array.forEach(function (v) {
						delete v._tmpIndex_;
					});
				}

				/**
     * @interface ILayoutItem
     * @prop {String} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {Function} update - Takes two parameters: width and height. Returns size of item
     * @prop {Function} getPadding -  Returns an object with padding on the edges
     * @prop {Number} width - Width of item. Must be valid after update()
     * @prop {Number} height - Height of item. Must be valid after update()
     * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */

				// The layout service is very self explanatory.  It's responsible for the layout within a chart.
				// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
				// It is this service's responsibility of carrying out that layout.
				Chart.layoutService = {
					defaults: {},

					/**
      * Register a box to a chart.
      * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
      * @param {Chart} chart - the chart to use
      * @param {ILayoutItem} item - the item to add to be layed out
      */
					addBox: function addBox(chart, item) {
						if (!chart.boxes) {
							chart.boxes = [];
						}

						// initialize item with default values
						item.fullWidth = item.fullWidth || false;
						item.position = item.position || 'top';
						item.weight = item.weight || 0;

						chart.boxes.push(item);
					},

					/**
      * Remove a layoutItem from a chart
      * @param {Chart} chart - the chart to remove the box from
      * @param {Object} layoutItem - the item to remove from the layout
      */
					removeBox: function removeBox(chart, layoutItem) {
						var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
						if (index !== -1) {
							chart.boxes.splice(index, 1);
						}
					},

					/**
      * Sets (or updates) options on the given `item`.
      * @param {Chart} chart - the chart in which the item lives (or will be added to)
      * @param {Object} item - the item to configure with the given options
      * @param {Object} options - the new item options.
      */
					configure: function configure(chart, item, options) {
						var props = ['fullWidth', 'position', 'weight'];
						var ilen = props.length;
						var i = 0;
						var prop;

						for (; i < ilen; ++i) {
							prop = props[i];
							if (options.hasOwnProperty(prop)) {
								item[prop] = options[prop];
							}
						}
					},

					/**
      * Fits boxes of the given chart into the given size by having each box measure itself
      * then running a fitting algorithm
      * @param {Chart} chart - the chart
      * @param {Number} width - the width to fit into
      * @param {Number} height - the height to fit into
      */
					update: function update(chart, width, height) {
						if (!chart) {
							return;
						}

						var layoutOptions = chart.options.layout || {};
						var padding = helpers.options.toPadding(layoutOptions.padding);
						var leftPadding = padding.left;
						var rightPadding = padding.right;
						var topPadding = padding.top;
						var bottomPadding = padding.bottom;

						var leftBoxes = filterByPosition(chart.boxes, 'left');
						var rightBoxes = filterByPosition(chart.boxes, 'right');
						var topBoxes = filterByPosition(chart.boxes, 'top');
						var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
						var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

						// Sort boxes by weight. A higher weight is further away from the chart area
						sortByWeight(leftBoxes, true);
						sortByWeight(rightBoxes, false);
						sortByWeight(topBoxes, true);
						sortByWeight(bottomBoxes, false);

						// Essentially we now have any number of boxes on each of the 4 sides.
						// Our canvas looks like the following.
						// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
						// B1 is the bottom axis
						// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
						// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
						// an error will be thrown.
						//
						// |----------------------------------------------------|
						// |                  T1 (Full Width)                   |
						// |----------------------------------------------------|
						// |    |    |                 T2                  |    |
						// |    |----|-------------------------------------|----|
						// |    |    | C1 |                           | C2 |    |
						// |    |    |----|                           |----|    |
						// |    |    |                                     |    |
						// | L1 | L2 |           ChartArea (C0)            | R1 |
						// |    |    |                                     |    |
						// |    |    |----|                           |----|    |
						// |    |    | C3 |                           | C4 |    |
						// |    |----|-------------------------------------|----|
						// |    |    |                 B1                  |    |
						// |----------------------------------------------------|
						// |                  B2 (Full Width)                   |
						// |----------------------------------------------------|
						//
						// What we do to find the best sizing, we do the following
						// 1. Determine the minimum size of the chart area.
						// 2. Split the remaining width equally between each vertical axis
						// 3. Split the remaining height equally between each horizontal axis
						// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
						// 5. Adjust the sizes of each axis based on it's minimum reported size.
						// 6. Refit each axis
						// 7. Position each axis in the final location
						// 8. Tell the chart the final location of the chart area
						// 9. Tell any axes that overlay the chart area the positions of the chart area

						// Step 1
						var chartWidth = width - leftPadding - rightPadding;
						var chartHeight = height - topPadding - bottomPadding;
						var chartAreaWidth = chartWidth / 2; // min 50%
						var chartAreaHeight = chartHeight / 2; // min 50%

						// Step 2
						var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

						// Step 3
						var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

						// Step 4
						var maxChartAreaWidth = chartWidth;
						var maxChartAreaHeight = chartHeight;
						var minBoxSizes = [];

						function getMinimumBoxSize(box) {
							var minSize;
							var isHorizontal = box.isHorizontal();

							if (isHorizontal) {
								minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
								maxChartAreaHeight -= minSize.height;
							} else {
								minSize = box.update(verticalBoxWidth, chartAreaHeight);
								maxChartAreaWidth -= minSize.width;
							}

							minBoxSizes.push({
								horizontal: isHorizontal,
								minSize: minSize,
								box: box
							});
						}

						helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

						// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
						var maxHorizontalLeftPadding = 0;
						var maxHorizontalRightPadding = 0;
						var maxVerticalTopPadding = 0;
						var maxVerticalBottomPadding = 0;

						helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {
							if (horizontalBox.getPadding) {
								var boxPadding = horizontalBox.getPadding();
								maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
								maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
							}
						});

						helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {
							if (verticalBox.getPadding) {
								var boxPadding = verticalBox.getPadding();
								maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
								maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
							}
						});

						// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
						// be if the axes are drawn at their minimum sizes.
						// Steps 5 & 6
						var totalLeftBoxesWidth = leftPadding;
						var totalRightBoxesWidth = rightPadding;
						var totalTopBoxesHeight = topPadding;
						var totalBottomBoxesHeight = bottomPadding;

						// Function to fit a box
						function fitBox(box) {
							var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
								return minBox.box === box;
							});

							if (minBoxSize) {
								if (box.isHorizontal()) {
									var scaleMargin = {
										left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
										right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
										top: 0,
										bottom: 0
									};

									// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
									// on the margin. Sometimes they need to increase in size slightly
									box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
								} else {
									box.update(minBoxSize.minSize.width, maxChartAreaHeight);
								}
							}
						}

						// Update, and calculate the left and right margins for the horizontal boxes
						helpers.each(leftBoxes.concat(rightBoxes), fitBox);

						helpers.each(leftBoxes, function (box) {
							totalLeftBoxesWidth += box.width;
						});

						helpers.each(rightBoxes, function (box) {
							totalRightBoxesWidth += box.width;
						});

						// Set the Left and Right margins for the horizontal boxes
						helpers.each(topBoxes.concat(bottomBoxes), fitBox);

						// Figure out how much margin is on the top and bottom of the vertical boxes
						helpers.each(topBoxes, function (box) {
							totalTopBoxesHeight += box.height;
						});

						helpers.each(bottomBoxes, function (box) {
							totalBottomBoxesHeight += box.height;
						});

						function finalFitVerticalBox(box) {
							var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
								return minSize.box === box;
							});

							var scaleMargin = {
								left: 0,
								right: 0,
								top: totalTopBoxesHeight,
								bottom: totalBottomBoxesHeight
							};

							if (minBoxSize) {
								box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
							}
						}

						// Let the left layout know the final margin
						helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

						// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
						totalLeftBoxesWidth = leftPadding;
						totalRightBoxesWidth = rightPadding;
						totalTopBoxesHeight = topPadding;
						totalBottomBoxesHeight = bottomPadding;

						helpers.each(leftBoxes, function (box) {
							totalLeftBoxesWidth += box.width;
						});

						helpers.each(rightBoxes, function (box) {
							totalRightBoxesWidth += box.width;
						});

						helpers.each(topBoxes, function (box) {
							totalTopBoxesHeight += box.height;
						});
						helpers.each(bottomBoxes, function (box) {
							totalBottomBoxesHeight += box.height;
						});

						// We may be adding some padding to account for rotated x axis labels
						var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
						totalLeftBoxesWidth += leftPaddingAddition;
						totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

						var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
						totalTopBoxesHeight += topPaddingAddition;
						totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

						// Figure out if our chart area changed. This would occur if the dataset layout label rotation
						// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
						// without calling `fit` again
						var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
						var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

						if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
							helpers.each(leftBoxes, function (box) {
								box.height = newMaxChartAreaHeight;
							});

							helpers.each(rightBoxes, function (box) {
								box.height = newMaxChartAreaHeight;
							});

							helpers.each(topBoxes, function (box) {
								if (!box.fullWidth) {
									box.width = newMaxChartAreaWidth;
								}
							});

							helpers.each(bottomBoxes, function (box) {
								if (!box.fullWidth) {
									box.width = newMaxChartAreaWidth;
								}
							});

							maxChartAreaHeight = newMaxChartAreaHeight;
							maxChartAreaWidth = newMaxChartAreaWidth;
						}

						// Step 7 - Position the boxes
						var left = leftPadding + leftPaddingAddition;
						var top = topPadding + topPaddingAddition;

						function placeBox(box) {
							if (box.isHorizontal()) {
								box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
								box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
								box.top = top;
								box.bottom = top + box.height;

								// Move to next point
								top = box.bottom;
							} else {

								box.left = left;
								box.right = left + box.width;
								box.top = totalTopBoxesHeight;
								box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

								// Move to next point
								left = box.right;
							}
						}

						helpers.each(leftBoxes.concat(topBoxes), placeBox);

						// Account for chart width and height
						left += maxChartAreaWidth;
						top += maxChartAreaHeight;

						helpers.each(rightBoxes, placeBox);
						helpers.each(bottomBoxes, placeBox);

						// Step 8
						chart.chartArea = {
							left: totalLeftBoxesWidth,
							top: totalTopBoxesHeight,
							right: totalLeftBoxesWidth + maxChartAreaWidth,
							bottom: totalTopBoxesHeight + maxChartAreaHeight
						};

						// Step 9
						helpers.each(chartAreaBoxes, function (box) {
							box.left = chart.chartArea.left;
							box.top = chart.chartArea.top;
							box.right = chart.chartArea.right;
							box.bottom = chart.chartArea.bottom;

							box.update(maxChartAreaWidth, maxChartAreaHeight);
						});
					}
				};
			};
		}, { "45": 45 }], 31: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				plugins: {}
			});

			module.exports = function (Chart) {

				/**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */
				Chart.plugins = {
					/**
      * Globally registered plugins.
      * @private
      */
					_plugins: [],

					/**
      * This identifier is used to invalidate the descriptors cache attached to each chart
      * when a global plugin is registered or unregistered. In this case, the cache ID is
      * incremented and descriptors are regenerated during following API calls.
      * @private
      */
					_cacheId: 0,

					/**
      * Registers the given plugin(s) if not already registered.
      * @param {Array|Object} plugins plugin instance(s).
      */
					register: function register(plugins) {
						var p = this._plugins;
						[].concat(plugins).forEach(function (plugin) {
							if (p.indexOf(plugin) === -1) {
								p.push(plugin);
							}
						});

						this._cacheId++;
					},

					/**
      * Unregisters the given plugin(s) only if registered.
      * @param {Array|Object} plugins plugin instance(s).
      */
					unregister: function unregister(plugins) {
						var p = this._plugins;
						[].concat(plugins).forEach(function (plugin) {
							var idx = p.indexOf(plugin);
							if (idx !== -1) {
								p.splice(idx, 1);
							}
						});

						this._cacheId++;
					},

					/**
      * Remove all registered plugins.
      * @since 2.1.5
      */
					clear: function clear() {
						this._plugins = [];
						this._cacheId++;
					},

					/**
      * Returns the number of registered plugins?
      * @returns {Number}
      * @since 2.1.5
      */
					count: function count() {
						return this._plugins.length;
					},

					/**
      * Returns all registered plugin instances.
      * @returns {Array} array of plugin objects.
      * @since 2.1.5
      */
					getAll: function getAll() {
						return this._plugins;
					},

					/**
      * Calls enabled plugins for `chart` on the specified hook and with the given args.
      * This method immediately returns as soon as a plugin explicitly returns false. The
      * returned value can be used, for instance, to interrupt the current action.
      * @param {Object} chart - The chart instance for which plugins should be called.
      * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
      * @param {Array} [args] - Extra arguments to apply to the hook call.
      * @returns {Boolean} false if any of the plugins return false, else returns true.
      */
					notify: function notify(chart, hook, args) {
						var descriptors = this.descriptors(chart);
						var ilen = descriptors.length;
						var i, descriptor, plugin, params, method;

						for (i = 0; i < ilen; ++i) {
							descriptor = descriptors[i];
							plugin = descriptor.plugin;
							method = plugin[hook];
							if (typeof method === 'function') {
								params = [chart].concat(args || []);
								params.push(descriptor.options);
								if (method.apply(plugin, params) === false) {
									return false;
								}
							}
						}

						return true;
					},

					/**
      * Returns descriptors of enabled plugins for the given chart.
      * @returns {Array} [{ plugin, options }]
      * @private
      */
					descriptors: function descriptors(chart) {
						var cache = chart._plugins || (chart._plugins = {});
						if (cache.id === this._cacheId) {
							return cache.descriptors;
						}

						var plugins = [];
						var descriptors = [];
						var config = chart && chart.config || {};
						var options = config.options && config.options.plugins || {};

						this._plugins.concat(config.plugins || []).forEach(function (plugin) {
							var idx = plugins.indexOf(plugin);
							if (idx !== -1) {
								return;
							}

							var id = plugin.id;
							var opts = options[id];
							if (opts === false) {
								return;
							}

							if (opts === true) {
								opts = helpers.clone(defaults.global.plugins[id]);
							}

							plugins.push(plugin);
							descriptors.push({
								plugin: plugin,
								options: opts || {}
							});
						});

						cache.descriptors = descriptors;
						cache.id = this._cacheId;
						return descriptors;
					}
				};

				/**
     * Plugin extension hooks.
     * @interface IPlugin
     * @since 2.1.0
     */
				/**
     * @method IPlugin#beforeInit
     * @desc Called before initializing `chart`.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#afterInit
     * @desc Called after `chart` has been initialized and before the first update.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeUpdate
     * @desc Called before updating `chart`. If any plugin returns `false`, the update
     * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart update.
     */
				/**
     * @method IPlugin#afterUpdate
     * @desc Called after `chart` has been updated and before rendering. Note that this
     * hook will not be called if the chart update has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDatasetsUpdate
    	 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
     * the datasets update is cancelled until another `update` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} false to cancel the datasets update.
     * @since version 2.1.5
     */
				/**
     * @method IPlugin#afterDatasetsUpdate
     * @desc Called after the `chart` datasets have been updated. Note that this hook
     * will not be called if the datasets update has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @since version 2.1.5
     */
				/**
     * @method IPlugin#beforeDatasetUpdate
    	 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
     * returns `false`, the datasets update is cancelled until another `update` is triggered.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart datasets drawing.
     */
				/**
     * @method IPlugin#afterDatasetUpdate
    	 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
     * that this hook will not be called if the datasets update has been previously cancelled.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeLayout
     * @desc Called before laying out `chart`. If any plugin returns `false`,
     * the layout update is cancelled until another `update` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart layout.
     */
				/**
     * @method IPlugin#afterLayout
     * @desc Called after the `chart` has been layed out. Note that this hook will not
     * be called if the layout update has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeRender
     * @desc Called before rendering `chart`. If any plugin returns `false`,
     * the rendering is cancelled until another `render` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart rendering.
     */
				/**
     * @method IPlugin#afterRender
     * @desc Called after the `chart` has been fully rendered (and animation completed). Note
     * that this hook will not be called if the rendering has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDraw
     * @desc Called before drawing `chart` at every animation frame specified by the given
     * easing value. If any plugin returns `false`, the frame drawing is cancelled until
     * another `render` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart drawing.
     */
				/**
     * @method IPlugin#afterDraw
     * @desc Called after the `chart` has been drawn for the specific easing value. Note
     * that this hook will not be called if the drawing has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDatasetsDraw
    	 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
     * the datasets drawing is cancelled until another `render` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart datasets drawing.
     */
				/**
     * @method IPlugin#afterDatasetsDraw
     * @desc Called after the `chart` datasets have been drawn. Note that this hook
     * will not be called if the datasets drawing has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDatasetDraw
    	 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
     * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
     * is cancelled until another `render` is triggered.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart datasets drawing.
     */
				/**
     * @method IPlugin#afterDatasetDraw
    	 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
     * (datasets are drawn in the reverse order). Note that this hook will not be called
     * if the datasets drawing has been previously cancelled.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeEvent
    	 * @desc Called before processing the specified `event`. If any plugin returns `false`,
     * the event will be discarded.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {IEvent} event - The event object.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#afterEvent
     * @desc Called after the `event` has been consumed. Note that this hook
     * will not be called if the `event` has been previously discarded.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {IEvent} event - The event object.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#resize
     * @desc Called after the chart as been resized.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#destroy
     * @desc Called after the chart as been destroyed.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */

				/**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */
				Chart.pluginService = Chart.plugins;

				/**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */
				Chart.PluginBase = Element.extend({});
			};
		}, { "25": 25, "26": 26, "45": 45 }], 32: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);
			var Ticks = require(34);

			defaults._set('scale', {
				display: true,
				position: 'left',
				offset: false,

				// grid line settings
				gridLines: {
					display: true,
					color: 'rgba(0, 0, 0, 0.1)',
					lineWidth: 1,
					drawBorder: true,
					drawOnChartArea: true,
					drawTicks: true,
					tickMarkLength: 10,
					zeroLineWidth: 1,
					zeroLineColor: 'rgba(0,0,0,0.25)',
					zeroLineBorderDash: [],
					zeroLineBorderDashOffset: 0.0,
					offsetGridLines: false,
					borderDash: [],
					borderDashOffset: 0.0
				},

				// scale label
				scaleLabel: {
					// display property
					display: false,

					// actual label
					labelString: '',

					// line height
					lineHeight: 1.2,

					// top/bottom padding
					padding: {
						top: 4,
						bottom: 4
					}
				},

				// label settings
				ticks: {
					beginAtZero: false,
					minRotation: 0,
					maxRotation: 50,
					mirror: false,
					padding: 0,
					reverse: false,
					display: true,
					autoSkip: true,
					autoSkipPadding: 0,
					labelOffset: 0,
					// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
					callback: Ticks.formatters.values,
					minor: {},
					major: {}
				}
			});

			function labelsFromTicks(ticks) {
				var labels = [];
				var i, ilen;

				for (i = 0, ilen = ticks.length; i < ilen; ++i) {
					labels.push(ticks[i].label);
				}

				return labels;
			}

			function getLineValue(scale, index, offsetGridLines) {
				var lineValue = scale.getPixelForTick(index);

				if (offsetGridLines) {
					if (index === 0) {
						lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
					} else {
						lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
					}
				}
				return lineValue;
			}

			module.exports = function (Chart) {

				function computeTextSize(context, tick, font) {
					return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;
				}

				function parseFontOptions(options) {
					var valueOrDefault = helpers.valueOrDefault;
					var globalDefaults = defaults.global;
					var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
					var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
					var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

					return {
						size: size,
						style: style,
						family: family,
						font: helpers.fontString(size, style, family)
					};
				}

				function parseLineHeight(options) {
					return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
				}

				Chart.Scale = Element.extend({
					/**
      * Get the padding needed for the scale
      * @method getPadding
      * @private
      * @returns {Padding} the necessary padding
      */
					getPadding: function getPadding() {
						var me = this;
						return {
							left: me.paddingLeft || 0,
							top: me.paddingTop || 0,
							right: me.paddingRight || 0,
							bottom: me.paddingBottom || 0
						};
					},

					/**
      * Returns the scale tick objects ({label, major})
      * @since 2.7
      */
					getTicks: function getTicks() {
						return this._ticks;
					},

					// These methods are ordered by lifecyle. Utilities then follow.
					// Any function defined here is inherited by all scale types.
					// Any function can be extended by the scale type

					mergeTicksOptions: function mergeTicksOptions() {
						var ticks = this.options.ticks;
						if (ticks.minor === false) {
							ticks.minor = {
								display: false
							};
						}
						if (ticks.major === false) {
							ticks.major = {
								display: false
							};
						}
						for (var key in ticks) {
							if (key !== 'major' && key !== 'minor') {
								if (typeof ticks.minor[key] === 'undefined') {
									ticks.minor[key] = ticks[key];
								}
								if (typeof ticks.major[key] === 'undefined') {
									ticks.major[key] = ticks[key];
								}
							}
						}
					},
					beforeUpdate: function beforeUpdate() {
						helpers.callback(this.options.beforeUpdate, [this]);
					},
					update: function update(maxWidth, maxHeight, margins) {
						var me = this;
						var i, ilen, labels, label, ticks, tick;

						// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
						me.beforeUpdate();

						// Absorb the master measurements
						me.maxWidth = maxWidth;
						me.maxHeight = maxHeight;
						me.margins = helpers.extend({
							left: 0,
							right: 0,
							top: 0,
							bottom: 0
						}, margins);
						me.longestTextCache = me.longestTextCache || {};

						// Dimensions
						me.beforeSetDimensions();
						me.setDimensions();
						me.afterSetDimensions();

						// Data min/max
						me.beforeDataLimits();
						me.determineDataLimits();
						me.afterDataLimits();

						// Ticks - `this.ticks` is now DEPRECATED!
						// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
						// and must not be accessed directly from outside this class. `this.ticks` being
						// around for long time and not marked as private, we can't change its structure
						// without unexpected breaking changes. If you need to access the scale ticks,
						// use scale.getTicks() instead.

						me.beforeBuildTicks();

						// New implementations should return an array of objects but for BACKWARD COMPAT,
						// we still support no return (`this.ticks` internally set by calling this method).
						ticks = me.buildTicks() || [];

						me.afterBuildTicks();

						me.beforeTickToLabelConversion();

						// New implementations should return the formatted tick labels but for BACKWARD
						// COMPAT, we still support no return (`this.ticks` internally changed by calling
						// this method and supposed to contain only string values).
						labels = me.convertTicksToLabels(ticks) || me.ticks;

						me.afterTickToLabelConversion();

						me.ticks = labels; // BACKWARD COMPATIBILITY

						// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

						// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
						for (i = 0, ilen = labels.length; i < ilen; ++i) {
							label = labels[i];
							tick = ticks[i];
							if (!tick) {
								ticks.push(tick = {
									label: label,
									major: false
								});
							} else {
								tick.label = label;
							}
						}

						me._ticks = ticks;

						// Tick Rotation
						me.beforeCalculateTickRotation();
						me.calculateTickRotation();
						me.afterCalculateTickRotation();
						// Fit
						me.beforeFit();
						me.fit();
						me.afterFit();
						//
						me.afterUpdate();

						return me.minSize;
					},
					afterUpdate: function afterUpdate() {
						helpers.callback(this.options.afterUpdate, [this]);
					},

					//

					beforeSetDimensions: function beforeSetDimensions() {
						helpers.callback(this.options.beforeSetDimensions, [this]);
					},
					setDimensions: function setDimensions() {
						var me = this;
						// Set the unconstrained dimension before label rotation
						if (me.isHorizontal()) {
							// Reset position before calculating rotation
							me.width = me.maxWidth;
							me.left = 0;
							me.right = me.width;
						} else {
							me.height = me.maxHeight;

							// Reset position before calculating rotation
							me.top = 0;
							me.bottom = me.height;
						}

						// Reset padding
						me.paddingLeft = 0;
						me.paddingTop = 0;
						me.paddingRight = 0;
						me.paddingBottom = 0;
					},
					afterSetDimensions: function afterSetDimensions() {
						helpers.callback(this.options.afterSetDimensions, [this]);
					},

					// Data limits
					beforeDataLimits: function beforeDataLimits() {
						helpers.callback(this.options.beforeDataLimits, [this]);
					},
					determineDataLimits: helpers.noop,
					afterDataLimits: function afterDataLimits() {
						helpers.callback(this.options.afterDataLimits, [this]);
					},

					//
					beforeBuildTicks: function beforeBuildTicks() {
						helpers.callback(this.options.beforeBuildTicks, [this]);
					},
					buildTicks: helpers.noop,
					afterBuildTicks: function afterBuildTicks() {
						helpers.callback(this.options.afterBuildTicks, [this]);
					},

					beforeTickToLabelConversion: function beforeTickToLabelConversion() {
						helpers.callback(this.options.beforeTickToLabelConversion, [this]);
					},
					convertTicksToLabels: function convertTicksToLabels() {
						var me = this;
						// Convert ticks to strings
						var tickOpts = me.options.ticks;
						me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
					},
					afterTickToLabelConversion: function afterTickToLabelConversion() {
						helpers.callback(this.options.afterTickToLabelConversion, [this]);
					},

					//

					beforeCalculateTickRotation: function beforeCalculateTickRotation() {
						helpers.callback(this.options.beforeCalculateTickRotation, [this]);
					},
					calculateTickRotation: function calculateTickRotation() {
						var me = this;
						var context = me.ctx;
						var tickOpts = me.options.ticks;
						var labels = labelsFromTicks(me._ticks);

						// Get the width of each grid by calculating the difference
						// between x offsets between 0 and 1.
						var tickFont = parseFontOptions(tickOpts);
						context.font = tickFont.font;

						var labelRotation = tickOpts.minRotation || 0;

						if (labels.length && me.options.display && me.isHorizontal()) {
							var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
							var labelWidth = originalLabelWidth;
							var cosRotation, sinRotation;

							// Allow 3 pixels x2 padding either side for label readability
							var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

							// Max label rotation can be set or default to 90 - also act as a loop counter
							while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
								var angleRadians = helpers.toRadians(labelRotation);
								cosRotation = Math.cos(angleRadians);
								sinRotation = Math.sin(angleRadians);

								if (sinRotation * originalLabelWidth > me.maxHeight) {
									// go back one step
									labelRotation--;
									break;
								}

								labelRotation++;
								labelWidth = cosRotation * originalLabelWidth;
							}
						}

						me.labelRotation = labelRotation;
					},
					afterCalculateTickRotation: function afterCalculateTickRotation() {
						helpers.callback(this.options.afterCalculateTickRotation, [this]);
					},

					//

					beforeFit: function beforeFit() {
						helpers.callback(this.options.beforeFit, [this]);
					},
					fit: function fit() {
						var me = this;
						// Reset
						var minSize = me.minSize = {
							width: 0,
							height: 0
						};

						var labels = labelsFromTicks(me._ticks);

						var opts = me.options;
						var tickOpts = opts.ticks;
						var scaleLabelOpts = opts.scaleLabel;
						var gridLineOpts = opts.gridLines;
						var display = opts.display;
						var isHorizontal = me.isHorizontal();

						var tickFont = parseFontOptions(tickOpts);
						var tickMarkLength = opts.gridLines.tickMarkLength;

						// Width
						if (isHorizontal) {
							// subtract the margins to line up with the chartArea if we are a full width scale
							minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
						} else {
							minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
						}

						// height
						if (isHorizontal) {
							minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
						} else {
							minSize.height = me.maxHeight; // fill all the height
						}

						// Are we showing a title for the scale?
						if (scaleLabelOpts.display && display) {
							var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
							var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
							var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

							if (isHorizontal) {
								minSize.height += deltaHeight;
							} else {
								minSize.width += deltaHeight;
							}
						}

						// Don't bother fitting the ticks if we are not showing them
						if (tickOpts.display && display) {
							var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
							var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
							var lineSpace = tickFont.size * 0.5;
							var tickPadding = me.options.ticks.padding;

							if (isHorizontal) {
								// A horizontal axis is more constrained by the height.
								me.longestLabelWidth = largestTextWidth;

								var angleRadians = helpers.toRadians(me.labelRotation);
								var cosRotation = Math.cos(angleRadians);
								var sinRotation = Math.sin(angleRadians);

								// TODO - improve this calculation
								var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace; // padding

								minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

								me.ctx.font = tickFont.font;
								var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
								var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

								// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
								// which means that the right padding is dominated by the font height
								if (me.labelRotation !== 0) {
									me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges
									me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;
								} else {
									me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
									me.paddingRight = lastLabelWidth / 2 + 3;
								}
							} else {
								// A vertical axis is more constrained by the width. Labels are the
								// dominant factor here, so get that length first and account for padding
								if (tickOpts.mirror) {
									largestTextWidth = 0;
								} else {
									// use lineSpace for consistency with horizontal axis
									// tickPadding is not implemented for horizontal
									largestTextWidth += tickPadding + lineSpace;
								}

								minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

								me.paddingTop = tickFont.size / 2;
								me.paddingBottom = tickFont.size / 2;
							}
						}

						me.handleMargins();

						me.width = minSize.width;
						me.height = minSize.height;
					},

					/**
      * Handle margins and padding interactions
      * @private
      */
					handleMargins: function handleMargins() {
						var me = this;
						if (me.margins) {
							me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
							me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
							me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
							me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
						}
					},

					afterFit: function afterFit() {
						helpers.callback(this.options.afterFit, [this]);
					},

					// Shared Methods
					isHorizontal: function isHorizontal() {
						return this.options.position === 'top' || this.options.position === 'bottom';
					},
					isFullWidth: function isFullWidth() {
						return this.options.fullWidth;
					},

					// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
					getRightValue: function getRightValue(rawValue) {
						// Null and undefined values first
						if (helpers.isNullOrUndef(rawValue)) {
							return NaN;
						}
						// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
						if (typeof rawValue === 'number' && !isFinite(rawValue)) {
							return NaN;
						}
						// If it is in fact an object, dive in one more level
						if (rawValue) {
							if (this.isHorizontal()) {
								if (rawValue.x !== undefined) {
									return this.getRightValue(rawValue.x);
								}
							} else if (rawValue.y !== undefined) {
								return this.getRightValue(rawValue.y);
							}
						}

						// Value is good, return it
						return rawValue;
					},

					// Used to get the value to display in the tooltip for the data at the given index
					// function getLabelForIndex(index, datasetIndex)
					getLabelForIndex: helpers.noop,

					// Used to get data value locations.  Value can either be an index or a numerical value
					getPixelForValue: helpers.noop,

					// Used to get the data value from a given pixel. This is the inverse of getPixelForValue
					getValueForPixel: helpers.noop,

					// Used for tick location, should
					getPixelForTick: function getPixelForTick(index) {
						var me = this;
						var offset = me.options.offset;
						if (me.isHorizontal()) {
							var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
							var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
							var pixel = tickWidth * index + me.paddingLeft;

							if (offset) {
								pixel += tickWidth / 2;
							}

							var finalVal = me.left + Math.round(pixel);
							finalVal += me.isFullWidth() ? me.margins.left : 0;
							return finalVal;
						}
						var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
						return me.top + index * (innerHeight / (me._ticks.length - 1));
					},

					// Utility for getting the pixel location of a percentage of scale
					getPixelForDecimal: function getPixelForDecimal(decimal) {
						var me = this;
						if (me.isHorizontal()) {
							var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
							var valueOffset = innerWidth * decimal + me.paddingLeft;

							var finalVal = me.left + Math.round(valueOffset);
							finalVal += me.isFullWidth() ? me.margins.left : 0;
							return finalVal;
						}
						return me.top + decimal * me.height;
					},

					getBasePixel: function getBasePixel() {
						return this.getPixelForValue(this.getBaseValue());
					},

					getBaseValue: function getBaseValue() {
						var me = this;
						var min = me.min;
						var max = me.max;

						return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
					},

					/**
      * Returns a subset of ticks to be plotted to avoid overlapping labels.
      * @private
      */
					_autoSkip: function _autoSkip(ticks) {
						var skipRatio;
						var me = this;
						var isHorizontal = me.isHorizontal();
						var optionTicks = me.options.ticks.minor;
						var tickCount = ticks.length;
						var labelRotationRadians = helpers.toRadians(me.labelRotation);
						var cosRotation = Math.cos(labelRotationRadians);
						var longestRotatedLabel = me.longestLabelWidth * cosRotation;
						var result = [];
						var i, tick, shouldSkip;

						// figure out the maximum number of gridlines to show
						var maxTicks;
						if (optionTicks.maxTicksLimit) {
							maxTicks = optionTicks.maxTicksLimit;
						}

						if (isHorizontal) {
							skipRatio = false;

							if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {
								skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));
							}

							// if they defined a max number of optionTicks,
							// increase skipRatio until that number is met
							if (maxTicks && tickCount > maxTicks) {
								skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
							}
						}

						for (i = 0; i < tickCount; i++) {
							tick = ticks[i];

							// Since we always show the last tick,we need may need to hide the last shown one before
							shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;
							if (shouldSkip && i !== tickCount - 1 || helpers.isNullOrUndef(tick.label)) {
								// leave tick in place but make sure it's not displayed (#4635)
								delete tick.label;
							}
							result.push(tick);
						}
						return result;
					},

					// Actually draw the scale on the canvas
					// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
					draw: function draw(chartArea) {
						var me = this;
						var options = me.options;
						if (!options.display) {
							return;
						}

						var context = me.ctx;
						var globalDefaults = defaults.global;
						var optionTicks = options.ticks.minor;
						var optionMajorTicks = options.ticks.major || optionTicks;
						var gridLines = options.gridLines;
						var scaleLabel = options.scaleLabel;

						var isRotated = me.labelRotation !== 0;
						var isHorizontal = me.isHorizontal();

						var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
						var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
						var tickFont = parseFontOptions(optionTicks);
						var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
						var majorTickFont = parseFontOptions(optionMajorTicks);

						var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

						var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
						var scaleLabelFont = parseFontOptions(scaleLabel);
						var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
						var labelRotationRadians = helpers.toRadians(me.labelRotation);

						var itemsToDraw = [];

						var xTickStart = options.position === 'right' ? me.left : me.right - tl;
						var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
						var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
						var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;

						helpers.each(ticks, function (tick, index) {
							// autoskipper skipped this tick (#4635)
							if (tick.label === undefined) {
								return;
							}

							var label = tick.label;
							var lineWidth, lineColor, borderDash, borderDashOffset;
							if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
								// Draw the first index specially
								lineWidth = gridLines.zeroLineWidth;
								lineColor = gridLines.zeroLineColor;
								borderDash = gridLines.zeroLineBorderDash;
								borderDashOffset = gridLines.zeroLineBorderDashOffset;
							} else {
								lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
								lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
								borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
								borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
							}

							// Common properties
							var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
							var textAlign = 'middle';
							var textBaseline = 'middle';
							var tickPadding = optionTicks.padding;

							if (isHorizontal) {
								var labelYOffset = tl + tickPadding;

								if (options.position === 'bottom') {
									// bottom
									textBaseline = !isRotated ? 'top' : 'middle';
									textAlign = !isRotated ? 'center' : 'right';
									labelY = me.top + labelYOffset;
								} else {
									// top
									textBaseline = !isRotated ? 'bottom' : 'middle';
									textAlign = !isRotated ? 'center' : 'left';
									labelY = me.bottom - labelYOffset;
								}

								var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
								if (xLineValue < me.left) {
									lineColor = 'rgba(0,0,0,0)';
								}
								xLineValue += helpers.aliasPixel(lineWidth);

								labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

								tx1 = tx2 = x1 = x2 = xLineValue;
								ty1 = yTickStart;
								ty2 = yTickEnd;
								y1 = chartArea.top;
								y2 = chartArea.bottom;
							} else {
								var isLeft = options.position === 'left';
								var labelXOffset;

								if (optionTicks.mirror) {
									textAlign = isLeft ? 'left' : 'right';
									labelXOffset = tickPadding;
								} else {
									textAlign = isLeft ? 'right' : 'left';
									labelXOffset = tl + tickPadding;
								}

								labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

								var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
								if (yLineValue < me.top) {
									lineColor = 'rgba(0,0,0,0)';
								}
								yLineValue += helpers.aliasPixel(lineWidth);

								labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

								tx1 = xTickStart;
								tx2 = xTickEnd;
								x1 = chartArea.left;
								x2 = chartArea.right;
								ty1 = ty2 = y1 = y2 = yLineValue;
							}

							itemsToDraw.push({
								tx1: tx1,
								ty1: ty1,
								tx2: tx2,
								ty2: ty2,
								x1: x1,
								y1: y1,
								x2: x2,
								y2: y2,
								labelX: labelX,
								labelY: labelY,
								glWidth: lineWidth,
								glColor: lineColor,
								glBorderDash: borderDash,
								glBorderDashOffset: borderDashOffset,
								rotation: -1 * labelRotationRadians,
								label: label,
								major: tick.major,
								textBaseline: textBaseline,
								textAlign: textAlign
							});
						});

						// Draw all of the tick labels, tick marks, and grid lines at the correct places
						helpers.each(itemsToDraw, function (itemToDraw) {
							if (gridLines.display) {
								context.save();
								context.lineWidth = itemToDraw.glWidth;
								context.strokeStyle = itemToDraw.glColor;
								if (context.setLineDash) {
									context.setLineDash(itemToDraw.glBorderDash);
									context.lineDashOffset = itemToDraw.glBorderDashOffset;
								}

								context.beginPath();

								if (gridLines.drawTicks) {
									context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
									context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
								}

								if (gridLines.drawOnChartArea) {
									context.moveTo(itemToDraw.x1, itemToDraw.y1);
									context.lineTo(itemToDraw.x2, itemToDraw.y2);
								}

								context.stroke();
								context.restore();
							}

							if (optionTicks.display) {
								// Make sure we draw text in the correct color and font
								context.save();
								context.translate(itemToDraw.labelX, itemToDraw.labelY);
								context.rotate(itemToDraw.rotation);
								context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
								context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
								context.textBaseline = itemToDraw.textBaseline;
								context.textAlign = itemToDraw.textAlign;

								var label = itemToDraw.label;
								if (helpers.isArray(label)) {
									for (var i = 0, y = 0; i < label.length; ++i) {
										// We just make sure the multiline element is a string here..
										context.fillText('' + label[i], 0, y);
										// apply same lineSpacing as calculated @ L#320
										y += tickFont.size * 1.5;
									}
								} else {
									context.fillText(label, 0, 0);
								}
								context.restore();
							}
						});

						if (scaleLabel.display) {
							// Draw the scale label
							var scaleLabelX;
							var scaleLabelY;
							var rotation = 0;
							var halfLineHeight = parseLineHeight(scaleLabel) / 2;

							if (isHorizontal) {
								scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width
								scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
							} else {
								var isLeft = options.position === 'left';
								scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
								scaleLabelY = me.top + (me.bottom - me.top) / 2;
								rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
							}

							context.save();
							context.translate(scaleLabelX, scaleLabelY);
							context.rotate(rotation);
							context.textAlign = 'center';
							context.textBaseline = 'middle';
							context.fillStyle = scaleLabelFontColor; // render in correct colour
							context.font = scaleLabelFont.font;
							context.fillText(scaleLabel.labelString, 0, 0);
							context.restore();
						}

						if (gridLines.drawBorder) {
							// Draw the line at the edge of the axis
							context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
							context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
							var x1 = me.left;
							var x2 = me.right;
							var y1 = me.top;
							var y2 = me.bottom;

							var aliasPixel = helpers.aliasPixel(context.lineWidth);
							if (isHorizontal) {
								y1 = y2 = options.position === 'top' ? me.bottom : me.top;
								y1 += aliasPixel;
								y2 += aliasPixel;
							} else {
								x1 = x2 = options.position === 'left' ? me.right : me.left;
								x1 += aliasPixel;
								x2 += aliasPixel;
							}

							context.beginPath();
							context.moveTo(x1, y1);
							context.lineTo(x2, y2);
							context.stroke();
						}
					}
				});
			};
		}, { "25": 25, "26": 26, "34": 34, "45": 45 }], 33: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);

			module.exports = function (Chart) {

				Chart.scaleService = {
					// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
					// use the new chart options to grab the correct scale
					constructors: {},
					// Use a registration function so that we can move to an ES6 map when we no longer need to support
					// old browsers

					// Scale config defaults
					defaults: {},
					registerScaleType: function registerScaleType(type, scaleConstructor, scaleDefaults) {
						this.constructors[type] = scaleConstructor;
						this.defaults[type] = helpers.clone(scaleDefaults);
					},
					getScaleConstructor: function getScaleConstructor(type) {
						return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
					},
					getScaleDefaults: function getScaleDefaults(type) {
						// Return the scale defaults merged with the global settings so that we always use the latest ones
						return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
					},
					updateScaleDefaults: function updateScaleDefaults(type, additions) {
						var me = this;
						if (me.defaults.hasOwnProperty(type)) {
							me.defaults[type] = helpers.extend(me.defaults[type], additions);
						}
					},
					addScalesToLayout: function addScalesToLayout(chart) {
						// Adds each scale to the chart.boxes array to be sized accordingly
						helpers.each(chart.scales, function (scale) {
							// Set ILayoutItem parameters for backwards compatibility
							scale.fullWidth = scale.options.fullWidth;
							scale.position = scale.options.position;
							scale.weight = scale.options.weight;
							Chart.layoutService.addBox(chart, scale);
						});
					}
				};
			};
		}, { "25": 25, "45": 45 }], 34: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			/**
    * Namespace to hold static tick generation functions
    * @namespace Chart.Ticks
    */
			module.exports = {
				/**
     * Namespace to hold generators for different types of ticks
     * @namespace Chart.Ticks.generators
     */
				generators: {
					/**
      * Interface for the options provided to the numeric tick generator
      * @interface INumericTickGenerationOptions
      */
					/**
      * The maximum number of ticks to display
      * @name INumericTickGenerationOptions#maxTicks
      * @type Number
      */
					/**
      * The distance between each tick.
      * @name INumericTickGenerationOptions#stepSize
      * @type Number
      * @optional
      */
					/**
      * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
      * @name INumericTickGenerationOptions#min
      * @type Number
      * @optional
      */
					/**
      * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
      * @name INumericTickGenerationOptions#max
      * @type Number
      * @optional
      */

					/**
      * Generate a set of linear ticks
      * @method Chart.Ticks.generators.linear
      * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
      * @param dataRange {IRange} the range of the data
      * @returns {Array<Number>} array of tick values
      */
					linear: function linear(generationOptions, dataRange) {
						var ticks = [];
						// To get a "nice" value for the tick spacing, we will use the appropriately named
						// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
						// for details.

						var spacing;
						if (generationOptions.stepSize && generationOptions.stepSize > 0) {
							spacing = generationOptions.stepSize;
						} else {
							var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
							spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
						}
						var niceMin = Math.floor(dataRange.min / spacing) * spacing;
						var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

						// If min, max and stepSize is set and they make an evenly spaced scale use it.
						if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
							// If very close to our whole number, use it.
							if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
								niceMin = generationOptions.min;
								niceMax = generationOptions.max;
							}
						}

						var numSpaces = (niceMax - niceMin) / spacing;
						// If very close to our rounded value, use it.
						if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
							numSpaces = Math.round(numSpaces);
						} else {
							numSpaces = Math.ceil(numSpaces);
						}

						// Put the values into the ticks array
						ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
						for (var j = 1; j < numSpaces; ++j) {
							ticks.push(niceMin + j * spacing);
						}
						ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

						return ticks;
					},

					/**
      * Generate a set of logarithmic ticks
      * @method Chart.Ticks.generators.logarithmic
      * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
      * @param dataRange {IRange} the range of the data
      * @returns {Array<Number>} array of tick values
      */
					logarithmic: function logarithmic(generationOptions, dataRange) {
						var ticks = [];
						var valueOrDefault = helpers.valueOrDefault;

						// Figure out what the max number of ticks we can support it is based on the size of
						// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
						// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
						// the graph
						var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

						var endExp = Math.floor(helpers.log10(dataRange.max));
						var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
						var exp, significand;

						if (tickVal === 0) {
							exp = Math.floor(helpers.log10(dataRange.minNotZero));
							significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

							ticks.push(tickVal);
							tickVal = significand * Math.pow(10, exp);
						} else {
							exp = Math.floor(helpers.log10(tickVal));
							significand = Math.floor(tickVal / Math.pow(10, exp));
						}

						do {
							ticks.push(tickVal);

							++significand;
							if (significand === 10) {
								significand = 1;
								++exp;
							}

							tickVal = significand * Math.pow(10, exp);
						} while (exp < endExp || exp === endExp && significand < endSignificand);

						var lastTick = valueOrDefault(generationOptions.max, tickVal);
						ticks.push(lastTick);

						return ticks;
					}
				},

				/**
     * Namespace to hold formatters for different types of ticks
     * @namespace Chart.Ticks.formatters
     */
				formatters: {
					/**
      * Formatter for value labels
      * @method Chart.Ticks.formatters.values
      * @param value the value to display
      * @return {String|Array} the label to display
      */
					values: function values(value) {
						return helpers.isArray(value) ? value : '' + value;
					},

					/**
      * Formatter for linear numeric ticks
      * @method Chart.Ticks.formatters.linear
      * @param tickValue {Number} the value to be formatted
      * @param index {Number} the position of the tickValue parameter in the ticks array
      * @param ticks {Array<Number>} the list of ticks being converted
      * @return {String} string representation of the tickValue parameter
      */
					linear: function linear(tickValue, index, ticks) {
						// If we have lots of ticks, don't use the ones
						var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

						// If we have a number like 2.5 as the delta, figure out how many decimal places we need
						if (Math.abs(delta) > 1) {
							if (tickValue !== Math.floor(tickValue)) {
								// not an integer
								delta = tickValue - Math.floor(tickValue);
							}
						}

						var logDelta = helpers.log10(Math.abs(delta));
						var tickString = '';

						if (tickValue !== 0) {
							var numDecimal = -1 * Math.floor(logDelta);
							numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
							tickString = tickValue.toFixed(numDecimal);
						} else {
							tickString = '0'; // never show decimal places for 0
						}

						return tickString;
					},

					logarithmic: function logarithmic(tickValue, index, ticks) {
						var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));

						if (tickValue === 0) {
							return '0';
						} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
							return tickValue.toExponential();
						}
						return '';
					}
				}
			};
		}, { "45": 45 }], 35: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				tooltips: {
					enabled: true,
					custom: null,
					mode: 'nearest',
					position: 'average',
					intersect: true,
					backgroundColor: 'rgba(0,0,0,0.8)',
					titleFontStyle: 'bold',
					titleSpacing: 2,
					titleMarginBottom: 6,
					titleFontColor: '#fff',
					titleAlign: 'left',
					bodySpacing: 2,
					bodyFontColor: '#fff',
					bodyAlign: 'left',
					footerFontStyle: 'bold',
					footerSpacing: 2,
					footerMarginTop: 6,
					footerFontColor: '#fff',
					footerAlign: 'left',
					yPadding: 6,
					xPadding: 6,
					caretPadding: 2,
					caretSize: 5,
					cornerRadius: 6,
					multiKeyBackground: '#fff',
					displayColors: true,
					borderColor: 'rgba(0,0,0,0)',
					borderWidth: 0,
					callbacks: {
						// Args are: (tooltipItems, data)
						beforeTitle: helpers.noop,
						title: function title(tooltipItems, data) {
							// Pick first xLabel for now
							var title = '';
							var labels = data.labels;
							var labelCount = labels ? labels.length : 0;

							if (tooltipItems.length > 0) {
								var item = tooltipItems[0];

								if (item.xLabel) {
									title = item.xLabel;
								} else if (labelCount > 0 && item.index < labelCount) {
									title = labels[item.index];
								}
							}

							return title;
						},
						afterTitle: helpers.noop,

						// Args are: (tooltipItems, data)
						beforeBody: helpers.noop,

						// Args are: (tooltipItem, data)
						beforeLabel: helpers.noop,
						label: function label(tooltipItem, data) {
							var label = data.datasets[tooltipItem.datasetIndex].label || '';

							if (label) {
								label += ': ';
							}
							label += tooltipItem.yLabel;
							return label;
						},
						labelColor: function labelColor(tooltipItem, chart) {
							var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
							var activeElement = meta.data[tooltipItem.index];
							var view = activeElement._view;
							return {
								borderColor: view.borderColor,
								backgroundColor: view.backgroundColor
							};
						},
						labelTextColor: function labelTextColor() {
							return this._options.bodyFontColor;
						},
						afterLabel: helpers.noop,

						// Args are: (tooltipItems, data)
						afterBody: helpers.noop,

						// Args are: (tooltipItems, data)
						beforeFooter: helpers.noop,
						footer: helpers.noop,
						afterFooter: helpers.noop
					}
				}
			});

			module.exports = function (Chart) {

				/**
    	 * Helper method to merge the opacity into a color
    	 */
				function mergeOpacity(colorString, opacity) {
					var color = helpers.color(colorString);
					return color.alpha(opacity * color.alpha()).rgbaString();
				}

				// Helper to push or concat based on if the 2nd parameter is an array or not
				function pushOrConcat(base, toPush) {
					if (toPush) {
						if (helpers.isArray(toPush)) {
							// base = base.concat(toPush);
							Array.prototype.push.apply(base, toPush);
						} else {
							base.push(toPush);
						}
					}

					return base;
				}

				// Private helper to create a tooltip item model
				// @param element : the chart element (point, arc, bar) to create the tooltip item for
				// @return : new tooltip item
				function createTooltipItem(element) {
					var xScale = element._xScale;
					var yScale = element._yScale || element._scale; // handle radar || polarArea charts
					var index = element._index;
					var datasetIndex = element._datasetIndex;

					return {
						xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
						yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
						index: index,
						datasetIndex: datasetIndex,
						x: element._model.x,
						y: element._model.y
					};
				}

				/**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {Object} the tooltip options
     */
				function getBaseModel(tooltipOpts) {
					var globalDefaults = defaults.global;
					var valueOrDefault = helpers.valueOrDefault;

					return {
						// Positioning
						xPadding: tooltipOpts.xPadding,
						yPadding: tooltipOpts.yPadding,
						xAlign: tooltipOpts.xAlign,
						yAlign: tooltipOpts.yAlign,

						// Body
						bodyFontColor: tooltipOpts.bodyFontColor,
						_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
						_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
						_bodyAlign: tooltipOpts.bodyAlign,
						bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
						bodySpacing: tooltipOpts.bodySpacing,

						// Title
						titleFontColor: tooltipOpts.titleFontColor,
						_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
						_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
						titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
						_titleAlign: tooltipOpts.titleAlign,
						titleSpacing: tooltipOpts.titleSpacing,
						titleMarginBottom: tooltipOpts.titleMarginBottom,

						// Footer
						footerFontColor: tooltipOpts.footerFontColor,
						_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
						_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
						footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
						_footerAlign: tooltipOpts.footerAlign,
						footerSpacing: tooltipOpts.footerSpacing,
						footerMarginTop: tooltipOpts.footerMarginTop,

						// Appearance
						caretSize: tooltipOpts.caretSize,
						cornerRadius: tooltipOpts.cornerRadius,
						backgroundColor: tooltipOpts.backgroundColor,
						opacity: 0,
						legendColorBackground: tooltipOpts.multiKeyBackground,
						displayColors: tooltipOpts.displayColors,
						borderColor: tooltipOpts.borderColor,
						borderWidth: tooltipOpts.borderWidth
					};
				}

				/**
     * Get the size of the tooltip
     */
				function getTooltipSize(tooltip, model) {
					var ctx = tooltip._chart.ctx;

					var height = model.yPadding * 2; // Tooltip Padding
					var width = 0;

					// Count of all lines in the body
					var body = model.body;
					var combinedBodyLength = body.reduce(function (count, bodyItem) {
						return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
					}, 0);
					combinedBodyLength += model.beforeBody.length + model.afterBody.length;

					var titleLineCount = model.title.length;
					var footerLineCount = model.footer.length;
					var titleFontSize = model.titleFontSize;
					var bodyFontSize = model.bodyFontSize;
					var footerFontSize = model.footerFontSize;

					height += titleLineCount * titleFontSize; // Title Lines
					height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
					height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
					height += combinedBodyLength * bodyFontSize; // Body Lines
					height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
					height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
					height += footerLineCount * footerFontSize; // Footer Lines
					height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

					// Title width
					var widthPadding = 0;
					var maxLineWidth = function maxLineWidth(line) {
						width = Math.max(width, ctx.measureText(line).width + widthPadding);
					};

					ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
					helpers.each(model.title, maxLineWidth);

					// Body width
					ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
					helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

					// Body lines may include some extra width due to the color box
					widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
					helpers.each(body, function (bodyItem) {
						helpers.each(bodyItem.before, maxLineWidth);
						helpers.each(bodyItem.lines, maxLineWidth);
						helpers.each(bodyItem.after, maxLineWidth);
					});

					// Reset back to 0
					widthPadding = 0;

					// Footer width
					ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
					helpers.each(model.footer, maxLineWidth);

					// Add padding
					width += 2 * model.xPadding;

					return {
						width: width,
						height: height
					};
				}

				/**
     * Helper to get the alignment of a tooltip given the size
     */
				function determineAlignment(tooltip, size) {
					var model = tooltip._model;
					var chart = tooltip._chart;
					var chartArea = tooltip._chart.chartArea;
					var xAlign = 'center';
					var yAlign = 'center';

					if (model.y < size.height) {
						yAlign = 'top';
					} else if (model.y > chart.height - size.height) {
						yAlign = 'bottom';
					}

					var lf, rf; // functions to determine left, right alignment
					var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
					var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
					var midX = (chartArea.left + chartArea.right) / 2;
					var midY = (chartArea.top + chartArea.bottom) / 2;

					if (yAlign === 'center') {
						lf = function lf(x) {
							return x <= midX;
						};
						rf = function rf(x) {
							return x > midX;
						};
					} else {
						lf = function lf(x) {
							return x <= size.width / 2;
						};
						rf = function rf(x) {
							return x >= chart.width - size.width / 2;
						};
					}

					olf = function olf(x) {
						return x + size.width > chart.width;
					};
					orf = function orf(x) {
						return x - size.width < 0;
					};
					yf = function yf(y) {
						return y <= midY ? 'top' : 'bottom';
					};

					if (lf(model.x)) {
						xAlign = 'left';

						// Is tooltip too wide and goes over the right side of the chart.?
						if (olf(model.x)) {
							xAlign = 'center';
							yAlign = yf(model.y);
						}
					} else if (rf(model.x)) {
						xAlign = 'right';

						// Is tooltip too wide and goes outside left edge of canvas?
						if (orf(model.x)) {
							xAlign = 'center';
							yAlign = yf(model.y);
						}
					}

					var opts = tooltip._options;
					return {
						xAlign: opts.xAlign ? opts.xAlign : xAlign,
						yAlign: opts.yAlign ? opts.yAlign : yAlign
					};
				}

				/**
     * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */
				function getBackgroundPoint(vm, size, alignment) {
					// Background Position
					var x = vm.x;
					var y = vm.y;

					var caretSize = vm.caretSize;
					var caretPadding = vm.caretPadding;
					var cornerRadius = vm.cornerRadius;
					var xAlign = alignment.xAlign;
					var yAlign = alignment.yAlign;
					var paddingAndSize = caretSize + caretPadding;
					var radiusAndPadding = cornerRadius + caretPadding;

					if (xAlign === 'right') {
						x -= size.width;
					} else if (xAlign === 'center') {
						x -= size.width / 2;
					}

					if (yAlign === 'top') {
						y += paddingAndSize;
					} else if (yAlign === 'bottom') {
						y -= size.height + paddingAndSize;
					} else {
						y -= size.height / 2;
					}

					if (yAlign === 'center') {
						if (xAlign === 'left') {
							x += paddingAndSize;
						} else if (xAlign === 'right') {
							x -= paddingAndSize;
						}
					} else if (xAlign === 'left') {
						x -= radiusAndPadding;
					} else if (xAlign === 'right') {
						x += radiusAndPadding;
					}

					return {
						x: x,
						y: y
					};
				}

				Chart.Tooltip = Element.extend({
					initialize: function initialize() {
						this._model = getBaseModel(this._options);
					},

					// Get the title
					// Args are: (tooltipItem, data)
					getTitle: function getTitle() {
						var me = this;
						var opts = me._options;
						var callbacks = opts.callbacks;

						var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
						var title = callbacks.title.apply(me, arguments);
						var afterTitle = callbacks.afterTitle.apply(me, arguments);

						var lines = [];
						lines = pushOrConcat(lines, beforeTitle);
						lines = pushOrConcat(lines, title);
						lines = pushOrConcat(lines, afterTitle);

						return lines;
					},

					// Args are: (tooltipItem, data)
					getBeforeBody: function getBeforeBody() {
						var lines = this._options.callbacks.beforeBody.apply(this, arguments);
						return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
					},

					// Args are: (tooltipItem, data)
					getBody: function getBody(tooltipItems, data) {
						var me = this;
						var callbacks = me._options.callbacks;
						var bodyItems = [];

						helpers.each(tooltipItems, function (tooltipItem) {
							var bodyItem = {
								before: [],
								lines: [],
								after: []
							};
							pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
							pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
							pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

							bodyItems.push(bodyItem);
						});

						return bodyItems;
					},

					// Args are: (tooltipItem, data)
					getAfterBody: function getAfterBody() {
						var lines = this._options.callbacks.afterBody.apply(this, arguments);
						return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
					},

					// Get the footer and beforeFooter and afterFooter lines
					// Args are: (tooltipItem, data)
					getFooter: function getFooter() {
						var me = this;
						var callbacks = me._options.callbacks;

						var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
						var footer = callbacks.footer.apply(me, arguments);
						var afterFooter = callbacks.afterFooter.apply(me, arguments);

						var lines = [];
						lines = pushOrConcat(lines, beforeFooter);
						lines = pushOrConcat(lines, footer);
						lines = pushOrConcat(lines, afterFooter);

						return lines;
					},

					update: function update(changed) {
						var me = this;
						var opts = me._options;

						// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
						// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
						// which breaks any animations.
						var existingModel = me._model;
						var model = me._model = getBaseModel(opts);
						var active = me._active;

						var data = me._data;

						// In the case where active.length === 0 we need to keep these at existing values for good animations
						var alignment = {
							xAlign: existingModel.xAlign,
							yAlign: existingModel.yAlign
						};
						var backgroundPoint = {
							x: existingModel.x,
							y: existingModel.y
						};
						var tooltipSize = {
							width: existingModel.width,
							height: existingModel.height
						};
						var tooltipPosition = {
							x: existingModel.caretX,
							y: existingModel.caretY
						};

						var i, len;

						if (active.length) {
							model.opacity = 1;

							var labelColors = [];
							var labelTextColors = [];
							tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);

							var tooltipItems = [];
							for (i = 0, len = active.length; i < len; ++i) {
								tooltipItems.push(createTooltipItem(active[i]));
							}

							// If the user provided a filter function, use it to modify the tooltip items
							if (opts.filter) {
								tooltipItems = tooltipItems.filter(function (a) {
									return opts.filter(a, data);
								});
							}

							// If the user provided a sorting function, use it to modify the tooltip items
							if (opts.itemSort) {
								tooltipItems = tooltipItems.sort(function (a, b) {
									return opts.itemSort(a, b, data);
								});
							}

							// Determine colors for boxes
							helpers.each(tooltipItems, function (tooltipItem) {
								labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
								labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
							});

							// Build the Text Lines
							model.title = me.getTitle(tooltipItems, data);
							model.beforeBody = me.getBeforeBody(tooltipItems, data);
							model.body = me.getBody(tooltipItems, data);
							model.afterBody = me.getAfterBody(tooltipItems, data);
							model.footer = me.getFooter(tooltipItems, data);

							// Initial positioning and colors
							model.x = Math.round(tooltipPosition.x);
							model.y = Math.round(tooltipPosition.y);
							model.caretPadding = opts.caretPadding;
							model.labelColors = labelColors;
							model.labelTextColors = labelTextColors;

							// data points
							model.dataPoints = tooltipItems;

							// We need to determine alignment of the tooltip
							tooltipSize = getTooltipSize(this, model);
							alignment = determineAlignment(this, tooltipSize);
							// Final Size and Position
							backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
						} else {
							model.opacity = 0;
						}

						model.xAlign = alignment.xAlign;
						model.yAlign = alignment.yAlign;
						model.x = backgroundPoint.x;
						model.y = backgroundPoint.y;
						model.width = tooltipSize.width;
						model.height = tooltipSize.height;

						// Point where the caret on the tooltip points to
						model.caretX = tooltipPosition.x;
						model.caretY = tooltipPosition.y;

						me._model = model;

						if (changed && opts.custom) {
							opts.custom.call(me, model);
						}

						return me;
					},
					drawCaret: function drawCaret(tooltipPoint, size) {
						var ctx = this._chart.ctx;
						var vm = this._view;
						var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

						ctx.lineTo(caretPosition.x1, caretPosition.y1);
						ctx.lineTo(caretPosition.x2, caretPosition.y2);
						ctx.lineTo(caretPosition.x3, caretPosition.y3);
					},
					getCaretPosition: function getCaretPosition(tooltipPoint, size, vm) {
						var x1, x2, x3, y1, y2, y3;
						var caretSize = vm.caretSize;
						var cornerRadius = vm.cornerRadius;
						var xAlign = vm.xAlign;
						var yAlign = vm.yAlign;
						var ptX = tooltipPoint.x;
						var ptY = tooltipPoint.y;
						var width = size.width;
						var height = size.height;

						if (yAlign === 'center') {
							y2 = ptY + height / 2;

							if (xAlign === 'left') {
								x1 = ptX;
								x2 = x1 - caretSize;
								x3 = x1;

								y1 = y2 + caretSize;
								y3 = y2 - caretSize;
							} else {
								x1 = ptX + width;
								x2 = x1 + caretSize;
								x3 = x1;

								y1 = y2 - caretSize;
								y3 = y2 + caretSize;
							}
						} else {
							if (xAlign === 'left') {
								x2 = ptX + cornerRadius + caretSize;
								x1 = x2 - caretSize;
								x3 = x2 + caretSize;
							} else if (xAlign === 'right') {
								x2 = ptX + width - cornerRadius - caretSize;
								x1 = x2 - caretSize;
								x3 = x2 + caretSize;
							} else {
								x2 = ptX + width / 2;
								x1 = x2 - caretSize;
								x3 = x2 + caretSize;
							}
							if (yAlign === 'top') {
								y1 = ptY;
								y2 = y1 - caretSize;
								y3 = y1;
							} else {
								y1 = ptY + height;
								y2 = y1 + caretSize;
								y3 = y1;
								// invert drawing order
								var tmp = x3;
								x3 = x1;
								x1 = tmp;
							}
						}
						return { x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3 };
					},
					drawTitle: function drawTitle(pt, vm, ctx, opacity) {
						var title = vm.title;

						if (title.length) {
							ctx.textAlign = vm._titleAlign;
							ctx.textBaseline = 'top';

							var titleFontSize = vm.titleFontSize;
							var titleSpacing = vm.titleSpacing;

							ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
							ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

							var i, len;
							for (i = 0, len = title.length; i < len; ++i) {
								ctx.fillText(title[i], pt.x, pt.y);
								pt.y += titleFontSize + titleSpacing; // Line Height and spacing

								if (i + 1 === title.length) {
									pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
								}
							}
						}
					},
					drawBody: function drawBody(pt, vm, ctx, opacity) {
						var bodyFontSize = vm.bodyFontSize;
						var bodySpacing = vm.bodySpacing;
						var body = vm.body;

						ctx.textAlign = vm._bodyAlign;
						ctx.textBaseline = 'top';
						ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

						// Before Body
						var xLinePadding = 0;
						var fillLineOfText = function fillLineOfText(line) {
							ctx.fillText(line, pt.x + xLinePadding, pt.y);
							pt.y += bodyFontSize + bodySpacing;
						};

						// Before body lines
						helpers.each(vm.beforeBody, fillLineOfText);

						var drawColorBoxes = vm.displayColors;
						xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0;

						// Draw body lines now
						helpers.each(body, function (bodyItem, i) {
							helpers.each(bodyItem.before, fillLineOfText);

							helpers.each(bodyItem.lines, function (line) {
								// Draw Legend-like boxes if needed
								if (drawColorBoxes) {
									// Fill a white rect so that colours merge nicely if the opacity is < 1
									ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
									ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

									// Border
									ctx.lineWidth = 1;
									ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
									ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

									// Inner square
									ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
									ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
									var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
									ctx.fillStyle = textColor;
								}

								fillLineOfText(line);
							});

							helpers.each(bodyItem.after, fillLineOfText);
						});

						// Reset back to 0 for after body
						xLinePadding = 0;

						// After body lines
						helpers.each(vm.afterBody, fillLineOfText);
						pt.y -= bodySpacing; // Remove last body spacing
					},
					drawFooter: function drawFooter(pt, vm, ctx, opacity) {
						var footer = vm.footer;

						if (footer.length) {
							pt.y += vm.footerMarginTop;

							ctx.textAlign = vm._footerAlign;
							ctx.textBaseline = 'top';

							ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
							ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

							helpers.each(footer, function (line) {
								ctx.fillText(line, pt.x, pt.y);
								pt.y += vm.footerFontSize + vm.footerSpacing;
							});
						}
					},
					drawBackground: function drawBackground(pt, vm, ctx, tooltipSize, opacity) {
						ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
						ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
						ctx.lineWidth = vm.borderWidth;
						var xAlign = vm.xAlign;
						var yAlign = vm.yAlign;
						var x = pt.x;
						var y = pt.y;
						var width = tooltipSize.width;
						var height = tooltipSize.height;
						var radius = vm.cornerRadius;

						ctx.beginPath();
						ctx.moveTo(x + radius, y);
						if (yAlign === 'top') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x + width - radius, y);
						ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
						if (yAlign === 'center' && xAlign === 'right') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x + width, y + height - radius);
						ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
						if (yAlign === 'bottom') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x + radius, y + height);
						ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
						if (yAlign === 'center' && xAlign === 'left') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x, y + radius);
						ctx.quadraticCurveTo(x, y, x + radius, y);
						ctx.closePath();

						ctx.fill();

						if (vm.borderWidth > 0) {
							ctx.stroke();
						}
					},
					draw: function draw() {
						var ctx = this._chart.ctx;
						var vm = this._view;

						if (vm.opacity === 0) {
							return;
						}

						var tooltipSize = {
							width: vm.width,
							height: vm.height
						};
						var pt = {
							x: vm.x,
							y: vm.y
						};

						// IE11/Edge does not like very small opacities, so snap to 0
						var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

						// Truthy/falsey value for empty tooltip
						var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

						if (this._options.enabled && hasTooltipContent) {
							// Draw Background
							this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

							// Draw Title, Body, and Footer
							pt.x += vm.xPadding;
							pt.y += vm.yPadding;

							// Titles
							this.drawTitle(pt, vm, ctx, opacity);

							// Body
							this.drawBody(pt, vm, ctx, opacity);

							// Footer
							this.drawFooter(pt, vm, ctx, opacity);
						}
					},

					/**
      * Handle an event
      * @private
      * @param {IEvent} event - The event to handle
      * @returns {Boolean} true if the tooltip changed
      */
					handleEvent: function handleEvent(e) {
						var me = this;
						var options = me._options;
						var changed = false;

						me._lastActive = me._lastActive || [];

						// Find Active Elements for tooltips
						if (e.type === 'mouseout') {
							me._active = [];
						} else {
							me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
						}

						// Remember Last Actives
						changed = !helpers.arrayEquals(me._active, me._lastActive);

						// If tooltip didn't change, do not handle the target event
						if (!changed) {
							return false;
						}

						me._lastActive = me._active;

						if (options.enabled || options.custom) {
							me._eventPosition = {
								x: e.x,
								y: e.y
							};

							var model = me._model;
							me.update(true);
							me.pivot();

							// See if our tooltip position changed
							changed |= model.x !== me._model.x || model.y !== me._model.y;
						}

						return changed;
					}
				});

				/**
     * @namespace Chart.Tooltip.positioners
     */
				Chart.Tooltip.positioners = {
					/**
      * Average mode places the tooltip at the average position of the elements shown
      * @function Chart.Tooltip.positioners.average
      * @param elements {ChartElement[]} the elements being displayed in the tooltip
      * @returns {Point} tooltip position
      */
					average: function average(elements) {
						if (!elements.length) {
							return false;
						}

						var i, len;
						var x = 0;
						var y = 0;
						var count = 0;

						for (i = 0, len = elements.length; i < len; ++i) {
							var el = elements[i];
							if (el && el.hasValue()) {
								var pos = el.tooltipPosition();
								x += pos.x;
								y += pos.y;
								++count;
							}
						}

						return {
							x: Math.round(x / count),
							y: Math.round(y / count)
						};
					},

					/**
      * Gets the tooltip position nearest of the item nearest to the event position
      * @function Chart.Tooltip.positioners.nearest
      * @param elements {Chart.Element[]} the tooltip elements
      * @param eventPosition {Point} the position of the event in canvas coordinates
      * @returns {Point} the tooltip position
      */
					nearest: function nearest(elements, eventPosition) {
						var x = eventPosition.x;
						var y = eventPosition.y;
						var minDistance = Number.POSITIVE_INFINITY;
						var i, len, nearestElement;

						for (i = 0, len = elements.length; i < len; ++i) {
							var el = elements[i];
							if (el && el.hasValue()) {
								var center = el.getCenterPoint();
								var d = helpers.distanceBetweenPoints(eventPosition, center);

								if (d < minDistance) {
									minDistance = d;
									nearestElement = el;
								}
							}
						}

						if (nearestElement) {
							var tp = nearestElement.tooltipPosition();
							x = tp.x;
							y = tp.y;
						}

						return {
							x: x,
							y: y
						};
					}
				};
			};
		}, { "25": 25, "26": 26, "45": 45 }], 36: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				elements: {
					arc: {
						backgroundColor: defaults.global.defaultColor,
						borderColor: '#fff',
						borderWidth: 2
					}
				}
			});

			module.exports = Element.extend({
				inLabelRange: function inLabelRange(mouseX) {
					var vm = this._view;

					if (vm) {
						return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
					}
					return false;
				},

				inRange: function inRange(chartX, chartY) {
					var vm = this._view;

					if (vm) {
						var pointRelativePosition = helpers.getAngleFromPoint(vm, { x: chartX, y: chartY });
						var angle = pointRelativePosition.angle;
						var distance = pointRelativePosition.distance;

						// Sanitise angle range
						var startAngle = vm.startAngle;
						var endAngle = vm.endAngle;
						while (endAngle < startAngle) {
							endAngle += 2.0 * Math.PI;
						}
						while (angle > endAngle) {
							angle -= 2.0 * Math.PI;
						}
						while (angle < startAngle) {
							angle += 2.0 * Math.PI;
						}

						// Check if within the range of the open/close angle
						var betweenAngles = angle >= startAngle && angle <= endAngle;
						var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;

						return betweenAngles && withinRadius;
					}
					return false;
				},

				getCenterPoint: function getCenterPoint() {
					var vm = this._view;
					var halfAngle = (vm.startAngle + vm.endAngle) / 2;
					var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
					return {
						x: vm.x + Math.cos(halfAngle) * halfRadius,
						y: vm.y + Math.sin(halfAngle) * halfRadius
					};
				},

				getArea: function getArea() {
					var vm = this._view;
					return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
				},

				tooltipPosition: function tooltipPosition() {
					var vm = this._view;
					var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
					var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

					return {
						x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
						y: vm.y + Math.sin(centreAngle) * rangeFromCentre
					};
				},

				draw: function draw() {
					var ctx = this._chart.ctx;
					var vm = this._view;
					var sA = vm.startAngle;
					var eA = vm.endAngle;

					ctx.beginPath();

					ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
					ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

					ctx.closePath();
					ctx.strokeStyle = vm.borderColor;
					ctx.lineWidth = vm.borderWidth;

					ctx.fillStyle = vm.backgroundColor;

					ctx.fill();
					ctx.lineJoin = 'bevel';

					if (vm.borderWidth) {
						ctx.stroke();
					}
				}
			});
		}, { "25": 25, "26": 26, "45": 45 }], 37: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			var globalDefaults = defaults.global;

			defaults._set('global', {
				elements: {
					line: {
						tension: 0.4,
						backgroundColor: globalDefaults.defaultColor,
						borderWidth: 3,
						borderColor: globalDefaults.defaultColor,
						borderCapStyle: 'butt',
						borderDash: [],
						borderDashOffset: 0.0,
						borderJoinStyle: 'miter',
						capBezierPoints: true,
						fill: true // do we fill in the area between the line and its base axis
					}
				}
			});

			module.exports = Element.extend({
				draw: function draw() {
					var me = this;
					var vm = me._view;
					var ctx = me._chart.ctx;
					var spanGaps = vm.spanGaps;
					var points = me._children.slice(); // clone array
					var globalOptionLineElements = globalDefaults.elements.line;
					var lastDrawnIndex = -1;
					var index, current, previous, currentVM;

					// If we are looping, adding the first point again
					if (me._loop && points.length) {
						points.push(points[0]);
					}

					ctx.save();

					// Stroke Line Options
					ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

					// IE 9 and 10 do not support line dash
					if (ctx.setLineDash) {
						ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
					}

					ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
					ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
					ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
					ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

					// Stroke Line
					ctx.beginPath();
					lastDrawnIndex = -1;

					for (index = 0; index < points.length; ++index) {
						current = points[index];
						previous = helpers.previousItem(points, index);
						currentVM = current._view;

						// First point moves to it's starting position no matter what
						if (index === 0) {
							if (!currentVM.skip) {
								ctx.moveTo(currentVM.x, currentVM.y);
								lastDrawnIndex = index;
							}
						} else {
							previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

							if (!currentVM.skip) {
								if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
									// There was a gap and this is the first point after the gap
									ctx.moveTo(currentVM.x, currentVM.y);
								} else {
									// Line to next point
									helpers.canvas.lineTo(ctx, previous._view, current._view);
								}
								lastDrawnIndex = index;
							}
						}
					}

					ctx.stroke();
					ctx.restore();
				}
			});
		}, { "25": 25, "26": 26, "45": 45 }], 38: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			var defaultColor = defaults.global.defaultColor;

			defaults._set('global', {
				elements: {
					point: {
						radius: 3,
						pointStyle: 'circle',
						backgroundColor: defaultColor,
						borderColor: defaultColor,
						borderWidth: 1,
						// Hover
						hitRadius: 1,
						hoverRadius: 4,
						hoverBorderWidth: 1
					}
				}
			});

			function xRange(mouseX) {
				var vm = this._view;
				return vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
			}

			function yRange(mouseY) {
				var vm = this._view;
				return vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
			}

			module.exports = Element.extend({
				inRange: function inRange(mouseX, mouseY) {
					var vm = this._view;
					return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
				},

				inLabelRange: xRange,
				inXRange: xRange,
				inYRange: yRange,

				getCenterPoint: function getCenterPoint() {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y
					};
				},

				getArea: function getArea() {
					return Math.PI * Math.pow(this._view.radius, 2);
				},

				tooltipPosition: function tooltipPosition() {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y,
						padding: vm.radius + vm.borderWidth
					};
				},

				draw: function draw(chartArea) {
					var vm = this._view;
					var model = this._model;
					var ctx = this._chart.ctx;
					var pointStyle = vm.pointStyle;
					var radius = vm.radius;
					var x = vm.x;
					var y = vm.y;
					var color = helpers.color;
					var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
					var ratio = 0;

					if (vm.skip) {
						return;
					}

					ctx.strokeStyle = vm.borderColor || defaultColor;
					ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
					ctx.fillStyle = vm.backgroundColor || defaultColor;

					// Cliping for Points.
					// going out from inner charArea?
					if (chartArea !== undefined && (model.x < chartArea.left || chartArea.right * errMargin < model.x || model.y < chartArea.top || chartArea.bottom * errMargin < model.y)) {
						// Point fade out
						if (model.x < chartArea.left) {
							ratio = (x - model.x) / (chartArea.left - model.x);
						} else if (chartArea.right * errMargin < model.x) {
							ratio = (model.x - x) / (model.x - chartArea.right);
						} else if (model.y < chartArea.top) {
							ratio = (y - model.y) / (chartArea.top - model.y);
						} else if (chartArea.bottom * errMargin < model.y) {
							ratio = (model.y - y) / (model.y - chartArea.bottom);
						}
						ratio = Math.round(ratio * 100) / 100;
						ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
						ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
					}

					helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
				}
			});
		}, { "25": 25, "26": 26, "45": 45 }], 39: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);

			defaults._set('global', {
				elements: {
					rectangle: {
						backgroundColor: defaults.global.defaultColor,
						borderColor: defaults.global.defaultColor,
						borderSkipped: 'bottom',
						borderWidth: 0
					}
				}
			});

			function isVertical(bar) {
				return bar._view.width !== undefined;
			}

			/**
    * Helper function to get the bounds of the bar regardless of the orientation
    * @param bar {Chart.Element.Rectangle} the bar
    * @return {Bounds} bounds of the bar
    * @private
    */
			function getBarBounds(bar) {
				var vm = bar._view;
				var x1, x2, y1, y2;

				if (isVertical(bar)) {
					// vertical
					var halfWidth = vm.width / 2;
					x1 = vm.x - halfWidth;
					x2 = vm.x + halfWidth;
					y1 = Math.min(vm.y, vm.base);
					y2 = Math.max(vm.y, vm.base);
				} else {
					// horizontal bar
					var halfHeight = vm.height / 2;
					x1 = Math.min(vm.x, vm.base);
					x2 = Math.max(vm.x, vm.base);
					y1 = vm.y - halfHeight;
					y2 = vm.y + halfHeight;
				}

				return {
					left: x1,
					top: y1,
					right: x2,
					bottom: y2
				};
			}

			module.exports = Element.extend({
				draw: function draw() {
					var ctx = this._chart.ctx;
					var vm = this._view;
					var left, right, top, bottom, signX, signY, borderSkipped;
					var borderWidth = vm.borderWidth;

					if (!vm.horizontal) {
						// bar
						left = vm.x - vm.width / 2;
						right = vm.x + vm.width / 2;
						top = vm.y;
						bottom = vm.base;
						signX = 1;
						signY = bottom > top ? 1 : -1;
						borderSkipped = vm.borderSkipped || 'bottom';
					} else {
						// horizontal bar
						left = vm.base;
						right = vm.x;
						top = vm.y - vm.height / 2;
						bottom = vm.y + vm.height / 2;
						signX = right > left ? 1 : -1;
						signY = 1;
						borderSkipped = vm.borderSkipped || 'left';
					}

					// Canvas doesn't allow us to stroke inside the width so we can
					// adjust the sizes to fit if we're setting a stroke on the line
					if (borderWidth) {
						// borderWidth shold be less than bar width and bar height.
						var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
						borderWidth = borderWidth > barSize ? barSize : borderWidth;
						var halfStroke = borderWidth / 2;
						// Adjust borderWidth when bar top position is near vm.base(zero).
						var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
						var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
						var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
						var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
						// not become a vertical line?
						if (borderLeft !== borderRight) {
							top = borderTop;
							bottom = borderBottom;
						}
						// not become a horizontal line?
						if (borderTop !== borderBottom) {
							left = borderLeft;
							right = borderRight;
						}
					}

					ctx.beginPath();
					ctx.fillStyle = vm.backgroundColor;
					ctx.strokeStyle = vm.borderColor;
					ctx.lineWidth = borderWidth;

					// Corner points, from bottom-left to bottom-right clockwise
					// | 1 2 |
					// | 0 3 |
					var corners = [[left, bottom], [left, top], [right, top], [right, bottom]];

					// Find first (starting) corner with fallback to 'bottom'
					var borders = ['bottom', 'left', 'top', 'right'];
					var startCorner = borders.indexOf(borderSkipped, 0);
					if (startCorner === -1) {
						startCorner = 0;
					}

					function cornerAt(index) {
						return corners[(startCorner + index) % 4];
					}

					// Draw rectangle from 'startCorner'
					var corner = cornerAt(0);
					ctx.moveTo(corner[0], corner[1]);

					for (var i = 1; i < 4; i++) {
						corner = cornerAt(i);
						ctx.lineTo(corner[0], corner[1]);
					}

					ctx.fill();
					if (borderWidth) {
						ctx.stroke();
					}
				},

				height: function height() {
					var vm = this._view;
					return vm.base - vm.y;
				},

				inRange: function inRange(mouseX, mouseY) {
					var inRange = false;

					if (this._view) {
						var bounds = getBarBounds(this);
						inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
					}

					return inRange;
				},

				inLabelRange: function inLabelRange(mouseX, mouseY) {
					var me = this;
					if (!me._view) {
						return false;
					}

					var inRange = false;
					var bounds = getBarBounds(me);

					if (isVertical(me)) {
						inRange = mouseX >= bounds.left && mouseX <= bounds.right;
					} else {
						inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
					}

					return inRange;
				},

				inXRange: function inXRange(mouseX) {
					var bounds = getBarBounds(this);
					return mouseX >= bounds.left && mouseX <= bounds.right;
				},

				inYRange: function inYRange(mouseY) {
					var bounds = getBarBounds(this);
					return mouseY >= bounds.top && mouseY <= bounds.bottom;
				},

				getCenterPoint: function getCenterPoint() {
					var vm = this._view;
					var x, y;
					if (isVertical(this)) {
						x = vm.x;
						y = (vm.y + vm.base) / 2;
					} else {
						x = (vm.x + vm.base) / 2;
						y = vm.y;
					}

					return { x: x, y: y };
				},

				getArea: function getArea() {
					var vm = this._view;
					return vm.width * Math.abs(vm.y - vm.base);
				},

				tooltipPosition: function tooltipPosition() {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y
					};
				}
			});
		}, { "25": 25, "26": 26 }], 40: [function (require, module, exports) {
			'use strict';

			module.exports = {};
			module.exports.Arc = require(36);
			module.exports.Line = require(37);
			module.exports.Point = require(38);
			module.exports.Rectangle = require(39);
		}, { "36": 36, "37": 37, "38": 38, "39": 39 }], 41: [function (require, module, exports) {
			'use strict';

			var helpers = require(42);

			/**
    * @namespace Chart.helpers.canvas
    */
			var exports = module.exports = {
				/**
     * Clears the entire canvas associated to the given `chart`.
     * @param {Chart} chart - The chart for which to clear the canvas.
     */
				clear: function clear(chart) {
					chart.ctx.clearRect(0, 0, chart.width, chart.height);
				},

				/**
     * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
     * given size (width, height) and the same `radius` for all corners.
     * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
     * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
     * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
     * @param {Number} width - The rectangle's width.
     * @param {Number} height - The rectangle's height.
     * @param {Number} radius - The rounded amount (in pixels) for the four corners.
     * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
     */
				roundedRect: function roundedRect(ctx, x, y, width, height, radius) {
					if (radius) {
						var rx = Math.min(radius, width / 2);
						var ry = Math.min(radius, height / 2);

						ctx.moveTo(x + rx, y);
						ctx.lineTo(x + width - rx, y);
						ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
						ctx.lineTo(x + width, y + height - ry);
						ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
						ctx.lineTo(x + rx, y + height);
						ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
						ctx.lineTo(x, y + ry);
						ctx.quadraticCurveTo(x, y, x + rx, y);
					} else {
						ctx.rect(x, y, width, height);
					}
				},

				drawPoint: function drawPoint(ctx, style, radius, x, y) {
					var type, edgeLength, xOffset, yOffset, height, size;

					if ((typeof style === "undefined" ? "undefined" : _typeof(style)) === 'object') {
						type = style.toString();
						if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
							ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
							return;
						}
					}

					if (isNaN(radius) || radius <= 0) {
						return;
					}

					switch (style) {
						// Default includes circle
						default:
							ctx.beginPath();
							ctx.arc(x, y, radius, 0, Math.PI * 2);
							ctx.closePath();
							ctx.fill();
							break;
						case 'triangle':
							ctx.beginPath();
							edgeLength = 3 * radius / Math.sqrt(3);
							height = edgeLength * Math.sqrt(3) / 2;
							ctx.moveTo(x - edgeLength / 2, y + height / 3);
							ctx.lineTo(x + edgeLength / 2, y + height / 3);
							ctx.lineTo(x, y - 2 * height / 3);
							ctx.closePath();
							ctx.fill();
							break;
						case 'rect':
							size = 1 / Math.SQRT2 * radius;
							ctx.beginPath();
							ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
							ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
							break;
						case 'rectRounded':
							var offset = radius / Math.SQRT2;
							var leftX = x - offset;
							var topY = y - offset;
							var sideSize = Math.SQRT2 * radius;
							ctx.beginPath();
							this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
							ctx.closePath();
							ctx.fill();
							break;
						case 'rectRot':
							size = 1 / Math.SQRT2 * radius;
							ctx.beginPath();
							ctx.moveTo(x - size, y);
							ctx.lineTo(x, y + size);
							ctx.lineTo(x + size, y);
							ctx.lineTo(x, y - size);
							ctx.closePath();
							ctx.fill();
							break;
						case 'cross':
							ctx.beginPath();
							ctx.moveTo(x, y + radius);
							ctx.lineTo(x, y - radius);
							ctx.moveTo(x - radius, y);
							ctx.lineTo(x + radius, y);
							ctx.closePath();
							break;
						case 'crossRot':
							ctx.beginPath();
							xOffset = Math.cos(Math.PI / 4) * radius;
							yOffset = Math.sin(Math.PI / 4) * radius;
							ctx.moveTo(x - xOffset, y - yOffset);
							ctx.lineTo(x + xOffset, y + yOffset);
							ctx.moveTo(x - xOffset, y + yOffset);
							ctx.lineTo(x + xOffset, y - yOffset);
							ctx.closePath();
							break;
						case 'star':
							ctx.beginPath();
							ctx.moveTo(x, y + radius);
							ctx.lineTo(x, y - radius);
							ctx.moveTo(x - radius, y);
							ctx.lineTo(x + radius, y);
							xOffset = Math.cos(Math.PI / 4) * radius;
							yOffset = Math.sin(Math.PI / 4) * radius;
							ctx.moveTo(x - xOffset, y - yOffset);
							ctx.lineTo(x + xOffset, y + yOffset);
							ctx.moveTo(x - xOffset, y + yOffset);
							ctx.lineTo(x + xOffset, y - yOffset);
							ctx.closePath();
							break;
						case 'line':
							ctx.beginPath();
							ctx.moveTo(x - radius, y);
							ctx.lineTo(x + radius, y);
							ctx.closePath();
							break;
						case 'dash':
							ctx.beginPath();
							ctx.moveTo(x, y);
							ctx.lineTo(x + radius, y);
							ctx.closePath();
							break;
					}

					ctx.stroke();
				},

				clipArea: function clipArea(ctx, area) {
					ctx.save();
					ctx.beginPath();
					ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
					ctx.clip();
				},

				unclipArea: function unclipArea(ctx) {
					ctx.restore();
				},

				lineTo: function lineTo(ctx, previous, target, flip) {
					if (target.steppedLine) {
						if (target.steppedLine === 'after' && !flip || target.steppedLine !== 'after' && flip) {
							ctx.lineTo(previous.x, target.y);
						} else {
							ctx.lineTo(target.x, previous.y);
						}
						ctx.lineTo(target.x, target.y);
						return;
					}

					if (!target.tension) {
						ctx.lineTo(target.x, target.y);
						return;
					}

					ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
				}
			};

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
    * @namespace Chart.helpers.clear
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.clear = exports.clear;

			/**
    * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
    * @namespace Chart.helpers.drawRoundedRectangle
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.drawRoundedRectangle = function (ctx) {
				ctx.beginPath();
				exports.roundedRect.apply(exports, arguments);
				ctx.closePath();
			};
		}, { "42": 42 }], 42: [function (require, module, exports) {
			'use strict';

			/**
    * @namespace Chart.helpers
    */

			var helpers = {
				/**
     * An empty function that can be used, for example, for optional callback.
     */
				noop: function noop() {},

				/**
     * Returns a unique id, sequentially generated from a global variable.
     * @returns {Number}
     * @function
     */
				uid: function () {
					var id = 0;
					return function () {
						return id++;
					};
				}(),

				/**
     * Returns true if `value` is neither null nor undefined, else returns false.
     * @param {*} value - The value to test.
     * @returns {Boolean}
     * @since 2.7.0
     */
				isNullOrUndef: function isNullOrUndef(value) {
					return value === null || typeof value === 'undefined';
				},

				/**
     * Returns true if `value` is an array, else returns false.
     * @param {*} value - The value to test.
     * @returns {Boolean}
     * @function
     */
				isArray: Array.isArray ? Array.isArray : function (value) {
					return Object.prototype.toString.call(value) === '[object Array]';
				},

				/**
     * Returns true if `value` is an object (excluding null), else returns false.
     * @param {*} value - The value to test.
     * @returns {Boolean}
     * @since 2.7.0
     */
				isObject: function isObject(value) {
					return value !== null && Object.prototype.toString.call(value) === '[object Object]';
				},

				/**
     * Returns `value` if defined, else returns `defaultValue`.
     * @param {*} value - The value to return if defined.
     * @param {*} defaultValue - The value to return if `value` is undefined.
     * @returns {*}
     */
				valueOrDefault: function valueOrDefault(value, defaultValue) {
					return typeof value === 'undefined' ? defaultValue : value;
				},

				/**
     * Returns value at the given `index` in array if defined, else returns `defaultValue`.
     * @param {Array} value - The array to lookup for value at `index`.
     * @param {Number} index - The index in `value` to lookup for value.
     * @param {*} defaultValue - The value to return if `value[index]` is undefined.
     * @returns {*}
     */
				valueAtIndexOrDefault: function valueAtIndexOrDefault(value, index, defaultValue) {
					return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
				},

				/**
     * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
     * value returned by `fn`. If `fn` is not a function, this method returns undefined.
     * @param {Function} fn - The function to call.
     * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
     * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @returns {*}
     */
				callback: function callback(fn, args, thisArg) {
					if (fn && typeof fn.call === 'function') {
						return fn.apply(thisArg, args);
					}
				},

				/**
     * Note(SB) for performance sake, this method should only be used when loopable type
     * is unknown or in none intensive code (not called often and small loopable). Else
     * it's preferable to use a regular for() loop and save extra function calls.
     * @param {Object|Array} loopable - The object or array to be iterated.
     * @param {Function} fn - The function to call for each item.
     * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
     */
				each: function each(loopable, fn, thisArg, reverse) {
					var i, len, keys;
					if (helpers.isArray(loopable)) {
						len = loopable.length;
						if (reverse) {
							for (i = len - 1; i >= 0; i--) {
								fn.call(thisArg, loopable[i], i);
							}
						} else {
							for (i = 0; i < len; i++) {
								fn.call(thisArg, loopable[i], i);
							}
						}
					} else if (helpers.isObject(loopable)) {
						keys = Object.keys(loopable);
						len = keys.length;
						for (i = 0; i < len; i++) {
							fn.call(thisArg, loopable[keys[i]], keys[i]);
						}
					}
				},

				/**
     * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
     * @see http://stackoverflow.com/a/14853974
     * @param {Array} a0 - The array to compare
     * @param {Array} a1 - The array to compare
     * @returns {Boolean}
     */
				arrayEquals: function arrayEquals(a0, a1) {
					var i, ilen, v0, v1;

					if (!a0 || !a1 || a0.length !== a1.length) {
						return false;
					}

					for (i = 0, ilen = a0.length; i < ilen; ++i) {
						v0 = a0[i];
						v1 = a1[i];

						if (v0 instanceof Array && v1 instanceof Array) {
							if (!helpers.arrayEquals(v0, v1)) {
								return false;
							}
						} else if (v0 !== v1) {
							// NOTE: two different object instances will never be equal: {x:20} != {x:20}
							return false;
						}
					}

					return true;
				},

				/**
     * Returns a deep copy of `source` without keeping references on objects and arrays.
     * @param {*} source - The value to clone.
     * @returns {*}
     */
				clone: function clone(source) {
					if (helpers.isArray(source)) {
						return source.map(helpers.clone);
					}

					if (helpers.isObject(source)) {
						var target = {};
						var keys = Object.keys(source);
						var klen = keys.length;
						var k = 0;

						for (; k < klen; ++k) {
							target[keys[k]] = helpers.clone(source[keys[k]]);
						}

						return target;
					}

					return source;
				},

				/**
     * The default merger when Chart.helpers.merge is called without merger option.
     * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
     * @private
     */
				_merger: function _merger(key, target, source, options) {
					var tval = target[key];
					var sval = source[key];

					if (helpers.isObject(tval) && helpers.isObject(sval)) {
						helpers.merge(tval, sval, options);
					} else {
						target[key] = helpers.clone(sval);
					}
				},

				/**
     * Merges source[key] in target[key] only if target[key] is undefined.
     * @private
     */
				_mergerIf: function _mergerIf(key, target, source) {
					var tval = target[key];
					var sval = source[key];

					if (helpers.isObject(tval) && helpers.isObject(sval)) {
						helpers.mergeIf(tval, sval);
					} else if (!target.hasOwnProperty(key)) {
						target[key] = helpers.clone(sval);
					}
				},

				/**
     * Recursively deep copies `source` properties into `target` with the given `options`.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {Object} target - The target object in which all sources are merged into.
     * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
     * @param {Object} [options] - Merging options:
     * @param {Function} [options.merger] - The merge method (key, target, source, options)
     * @returns {Object} The `target` object.
     */
				merge: function merge(target, source, options) {
					var sources = helpers.isArray(source) ? source : [source];
					var ilen = sources.length;
					var merge, i, keys, klen, k;

					if (!helpers.isObject(target)) {
						return target;
					}

					options = options || {};
					merge = options.merger || helpers._merger;

					for (i = 0; i < ilen; ++i) {
						source = sources[i];
						if (!helpers.isObject(source)) {
							continue;
						}

						keys = Object.keys(source);
						for (k = 0, klen = keys.length; k < klen; ++k) {
							merge(keys[k], target, source, options);
						}
					}

					return target;
				},

				/**
     * Recursively deep copies `source` properties into `target` *only* if not defined in target.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {Object} target - The target object in which all sources are merged into.
     * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
     * @returns {Object} The `target` object.
     */
				mergeIf: function mergeIf(target, source) {
					return helpers.merge(target, source, { merger: helpers._mergerIf });
				}
			};

			module.exports = helpers;

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.callback instead.
    * @function Chart.helpers.callCallback
    * @deprecated since version 2.6.0
    * @todo remove at version 3
    * @private
    */
			helpers.callCallback = helpers.callback;

			/**
    * Provided for backward compatibility, use Array.prototype.indexOf instead.
    * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
    * @function Chart.helpers.indexOf
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.indexOf = function (array, item, fromIndex) {
				return Array.prototype.indexOf.call(array, item, fromIndex);
			};

			/**
    * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
    * @function Chart.helpers.getValueOrDefault
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.getValueOrDefault = helpers.valueOrDefault;

			/**
    * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
    * @function Chart.helpers.getValueAtIndexOrDefault
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
		}, {}], 43: [function (require, module, exports) {
			'use strict';

			var helpers = require(42);

			/**
    * Easing functions adapted from Robert Penner's easing equations.
    * @namespace Chart.helpers.easingEffects
    * @see http://www.robertpenner.com/easing/
    */
			var effects = {
				linear: function linear(t) {
					return t;
				},

				easeInQuad: function easeInQuad(t) {
					return t * t;
				},

				easeOutQuad: function easeOutQuad(t) {
					return -t * (t - 2);
				},

				easeInOutQuad: function easeInOutQuad(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t;
					}
					return -0.5 * (--t * (t - 2) - 1);
				},

				easeInCubic: function easeInCubic(t) {
					return t * t * t;
				},

				easeOutCubic: function easeOutCubic(t) {
					return (t = t - 1) * t * t + 1;
				},

				easeInOutCubic: function easeInOutCubic(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t * t;
					}
					return 0.5 * ((t -= 2) * t * t + 2);
				},

				easeInQuart: function easeInQuart(t) {
					return t * t * t * t;
				},

				easeOutQuart: function easeOutQuart(t) {
					return -((t = t - 1) * t * t * t - 1);
				},

				easeInOutQuart: function easeInOutQuart(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t * t * t;
					}
					return -0.5 * ((t -= 2) * t * t * t - 2);
				},

				easeInQuint: function easeInQuint(t) {
					return t * t * t * t * t;
				},

				easeOutQuint: function easeOutQuint(t) {
					return (t = t - 1) * t * t * t * t + 1;
				},

				easeInOutQuint: function easeInOutQuint(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t * t * t * t;
					}
					return 0.5 * ((t -= 2) * t * t * t * t + 2);
				},

				easeInSine: function easeInSine(t) {
					return -Math.cos(t * (Math.PI / 2)) + 1;
				},

				easeOutSine: function easeOutSine(t) {
					return Math.sin(t * (Math.PI / 2));
				},

				easeInOutSine: function easeInOutSine(t) {
					return -0.5 * (Math.cos(Math.PI * t) - 1);
				},

				easeInExpo: function easeInExpo(t) {
					return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
				},

				easeOutExpo: function easeOutExpo(t) {
					return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
				},

				easeInOutExpo: function easeInOutExpo(t) {
					if (t === 0) {
						return 0;
					}
					if (t === 1) {
						return 1;
					}
					if ((t /= 0.5) < 1) {
						return 0.5 * Math.pow(2, 10 * (t - 1));
					}
					return 0.5 * (-Math.pow(2, -10 * --t) + 2);
				},

				easeInCirc: function easeInCirc(t) {
					if (t >= 1) {
						return t;
					}
					return -(Math.sqrt(1 - t * t) - 1);
				},

				easeOutCirc: function easeOutCirc(t) {
					return Math.sqrt(1 - (t = t - 1) * t);
				},

				easeInOutCirc: function easeInOutCirc(t) {
					if ((t /= 0.5) < 1) {
						return -0.5 * (Math.sqrt(1 - t * t) - 1);
					}
					return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
				},

				easeInElastic: function easeInElastic(t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if (t === 1) {
						return 1;
					}
					if (!p) {
						p = 0.3;
					}
					if (a < 1) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
				},

				easeOutElastic: function easeOutElastic(t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if (t === 1) {
						return 1;
					}
					if (!p) {
						p = 0.3;
					}
					if (a < 1) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
				},

				easeInOutElastic: function easeInOutElastic(t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if ((t /= 0.5) === 2) {
						return 1;
					}
					if (!p) {
						p = 0.45;
					}
					if (a < 1) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					if (t < 1) {
						return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
					}
					return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
				},
				easeInBack: function easeInBack(t) {
					var s = 1.70158;
					return t * t * ((s + 1) * t - s);
				},

				easeOutBack: function easeOutBack(t) {
					var s = 1.70158;
					return (t = t - 1) * t * ((s + 1) * t + s) + 1;
				},

				easeInOutBack: function easeInOutBack(t) {
					var s = 1.70158;
					if ((t /= 0.5) < 1) {
						return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
					}
					return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
				},

				easeInBounce: function easeInBounce(t) {
					return 1 - effects.easeOutBounce(1 - t);
				},

				easeOutBounce: function easeOutBounce(t) {
					if (t < 1 / 2.75) {
						return 7.5625 * t * t;
					}
					if (t < 2 / 2.75) {
						return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
					}
					if (t < 2.5 / 2.75) {
						return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
					}
					return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
				},

				easeInOutBounce: function easeInOutBounce(t) {
					if (t < 0.5) {
						return effects.easeInBounce(t * 2) * 0.5;
					}
					return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
				}
			};

			module.exports = {
				effects: effects
			};

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
    * @function Chart.helpers.easingEffects
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.easingEffects = effects;
		}, { "42": 42 }], 44: [function (require, module, exports) {
			'use strict';

			var helpers = require(42);

			/**
    * @alias Chart.helpers.options
    * @namespace
    */
			module.exports = {
				/**
     * Converts the given line height `value` in pixels for a specific font `size`.
     * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
     * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
     * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
     * @since 2.7.0
     */
				toLineHeight: function toLineHeight(value, size) {
					var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
					if (!matches || matches[1] === 'normal') {
						return size * 1.2;
					}

					value = +matches[2];

					switch (matches[3]) {
						case 'px':
							return value;
						case '%':
							value /= 100;
							break;
						default:
							break;
					}

					return size * value;
				},

				/**
     * Converts the given value into a padding object with pre-computed width/height.
     * @param {Number|Object} value - If a number, set the value to all TRBL component,
     *  else, if and object, use defined properties and sets undefined ones to 0.
     * @returns {Object} The padding values (top, right, bottom, left, width, height)
     * @since 2.7.0
     */
				toPadding: function toPadding(value) {
					var t, r, b, l;

					if (helpers.isObject(value)) {
						t = +value.top || 0;
						r = +value.right || 0;
						b = +value.bottom || 0;
						l = +value.left || 0;
					} else {
						t = r = b = l = +value || 0;
					}

					return {
						top: t,
						right: r,
						bottom: b,
						left: l,
						height: t + b,
						width: l + r
					};
				},

				/**
     * Evaluates the given `inputs` sequentially and returns the first defined value.
     * @param {Array[]} inputs - An array of values, falling back to the last value.
     * @param {Object} [context] - If defined and the current value is a function, the value
     * is called with `context` as first argument and the result becomes the new input.
     * @param {Number} [index] - If defined and the current value is an array, the value
     * at `index` become the new input.
     * @since 2.7.0
     */
				resolve: function resolve(inputs, context, index) {
					var i, ilen, value;

					for (i = 0, ilen = inputs.length; i < ilen; ++i) {
						value = inputs[i];
						if (value === undefined) {
							continue;
						}
						if (context !== undefined && typeof value === 'function') {
							value = value(context);
						}
						if (index !== undefined && helpers.isArray(value)) {
							value = value[index];
						}
						if (value !== undefined) {
							return value;
						}
					}
				}
			};
		}, { "42": 42 }], 45: [function (require, module, exports) {
			'use strict';

			module.exports = require(42);
			module.exports.easing = require(43);
			module.exports.canvas = require(41);
			module.exports.options = require(44);
		}, { "41": 41, "42": 42, "43": 43, "44": 44 }], 46: [function (require, module, exports) {
			/**
    * Platform fallback implementation (minimal).
    * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
    */

			module.exports = {
				acquireContext: function acquireContext(item) {
					if (item && item.canvas) {
						// Support for any object associated to a canvas (including a context2d)
						item = item.canvas;
					}

					return item && item.getContext('2d') || null;
				}
			};
		}, {}], 47: [function (require, module, exports) {
			/**
    * Chart.Platform implementation for targeting a web browser
    */

			'use strict';

			var helpers = require(45);

			var EXPANDO_KEY = '$chartjs';
			var CSS_PREFIX = 'chartjs-';
			var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
			var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
			var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

			/**
    * DOM event types -> Chart.js event types.
    * Note: only events with different types are mapped.
    * @see https://developer.mozilla.org/en-US/docs/Web/Events
    */
			var EVENT_TYPES = {
				touchstart: 'mousedown',
				touchmove: 'mousemove',
				touchend: 'mouseup',
				pointerenter: 'mouseenter',
				pointerdown: 'mousedown',
				pointermove: 'mousemove',
				pointerup: 'mouseup',
				pointerleave: 'mouseout',
				pointerout: 'mouseout'
			};

			/**
    * The "used" size is the final value of a dimension property after all calculations have
    * been performed. This method uses the computed style of `element` but returns undefined
    * if the computed style is not expressed in pixels. That can happen in some cases where
    * `element` has a size relative to its parent and this last one is not yet displayed,
    * for example because of `display: none` on a parent node.
    * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
    * @returns {Number} Size in pixels or undefined if unknown.
    */
			function readUsedSize(element, property) {
				var value = helpers.getStyle(element, property);
				var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
				return matches ? Number(matches[1]) : undefined;
			}

			/**
    * Initializes the canvas style and render size without modifying the canvas display size,
    * since responsiveness is handled by the controller.resize() method. The config is used
    * to determine the aspect ratio to apply in case no explicit height has been specified.
    */
			function initCanvas(canvas, config) {
				var style = canvas.style;

				// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
				// returns null or '' if no explicit value has been set to the canvas attribute.
				var renderHeight = canvas.getAttribute('height');
				var renderWidth = canvas.getAttribute('width');

				// Chart.js modifies some canvas values that we want to restore on destroy
				canvas[EXPANDO_KEY] = {
					initial: {
						height: renderHeight,
						width: renderWidth,
						style: {
							display: style.display,
							height: style.height,
							width: style.width
						}
					}
				};

				// Force canvas to display as block to avoid extra space caused by inline
				// elements, which would interfere with the responsive resize process.
				// https://github.com/chartjs/Chart.js/issues/2538
				style.display = style.display || 'block';

				if (renderWidth === null || renderWidth === '') {
					var displayWidth = readUsedSize(canvas, 'width');
					if (displayWidth !== undefined) {
						canvas.width = displayWidth;
					}
				}

				if (renderHeight === null || renderHeight === '') {
					if (canvas.style.height === '') {
						// If no explicit render height and style height, let's apply the aspect ratio,
						// which one can be specified by the user but also by charts as default option
						// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
						canvas.height = canvas.width / (config.options.aspectRatio || 2);
					} else {
						var displayHeight = readUsedSize(canvas, 'height');
						if (displayWidth !== undefined) {
							canvas.height = displayHeight;
						}
					}
				}

				return canvas;
			}

			/**
    * Detects support for options object argument in addEventListener.
    * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    * @private
    */
			var supportsEventListenerOptions = function () {
				var supports = false;
				try {
					var options = Object.defineProperty({}, 'passive', {
						get: function get() {
							supports = true;
						}
					});
					window.addEventListener('e', null, options);
				} catch (e) {
					// continue regardless of error
				}
				return supports;
			}();

			// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
			// https://github.com/chartjs/Chart.js/issues/4287
			var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;

			function _addEventListener(node, type, listener) {
				node.addEventListener(type, listener, eventListenerOptions);
			}

			function _removeEventListener(node, type, listener) {
				node.removeEventListener(type, listener, eventListenerOptions);
			}

			function createEvent(type, chart, x, y, nativeEvent) {
				return {
					type: type,
					chart: chart,
					native: nativeEvent || null,
					x: x !== undefined ? x : null,
					y: y !== undefined ? y : null
				};
			}

			function fromNativeEvent(event, chart) {
				var type = EVENT_TYPES[event.type] || event.type;
				var pos = helpers.getRelativePosition(event, chart);
				return createEvent(type, chart, pos.x, pos.y, event);
			}

			function throttled(fn, thisArg) {
				var ticking = false;
				var args = [];

				return function () {
					args = Array.prototype.slice.call(arguments);
					thisArg = thisArg || this;

					if (!ticking) {
						ticking = true;
						helpers.requestAnimFrame.call(window, function () {
							ticking = false;
							fn.apply(thisArg, args);
						});
					}
				};
			}

			// Implementation based on https://github.com/marcj/css-element-queries
			function createResizer(handler) {
				var resizer = document.createElement('div');
				var cls = CSS_PREFIX + 'size-monitor';
				var maxSize = 1000000;
				var style = 'position:absolute;' + 'left:0;' + 'top:0;' + 'right:0;' + 'bottom:0;' + 'overflow:hidden;' + 'pointer-events:none;' + 'visibility:hidden;' + 'z-index:-1;';

				resizer.style.cssText = style;
				resizer.className = cls;
				resizer.innerHTML = '<div class="' + cls + '-expand" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:' + maxSize + 'px;' + 'height:' + maxSize + 'px;' + 'left:0;' + 'top:0">' + '</div>' + '</div>' + '<div class="' + cls + '-shrink" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:200%;' + 'height:200%;' + 'left:0; ' + 'top:0">' + '</div>' + '</div>';

				var expand = resizer.childNodes[0];
				var shrink = resizer.childNodes[1];

				resizer._reset = function () {
					expand.scrollLeft = maxSize;
					expand.scrollTop = maxSize;
					shrink.scrollLeft = maxSize;
					shrink.scrollTop = maxSize;
				};
				var onScroll = function onScroll() {
					resizer._reset();
					handler();
				};

				_addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
				_addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

				return resizer;
			}

			// https://davidwalsh.name/detect-node-insertion
			function watchForRender(node, handler) {
				var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
				var proxy = expando.renderProxy = function (e) {
					if (e.animationName === CSS_RENDER_ANIMATION) {
						handler();
					}
				};

				helpers.each(ANIMATION_START_EVENTS, function (type) {
					_addEventListener(node, type, proxy);
				});

				node.classList.add(CSS_RENDER_MONITOR);
			}

			function unwatchForRender(node) {
				var expando = node[EXPANDO_KEY] || {};
				var proxy = expando.renderProxy;

				if (proxy) {
					helpers.each(ANIMATION_START_EVENTS, function (type) {
						_removeEventListener(node, type, proxy);
					});

					delete expando.renderProxy;
				}

				node.classList.remove(CSS_RENDER_MONITOR);
			}

			function addResizeListener(node, listener, chart) {
				var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

				// Let's keep track of this added resizer and thus avoid DOM query when removing it.
				var resizer = expando.resizer = createResizer(throttled(function () {
					if (expando.resizer) {
						return listener(createEvent('resize', chart));
					}
				}));

				// The resizer needs to be attached to the node parent, so we first need to be
				// sure that `node` is attached to the DOM before injecting the resizer element.
				watchForRender(node, function () {
					if (expando.resizer) {
						var container = node.parentNode;
						if (container && container !== resizer.parentNode) {
							container.insertBefore(resizer, container.firstChild);
						}

						// The container size might have changed, let's reset the resizer state.
						resizer._reset();
					}
				});
			}

			function removeResizeListener(node) {
				var expando = node[EXPANDO_KEY] || {};
				var resizer = expando.resizer;

				delete expando.resizer;
				unwatchForRender(node);

				if (resizer && resizer.parentNode) {
					resizer.parentNode.removeChild(resizer);
				}
			}

			function injectCSS(platform, css) {
				// http://stackoverflow.com/q/3922139
				var style = platform._style || document.createElement('style');
				if (!platform._style) {
					platform._style = style;
					css = '/* Chart.js */\n' + css;
					style.setAttribute('type', 'text/css');
					document.getElementsByTagName('head')[0].appendChild(style);
				}

				style.appendChild(document.createTextNode(css));
			}

			module.exports = {
				/**
     * This property holds whether this platform is enabled for the current environment.
     * Currently used by platform.js to select the proper implementation.
     * @private
     */
				_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

				initialize: function initialize() {
					var keyframes = 'from{opacity:0.99}to{opacity:1}';

					injectCSS(this,
					// DOM rendering detection
					// https://davidwalsh.name/detect-node-insertion
					'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '.' + CSS_RENDER_MONITOR + '{' + '-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + 'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + '}');
				},

				acquireContext: function acquireContext(item, config) {
					if (typeof item === 'string') {
						item = document.getElementById(item);
					} else if (item.length) {
						// Support for array based queries (such as jQuery)
						item = item[0];
					}

					if (item && item.canvas) {
						// Support for any object associated to a canvas (including a context2d)
						item = item.canvas;
					}

					// To prevent canvas fingerprinting, some add-ons undefine the getContext
					// method, for example: https://github.com/kkapsner/CanvasBlocker
					// https://github.com/chartjs/Chart.js/issues/2807
					var context = item && item.getContext && item.getContext('2d');

					// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
					// inside an iframe or when running in a protected environment. We could guess the
					// types from their toString() value but let's keep things flexible and assume it's
					// a sufficient condition if the item has a context2D which has item as `canvas`.
					// https://github.com/chartjs/Chart.js/issues/3887
					// https://github.com/chartjs/Chart.js/issues/4102
					// https://github.com/chartjs/Chart.js/issues/4152
					if (context && context.canvas === item) {
						initCanvas(item, config);
						return context;
					}

					return null;
				},

				releaseContext: function releaseContext(context) {
					var canvas = context.canvas;
					if (!canvas[EXPANDO_KEY]) {
						return;
					}

					var initial = canvas[EXPANDO_KEY].initial;
					['height', 'width'].forEach(function (prop) {
						var value = initial[prop];
						if (helpers.isNullOrUndef(value)) {
							canvas.removeAttribute(prop);
						} else {
							canvas.setAttribute(prop, value);
						}
					});

					helpers.each(initial.style || {}, function (value, key) {
						canvas.style[key] = value;
					});

					// The canvas render size might have been changed (and thus the state stack discarded),
					// we can't use save() and restore() to restore the initial state. So make sure that at
					// least the canvas context is reset to the default state by setting the canvas width.
					// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
					canvas.width = canvas.width;

					delete canvas[EXPANDO_KEY];
				},

				addEventListener: function addEventListener(chart, type, listener) {
					var canvas = chart.canvas;
					if (type === 'resize') {
						// Note: the resize event is not supported on all browsers.
						addResizeListener(canvas, listener, chart);
						return;
					}

					var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
					var proxies = expando.proxies || (expando.proxies = {});
					var proxy = proxies[chart.id + '_' + type] = function (event) {
						listener(fromNativeEvent(event, chart));
					};

					_addEventListener(canvas, type, proxy);
				},

				removeEventListener: function removeEventListener(chart, type, listener) {
					var canvas = chart.canvas;
					if (type === 'resize') {
						// Note: the resize event is not supported on all browsers.
						removeResizeListener(canvas, listener);
						return;
					}

					var expando = listener[EXPANDO_KEY] || {};
					var proxies = expando.proxies || {};
					var proxy = proxies[chart.id + '_' + type];
					if (!proxy) {
						return;
					}

					_removeEventListener(canvas, type, proxy);
				}
			};

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use EventTarget.addEventListener instead.
    * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
    * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
    * @function Chart.helpers.addEvent
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.addEvent = _addEventListener;

			/**
    * Provided for backward compatibility, use EventTarget.removeEventListener instead.
    * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
    * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
    * @function Chart.helpers.removeEvent
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.removeEvent = _removeEventListener;
		}, { "45": 45 }], 48: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);
			var basic = require(46);
			var dom = require(47);

			// @TODO Make possible to select another platform at build time.
			var implementation = dom._enabled ? dom : basic;

			/**
    * @namespace Chart.platform
    * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
    * @since 2.4.0
    */
			module.exports = helpers.extend({
				/**
     * @since 2.7.0
     */
				initialize: function initialize() {},

				/**
     * Called at chart construction time, returns a context2d instance implementing
     * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
     * @param {*} item - The native item from which to acquire context (platform specific)
     * @param {Object} options - The chart options
     * @returns {CanvasRenderingContext2D} context2d instance
     */
				acquireContext: function acquireContext() {},

				/**
     * Called at chart destruction time, releases any resources associated to the context
     * previously returned by the acquireContext() method.
     * @param {CanvasRenderingContext2D} context - The context2d instance
     * @returns {Boolean} true if the method succeeded, else false
     */
				releaseContext: function releaseContext() {},

				/**
     * Registers the specified listener on the given chart.
     * @param {Chart} chart - Chart from which to listen for event
     * @param {String} type - The ({@link IEvent}) type to listen for
     * @param {Function} listener - Receives a notification (an object that implements
     * the {@link IEvent} interface) when an event of the specified type occurs.
     */
				addEventListener: function addEventListener() {},

				/**
     * Removes the specified listener previously registered with addEventListener.
     * @param {Chart} chart -Chart from which to remove the listener
     * @param {String} type - The ({@link IEvent}) type to remove
     * @param {Function} listener - The listener function to remove from the event target.
     */
				removeEventListener: function removeEventListener() {}

			}, implementation);

			/**
    * @interface IPlatform
    * Allows abstracting platform dependencies away from the chart
    * @borrows Chart.platform.acquireContext as acquireContext
    * @borrows Chart.platform.releaseContext as releaseContext
    * @borrows Chart.platform.addEventListener as addEventListener
    * @borrows Chart.platform.removeEventListener as removeEventListener
    */

			/**
    * @interface IEvent
    * @prop {String} type - The event type name, possible values are:
    * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
    * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
    * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
    * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
    * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
    */
		}, { "45": 45, "46": 46, "47": 47 }], 49: [function (require, module, exports) {
			/**
    * Plugin based on discussion from the following Chart.js issues:
    * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
    * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
    */

			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('global', {
				plugins: {
					filler: {
						propagate: true
					}
				}
			});

			module.exports = function () {

				var mappers = {
					dataset: function dataset(source) {
						var index = source.fill;
						var chart = source.chart;
						var meta = chart.getDatasetMeta(index);
						var visible = meta && chart.isDatasetVisible(index);
						var points = visible && meta.dataset._children || [];
						var length = points.length || 0;

						return !length ? null : function (point, i) {
							return i < length && points[i]._view || null;
						};
					},

					boundary: function boundary(source) {
						var boundary = source.boundary;
						var x = boundary ? boundary.x : null;
						var y = boundary ? boundary.y : null;

						return function (point) {
							return {
								x: x === null ? point.x : x,
								y: y === null ? point.y : y
							};
						};
					}
				};

				// @todo if (fill[0] === '#')
				function decodeFill(el, index, count) {
					var model = el._model || {};
					var fill = model.fill;
					var target;

					if (fill === undefined) {
						fill = !!model.backgroundColor;
					}

					if (fill === false || fill === null) {
						return false;
					}

					if (fill === true) {
						return 'origin';
					}

					target = parseFloat(fill, 10);
					if (isFinite(target) && Math.floor(target) === target) {
						if (fill[0] === '-' || fill[0] === '+') {
							target = index + target;
						}

						if (target === index || target < 0 || target >= count) {
							return false;
						}

						return target;
					}

					switch (fill) {
						// compatibility
						case 'bottom':
							return 'start';
						case 'top':
							return 'end';
						case 'zero':
							return 'origin';
						// supported boundaries
						case 'origin':
						case 'start':
						case 'end':
							return fill;
						// invalid fill values
						default:
							return false;
					}
				}

				function computeBoundary(source) {
					var model = source.el._model || {};
					var scale = source.el._scale || {};
					var fill = source.fill;
					var target = null;
					var horizontal;

					if (isFinite(fill)) {
						return null;
					}

					// Backward compatibility: until v3, we still need to support boundary values set on
					// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
					// controllers might still use it (e.g. the Smith chart).

					if (fill === 'start') {
						target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
					} else if (fill === 'end') {
						target = model.scaleTop === undefined ? scale.top : model.scaleTop;
					} else if (model.scaleZero !== undefined) {
						target = model.scaleZero;
					} else if (scale.getBasePosition) {
						target = scale.getBasePosition();
					} else if (scale.getBasePixel) {
						target = scale.getBasePixel();
					}

					if (target !== undefined && target !== null) {
						if (target.x !== undefined && target.y !== undefined) {
							return target;
						}

						if (typeof target === 'number' && isFinite(target)) {
							horizontal = scale.isHorizontal();
							return {
								x: horizontal ? target : null,
								y: horizontal ? null : target
							};
						}
					}

					return null;
				}

				function resolveTarget(sources, index, propagate) {
					var source = sources[index];
					var fill = source.fill;
					var visited = [index];
					var target;

					if (!propagate) {
						return fill;
					}

					while (fill !== false && visited.indexOf(fill) === -1) {
						if (!isFinite(fill)) {
							return fill;
						}

						target = sources[fill];
						if (!target) {
							return false;
						}

						if (target.visible) {
							return fill;
						}

						visited.push(fill);
						fill = target.fill;
					}

					return false;
				}

				function createMapper(source) {
					var fill = source.fill;
					var type = 'dataset';

					if (fill === false) {
						return null;
					}

					if (!isFinite(fill)) {
						type = 'boundary';
					}

					return mappers[type](source);
				}

				function isDrawable(point) {
					return point && !point.skip;
				}

				function drawArea(ctx, curve0, curve1, len0, len1) {
					var i;

					if (!len0 || !len1) {
						return;
					}

					// building first area curve (normal)
					ctx.moveTo(curve0[0].x, curve0[0].y);
					for (i = 1; i < len0; ++i) {
						helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
					}

					// joining the two area curves
					ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

					// building opposite area curve (reverse)
					for (i = len1 - 1; i > 0; --i) {
						helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
					}
				}

				function doFill(ctx, points, mapper, view, color, loop) {
					var count = points.length;
					var span = view.spanGaps;
					var curve0 = [];
					var curve1 = [];
					var len0 = 0;
					var len1 = 0;
					var i, ilen, index, p0, p1, d0, d1;

					ctx.beginPath();

					for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
						index = i % count;
						p0 = points[index]._view;
						p1 = mapper(p0, index, view);
						d0 = isDrawable(p0);
						d1 = isDrawable(p1);

						if (d0 && d1) {
							len0 = curve0.push(p0);
							len1 = curve1.push(p1);
						} else if (len0 && len1) {
							if (!span) {
								drawArea(ctx, curve0, curve1, len0, len1);
								len0 = len1 = 0;
								curve0 = [];
								curve1 = [];
							} else {
								if (d0) {
									curve0.push(p0);
								}
								if (d1) {
									curve1.push(p1);
								}
							}
						}
					}

					drawArea(ctx, curve0, curve1, len0, len1);

					ctx.closePath();
					ctx.fillStyle = color;
					ctx.fill();
				}

				return {
					id: 'filler',

					afterDatasetsUpdate: function afterDatasetsUpdate(chart, options) {
						var count = (chart.data.datasets || []).length;
						var propagate = options.propagate;
						var sources = [];
						var meta, i, el, source;

						for (i = 0; i < count; ++i) {
							meta = chart.getDatasetMeta(i);
							el = meta.dataset;
							source = null;

							if (el && el._model && el instanceof elements.Line) {
								source = {
									visible: chart.isDatasetVisible(i),
									fill: decodeFill(el, i, count),
									chart: chart,
									el: el
								};
							}

							meta.$filler = source;
							sources.push(source);
						}

						for (i = 0; i < count; ++i) {
							source = sources[i];
							if (!source) {
								continue;
							}

							source.fill = resolveTarget(sources, i, propagate);
							source.boundary = computeBoundary(source);
							source.mapper = createMapper(source);
						}
					},

					beforeDatasetDraw: function beforeDatasetDraw(chart, args) {
						var meta = args.meta.$filler;
						if (!meta) {
							return;
						}

						var ctx = chart.ctx;
						var el = meta.el;
						var view = el._view;
						var points = el._children || [];
						var mapper = meta.mapper;
						var color = view.backgroundColor || defaults.global.defaultColor;

						if (mapper && color && points.length) {
							helpers.canvas.clipArea(ctx, chart.chartArea);
							doFill(ctx, points, mapper, view, color, el._loop);
							helpers.canvas.unclipArea(ctx);
						}
					}
				};
			};
		}, { "25": 25, "40": 40, "45": 45 }], 50: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				legend: {
					display: true,
					position: 'top',
					fullWidth: true,
					reverse: false,
					weight: 1000,

					// a callback that will handle
					onClick: function onClick(e, legendItem) {
						var index = legendItem.datasetIndex;
						var ci = this.chart;
						var meta = ci.getDatasetMeta(index);

						// See controller.isDatasetVisible comment
						meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

						// We hid a dataset ... rerender the chart
						ci.update();
					},

					onHover: null,

					labels: {
						boxWidth: 40,
						padding: 10,
						// Generates labels shown in the legend
						// Valid properties to return:
						// text : text to display
						// fillStyle : fill of coloured box
						// strokeStyle: stroke of coloured box
						// hidden : if this legend item refers to a hidden item
						// lineCap : cap style for line
						// lineDash
						// lineDashOffset :
						// lineJoin :
						// lineWidth :
						generateLabels: function generateLabels(chart) {
							var data = chart.data;
							return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
								return {
									text: dataset.label,
									fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
									hidden: !chart.isDatasetVisible(i),
									lineCap: dataset.borderCapStyle,
									lineDash: dataset.borderDash,
									lineDashOffset: dataset.borderDashOffset,
									lineJoin: dataset.borderJoinStyle,
									lineWidth: dataset.borderWidth,
									strokeStyle: dataset.borderColor,
									pointStyle: dataset.pointStyle,

									// Below is extra data used for toggling the datasets
									datasetIndex: i
								};
							}, this) : [];
						}
					}
				},

				legendCallback: function legendCallback(chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');
					for (var i = 0; i < chart.data.datasets.length; i++) {
						text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
						if (chart.data.datasets[i].label) {
							text.push(chart.data.datasets[i].label);
						}
						text.push('</li>');
					}
					text.push('</ul>');
					return text.join('');
				}
			});

			module.exports = function (Chart) {

				var layout = Chart.layoutService;
				var noop = helpers.noop;

				/**
     * Helper function to get the box width based on the usePointStyle option
     * @param labelopts {Object} the label options on the legend
     * @param fontSize {Number} the label font size
     * @return {Number} width of the color box area
     */
				function getBoxWidth(labelOpts, fontSize) {
					return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;
				}

				Chart.Legend = Element.extend({

					initialize: function initialize(config) {
						helpers.extend(this, config);

						// Contains hit boxes for each dataset (in dataset order)
						this.legendHitBoxes = [];

						// Are we in doughnut mode which has a different data type
						this.doughnutMode = false;
					},

					// These methods are ordered by lifecycle. Utilities then follow.
					// Any function defined here is inherited by all legend types.
					// Any function can be extended by the legend type

					beforeUpdate: noop,
					update: function update(maxWidth, maxHeight, margins) {
						var me = this;

						// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
						me.beforeUpdate();

						// Absorb the master measurements
						me.maxWidth = maxWidth;
						me.maxHeight = maxHeight;
						me.margins = margins;

						// Dimensions
						me.beforeSetDimensions();
						me.setDimensions();
						me.afterSetDimensions();
						// Labels
						me.beforeBuildLabels();
						me.buildLabels();
						me.afterBuildLabels();

						// Fit
						me.beforeFit();
						me.fit();
						me.afterFit();
						//
						me.afterUpdate();

						return me.minSize;
					},
					afterUpdate: noop,

					//

					beforeSetDimensions: noop,
					setDimensions: function setDimensions() {
						var me = this;
						// Set the unconstrained dimension before label rotation
						if (me.isHorizontal()) {
							// Reset position before calculating rotation
							me.width = me.maxWidth;
							me.left = 0;
							me.right = me.width;
						} else {
							me.height = me.maxHeight;

							// Reset position before calculating rotation
							me.top = 0;
							me.bottom = me.height;
						}

						// Reset padding
						me.paddingLeft = 0;
						me.paddingTop = 0;
						me.paddingRight = 0;
						me.paddingBottom = 0;

						// Reset minSize
						me.minSize = {
							width: 0,
							height: 0
						};
					},
					afterSetDimensions: noop,

					//

					beforeBuildLabels: noop,
					buildLabels: function buildLabels() {
						var me = this;
						var labelOpts = me.options.labels || {};
						var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

						if (labelOpts.filter) {
							legendItems = legendItems.filter(function (item) {
								return labelOpts.filter(item, me.chart.data);
							});
						}

						if (me.options.reverse) {
							legendItems.reverse();
						}

						me.legendItems = legendItems;
					},
					afterBuildLabels: noop,

					//

					beforeFit: noop,
					fit: function fit() {
						var me = this;
						var opts = me.options;
						var labelOpts = opts.labels;
						var display = opts.display;

						var ctx = me.ctx;

						var globalDefault = defaults.global;
						var valueOrDefault = helpers.valueOrDefault;
						var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
						var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
						var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
						var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

						// Reset hit boxes
						var hitboxes = me.legendHitBoxes = [];

						var minSize = me.minSize;
						var isHorizontal = me.isHorizontal();

						if (isHorizontal) {
							minSize.width = me.maxWidth; // fill all the width
							minSize.height = display ? 10 : 0;
						} else {
							minSize.width = display ? 10 : 0;
							minSize.height = me.maxHeight; // fill all the height
						}

						// Increase sizes here
						if (display) {
							ctx.font = labelFont;

							if (isHorizontal) {
								// Labels

								// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
								var lineWidths = me.lineWidths = [0];
								var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;

								ctx.textAlign = 'left';
								ctx.textBaseline = 'top';

								helpers.each(me.legendItems, function (legendItem, i) {
									var boxWidth = getBoxWidth(labelOpts, fontSize);
									var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

									if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
										totalHeight += fontSize + labelOpts.padding;
										lineWidths[lineWidths.length] = me.left;
									}

									// Store the hitbox width and height here. Final position will be updated in `draw`
									hitboxes[i] = {
										left: 0,
										top: 0,
										width: width,
										height: fontSize
									};

									lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
								});

								minSize.height += totalHeight;
							} else {
								var vPadding = labelOpts.padding;
								var columnWidths = me.columnWidths = [];
								var totalWidth = labelOpts.padding;
								var currentColWidth = 0;
								var currentColHeight = 0;
								var itemHeight = fontSize + vPadding;

								helpers.each(me.legendItems, function (legendItem, i) {
									var boxWidth = getBoxWidth(labelOpts, fontSize);
									var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

									// If too tall, go to new column
									if (currentColHeight + itemHeight > minSize.height) {
										totalWidth += currentColWidth + labelOpts.padding;
										columnWidths.push(currentColWidth); // previous column width

										currentColWidth = 0;
										currentColHeight = 0;
									}

									// Get max width
									currentColWidth = Math.max(currentColWidth, itemWidth);
									currentColHeight += itemHeight;

									// Store the hitbox width and height here. Final position will be updated in `draw`
									hitboxes[i] = {
										left: 0,
										top: 0,
										width: itemWidth,
										height: fontSize
									};
								});

								totalWidth += currentColWidth;
								columnWidths.push(currentColWidth);
								minSize.width += totalWidth;
							}
						}

						me.width = minSize.width;
						me.height = minSize.height;
					},
					afterFit: noop,

					// Shared Methods
					isHorizontal: function isHorizontal() {
						return this.options.position === 'top' || this.options.position === 'bottom';
					},

					// Actually draw the legend on the canvas
					draw: function draw() {
						var me = this;
						var opts = me.options;
						var labelOpts = opts.labels;
						var globalDefault = defaults.global;
						var lineDefault = globalDefault.elements.line;
						var legendWidth = me.width;
						var lineWidths = me.lineWidths;

						if (opts.display) {
							var ctx = me.ctx;
							var valueOrDefault = helpers.valueOrDefault;
							var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
							var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
							var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
							var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
							var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
							var cursor;

							// Canvas setup
							ctx.textAlign = 'left';
							ctx.textBaseline = 'middle';
							ctx.lineWidth = 0.5;
							ctx.strokeStyle = fontColor; // for strikethrough effect
							ctx.fillStyle = fontColor; // render in correct colour
							ctx.font = labelFont;

							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var hitboxes = me.legendHitBoxes;

							// current position
							var drawLegendBox = function drawLegendBox(x, y, legendItem) {
								if (isNaN(boxWidth) || boxWidth <= 0) {
									return;
								}

								// Set the ctx for the box
								ctx.save();

								ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
								ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
								ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
								ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
								ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
								ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
								var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;

								if (ctx.setLineDash) {
									// IE 9 and 10 do not support line dash
									ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
								}

								if (opts.labels && opts.labels.usePointStyle) {
									// Recalculate x and y for drawPoint() because its expecting
									// x and y to be center of figure (instead of top left)
									var radius = fontSize * Math.SQRT2 / 2;
									var offSet = radius / Math.SQRT2;
									var centerX = x + offSet;
									var centerY = y + offSet;

									// Draw pointStyle as legend symbol
									helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
								} else {
									// Draw box as legend symbol
									if (!isLineWidthZero) {
										ctx.strokeRect(x, y, boxWidth, fontSize);
									}
									ctx.fillRect(x, y, boxWidth, fontSize);
								}

								ctx.restore();
							};
							var fillText = function fillText(x, y, legendItem, textWidth) {
								var halfFontSize = fontSize / 2;
								var xLeft = boxWidth + halfFontSize + x;
								var yMiddle = y + halfFontSize;

								ctx.fillText(legendItem.text, xLeft, yMiddle);

								if (legendItem.hidden) {
									// Strikethrough the text if hidden
									ctx.beginPath();
									ctx.lineWidth = 2;
									ctx.moveTo(xLeft, yMiddle);
									ctx.lineTo(xLeft + textWidth, yMiddle);
									ctx.stroke();
								}
							};

							// Horizontal
							var isHorizontal = me.isHorizontal();
							if (isHorizontal) {
								cursor = {
									x: me.left + (legendWidth - lineWidths[0]) / 2,
									y: me.top + labelOpts.padding,
									line: 0
								};
							} else {
								cursor = {
									x: me.left + labelOpts.padding,
									y: me.top + labelOpts.padding,
									line: 0
								};
							}

							var itemHeight = fontSize + labelOpts.padding;
							helpers.each(me.legendItems, function (legendItem, i) {
								var textWidth = ctx.measureText(legendItem.text).width;
								var width = boxWidth + fontSize / 2 + textWidth;
								var x = cursor.x;
								var y = cursor.y;

								if (isHorizontal) {
									if (x + width >= legendWidth) {
										y = cursor.y += itemHeight;
										cursor.line++;
										x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;
									}
								} else if (y + itemHeight > me.bottom) {
									x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
									y = cursor.y = me.top + labelOpts.padding;
									cursor.line++;
								}

								drawLegendBox(x, y, legendItem);

								hitboxes[i].left = x;
								hitboxes[i].top = y;

								// Fill the actual label
								fillText(x, y, legendItem, textWidth);

								if (isHorizontal) {
									cursor.x += width + labelOpts.padding;
								} else {
									cursor.y += itemHeight;
								}
							});
						}
					},

					/**
      * Handle an event
      * @private
      * @param {IEvent} event - The event to handle
      * @return {Boolean} true if a change occured
      */
					handleEvent: function handleEvent(e) {
						var me = this;
						var opts = me.options;
						var type = e.type === 'mouseup' ? 'click' : e.type;
						var changed = false;

						if (type === 'mousemove') {
							if (!opts.onHover) {
								return;
							}
						} else if (type === 'click') {
							if (!opts.onClick) {
								return;
							}
						} else {
							return;
						}

						// Chart event already has relative position in it
						var x = e.x;
						var y = e.y;

						if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
							// See if we are touching one of the dataset boxes
							var lh = me.legendHitBoxes;
							for (var i = 0; i < lh.length; ++i) {
								var hitBox = lh[i];

								if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
									// Touching an element
									if (type === 'click') {
										// use e.native for backwards compatibility
										opts.onClick.call(me, e.native, me.legendItems[i]);
										changed = true;
										break;
									} else if (type === 'mousemove') {
										// use e.native for backwards compatibility
										opts.onHover.call(me, e.native, me.legendItems[i]);
										changed = true;
										break;
									}
								}
							}
						}

						return changed;
					}
				});

				function createNewLegendAndAttach(chart, legendOpts) {
					var legend = new Chart.Legend({
						ctx: chart.ctx,
						options: legendOpts,
						chart: chart
					});

					layout.configure(chart, legend, legendOpts);
					layout.addBox(chart, legend);
					chart.legend = legend;
				}

				return {
					id: 'legend',

					beforeInit: function beforeInit(chart) {
						var legendOpts = chart.options.legend;

						if (legendOpts) {
							createNewLegendAndAttach(chart, legendOpts);
						}
					},

					beforeUpdate: function beforeUpdate(chart) {
						var legendOpts = chart.options.legend;
						var legend = chart.legend;

						if (legendOpts) {
							helpers.mergeIf(legendOpts, defaults.global.legend);

							if (legend) {
								layout.configure(chart, legend, legendOpts);
								legend.options = legendOpts;
							} else {
								createNewLegendAndAttach(chart, legendOpts);
							}
						} else if (legend) {
							layout.removeBox(chart, legend);
							delete chart.legend;
						}
					},

					afterEvent: function afterEvent(chart, e) {
						var legend = chart.legend;
						if (legend) {
							legend.handleEvent(e);
						}
					}
				};
			};
		}, { "25": 25, "26": 26, "45": 45 }], 51: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				title: {
					display: false,
					fontStyle: 'bold',
					fullWidth: true,
					lineHeight: 1.2,
					padding: 10,
					position: 'top',
					text: '',
					weight: 2000 // by default greater than legend (1000) to be above
				}
			});

			module.exports = function (Chart) {

				var layout = Chart.layoutService;
				var noop = helpers.noop;

				Chart.Title = Element.extend({
					initialize: function initialize(config) {
						var me = this;
						helpers.extend(me, config);

						// Contains hit boxes for each dataset (in dataset order)
						me.legendHitBoxes = [];
					},

					// These methods are ordered by lifecycle. Utilities then follow.

					beforeUpdate: noop,
					update: function update(maxWidth, maxHeight, margins) {
						var me = this;

						// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
						me.beforeUpdate();

						// Absorb the master measurements
						me.maxWidth = maxWidth;
						me.maxHeight = maxHeight;
						me.margins = margins;

						// Dimensions
						me.beforeSetDimensions();
						me.setDimensions();
						me.afterSetDimensions();
						// Labels
						me.beforeBuildLabels();
						me.buildLabels();
						me.afterBuildLabels();

						// Fit
						me.beforeFit();
						me.fit();
						me.afterFit();
						//
						me.afterUpdate();

						return me.minSize;
					},
					afterUpdate: noop,

					//

					beforeSetDimensions: noop,
					setDimensions: function setDimensions() {
						var me = this;
						// Set the unconstrained dimension before label rotation
						if (me.isHorizontal()) {
							// Reset position before calculating rotation
							me.width = me.maxWidth;
							me.left = 0;
							me.right = me.width;
						} else {
							me.height = me.maxHeight;

							// Reset position before calculating rotation
							me.top = 0;
							me.bottom = me.height;
						}

						// Reset padding
						me.paddingLeft = 0;
						me.paddingTop = 0;
						me.paddingRight = 0;
						me.paddingBottom = 0;

						// Reset minSize
						me.minSize = {
							width: 0,
							height: 0
						};
					},
					afterSetDimensions: noop,

					//

					beforeBuildLabels: noop,
					buildLabels: noop,
					afterBuildLabels: noop,

					//

					beforeFit: noop,
					fit: function fit() {
						var me = this;
						var valueOrDefault = helpers.valueOrDefault;
						var opts = me.options;
						var display = opts.display;
						var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
						var minSize = me.minSize;
						var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
						var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
						var textSize = display ? lineCount * lineHeight + opts.padding * 2 : 0;

						if (me.isHorizontal()) {
							minSize.width = me.maxWidth; // fill all the width
							minSize.height = textSize;
						} else {
							minSize.width = textSize;
							minSize.height = me.maxHeight; // fill all the height
						}

						me.width = minSize.width;
						me.height = minSize.height;
					},
					afterFit: noop,

					// Shared Methods
					isHorizontal: function isHorizontal() {
						var pos = this.options.position;
						return pos === 'top' || pos === 'bottom';
					},

					// Actually draw the title block on the canvas
					draw: function draw() {
						var me = this;
						var ctx = me.ctx;
						var valueOrDefault = helpers.valueOrDefault;
						var opts = me.options;
						var globalDefaults = defaults.global;

						if (opts.display) {
							var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
							var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
							var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
							var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
							var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
							var offset = lineHeight / 2 + opts.padding;
							var rotation = 0;
							var top = me.top;
							var left = me.left;
							var bottom = me.bottom;
							var right = me.right;
							var maxWidth, titleX, titleY;

							ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
							ctx.font = titleFont;

							// Horizontal
							if (me.isHorizontal()) {
								titleX = left + (right - left) / 2; // midpoint of the width
								titleY = top + offset;
								maxWidth = right - left;
							} else {
								titleX = opts.position === 'left' ? left + offset : right - offset;
								titleY = top + (bottom - top) / 2;
								maxWidth = bottom - top;
								rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
							}

							ctx.save();
							ctx.translate(titleX, titleY);
							ctx.rotate(rotation);
							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';

							var text = opts.text;
							if (helpers.isArray(text)) {
								var y = 0;
								for (var i = 0; i < text.length; ++i) {
									ctx.fillText(text[i], 0, y, maxWidth);
									y += lineHeight;
								}
							} else {
								ctx.fillText(text, 0, 0, maxWidth);
							}

							ctx.restore();
						}
					}
				});

				function createNewTitleBlockAndAttach(chart, titleOpts) {
					var title = new Chart.Title({
						ctx: chart.ctx,
						options: titleOpts,
						chart: chart
					});

					layout.configure(chart, title, titleOpts);
					layout.addBox(chart, title);
					chart.titleBlock = title;
				}

				return {
					id: 'title',

					beforeInit: function beforeInit(chart) {
						var titleOpts = chart.options.title;

						if (titleOpts) {
							createNewTitleBlockAndAttach(chart, titleOpts);
						}
					},

					beforeUpdate: function beforeUpdate(chart) {
						var titleOpts = chart.options.title;
						var titleBlock = chart.titleBlock;

						if (titleOpts) {
							helpers.mergeIf(titleOpts, defaults.global.title);

							if (titleBlock) {
								layout.configure(chart, titleBlock, titleOpts);
								titleBlock.options = titleOpts;
							} else {
								createNewTitleBlockAndAttach(chart, titleOpts);
							}
						} else if (titleBlock) {
							Chart.layoutService.removeBox(chart, titleBlock);
							delete chart.titleBlock;
						}
					}
				};
			};
		}, { "25": 25, "26": 26, "45": 45 }], 52: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				// Default config for a category scale
				var defaultConfig = {
					position: 'bottom'
				};

				var DatasetScale = Chart.Scale.extend({
					/**
     * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
     * else fall back to data.labels
     * @private
     */
					getLabels: function getLabels() {
						var data = this.chart.data;
						return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
					},

					determineDataLimits: function determineDataLimits() {
						var me = this;
						var labels = me.getLabels();
						me.minIndex = 0;
						me.maxIndex = labels.length - 1;
						var findIndex;

						if (me.options.ticks.min !== undefined) {
							// user specified min value
							findIndex = labels.indexOf(me.options.ticks.min);
							me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
						}

						if (me.options.ticks.max !== undefined) {
							// user specified max value
							findIndex = labels.indexOf(me.options.ticks.max);
							me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
						}

						me.min = labels[me.minIndex];
						me.max = labels[me.maxIndex];
					},

					buildTicks: function buildTicks() {
						var me = this;
						var labels = me.getLabels();
						// If we are viewing some subset of labels, slice the original array
						me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
					},

					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						var me = this;
						var data = me.chart.data;
						var isHorizontal = me.isHorizontal();

						if (data.yLabels && !isHorizontal) {
							return me.getRightValue(data.datasets[datasetIndex].data[index]);
						}
						return me.ticks[index - me.minIndex];
					},

					// Used to get data value locations.  Value can either be an index or a numerical value
					getPixelForValue: function getPixelForValue(value, index) {
						var me = this;
						var offset = me.options.offset;
						// 1 is added because we need the length but we have the indexes
						var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1);

						// If value is a data object, then index is the index in the data array,
						// not the index of the scale. We need to change that.
						var valueCategory;
						if (value !== undefined && value !== null) {
							valueCategory = me.isHorizontal() ? value.x : value.y;
						}
						if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
							var labels = me.getLabels();
							value = valueCategory || value;
							var idx = labels.indexOf(value);
							index = idx !== -1 ? idx : index;
						}

						if (me.isHorizontal()) {
							var valueWidth = me.width / offsetAmt;
							var widthOffset = valueWidth * (index - me.minIndex);

							if (offset) {
								widthOffset += valueWidth / 2;
							}

							return me.left + Math.round(widthOffset);
						}
						var valueHeight = me.height / offsetAmt;
						var heightOffset = valueHeight * (index - me.minIndex);

						if (offset) {
							heightOffset += valueHeight / 2;
						}

						return me.top + Math.round(heightOffset);
					},
					getPixelForTick: function getPixelForTick(index) {
						return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
					},
					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var offset = me.options.offset;
						var value;
						var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
						var horz = me.isHorizontal();
						var valueDimension = (horz ? me.width : me.height) / offsetAmt;

						pixel -= horz ? me.left : me.top;

						if (offset) {
							pixel -= valueDimension / 2;
						}

						if (pixel <= 0) {
							value = 0;
						} else {
							value = Math.round(pixel / valueDimension);
						}

						return value + me.minIndex;
					},
					getBasePixel: function getBasePixel() {
						return this.bottom;
					}
				});

				Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
			};
		}, {}], 53: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var defaultConfig = {
					position: 'left',
					ticks: {
						callback: Ticks.formatters.linear
					}
				};

				var LinearScale = Chart.LinearScaleBase.extend({

					determineDataLimits: function determineDataLimits() {
						var me = this;
						var opts = me.options;
						var chart = me.chart;
						var data = chart.data;
						var datasets = data.datasets;
						var isHorizontal = me.isHorizontal();
						var DEFAULT_MIN = 0;
						var DEFAULT_MAX = 1;

						function IDMatches(meta) {
							return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
						}

						// First Calculate the range
						me.min = null;
						me.max = null;

						var hasStacks = opts.stacked;
						if (hasStacks === undefined) {
							helpers.each(datasets, function (dataset, datasetIndex) {
								if (hasStacks) {
									return;
								}

								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
									hasStacks = true;
								}
							});
						}

						if (opts.stacked || hasStacks) {
							var valuesPerStack = {};

							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								var key = [meta.type,
								// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
								opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

								if (valuesPerStack[key] === undefined) {
									valuesPerStack[key] = {
										positiveValues: [],
										negativeValues: []
									};
								}

								// Store these per type
								var positiveValues = valuesPerStack[key].positiveValues;
								var negativeValues = valuesPerStack[key].negativeValues;

								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									helpers.each(dataset.data, function (rawValue, index) {
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										positiveValues[index] = positiveValues[index] || 0;
										negativeValues[index] = negativeValues[index] || 0;

										if (opts.relativePoints) {
											positiveValues[index] = 100;
										} else if (value < 0) {
											negativeValues[index] += value;
										} else {
											positiveValues[index] += value;
										}
									});
								}
							});

							helpers.each(valuesPerStack, function (valuesForType) {
								var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
								var minVal = helpers.min(values);
								var maxVal = helpers.max(values);
								me.min = me.min === null ? minVal : Math.min(me.min, minVal);
								me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
							});
						} else {
							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									helpers.each(dataset.data, function (rawValue, index) {
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										if (me.min === null) {
											me.min = value;
										} else if (value < me.min) {
											me.min = value;
										}

										if (me.max === null) {
											me.max = value;
										} else if (value > me.max) {
											me.max = value;
										}
									});
								}
							});
						}

						me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
						me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

						// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
						this.handleTickRangeOptions();
					},
					getTickLimit: function getTickLimit() {
						var maxTicks;
						var me = this;
						var tickOpts = me.options.ticks;

						if (me.isHorizontal()) {
							maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
						} else {
							// The factor of 2 used to scale the font size has been experimentally determined.
							var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
							maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
						}

						return maxTicks;
					},
					// Called after the ticks are built. We need
					handleDirectionalChanges: function handleDirectionalChanges() {
						if (!this.isHorizontal()) {
							// We are in a vertical orientation. The top value is the highest. So reverse the array
							this.ticks.reverse();
						}
					},
					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
					},
					// Utils
					getPixelForValue: function getPixelForValue(value) {
						// This must be called after fit has been run so that
						// this.left, this.top, this.right, and this.bottom have been defined
						var me = this;
						var start = me.start;

						var rightValue = +me.getRightValue(value);
						var pixel;
						var range = me.end - start;

						if (me.isHorizontal()) {
							pixel = me.left + me.width / range * (rightValue - start);
							return Math.round(pixel);
						}

						pixel = me.bottom - me.height / range * (rightValue - start);
						return Math.round(pixel);
					},
					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var isHorizontal = me.isHorizontal();
						var innerDimension = isHorizontal ? me.width : me.height;
						var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
						return me.start + (me.end - me.start) * offset;
					},
					getPixelForTick: function getPixelForTick(index) {
						return this.getPixelForValue(this.ticksAsNumbers[index]);
					}
				});
				Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
			};
		}, { "25": 25, "34": 34, "45": 45 }], 54: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var noop = helpers.noop;

				Chart.LinearScaleBase = Chart.Scale.extend({
					getRightValue: function getRightValue(value) {
						if (typeof value === 'string') {
							return +value;
						}
						return Chart.Scale.prototype.getRightValue.call(this, value);
					},

					handleTickRangeOptions: function handleTickRangeOptions() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;

						// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
						// do nothing since that would make the chart weird. If the user really wants a weird chart
						// axis, they can manually override it
						if (tickOpts.beginAtZero) {
							var minSign = helpers.sign(me.min);
							var maxSign = helpers.sign(me.max);

							if (minSign < 0 && maxSign < 0) {
								// move the top up to 0
								me.max = 0;
							} else if (minSign > 0 && maxSign > 0) {
								// move the bottom down to 0
								me.min = 0;
							}
						}

						var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
						var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

						if (tickOpts.min !== undefined) {
							me.min = tickOpts.min;
						} else if (tickOpts.suggestedMin !== undefined) {
							if (me.min === null) {
								me.min = tickOpts.suggestedMin;
							} else {
								me.min = Math.min(me.min, tickOpts.suggestedMin);
							}
						}

						if (tickOpts.max !== undefined) {
							me.max = tickOpts.max;
						} else if (tickOpts.suggestedMax !== undefined) {
							if (me.max === null) {
								me.max = tickOpts.suggestedMax;
							} else {
								me.max = Math.max(me.max, tickOpts.suggestedMax);
							}
						}

						if (setMin !== setMax) {
							// We set the min or the max but not both.
							// So ensure that our range is good
							// Inverted or 0 length range can happen when
							// ticks.min is set, and no datasets are visible
							if (me.min >= me.max) {
								if (setMin) {
									me.max = me.min + 1;
								} else {
									me.min = me.max - 1;
								}
							}
						}

						if (me.min === me.max) {
							me.max++;

							if (!tickOpts.beginAtZero) {
								me.min--;
							}
						}
					},
					getTickLimit: noop,
					handleDirectionalChanges: noop,

					buildTicks: function buildTicks() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;

						// Figure out what the max number of ticks we can support it is based on the size of
						// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
						// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
						// the graph. Make sure we always have at least 2 ticks
						var maxTicks = me.getTickLimit();
						maxTicks = Math.max(2, maxTicks);

						var numericGeneratorOptions = {
							maxTicks: maxTicks,
							min: tickOpts.min,
							max: tickOpts.max,
							stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
						};
						var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);

						me.handleDirectionalChanges();

						// At this point, we need to update our max and min given the tick values since we have expanded the
						// range of the scale
						me.max = helpers.max(ticks);
						me.min = helpers.min(ticks);

						if (tickOpts.reverse) {
							ticks.reverse();

							me.start = me.max;
							me.end = me.min;
						} else {
							me.start = me.min;
							me.end = me.max;
						}
					},
					convertTicksToLabels: function convertTicksToLabels() {
						var me = this;
						me.ticksAsNumbers = me.ticks.slice();
						me.zeroLineIndex = me.ticks.indexOf(0);

						Chart.Scale.prototype.convertTicksToLabels.call(me);
					}
				});
			};
		}, { "34": 34, "45": 45 }], 55: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var defaultConfig = {
					position: 'left',

					// label settings
					ticks: {
						callback: Ticks.formatters.logarithmic
					}
				};

				var LogarithmicScale = Chart.Scale.extend({
					determineDataLimits: function determineDataLimits() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;
						var chart = me.chart;
						var data = chart.data;
						var datasets = data.datasets;
						var valueOrDefault = helpers.valueOrDefault;
						var isHorizontal = me.isHorizontal();
						function IDMatches(meta) {
							return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
						}

						// Calculate Range
						me.min = null;
						me.max = null;
						me.minNotZero = null;

						var hasStacks = opts.stacked;
						if (hasStacks === undefined) {
							helpers.each(datasets, function (dataset, datasetIndex) {
								if (hasStacks) {
									return;
								}

								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
									hasStacks = true;
								}
							});
						}

						if (opts.stacked || hasStacks) {
							var valuesPerStack = {};

							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								var key = [meta.type,
								// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
								opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									if (valuesPerStack[key] === undefined) {
										valuesPerStack[key] = [];
									}

									helpers.each(dataset.data, function (rawValue, index) {
										var values = valuesPerStack[key];
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										values[index] = values[index] || 0;

										if (opts.relativePoints) {
											values[index] = 100;
										} else {
											// Don't need to split positive and negative since the log scale can't handle a 0 crossing
											values[index] += value;
										}
									});
								}
							});

							helpers.each(valuesPerStack, function (valuesForType) {
								var minVal = helpers.min(valuesForType);
								var maxVal = helpers.max(valuesForType);
								me.min = me.min === null ? minVal : Math.min(me.min, minVal);
								me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
							});
						} else {
							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									helpers.each(dataset.data, function (rawValue, index) {
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										if (me.min === null) {
											me.min = value;
										} else if (value < me.min) {
											me.min = value;
										}

										if (me.max === null) {
											me.max = value;
										} else if (value > me.max) {
											me.max = value;
										}

										if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
											me.minNotZero = value;
										}
									});
								}
							});
						}

						me.min = valueOrDefault(tickOpts.min, me.min);
						me.max = valueOrDefault(tickOpts.max, me.max);

						if (me.min === me.max) {
							if (me.min !== 0 && me.min !== null) {
								me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
								me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
							} else {
								me.min = 1;
								me.max = 10;
							}
						}
					},
					buildTicks: function buildTicks() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;

						var generationOptions = {
							min: tickOpts.min,
							max: tickOpts.max
						};
						var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);

						if (!me.isHorizontal()) {
							// We are in a vertical orientation. The top value is the highest. So reverse the array
							ticks.reverse();
						}

						// At this point, we need to update our max and min given the tick values since we have expanded the
						// range of the scale
						me.max = helpers.max(ticks);
						me.min = helpers.min(ticks);

						if (tickOpts.reverse) {
							ticks.reverse();

							me.start = me.max;
							me.end = me.min;
						} else {
							me.start = me.min;
							me.end = me.max;
						}
					},
					convertTicksToLabels: function convertTicksToLabels() {
						this.tickValues = this.ticks.slice();

						Chart.Scale.prototype.convertTicksToLabels.call(this);
					},
					// Get the correct tooltip label
					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
					},
					getPixelForTick: function getPixelForTick(index) {
						return this.getPixelForValue(this.tickValues[index]);
					},
					getPixelForValue: function getPixelForValue(value) {
						var me = this;
						var start = me.start;
						var newVal = +me.getRightValue(value);
						var opts = me.options;
						var tickOpts = opts.ticks;
						var innerDimension, pixel, range;

						if (me.isHorizontal()) {
							range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0
							if (newVal === 0) {
								pixel = me.left;
							} else {
								innerDimension = me.width;
								pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
							}
						} else {
							// Bottom - top since pixels increase downward on a screen
							innerDimension = me.height;
							if (start === 0 && !tickOpts.reverse) {
								range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
								if (newVal === start) {
									pixel = me.bottom;
								} else if (newVal === me.minNotZero) {
									pixel = me.bottom - innerDimension * 0.02;
								} else {
									pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
								}
							} else if (me.end === 0 && tickOpts.reverse) {
								range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
								if (newVal === me.end) {
									pixel = me.top;
								} else if (newVal === me.minNotZero) {
									pixel = me.top + innerDimension * 0.02;
								} else {
									pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
								}
							} else if (newVal === 0) {
								pixel = tickOpts.reverse ? me.top : me.bottom;
							} else {
								range = helpers.log10(me.end) - helpers.log10(start);
								innerDimension = me.height;
								pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
							}
						}
						return pixel;
					},
					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var range = helpers.log10(me.end) - helpers.log10(me.start);
						var value, innerDimension;

						if (me.isHorizontal()) {
							innerDimension = me.width;
							value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
						} else {
							// todo: if start === 0
							innerDimension = me.height;
							value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
						}
						return value;
					}
				});
				Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
			};
		}, { "34": 34, "45": 45 }], 56: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var globalDefaults = defaults.global;

				var defaultConfig = {
					display: true,

					// Boolean - Whether to animate scaling the chart from the centre
					animate: true,
					position: 'chartArea',

					angleLines: {
						display: true,
						color: 'rgba(0, 0, 0, 0.1)',
						lineWidth: 1
					},

					gridLines: {
						circular: false
					},

					// label settings
					ticks: {
						// Boolean - Show a backdrop to the scale label
						showLabelBackdrop: true,

						// String - The colour of the label backdrop
						backdropColor: 'rgba(255,255,255,0.75)',

						// Number - The backdrop padding above & below the label in pixels
						backdropPaddingY: 2,

						// Number - The backdrop padding to the side of the label in pixels
						backdropPaddingX: 2,

						callback: Ticks.formatters.linear
					},

					pointLabels: {
						// Boolean - if true, show point labels
						display: true,

						// Number - Point label font size in pixels
						fontSize: 10,

						// Function - Used to convert point labels
						callback: function callback(label) {
							return label;
						}
					}
				};

				function getValueCount(scale) {
					var opts = scale.options;
					return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
				}

				function getPointLabelFontOptions(scale) {
					var pointLabelOptions = scale.options.pointLabels;
					var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
					var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
					var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
					var font = helpers.fontString(fontSize, fontStyle, fontFamily);

					return {
						size: fontSize,
						style: fontStyle,
						family: fontFamily,
						font: font
					};
				}

				function measureLabelSize(ctx, fontSize, label) {
					if (helpers.isArray(label)) {
						return {
							w: helpers.longestText(ctx, ctx.font, label),
							h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize
						};
					}

					return {
						w: ctx.measureText(label).width,
						h: fontSize
					};
				}

				function determineLimits(angle, pos, size, min, max) {
					if (angle === min || angle === max) {
						return {
							start: pos - size / 2,
							end: pos + size / 2
						};
					} else if (angle < min || angle > max) {
						return {
							start: pos - size - 5,
							end: pos
						};
					}

					return {
						start: pos,
						end: pos + size + 5
					};
				}

				/**
     * Helper function to fit a radial linear scale with point labels
     */
				function fitWithPointLabels(scale) {
					/*
      * Right, this is really confusing and there is a lot of maths going on here
      * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      *
      * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      *
      * Solution:
      *
      * We assume the radius of the polygon is half the size of the canvas at first
      * at each index we check if the text overlaps.
      *
      * Where it does, we store that angle and that index.
      *
      * After finding the largest index and angle we calculate how much we need to remove
      * from the shape radius to move the point inwards by that x.
      *
      * We average the left and right distances to get the maximum shape radius that can fit in the box
      * along with labels.
      *
      * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      * on each side, removing that from the size, halving it and adding the left x protrusion width.
      *
      * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      * and position it in the most space efficient manner
      *
      * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      */

					var plFont = getPointLabelFontOptions(scale);

					// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
					// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
					var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
					var furthestLimits = {
						r: scale.width,
						l: 0,
						t: scale.height,
						b: 0
					};
					var furthestAngles = {};
					var i, textSize, pointPosition;

					scale.ctx.font = plFont.font;
					scale._pointLabelSizes = [];

					var valueCount = getValueCount(scale);
					for (i = 0; i < valueCount; i++) {
						pointPosition = scale.getPointPosition(i, largestPossibleRadius);
						textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
						scale._pointLabelSizes[i] = textSize;

						// Add quarter circle to make degree 0 mean top of circle
						var angleRadians = scale.getIndexAngle(i);
						var angle = helpers.toDegrees(angleRadians) % 360;
						var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
						var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

						if (hLimits.start < furthestLimits.l) {
							furthestLimits.l = hLimits.start;
							furthestAngles.l = angleRadians;
						}

						if (hLimits.end > furthestLimits.r) {
							furthestLimits.r = hLimits.end;
							furthestAngles.r = angleRadians;
						}

						if (vLimits.start < furthestLimits.t) {
							furthestLimits.t = vLimits.start;
							furthestAngles.t = angleRadians;
						}

						if (vLimits.end > furthestLimits.b) {
							furthestLimits.b = vLimits.end;
							furthestAngles.b = angleRadians;
						}
					}

					scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
				}

				/**
     * Helper function to fit a radial linear scale with no point labels
     */
				function _fit(scale) {
					var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
					scale.drawingArea = Math.round(largestPossibleRadius);
					scale.setCenterPoint(0, 0, 0, 0);
				}

				function getTextAlignForAngle(angle) {
					if (angle === 0 || angle === 180) {
						return 'center';
					} else if (angle < 180) {
						return 'left';
					}

					return 'right';
				}

				function fillText(ctx, text, position, fontSize) {
					if (helpers.isArray(text)) {
						var y = position.y;
						var spacing = 1.5 * fontSize;

						for (var i = 0; i < text.length; ++i) {
							ctx.fillText(text[i], position.x, y);
							y += spacing;
						}
					} else {
						ctx.fillText(text, position.x, position.y);
					}
				}

				function adjustPointPositionForLabelHeight(angle, textSize, position) {
					if (angle === 90 || angle === 270) {
						position.y -= textSize.h / 2;
					} else if (angle > 270 || angle < 90) {
						position.y -= textSize.h;
					}
				}

				function drawPointLabels(scale) {
					var ctx = scale.ctx;
					var valueOrDefault = helpers.valueOrDefault;
					var opts = scale.options;
					var angleLineOpts = opts.angleLines;
					var pointLabelOpts = opts.pointLabels;

					ctx.lineWidth = angleLineOpts.lineWidth;
					ctx.strokeStyle = angleLineOpts.color;

					var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

					// Point Label Font
					var plFont = getPointLabelFontOptions(scale);

					ctx.textBaseline = 'top';

					for (var i = getValueCount(scale) - 1; i >= 0; i--) {
						if (angleLineOpts.display) {
							var outerPosition = scale.getPointPosition(i, outerDistance);
							ctx.beginPath();
							ctx.moveTo(scale.xCenter, scale.yCenter);
							ctx.lineTo(outerPosition.x, outerPosition.y);
							ctx.stroke();
							ctx.closePath();
						}

						if (pointLabelOpts.display) {
							// Extra 3px out for some label spacing
							var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

							// Keep this in loop since we may support array properties here
							var pointLabelFontColor = valueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
							ctx.font = plFont.font;
							ctx.fillStyle = pointLabelFontColor;

							var angleRadians = scale.getIndexAngle(i);
							var angle = helpers.toDegrees(angleRadians);
							ctx.textAlign = getTextAlignForAngle(angle);
							adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
							fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
						}
					}
				}

				function drawRadiusLine(scale, gridLineOpts, radius, index) {
					var ctx = scale.ctx;
					ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
					ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

					if (scale.options.gridLines.circular) {
						// Draw circular arcs between the points
						ctx.beginPath();
						ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
						ctx.closePath();
						ctx.stroke();
					} else {
						// Draw straight lines connecting each index
						var valueCount = getValueCount(scale);

						if (valueCount === 0) {
							return;
						}

						ctx.beginPath();
						var pointPosition = scale.getPointPosition(0, radius);
						ctx.moveTo(pointPosition.x, pointPosition.y);

						for (var i = 1; i < valueCount; i++) {
							pointPosition = scale.getPointPosition(i, radius);
							ctx.lineTo(pointPosition.x, pointPosition.y);
						}

						ctx.closePath();
						ctx.stroke();
					}
				}

				function numberOrZero(param) {
					return helpers.isNumber(param) ? param : 0;
				}

				var LinearRadialScale = Chart.LinearScaleBase.extend({
					setDimensions: function setDimensions() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;
						// Set the unconstrained dimension before label rotation
						me.width = me.maxWidth;
						me.height = me.maxHeight;
						me.xCenter = Math.round(me.width / 2);
						me.yCenter = Math.round(me.height / 2);

						var minSize = helpers.min([me.height, me.width]);
						var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
						me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;
					},
					determineDataLimits: function determineDataLimits() {
						var me = this;
						var chart = me.chart;
						var min = Number.POSITIVE_INFINITY;
						var max = Number.NEGATIVE_INFINITY;

						helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
							if (chart.isDatasetVisible(datasetIndex)) {
								var meta = chart.getDatasetMeta(datasetIndex);

								helpers.each(dataset.data, function (rawValue, index) {
									var value = +me.getRightValue(rawValue);
									if (isNaN(value) || meta.data[index].hidden) {
										return;
									}

									min = Math.min(value, min);
									max = Math.max(value, max);
								});
							}
						});

						me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
						me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;

						// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
						me.handleTickRangeOptions();
					},
					getTickLimit: function getTickLimit() {
						var tickOpts = this.options.ticks;
						var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
						return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
					},
					convertTicksToLabels: function convertTicksToLabels() {
						var me = this;

						Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

						// Point labels
						me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
					},
					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
					},
					fit: function fit() {
						if (this.options.pointLabels.display) {
							fitWithPointLabels(this);
						} else {
							_fit(this);
						}
					},
					/**
      * Set radius reductions and determine new radius and center point
      * @private
      */
					setReductions: function setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
						var me = this;
						var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
						var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
						var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
						var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

						radiusReductionLeft = numberOrZero(radiusReductionLeft);
						radiusReductionRight = numberOrZero(radiusReductionRight);
						radiusReductionTop = numberOrZero(radiusReductionTop);
						radiusReductionBottom = numberOrZero(radiusReductionBottom);

						me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
						me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
					},
					setCenterPoint: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
						var me = this;
						var maxRight = me.width - rightMovement - me.drawingArea;
						var maxLeft = leftMovement + me.drawingArea;
						var maxTop = topMovement + me.drawingArea;
						var maxBottom = me.height - bottomMovement - me.drawingArea;

						me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
						me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);
					},

					getIndexAngle: function getIndexAngle(index) {
						var angleMultiplier = Math.PI * 2 / getValueCount(this);
						var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;

						var startAngleRadians = startAngle * Math.PI * 2 / 360;

						// Start from the top instead of right, so remove a quarter of the circle
						return index * angleMultiplier + startAngleRadians;
					},
					getDistanceFromCenterForValue: function getDistanceFromCenterForValue(value) {
						var me = this;

						if (value === null) {
							return 0; // null always in center
						}

						// Take into account half font size + the yPadding of the top value
						var scalingFactor = me.drawingArea / (me.max - me.min);
						if (me.options.ticks.reverse) {
							return (me.max - value) * scalingFactor;
						}
						return (value - me.min) * scalingFactor;
					},
					getPointPosition: function getPointPosition(index, distanceFromCenter) {
						var me = this;
						var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
						return {
							x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
							y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
						};
					},
					getPointPositionForValue: function getPointPositionForValue(index, value) {
						return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
					},

					getBasePosition: function getBasePosition() {
						var me = this;
						var min = me.min;
						var max = me.max;

						return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
					},

					draw: function draw() {
						var me = this;
						var opts = me.options;
						var gridLineOpts = opts.gridLines;
						var tickOpts = opts.ticks;
						var valueOrDefault = helpers.valueOrDefault;

						if (opts.display) {
							var ctx = me.ctx;
							var startAngle = this.getIndexAngle(0);

							// Tick Font
							var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
							var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
							var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
							var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

							helpers.each(me.ticks, function (label, index) {
								// Don't draw a centre value (if it is minimum)
								if (index > 0 || tickOpts.reverse) {
									var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

									// Draw circular lines around the scale
									if (gridLineOpts.display && index !== 0) {
										drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
									}

									if (tickOpts.display) {
										var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
										ctx.font = tickLabelFont;

										ctx.save();
										ctx.translate(me.xCenter, me.yCenter);
										ctx.rotate(startAngle);

										if (tickOpts.showLabelBackdrop) {
											var labelWidth = ctx.measureText(label).width;
											ctx.fillStyle = tickOpts.backdropColor;
											ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);
										}

										ctx.textAlign = 'center';
										ctx.textBaseline = 'middle';
										ctx.fillStyle = tickFontColor;
										ctx.fillText(label, 0, -yCenterOffset);
										ctx.restore();
									}
								}
							});

							if (opts.angleLines.display || opts.pointLabels.display) {
								drawPointLabels(me);
							}
						}
					}
				});
				Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
			};
		}, { "25": 25, "34": 34, "45": 45 }], 57: [function (require, module, exports) {
			/* global window: false */
			'use strict';

			var moment = require(1);
			moment = typeof moment === 'function' ? moment : window.moment;

			var defaults = require(25);
			var helpers = require(45);

			// Integer constants are from the ES6 spec.
			var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
			var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

			var INTERVALS = {
				millisecond: {
					major: true,
					size: 1,
					steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
				},
				second: {
					major: true,
					size: 1000,
					steps: [1, 2, 5, 10, 30]
				},
				minute: {
					major: true,
					size: 60000,
					steps: [1, 2, 5, 10, 30]
				},
				hour: {
					major: true,
					size: 3600000,
					steps: [1, 2, 3, 6, 12]
				},
				day: {
					major: true,
					size: 86400000,
					steps: [1, 2, 5]
				},
				week: {
					major: false,
					size: 604800000,
					steps: [1, 2, 3, 4]
				},
				month: {
					major: true,
					size: 2.628e9,
					steps: [1, 2, 3]
				},
				quarter: {
					major: false,
					size: 7.884e9,
					steps: [1, 2, 3, 4]
				},
				year: {
					major: true,
					size: 3.154e10
				}
			};

			var UNITS = Object.keys(INTERVALS);

			function sorter(a, b) {
				return a - b;
			}

			function arrayUnique(items) {
				var hash = {};
				var out = [];
				var i, ilen, item;

				for (i = 0, ilen = items.length; i < ilen; ++i) {
					item = items[i];
					if (!hash[item]) {
						hash[item] = true;
						out.push(item);
					}
				}

				return out;
			}

			/**
    * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
    * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
    * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
    * extremity (left + width or top + height). Note that it would be more optimized to directly
    * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
    * to create the lookup table. The table ALWAYS contains at least two items: min and max.
    *
    * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
    * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
    * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
    * If 'series', timestamps will be positioned at the same distance from each other. In this
    * case, only timestamps that break the time linearity are registered, meaning that in the
    * best case, all timestamps are linear, the table contains only min and max.
    */
			function buildLookupTable(timestamps, min, max, distribution) {
				if (distribution === 'linear' || !timestamps.length) {
					return [{ time: min, pos: 0 }, { time: max, pos: 1 }];
				}

				var table = [];
				var items = [min];
				var i, ilen, prev, curr, next;

				for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
					curr = timestamps[i];
					if (curr > min && curr < max) {
						items.push(curr);
					}
				}

				items.push(max);

				for (i = 0, ilen = items.length; i < ilen; ++i) {
					next = items[i + 1];
					prev = items[i - 1];
					curr = items[i];

					// only add points that breaks the scale linearity
					if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
						table.push({ time: curr, pos: i / (ilen - 1) });
					}
				}

				return table;
			}

			// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
			function lookup(table, key, value) {
				var lo = 0;
				var hi = table.length - 1;
				var mid, i0, i1;

				while (lo >= 0 && lo <= hi) {
					mid = lo + hi >> 1;
					i0 = table[mid - 1] || null;
					i1 = table[mid];

					if (!i0) {
						// given value is outside table (before first item)
						return { lo: null, hi: i1 };
					} else if (i1[key] < value) {
						lo = mid + 1;
					} else if (i0[key] > value) {
						hi = mid - 1;
					} else {
						return { lo: i0, hi: i1 };
					}
				}

				// given value is outside table (after last item)
				return { lo: i1, hi: null };
			}

			/**
    * Linearly interpolates the given source `value` using the table items `skey` values and
    * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
    * returns the position for a timestamp equal to 42. If value is out of bounds, values at
    * index [0, 1] or [n - 1, n] are used for the interpolation.
    */
			function interpolate(table, skey, sval, tkey) {
				var range = lookup(table, skey, sval);

				// Note: the lookup table ALWAYS contains at least 2 items (min and max)
				var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
				var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

				var span = next[skey] - prev[skey];
				var ratio = span ? (sval - prev[skey]) / span : 0;
				var offset = (next[tkey] - prev[tkey]) * ratio;

				return prev[tkey] + offset;
			}

			/**
    * Convert the given value to a moment object using the given time options.
    * @see http://momentjs.com/docs/#/parsing/
    */
			function momentify(value, options) {
				var parser = options.parser;
				var format = options.parser || options.format;

				if (typeof parser === 'function') {
					return parser(value);
				}

				if (typeof value === 'string' && typeof format === 'string') {
					return moment(value, format);
				}

				if (!(value instanceof moment)) {
					value = moment(value);
				}

				if (value.isValid()) {
					return value;
				}

				// Labels are in an incompatible moment format and no `parser` has been provided.
				// The user might still use the deprecated `format` option to convert his inputs.
				if (typeof format === 'function') {
					return format(value);
				}

				return value;
			}

			function parse(input, scale) {
				if (helpers.isNullOrUndef(input)) {
					return null;
				}

				var options = scale.options.time;
				var value = momentify(scale.getRightValue(input), options);
				if (!value.isValid()) {
					return null;
				}

				if (options.round) {
					value.startOf(options.round);
				}

				return value.valueOf();
			}

			/**
    * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
    * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
    */
			function determineStepSize(min, max, unit, capacity) {
				var range = max - min;
				var interval = INTERVALS[unit];
				var milliseconds = interval.size;
				var steps = interval.steps;
				var i, ilen, factor;

				if (!steps) {
					return Math.ceil(range / ((capacity || 1) * milliseconds));
				}

				for (i = 0, ilen = steps.length; i < ilen; ++i) {
					factor = steps[i];
					if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
						break;
					}
				}

				return factor;
			}

			function determineUnit(minUnit, min, max, capacity) {
				var ilen = UNITS.length;
				var i, interval, factor;

				for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
					interval = INTERVALS[UNITS[i]];
					factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

					if (Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
						return UNITS[i];
					}
				}

				return UNITS[ilen - 1];
			}

			function determineMajorUnit(unit) {
				for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
					if (INTERVALS[UNITS[i]].major) {
						return UNITS[i];
					}
				}
			}

			/**
    * Generates a maximum of `capacity` timestamps between min and max, rounded to the
    * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
    * Important: this method can return ticks outside the min and max range, it's the
    * responsibility of the calling code to clamp values if needed.
    */
			function generate(min, max, minor, major, capacity, options) {
				var timeOpts = options.time;
				var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
				var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
				var majorTicksEnabled = options.ticks.major.enabled;
				var interval = INTERVALS[minor];
				var first = moment(min);
				var last = moment(max);
				var ticks = [];
				var time;

				if (!stepSize) {
					stepSize = determineStepSize(min, max, minor, capacity);
				}

				// For 'week' unit, handle the first day of week option
				if (weekday) {
					first = first.isoWeekday(weekday);
					last = last.isoWeekday(weekday);
				}

				// Align first/last ticks on unit
				first = first.startOf(weekday ? 'day' : minor);
				last = last.startOf(weekday ? 'day' : minor);

				// Make sure that the last tick include max
				if (last < max) {
					last.add(1, minor);
				}

				time = moment(first);

				if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
					// Align the first tick on the previous `minor` unit aligned on the `major` unit:
					// we first aligned time on the previous `major` unit then add the number of full
					// stepSize there is between first and the previous major time.
					time.startOf(major);
					time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
				}

				for (; time < last; time.add(stepSize, minor)) {
					ticks.push(+time);
				}

				ticks.push(+time);

				return ticks;
			}

			/**
    * Returns the right and left offsets from edges in the form of {left, right}.
    * Offsets are added when the `offset` option is true.
    */
			function computeOffsets(table, ticks, min, max, options) {
				var left = 0;
				var right = 0;
				var upper, lower;

				if (options.offset && ticks.length) {
					if (!options.time.min) {
						upper = ticks.length > 1 ? ticks[1] : max;
						lower = ticks[0];
						left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
					}
					if (!options.time.max) {
						upper = ticks[ticks.length - 1];
						lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
						right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
					}
				}

				return { left: left, right: right };
			}

			function ticksFromTimestamps(values, majorUnit) {
				var ticks = [];
				var i, ilen, value, major;

				for (i = 0, ilen = values.length; i < ilen; ++i) {
					value = values[i];
					major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;

					ticks.push({
						value: value,
						major: major
					});
				}

				return ticks;
			}

			module.exports = function (Chart) {

				var defaultConfig = {
					position: 'bottom',

					/**
      * Data distribution along the scale:
      * - 'linear': data are spread according to their time (distances can vary),
      * - 'series': data are spread at the same distance from each other.
      * @see https://github.com/chartjs/Chart.js/pull/4507
      * @since 2.7.0
      */
					distribution: 'linear',

					/**
      * Scale boundary strategy (bypassed by min/max time options)
      * - `data`: make sure data are fully visible, ticks outside are removed
      * - `ticks`: make sure ticks are fully visible, data outside are truncated
      * @see https://github.com/chartjs/Chart.js/pull/4556
      * @since 2.7.0
      */
					bounds: 'data',

					time: {
						parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
						format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
						unit: false, // false == automatic or override with week, month, year, etc.
						round: false, // none, or override with week, month, year, etc.
						displayFormat: false, // DEPRECATED
						isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
						minUnit: 'millisecond',

						// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
						displayFormats: {
							millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
							second: 'h:mm:ss a', // 11:20:01 AM
							minute: 'h:mm a', // 11:20 AM
							hour: 'hA', // 5PM
							day: 'MMM D', // Sep 4
							week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
							month: 'MMM YYYY', // Sept 2015
							quarter: '[Q]Q - YYYY', // Q3
							year: 'YYYY' // 2015
						}
					},
					ticks: {
						autoSkip: false,

						/**
       * Ticks generation input values:
       * - 'auto': generates "optimal" ticks based on scale size and time options.
       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
       * - 'labels': generates ticks from user given `data.labels` values ONLY.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
						source: 'auto',

						major: {
							enabled: false
						}
					}
				};

				var TimeScale = Chart.Scale.extend({
					initialize: function initialize() {
						if (!moment) {
							throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
						}

						this.mergeTicksOptions();

						Chart.Scale.prototype.initialize.call(this);
					},

					update: function update() {
						var me = this;
						var options = me.options;

						// DEPRECATIONS: output a message only one time per update
						if (options.time && options.time.format) {
							console.warn('options.time.format is deprecated and replaced by options.time.parser.');
						}

						return Chart.Scale.prototype.update.apply(me, arguments);
					},

					/**
      * Allows data to be referenced via 't' attribute
      */
					getRightValue: function getRightValue(rawValue) {
						if (rawValue && rawValue.t !== undefined) {
							rawValue = rawValue.t;
						}
						return Chart.Scale.prototype.getRightValue.call(this, rawValue);
					},

					determineDataLimits: function determineDataLimits() {
						var me = this;
						var chart = me.chart;
						var timeOpts = me.options.time;
						var min = parse(timeOpts.min, me) || MAX_INTEGER;
						var max = parse(timeOpts.max, me) || MIN_INTEGER;
						var timestamps = [];
						var datasets = [];
						var labels = [];
						var i, j, ilen, jlen, data, timestamp;

						// Convert labels to timestamps
						for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
							labels.push(parse(chart.data.labels[i], me));
						}

						// Convert data to timestamps
						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							if (chart.isDatasetVisible(i)) {
								data = chart.data.datasets[i].data;

								// Let's consider that all data have the same format.
								if (helpers.isObject(data[0])) {
									datasets[i] = [];

									for (j = 0, jlen = data.length; j < jlen; ++j) {
										timestamp = parse(data[j], me);
										timestamps.push(timestamp);
										datasets[i][j] = timestamp;
									}
								} else {
									timestamps.push.apply(timestamps, labels);
									datasets[i] = labels.slice(0);
								}
							} else {
								datasets[i] = [];
							}
						}

						if (labels.length) {
							// Sort labels **after** data have been converted
							labels = arrayUnique(labels).sort(sorter);
							min = Math.min(min, labels[0]);
							max = Math.max(max, labels[labels.length - 1]);
						}

						if (timestamps.length) {
							timestamps = arrayUnique(timestamps).sort(sorter);
							min = Math.min(min, timestamps[0]);
							max = Math.max(max, timestamps[timestamps.length - 1]);
						}

						// In case there is no valid min/max, let's use today limits
						min = min === MAX_INTEGER ? +moment().startOf('day') : min;
						max = max === MIN_INTEGER ? +moment().endOf('day') + 1 : max;

						// Make sure that max is strictly higher than min (required by the lookup table)
						me.min = Math.min(min, max);
						me.max = Math.max(min + 1, max);

						// PRIVATE
						me._horizontal = me.isHorizontal();
						me._table = [];
						me._timestamps = {
							data: timestamps,
							datasets: datasets,
							labels: labels
						};
					},

					buildTicks: function buildTicks() {
						var me = this;
						var min = me.min;
						var max = me.max;
						var options = me.options;
						var timeOpts = options.time;
						var formats = timeOpts.displayFormats;
						var capacity = me.getLabelCapacity(min);
						var unit = timeOpts.unit || determineUnit(timeOpts.minUnit, min, max, capacity);
						var majorUnit = determineMajorUnit(unit);
						var timestamps = [];
						var ticks = [];
						var i, ilen, timestamp;

						switch (options.ticks.source) {
							case 'data':
								timestamps = me._timestamps.data;
								break;
							case 'labels':
								timestamps = me._timestamps.labels;
								break;
							case 'auto':
							default:
								timestamps = generate(min, max, unit, majorUnit, capacity, options);
						}

						if (options.bounds === 'ticks' && timestamps.length) {
							min = timestamps[0];
							max = timestamps[timestamps.length - 1];
						}

						// Enforce limits with user min/max options
						min = parse(timeOpts.min, me) || min;
						max = parse(timeOpts.max, me) || max;

						// Remove ticks outside the min/max range
						for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
							timestamp = timestamps[i];
							if (timestamp >= min && timestamp <= max) {
								ticks.push(timestamp);
							}
						}

						me.min = min;
						me.max = max;

						// PRIVATE
						me._unit = unit;
						me._majorUnit = majorUnit;
						me._minorFormat = formats[unit];
						me._majorFormat = formats[majorUnit];
						me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
						me._offsets = computeOffsets(me._table, ticks, min, max, options);

						return ticksFromTimestamps(ticks, majorUnit);
					},

					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						var me = this;
						var data = me.chart.data;
						var timeOpts = me.options.time;
						var label = data.labels && index < data.labels.length ? data.labels[index] : '';
						var value = data.datasets[datasetIndex].data[index];

						if (helpers.isObject(value)) {
							label = me.getRightValue(value);
						}
						if (timeOpts.tooltipFormat) {
							label = momentify(label, timeOpts).format(timeOpts.tooltipFormat);
						}

						return label;
					},

					/**
      * Function to format an individual tick mark
      * @private
      */
					tickFormatFunction: function tickFormatFunction(tick, index, ticks) {
						var me = this;
						var options = me.options;
						var time = tick.valueOf();
						var majorUnit = me._majorUnit;
						var majorFormat = me._majorFormat;
						var majorTime = tick.clone().startOf(me._majorUnit).valueOf();
						var majorTickOpts = options.ticks.major;
						var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
						var label = tick.format(major ? majorFormat : me._minorFormat);
						var tickOpts = major ? majorTickOpts : options.ticks.minor;
						var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

						return formatter ? formatter(label, index, ticks) : label;
					},

					convertTicksToLabels: function convertTicksToLabels(ticks) {
						var labels = [];
						var i, ilen;

						for (i = 0, ilen = ticks.length; i < ilen; ++i) {
							labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
						}

						return labels;
					},

					/**
      * @private
      */
					getPixelForOffset: function getPixelForOffset(time) {
						var me = this;
						var size = me._horizontal ? me.width : me.height;
						var start = me._horizontal ? me.left : me.top;
						var pos = interpolate(me._table, 'time', time, 'pos');

						return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
					},

					getPixelForValue: function getPixelForValue(value, index, datasetIndex) {
						var me = this;
						var time = null;

						if (index !== undefined && datasetIndex !== undefined) {
							time = me._timestamps.datasets[datasetIndex][index];
						}

						if (time === null) {
							time = parse(value, me);
						}

						if (time !== null) {
							return me.getPixelForOffset(time);
						}
					},

					getPixelForTick: function getPixelForTick(index) {
						var ticks = this.getTicks();
						return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
					},

					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var size = me._horizontal ? me.width : me.height;
						var start = me._horizontal ? me.left : me.top;
						var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
						var time = interpolate(me._table, 'pos', pos, 'time');

						return moment(time);
					},

					/**
      * Crude approximation of what the label width might be
      * @private
      */
					getLabelWidth: function getLabelWidth(label) {
						var me = this;
						var ticksOpts = me.options.ticks;
						var tickLabelWidth = me.ctx.measureText(label).width;
						var angle = helpers.toRadians(ticksOpts.maxRotation);
						var cosRotation = Math.cos(angle);
						var sinRotation = Math.sin(angle);
						var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

						return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
					},

					/**
      * @private
      */
					getLabelCapacity: function getLabelCapacity(exampleTime) {
						var me = this;

						me._minorFormat = me.options.time.displayFormats.millisecond; // Pick the longest format for guestimation

						var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);
						var tickLabelWidth = me.getLabelWidth(exampleLabel);
						var innerWidth = me.isHorizontal() ? me.width : me.height;

						return Math.floor(innerWidth / tickLabelWidth);
					}
				});

				Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
			};
		}, { "1": 1, "25": 25, "45": 45 }] }, {}, [7])(7);
});

/***/ }),

/***/ 69:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
Turbolinks 5.1.1
Copyright © 2018 Basecamp, LLC
 */
(function(){var t=this;(function(){(function(){this.Turbolinks={supported:function(){return null!=window.history.pushState&&null!=window.requestAnimationFrame&&null!=window.addEventListener}(),visit:function(t,r){return e.controller.visit(t,r)},clearCache:function(){return e.controller.clearCache()},setProgressBarDelay:function(t){return e.controller.setProgressBarDelay(t)}}}).call(this)}).call(t);var e=t.Turbolinks;(function(){(function(){var t,r,n,o=[].slice;e.copyObject=function(t){var e,r,n;r={};for(e in t)n=t[e],r[e]=n;return r},e.closest=function(e,r){return t.call(e,r)},t=function(){var t,e;return t=document.documentElement,null!=(e=t.closest)?e:function(t){var e;for(e=this;e;){if(e.nodeType===Node.ELEMENT_NODE&&r.call(e,t))return e;e=e.parentNode}}}(),e.defer=function(t){return setTimeout(t,1)},e.throttle=function(t){var e;return e=null,function(){var r;return r=1<=arguments.length?o.call(arguments,0):[],null!=e?e:e=requestAnimationFrame(function(n){return function(){return e=null,t.apply(n,r)}}(this))}},e.dispatch=function(t,e){var r,o,i,s,a,u;return a=null!=e?e:{},u=a.target,r=a.cancelable,o=a.data,i=document.createEvent("Events"),i.initEvent(t,!0,r===!0),i.data=null!=o?o:{},i.cancelable&&!n&&(s=i.preventDefault,i.preventDefault=function(){return this.defaultPrevented||Object.defineProperty(this,"defaultPrevented",{get:function(){return!0}}),s.call(this)}),(null!=u?u:document).dispatchEvent(i),i},n=function(){var t;return t=document.createEvent("Events"),t.initEvent("test",!0,!0),t.preventDefault(),t.defaultPrevented}(),e.match=function(t,e){return r.call(t,e)},r=function(){var t,e,r,n;return t=document.documentElement,null!=(e=null!=(r=null!=(n=t.matchesSelector)?n:t.webkitMatchesSelector)?r:t.msMatchesSelector)?e:t.mozMatchesSelector}(),e.uuid=function(){var t,e,r;for(r="",t=e=1;36>=e;t=++e)r+=9===t||14===t||19===t||24===t?"-":15===t?"4":20===t?(Math.floor(4*Math.random())+8).toString(16):Math.floor(15*Math.random()).toString(16);return r}}).call(this),function(){e.Location=function(){function t(t){var e,r;null==t&&(t=""),r=document.createElement("a"),r.href=t.toString(),this.absoluteURL=r.href,e=r.hash.length,2>e?this.requestURL=this.absoluteURL:(this.requestURL=this.absoluteURL.slice(0,-e),this.anchor=r.hash.slice(1))}var e,r,n,o;return t.wrap=function(t){return t instanceof this?t:new this(t)},t.prototype.getOrigin=function(){return this.absoluteURL.split("/",3).join("/")},t.prototype.getPath=function(){var t,e;return null!=(t=null!=(e=this.requestURL.match(/\/\/[^\/]*(\/[^?;]*)/))?e[1]:void 0)?t:"/"},t.prototype.getPathComponents=function(){return this.getPath().split("/").slice(1)},t.prototype.getLastPathComponent=function(){return this.getPathComponents().slice(-1)[0]},t.prototype.getExtension=function(){var t,e;return null!=(t=null!=(e=this.getLastPathComponent().match(/\.[^.]*$/))?e[0]:void 0)?t:""},t.prototype.isHTML=function(){return this.getExtension().match(/^(?:|\.(?:htm|html|xhtml))$/)},t.prototype.isPrefixedBy=function(t){var e;return e=r(t),this.isEqualTo(t)||o(this.absoluteURL,e)},t.prototype.isEqualTo=function(t){return this.absoluteURL===(null!=t?t.absoluteURL:void 0)},t.prototype.toCacheKey=function(){return this.requestURL},t.prototype.toJSON=function(){return this.absoluteURL},t.prototype.toString=function(){return this.absoluteURL},t.prototype.valueOf=function(){return this.absoluteURL},r=function(t){return e(t.getOrigin()+t.getPath())},e=function(t){return n(t,"/")?t:t+"/"},o=function(t,e){return t.slice(0,e.length)===e},n=function(t,e){return t.slice(-e.length)===e},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.HttpRequest=function(){function r(r,n,o){this.delegate=r,this.requestCanceled=t(this.requestCanceled,this),this.requestTimedOut=t(this.requestTimedOut,this),this.requestFailed=t(this.requestFailed,this),this.requestLoaded=t(this.requestLoaded,this),this.requestProgressed=t(this.requestProgressed,this),this.url=e.Location.wrap(n).requestURL,this.referrer=e.Location.wrap(o).absoluteURL,this.createXHR()}return r.NETWORK_FAILURE=0,r.TIMEOUT_FAILURE=-1,r.timeout=60,r.prototype.send=function(){var t;return this.xhr&&!this.sent?(this.notifyApplicationBeforeRequestStart(),this.setProgress(0),this.xhr.send(),this.sent=!0,"function"==typeof(t=this.delegate).requestStarted?t.requestStarted():void 0):void 0},r.prototype.cancel=function(){return this.xhr&&this.sent?this.xhr.abort():void 0},r.prototype.requestProgressed=function(t){return t.lengthComputable?this.setProgress(t.loaded/t.total):void 0},r.prototype.requestLoaded=function(){return this.endRequest(function(t){return function(){var e;return 200<=(e=t.xhr.status)&&300>e?t.delegate.requestCompletedWithResponse(t.xhr.responseText,t.xhr.getResponseHeader("Turbolinks-Location")):(t.failed=!0,t.delegate.requestFailedWithStatusCode(t.xhr.status,t.xhr.responseText))}}(this))},r.prototype.requestFailed=function(){return this.endRequest(function(t){return function(){return t.failed=!0,t.delegate.requestFailedWithStatusCode(t.constructor.NETWORK_FAILURE)}}(this))},r.prototype.requestTimedOut=function(){return this.endRequest(function(t){return function(){return t.failed=!0,t.delegate.requestFailedWithStatusCode(t.constructor.TIMEOUT_FAILURE)}}(this))},r.prototype.requestCanceled=function(){return this.endRequest()},r.prototype.notifyApplicationBeforeRequestStart=function(){return e.dispatch("turbolinks:request-start",{data:{url:this.url,xhr:this.xhr}})},r.prototype.notifyApplicationAfterRequestEnd=function(){return e.dispatch("turbolinks:request-end",{data:{url:this.url,xhr:this.xhr}})},r.prototype.createXHR=function(){return this.xhr=new XMLHttpRequest,this.xhr.open("GET",this.url,!0),this.xhr.timeout=1e3*this.constructor.timeout,this.xhr.setRequestHeader("Accept","text/html, application/xhtml+xml"),this.xhr.setRequestHeader("Turbolinks-Referrer",this.referrer),this.xhr.onprogress=this.requestProgressed,this.xhr.onload=this.requestLoaded,this.xhr.onerror=this.requestFailed,this.xhr.ontimeout=this.requestTimedOut,this.xhr.onabort=this.requestCanceled},r.prototype.endRequest=function(t){return this.xhr?(this.notifyApplicationAfterRequestEnd(),null!=t&&t.call(this),this.destroy()):void 0},r.prototype.setProgress=function(t){var e;return this.progress=t,"function"==typeof(e=this.delegate).requestProgressed?e.requestProgressed(this.progress):void 0},r.prototype.destroy=function(){var t;return this.setProgress(1),"function"==typeof(t=this.delegate).requestFinished&&t.requestFinished(),this.delegate=null,this.xhr=null},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.ProgressBar=function(){function e(){this.trickle=t(this.trickle,this),this.stylesheetElement=this.createStylesheetElement(),this.progressElement=this.createProgressElement()}var r;return r=300,e.defaultCSS=".turbolinks-progress-bar {\n  position: fixed;\n  display: block;\n  top: 0;\n  left: 0;\n  height: 3px;\n  background: #0076ff;\n  z-index: 9999;\n  transition: width "+r+"ms ease-out, opacity "+r/2+"ms "+r/2+"ms ease-in;\n  transform: translate3d(0, 0, 0);\n}",e.prototype.show=function(){return this.visible?void 0:(this.visible=!0,this.installStylesheetElement(),this.installProgressElement(),this.startTrickling())},e.prototype.hide=function(){return this.visible&&!this.hiding?(this.hiding=!0,this.fadeProgressElement(function(t){return function(){return t.uninstallProgressElement(),t.stopTrickling(),t.visible=!1,t.hiding=!1}}(this))):void 0},e.prototype.setValue=function(t){return this.value=t,this.refresh()},e.prototype.installStylesheetElement=function(){return document.head.insertBefore(this.stylesheetElement,document.head.firstChild)},e.prototype.installProgressElement=function(){return this.progressElement.style.width=0,this.progressElement.style.opacity=1,document.documentElement.insertBefore(this.progressElement,document.body),this.refresh()},e.prototype.fadeProgressElement=function(t){return this.progressElement.style.opacity=0,setTimeout(t,1.5*r)},e.prototype.uninstallProgressElement=function(){return this.progressElement.parentNode?document.documentElement.removeChild(this.progressElement):void 0},e.prototype.startTrickling=function(){return null!=this.trickleInterval?this.trickleInterval:this.trickleInterval=setInterval(this.trickle,r)},e.prototype.stopTrickling=function(){return clearInterval(this.trickleInterval),this.trickleInterval=null},e.prototype.trickle=function(){return this.setValue(this.value+Math.random()/100)},e.prototype.refresh=function(){return requestAnimationFrame(function(t){return function(){return t.progressElement.style.width=10+90*t.value+"%"}}(this))},e.prototype.createStylesheetElement=function(){var t;return t=document.createElement("style"),t.type="text/css",t.textContent=this.constructor.defaultCSS,t},e.prototype.createProgressElement=function(){var t;return t=document.createElement("div"),t.className="turbolinks-progress-bar",t},e}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.BrowserAdapter=function(){function r(r){this.controller=r,this.showProgressBar=t(this.showProgressBar,this),this.progressBar=new e.ProgressBar}var n,o,i;return i=e.HttpRequest,n=i.NETWORK_FAILURE,o=i.TIMEOUT_FAILURE,r.prototype.visitProposedToLocationWithAction=function(t,e){return this.controller.startVisitToLocationWithAction(t,e)},r.prototype.visitStarted=function(t){return t.issueRequest(),t.changeHistory(),t.loadCachedSnapshot()},r.prototype.visitRequestStarted=function(t){return this.progressBar.setValue(0),t.hasCachedSnapshot()||"restore"!==t.action?this.showProgressBarAfterDelay():this.showProgressBar()},r.prototype.visitRequestProgressed=function(t){return this.progressBar.setValue(t.progress)},r.prototype.visitRequestCompleted=function(t){return t.loadResponse()},r.prototype.visitRequestFailedWithStatusCode=function(t,e){switch(e){case n:case o:return this.reload();default:return t.loadResponse()}},r.prototype.visitRequestFinished=function(t){return this.hideProgressBar()},r.prototype.visitCompleted=function(t){return t.followRedirect()},r.prototype.pageInvalidated=function(){return this.reload()},r.prototype.showProgressBarAfterDelay=function(){return this.progressBarTimeout=setTimeout(this.showProgressBar,this.controller.progressBarDelay)},r.prototype.showProgressBar=function(){return this.progressBar.show()},r.prototype.hideProgressBar=function(){return this.progressBar.hide(),clearTimeout(this.progressBarTimeout)},r.prototype.reload=function(){return window.location.reload()},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.History=function(){function r(e){this.delegate=e,this.onPageLoad=t(this.onPageLoad,this),this.onPopState=t(this.onPopState,this)}return r.prototype.start=function(){return this.started?void 0:(addEventListener("popstate",this.onPopState,!1),addEventListener("load",this.onPageLoad,!1),this.started=!0)},r.prototype.stop=function(){return this.started?(removeEventListener("popstate",this.onPopState,!1),removeEventListener("load",this.onPageLoad,!1),this.started=!1):void 0},r.prototype.push=function(t,r){return t=e.Location.wrap(t),this.update("push",t,r)},r.prototype.replace=function(t,r){return t=e.Location.wrap(t),this.update("replace",t,r)},r.prototype.onPopState=function(t){var r,n,o,i;return this.shouldHandlePopState()&&(i=null!=(n=t.state)?n.turbolinks:void 0)?(r=e.Location.wrap(window.location),o=i.restorationIdentifier,this.delegate.historyPoppedToLocationWithRestorationIdentifier(r,o)):void 0},r.prototype.onPageLoad=function(t){return e.defer(function(t){return function(){return t.pageLoaded=!0}}(this))},r.prototype.shouldHandlePopState=function(){return this.pageIsLoaded()},r.prototype.pageIsLoaded=function(){return this.pageLoaded||"complete"===document.readyState},r.prototype.update=function(t,e,r){var n;return n={turbolinks:{restorationIdentifier:r}},history[t+"State"](n,null,e)},r}()}.call(this),function(){e.Snapshot=function(){function t(t){var e,r;r=t.head,e=t.body,this.head=null!=r?r:document.createElement("head"),this.body=null!=e?e:document.createElement("body")}return t.wrap=function(t){return t instanceof this?t:this.fromHTML(t)},t.fromHTML=function(t){var e;return e=document.createElement("html"),e.innerHTML=t,this.fromElement(e)},t.fromElement=function(t){return new this({head:t.querySelector("head"),body:t.querySelector("body")})},t.prototype.clone=function(){return new t({head:this.head.cloneNode(!0),body:this.body.cloneNode(!0)})},t.prototype.getRootLocation=function(){var t,r;return r=null!=(t=this.getSetting("root"))?t:"/",new e.Location(r)},t.prototype.getCacheControlValue=function(){return this.getSetting("cache-control")},t.prototype.getElementForAnchor=function(t){try{return this.body.querySelector("[id='"+t+"'], a[name='"+t+"']")}catch(e){}},t.prototype.hasAnchor=function(t){return null!=this.getElementForAnchor(t)},t.prototype.isPreviewable=function(){return"no-preview"!==this.getCacheControlValue()},t.prototype.isCacheable=function(){return"no-cache"!==this.getCacheControlValue()},t.prototype.isVisitable=function(){return"reload"!==this.getSetting("visit-control")},t.prototype.getSetting=function(t){var e,r;return r=this.head.querySelectorAll("meta[name='turbolinks-"+t+"']"),e=r[r.length-1],null!=e?e.getAttribute("content"):void 0},t}()}.call(this),function(){var t=[].slice;e.Renderer=function(){function e(){}var r;return e.render=function(){var e,r,n,o;return n=arguments[0],r=arguments[1],e=3<=arguments.length?t.call(arguments,2):[],o=function(t,e,r){r.prototype=t.prototype;var n=new r,o=t.apply(n,e);return Object(o)===o?o:n}(this,e,function(){}),o.delegate=n,o.render(r),o},e.prototype.renderView=function(t){return this.delegate.viewWillRender(this.newBody),t(),this.delegate.viewRendered(this.newBody)},e.prototype.invalidateView=function(){return this.delegate.viewInvalidated()},e.prototype.createScriptElement=function(t){var e;return"false"===t.getAttribute("data-turbolinks-eval")?t:(e=document.createElement("script"),e.textContent=t.textContent,e.async=!1,r(e,t),e)},r=function(t,e){var r,n,o,i,s,a,u;for(i=e.attributes,a=[],r=0,n=i.length;n>r;r++)s=i[r],o=s.name,u=s.value,a.push(t.setAttribute(o,u));return a},e}()}.call(this),function(){e.HeadDetails=function(){function t(t){var e,r,i,s,a,u,l;for(this.element=t,this.elements={},l=this.element.childNodes,s=0,u=l.length;u>s;s++)i=l[s],i.nodeType===Node.ELEMENT_NODE&&(a=i.outerHTML,r=null!=(e=this.elements)[a]?e[a]:e[a]={type:o(i),tracked:n(i),elements:[]},r.elements.push(i))}var e,r,n,o;return t.prototype.hasElementWithKey=function(t){return t in this.elements},t.prototype.getTrackedElementSignature=function(){var t,e;return function(){var r,n;r=this.elements,n=[];for(t in r)e=r[t].tracked,e&&n.push(t);return n}.call(this).join("")},t.prototype.getScriptElementsNotInDetails=function(t){return this.getElementsMatchingTypeNotInDetails("script",t)},t.prototype.getStylesheetElementsNotInDetails=function(t){return this.getElementsMatchingTypeNotInDetails("stylesheet",t)},t.prototype.getElementsMatchingTypeNotInDetails=function(t,e){var r,n,o,i,s,a;o=this.elements,s=[];for(n in o)i=o[n],a=i.type,r=i.elements,a!==t||e.hasElementWithKey(n)||s.push(r[0]);return s},t.prototype.getProvisionalElements=function(){var t,e,r,n,o,i,s;r=[],n=this.elements;for(e in n)o=n[e],s=o.type,i=o.tracked,t=o.elements,null!=s||i?t.length>1&&r.push.apply(r,t.slice(1)):r.push.apply(r,t);return r},o=function(t){return e(t)?"script":r(t)?"stylesheet":void 0},n=function(t){return"reload"===t.getAttribute("data-turbolinks-track")},e=function(t){var e;return e=t.tagName.toLowerCase(),"script"===e},r=function(t){var e;return e=t.tagName.toLowerCase(),"style"===e||"link"===e&&"stylesheet"===t.getAttribute("rel")},t}()}.call(this),function(){var t=function(t,e){function n(){this.constructor=t}for(var o in e)r.call(e,o)&&(t[o]=e[o]);return n.prototype=e.prototype,t.prototype=new n,t.__super__=e.prototype,t},r={}.hasOwnProperty;e.SnapshotRenderer=function(r){function n(t,r,n){this.currentSnapshot=t,this.newSnapshot=r,this.isPreview=n,this.currentHeadDetails=new e.HeadDetails(this.currentSnapshot.head),this.newHeadDetails=new e.HeadDetails(this.newSnapshot.head),this.newBody=this.newSnapshot.body}return t(n,r),n.prototype.render=function(t){return this.shouldRender()?(this.mergeHead(),this.renderView(function(e){return function(){return e.replaceBody(),e.isPreview||e.focusFirstAutofocusableElement(),t()}}(this))):this.invalidateView()},n.prototype.mergeHead=function(){return this.copyNewHeadStylesheetElements(),this.copyNewHeadScriptElements(),this.removeCurrentHeadProvisionalElements(),this.copyNewHeadProvisionalElements()},n.prototype.replaceBody=function(){return this.activateBodyScriptElements(),this.importBodyPermanentElements(),this.assignNewBody()},n.prototype.shouldRender=function(){return this.newSnapshot.isVisitable()&&this.trackedElementsAreIdentical()},n.prototype.trackedElementsAreIdentical=function(){return this.currentHeadDetails.getTrackedElementSignature()===this.newHeadDetails.getTrackedElementSignature()},n.prototype.copyNewHeadStylesheetElements=function(){var t,e,r,n,o;for(n=this.getNewHeadStylesheetElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(t));return o},n.prototype.copyNewHeadScriptElements=function(){var t,e,r,n,o;for(n=this.getNewHeadScriptElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(this.createScriptElement(t)));return o},n.prototype.removeCurrentHeadProvisionalElements=function(){var t,e,r,n,o;for(n=this.getCurrentHeadProvisionalElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.removeChild(t));return o},n.prototype.copyNewHeadProvisionalElements=function(){var t,e,r,n,o;for(n=this.getNewHeadProvisionalElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(t));return o},n.prototype.importBodyPermanentElements=function(){var t,e,r,n,o,i;for(n=this.getNewBodyPermanentElements(),i=[],e=0,r=n.length;r>e;e++)o=n[e],(t=this.findCurrentBodyPermanentElement(o))?i.push(o.parentNode.replaceChild(t,o)):i.push(void 0);return i},n.prototype.activateBodyScriptElements=function(){var t,e,r,n,o,i;for(n=this.getNewBodyScriptElements(),i=[],e=0,r=n.length;r>e;e++)o=n[e],t=this.createScriptElement(o),i.push(o.parentNode.replaceChild(t,o));return i},n.prototype.assignNewBody=function(){return document.body=this.newBody},n.prototype.focusFirstAutofocusableElement=function(){var t;return null!=(t=this.findFirstAutofocusableElement())?t.focus():void 0},n.prototype.getNewHeadStylesheetElements=function(){return this.newHeadDetails.getStylesheetElementsNotInDetails(this.currentHeadDetails)},n.prototype.getNewHeadScriptElements=function(){return this.newHeadDetails.getScriptElementsNotInDetails(this.currentHeadDetails)},n.prototype.getCurrentHeadProvisionalElements=function(){return this.currentHeadDetails.getProvisionalElements()},n.prototype.getNewHeadProvisionalElements=function(){return this.newHeadDetails.getProvisionalElements()},n.prototype.getNewBodyPermanentElements=function(){return this.newBody.querySelectorAll("[id][data-turbolinks-permanent]")},n.prototype.findCurrentBodyPermanentElement=function(t){return document.body.querySelector("#"+t.id+"[data-turbolinks-permanent]")},n.prototype.getNewBodyScriptElements=function(){return this.newBody.querySelectorAll("script")},n.prototype.findFirstAutofocusableElement=function(){return document.body.querySelector("[autofocus]")},n}(e.Renderer)}.call(this),function(){var t=function(t,e){function n(){this.constructor=t}for(var o in e)r.call(e,o)&&(t[o]=e[o]);return n.prototype=e.prototype,t.prototype=new n,t.__super__=e.prototype,t},r={}.hasOwnProperty;e.ErrorRenderer=function(e){function r(t){this.html=t}return t(r,e),r.prototype.render=function(t){return this.renderView(function(e){return function(){return e.replaceDocumentHTML(),e.activateBodyScriptElements(),t()}}(this))},r.prototype.replaceDocumentHTML=function(){return document.documentElement.innerHTML=this.html},r.prototype.activateBodyScriptElements=function(){var t,e,r,n,o,i;for(n=this.getScriptElements(),i=[],e=0,r=n.length;r>e;e++)o=n[e],t=this.createScriptElement(o),i.push(o.parentNode.replaceChild(t,o));return i},r.prototype.getScriptElements=function(){return document.documentElement.querySelectorAll("script")},r}(e.Renderer)}.call(this),function(){e.View=function(){function t(t){this.delegate=t,this.element=document.documentElement}return t.prototype.getRootLocation=function(){return this.getSnapshot().getRootLocation()},t.prototype.getElementForAnchor=function(t){return this.getSnapshot().getElementForAnchor(t)},t.prototype.getSnapshot=function(){return e.Snapshot.fromElement(this.element)},t.prototype.render=function(t,e){var r,n,o;return o=t.snapshot,r=t.error,n=t.isPreview,this.markAsPreview(n),null!=o?this.renderSnapshot(o,n,e):this.renderError(r,e)},t.prototype.markAsPreview=function(t){return t?this.element.setAttribute("data-turbolinks-preview",""):this.element.removeAttribute("data-turbolinks-preview")},t.prototype.renderSnapshot=function(t,r,n){return e.SnapshotRenderer.render(this.delegate,n,this.getSnapshot(),e.Snapshot.wrap(t),r)},t.prototype.renderError=function(t,r){return e.ErrorRenderer.render(this.delegate,r,t)},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.ScrollManager=function(){function r(r){this.delegate=r,this.onScroll=t(this.onScroll,this),this.onScroll=e.throttle(this.onScroll)}return r.prototype.start=function(){return this.started?void 0:(addEventListener("scroll",this.onScroll,!1),this.onScroll(),this.started=!0)},r.prototype.stop=function(){return this.started?(removeEventListener("scroll",this.onScroll,!1),this.started=!1):void 0},r.prototype.scrollToElement=function(t){return t.scrollIntoView()},r.prototype.scrollToPosition=function(t){var e,r;return e=t.x,r=t.y,window.scrollTo(e,r)},r.prototype.onScroll=function(t){return this.updatePosition({x:window.pageXOffset,y:window.pageYOffset})},r.prototype.updatePosition=function(t){var e;return this.position=t,null!=(e=this.delegate)?e.scrollPositionChanged(this.position):void 0},r}()}.call(this),function(){e.SnapshotCache=function(){function t(t){this.size=t,this.keys=[],this.snapshots={}}var r;return t.prototype.has=function(t){var e;return e=r(t),e in this.snapshots},t.prototype.get=function(t){var e;if(this.has(t))return e=this.read(t),this.touch(t),e},t.prototype.put=function(t,e){return this.write(t,e),this.touch(t),e},t.prototype.read=function(t){var e;return e=r(t),this.snapshots[e]},t.prototype.write=function(t,e){var n;return n=r(t),this.snapshots[n]=e},t.prototype.touch=function(t){var e,n;return n=r(t),e=this.keys.indexOf(n),e>-1&&this.keys.splice(e,1),this.keys.unshift(n),this.trim()},t.prototype.trim=function(){var t,e,r,n,o;for(n=this.keys.splice(this.size),o=[],t=0,r=n.length;r>t;t++)e=n[t],o.push(delete this.snapshots[e]);return o},r=function(t){return e.Location.wrap(t).toCacheKey()},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.Visit=function(){function r(r,n,o){this.controller=r,this.action=o,this.performScroll=t(this.performScroll,this),this.identifier=e.uuid(),this.location=e.Location.wrap(n),this.adapter=this.controller.adapter,this.state="initialized",this.timingMetrics={}}var n;return r.prototype.start=function(){return"initialized"===this.state?(this.recordTimingMetric("visitStart"),this.state="started",this.adapter.visitStarted(this)):void 0},r.prototype.cancel=function(){var t;return"started"===this.state?(null!=(t=this.request)&&t.cancel(),this.cancelRender(),this.state="canceled"):void 0},r.prototype.complete=function(){var t;return"started"===this.state?(this.recordTimingMetric("visitEnd"),this.state="completed","function"==typeof(t=this.adapter).visitCompleted&&t.visitCompleted(this),this.controller.visitCompleted(this)):void 0},r.prototype.fail=function(){var t;return"started"===this.state?(this.state="failed","function"==typeof(t=this.adapter).visitFailed?t.visitFailed(this):void 0):void 0},r.prototype.changeHistory=function(){var t,e;return this.historyChanged?void 0:(t=this.location.isEqualTo(this.referrer)?"replace":this.action,e=n(t),this.controller[e](this.location,this.restorationIdentifier),this.historyChanged=!0)},r.prototype.issueRequest=function(){return this.shouldIssueRequest()&&null==this.request?(this.progress=0,this.request=new e.HttpRequest(this,this.location,this.referrer),this.request.send()):void 0},r.prototype.getCachedSnapshot=function(){var t;return!(t=this.controller.getCachedSnapshotForLocation(this.location))||null!=this.location.anchor&&!t.hasAnchor(this.location.anchor)||"restore"!==this.action&&!t.isPreviewable()?void 0:t},r.prototype.hasCachedSnapshot=function(){return null!=this.getCachedSnapshot()},r.prototype.loadCachedSnapshot=function(){var t,e;return(e=this.getCachedSnapshot())?(t=this.shouldIssueRequest(),this.render(function(){var r;return this.cacheSnapshot(),this.controller.render({snapshot:e,isPreview:t},this.performScroll),"function"==typeof(r=this.adapter).visitRendered&&r.visitRendered(this),t?void 0:this.complete()})):void 0},r.prototype.loadResponse=function(){return null!=this.response?this.render(function(){var t,e;return this.cacheSnapshot(),this.request.failed?(this.controller.render({error:this.response},this.performScroll),"function"==typeof(t=this.adapter).visitRendered&&t.visitRendered(this),this.fail()):(this.controller.render({snapshot:this.response},this.performScroll),"function"==typeof(e=this.adapter).visitRendered&&e.visitRendered(this),this.complete())}):void 0},r.prototype.followRedirect=function(){return this.redirectedToLocation&&!this.followedRedirect?(this.location=this.redirectedToLocation,this.controller.replaceHistoryWithLocationAndRestorationIdentifier(this.redirectedToLocation,this.restorationIdentifier),this.followedRedirect=!0):void 0},r.prototype.requestStarted=function(){var t;return this.recordTimingMetric("requestStart"),"function"==typeof(t=this.adapter).visitRequestStarted?t.visitRequestStarted(this):void 0},r.prototype.requestProgressed=function(t){var e;return this.progress=t,"function"==typeof(e=this.adapter).visitRequestProgressed?e.visitRequestProgressed(this):void 0},r.prototype.requestCompletedWithResponse=function(t,r){return this.response=t,null!=r&&(this.redirectedToLocation=e.Location.wrap(r)),this.adapter.visitRequestCompleted(this)},r.prototype.requestFailedWithStatusCode=function(t,e){return this.response=e,this.adapter.visitRequestFailedWithStatusCode(this,t)},r.prototype.requestFinished=function(){var t;return this.recordTimingMetric("requestEnd"),"function"==typeof(t=this.adapter).visitRequestFinished?t.visitRequestFinished(this):void 0},r.prototype.performScroll=function(){return this.scrolled?void 0:("restore"===this.action?this.scrollToRestoredPosition()||this.scrollToTop():this.scrollToAnchor()||this.scrollToTop(),this.scrolled=!0)},r.prototype.scrollToRestoredPosition=function(){var t,e;return t=null!=(e=this.restorationData)?e.scrollPosition:void 0,null!=t?(this.controller.scrollToPosition(t),!0):void 0},r.prototype.scrollToAnchor=function(){return null!=this.location.anchor?(this.controller.scrollToAnchor(this.location.anchor),!0):void 0},r.prototype.scrollToTop=function(){return this.controller.scrollToPosition({x:0,y:0})},r.prototype.recordTimingMetric=function(t){var e;return null!=(e=this.timingMetrics)[t]?e[t]:e[t]=(new Date).getTime()},r.prototype.getTimingMetrics=function(){return e.copyObject(this.timingMetrics)},n=function(t){switch(t){case"replace":return"replaceHistoryWithLocationAndRestorationIdentifier";case"advance":case"restore":return"pushHistoryWithLocationAndRestorationIdentifier"}},r.prototype.shouldIssueRequest=function(){return"restore"===this.action?!this.hasCachedSnapshot():!0},r.prototype.cacheSnapshot=function(){return this.snapshotCached?void 0:(this.controller.cacheSnapshot(),this.snapshotCached=!0)},r.prototype.render=function(t){return this.cancelRender(),this.frame=requestAnimationFrame(function(e){return function(){return e.frame=null,t.call(e)}}(this))},r.prototype.cancelRender=function(){return this.frame?cancelAnimationFrame(this.frame):void 0},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.Controller=function(){function r(){this.clickBubbled=t(this.clickBubbled,this),this.clickCaptured=t(this.clickCaptured,this),this.pageLoaded=t(this.pageLoaded,this),this.history=new e.History(this),this.view=new e.View(this),this.scrollManager=new e.ScrollManager(this),this.restorationData={},this.clearCache(),this.setProgressBarDelay(500)}return r.prototype.start=function(){return e.supported&&!this.started?(addEventListener("click",this.clickCaptured,!0),addEventListener("DOMContentLoaded",this.pageLoaded,!1),this.scrollManager.start(),this.startHistory(),this.started=!0,this.enabled=!0):void 0},r.prototype.disable=function(){return this.enabled=!1},r.prototype.stop=function(){return this.started?(removeEventListener("click",this.clickCaptured,!0),removeEventListener("DOMContentLoaded",this.pageLoaded,!1),this.scrollManager.stop(),this.stopHistory(),this.started=!1):void 0},r.prototype.clearCache=function(){return this.cache=new e.SnapshotCache(10)},r.prototype.visit=function(t,r){var n,o;return null==r&&(r={}),t=e.Location.wrap(t),this.applicationAllowsVisitingLocation(t)?this.locationIsVisitable(t)?(n=null!=(o=r.action)?o:"advance",this.adapter.visitProposedToLocationWithAction(t,n)):window.location=t:void 0},r.prototype.startVisitToLocationWithAction=function(t,r,n){var o;return e.supported?(o=this.getRestorationDataForIdentifier(n),this.startVisit(t,r,{restorationData:o})):window.location=t},r.prototype.setProgressBarDelay=function(t){return this.progressBarDelay=t},r.prototype.startHistory=function(){return this.location=e.Location.wrap(window.location),this.restorationIdentifier=e.uuid(),this.history.start(),this.history.replace(this.location,this.restorationIdentifier)},r.prototype.stopHistory=function(){return this.history.stop()},r.prototype.pushHistoryWithLocationAndRestorationIdentifier=function(t,r){return this.restorationIdentifier=r,this.location=e.Location.wrap(t),this.history.push(this.location,this.restorationIdentifier)},r.prototype.replaceHistoryWithLocationAndRestorationIdentifier=function(t,r){return this.restorationIdentifier=r,this.location=e.Location.wrap(t),this.history.replace(this.location,this.restorationIdentifier)},r.prototype.historyPoppedToLocationWithRestorationIdentifier=function(t,r){var n;return this.restorationIdentifier=r,this.enabled?(n=this.getRestorationDataForIdentifier(this.restorationIdentifier),this.startVisit(t,"restore",{restorationIdentifier:this.restorationIdentifier,restorationData:n,historyChanged:!0}),this.location=e.Location.wrap(t)):this.adapter.pageInvalidated()},r.prototype.getCachedSnapshotForLocation=function(t){var e;return e=this.cache.get(t),e?e.clone():void 0},r.prototype.shouldCacheSnapshot=function(){return this.view.getSnapshot().isCacheable()},r.prototype.cacheSnapshot=function(){var t;return this.shouldCacheSnapshot()?(this.notifyApplicationBeforeCachingSnapshot(),t=this.view.getSnapshot(),this.cache.put(this.lastRenderedLocation,t.clone())):void 0},r.prototype.scrollToAnchor=function(t){var e;return(e=this.view.getElementForAnchor(t))?this.scrollToElement(e):this.scrollToPosition({x:0,y:0})},r.prototype.scrollToElement=function(t){return this.scrollManager.scrollToElement(t)},r.prototype.scrollToPosition=function(t){return this.scrollManager.scrollToPosition(t)},r.prototype.scrollPositionChanged=function(t){var e;return e=this.getCurrentRestorationData(),e.scrollPosition=t},r.prototype.render=function(t,e){return this.view.render(t,e)},r.prototype.viewInvalidated=function(){return this.adapter.pageInvalidated()},r.prototype.viewWillRender=function(t){return this.notifyApplicationBeforeRender(t)},r.prototype.viewRendered=function(){return this.lastRenderedLocation=this.currentVisit.location,this.notifyApplicationAfterRender()},r.prototype.pageLoaded=function(){return this.lastRenderedLocation=this.location,this.notifyApplicationAfterPageLoad()},r.prototype.clickCaptured=function(){return removeEventListener("click",this.clickBubbled,!1),addEventListener("click",this.clickBubbled,!1)},r.prototype.clickBubbled=function(t){var e,r,n;return this.enabled&&this.clickEventIsSignificant(t)&&(r=this.getVisitableLinkForNode(t.target))&&(n=this.getVisitableLocationForLink(r))&&this.applicationAllowsFollowingLinkToLocation(r,n)?(t.preventDefault(),e=this.getActionForLink(r),
this.visit(n,{action:e})):void 0},r.prototype.applicationAllowsFollowingLinkToLocation=function(t,e){var r;return r=this.notifyApplicationAfterClickingLinkToLocation(t,e),!r.defaultPrevented},r.prototype.applicationAllowsVisitingLocation=function(t){var e;return e=this.notifyApplicationBeforeVisitingLocation(t),!e.defaultPrevented},r.prototype.notifyApplicationAfterClickingLinkToLocation=function(t,r){return e.dispatch("turbolinks:click",{target:t,data:{url:r.absoluteURL},cancelable:!0})},r.prototype.notifyApplicationBeforeVisitingLocation=function(t){return e.dispatch("turbolinks:before-visit",{data:{url:t.absoluteURL},cancelable:!0})},r.prototype.notifyApplicationAfterVisitingLocation=function(t){return e.dispatch("turbolinks:visit",{data:{url:t.absoluteURL}})},r.prototype.notifyApplicationBeforeCachingSnapshot=function(){return e.dispatch("turbolinks:before-cache")},r.prototype.notifyApplicationBeforeRender=function(t){return e.dispatch("turbolinks:before-render",{data:{newBody:t}})},r.prototype.notifyApplicationAfterRender=function(){return e.dispatch("turbolinks:render")},r.prototype.notifyApplicationAfterPageLoad=function(t){return null==t&&(t={}),e.dispatch("turbolinks:load",{data:{url:this.location.absoluteURL,timing:t}})},r.prototype.startVisit=function(t,e,r){var n;return null!=(n=this.currentVisit)&&n.cancel(),this.currentVisit=this.createVisit(t,e,r),this.currentVisit.start(),this.notifyApplicationAfterVisitingLocation(t)},r.prototype.createVisit=function(t,r,n){var o,i,s,a,u;return i=null!=n?n:{},a=i.restorationIdentifier,s=i.restorationData,o=i.historyChanged,u=new e.Visit(this,t,r),u.restorationIdentifier=null!=a?a:e.uuid(),u.restorationData=e.copyObject(s),u.historyChanged=o,u.referrer=this.location,u},r.prototype.visitCompleted=function(t){return this.notifyApplicationAfterPageLoad(t.getTimingMetrics())},r.prototype.clickEventIsSignificant=function(t){return!(t.defaultPrevented||t.target.isContentEditable||t.which>1||t.altKey||t.ctrlKey||t.metaKey||t.shiftKey)},r.prototype.getVisitableLinkForNode=function(t){return this.nodeIsVisitable(t)?e.closest(t,"a[href]:not([target]):not([download])"):void 0},r.prototype.getVisitableLocationForLink=function(t){var r;return r=new e.Location(t.getAttribute("href")),this.locationIsVisitable(r)?r:void 0},r.prototype.getActionForLink=function(t){var e;return null!=(e=t.getAttribute("data-turbolinks-action"))?e:"advance"},r.prototype.nodeIsVisitable=function(t){var r;return(r=e.closest(t,"[data-turbolinks]"))?"false"!==r.getAttribute("data-turbolinks"):!0},r.prototype.locationIsVisitable=function(t){return t.isPrefixedBy(this.view.getRootLocation())&&t.isHTML()},r.prototype.getCurrentRestorationData=function(){return this.getRestorationDataForIdentifier(this.restorationIdentifier)},r.prototype.getRestorationDataForIdentifier=function(t){var e;return null!=(e=this.restorationData)[t]?e[t]:e[t]={}},r}()}.call(this),function(){!function(){var t,e;if((t=e=document.currentScript)&&!e.hasAttribute("data-turbolinks-suppress-warning"))for(;t=t.parentNode;)if(t===document.body)return console.warn("You are loading Turbolinks from a <script> element inside the <body> element. This is probably not what you meant to do!\n\nLoad your application\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\n\nFor more information, see: https://github.com/turbolinks/turbolinks#working-with-script-elements\n\n\u2014\u2014\nSuppress this warning by adding a `data-turbolinks-suppress-warning` attribute to: %s",e.outerHTML)}()}.call(this),function(){var t,r,n;e.start=function(){return r()?(null==e.controller&&(e.controller=t()),e.controller.start()):void 0},r=function(){return null==window.Turbolinks&&(window.Turbolinks=e),n()},t=function(){var t;return t=new e.Controller,t.adapter=new e.BrowserAdapter(t),t},n=function(){return window.Turbolinks===e},n()&&e.start()}.call(this)}).call(this),"object"==typeof module&&module.exports?module.exports=e:"function"=="function"&&__webpack_require__(70)&&!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}).call(this);

/***/ }),

/***/ 70:
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDJhOTZjNjQ2MmM1NWUwNGEyMjQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9rZXljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL3ZlbmRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3dpZGdldHMvZGF0ZXBpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3dpZGdldHMvc2xpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0cy9tb3VzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL2llLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2pxdWVyeS11aS10aW1lcGlja2VyLWFkZG9uLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL3BvcHBlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2Jvb3RzdHJhcC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9ib290c3RyYXAtc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2NoYXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJib2xpbmtzL2Rpc3QvdHVyYm9saW5rcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiXSwibmFtZXMiOlsid2luZG93IiwiJCIsImpRdWVyeSIsInJlcXVpcmUiLCJQb3BwZXIiLCJUdXJib2xpbmtzIiwiZm4iLCJzZXJpYWxpemVPYmplY3QiLCJzaG91bGRWYWxpZGF0ZSIsInNlbGYiLCJqc29uIiwicHVzaF9jb3VudGVycyIsInBhdHRlcm5zIiwiaXNWYWxpZCIsIiRmaWVsZHMiLCJmaW5kIiwibm90IiwiYnVpbGQiLCJiYXNlIiwia2V5IiwidmFsdWUiLCJwdXNoX2NvdW50ZXIiLCJ1bmRlZmluZWQiLCJyZW1vdmUiLCJyZW1vdmVDbGFzcyIsImNsZWFyVGltZW91dCIsInZhbGlkYXRpb25UaW1lb3V0Iiwic2V0VGltZW91dCIsImZhZGVPdXQiLCJtYXAiLCJ2YWxpZGF0ZSIsInRlc3QiLCJuYW1lIiwiayIsImtleXMiLCJtYXRjaCIsIm1lcmdlIiwicmV2ZXJzZV9rZXkiLCJ2YWxpZGF0aW9uX3J1bGVzIiwiYXR0cmlidXRlcyIsImhhc093blByb3BlcnR5IiwidmFsaWRhdGlvbiIsInJlc3BvbnNlIiwicG9wIiwicmVwbGFjZSIsIlJlZ0V4cCIsInB1c2giLCJmaXhlZCIsIm5hbWVkIiwiZXh0ZW5kIiwiY2xvc2VzdCIsImFkZENsYXNzIiwiZmlyc3QiLCJsZW5ndGgiLCJjbGljayIsIiR0aGlzIiwidmFsIiwidmFsaWRhdGlvblJ1bGVzIiwiYXR0ciIsInNwbGl0IiwiZmFpbGVkUnVsZXMiLCJpIiwicnVsZSIsImlucHV0IiwiaXNOYU4iLCJwYXJzZUludCIsImlzRmluaXRlIiwiTnVtYmVyIiwiaW5kZXhPZiIsImlzIiwiaGFzQ2xhc3MiLCJzaWJsaW5ncyIsInBhcmVudCIsIiRpbnZhbGlkRmVlZGJhY2siLCJhcHBlbmQiLCJPYmplY3QiLCJyZXNvbHZlIiwicGF0aCIsIm9iaiIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwidWkiLCJ0aW1lcGlja2VyIiwidmVyc2lvbiIsIlRpbWVwaWNrZXIiLCJyZWdpb25hbCIsImN1cnJlbnRUZXh0IiwiY2xvc2VUZXh0IiwiYW1OYW1lcyIsInBtTmFtZXMiLCJ0aW1lRm9ybWF0IiwidGltZVN1ZmZpeCIsInRpbWVPbmx5VGl0bGUiLCJ0aW1lVGV4dCIsImhvdXJUZXh0IiwibWludXRlVGV4dCIsInNlY29uZFRleHQiLCJtaWxsaXNlY1RleHQiLCJtaWNyb3NlY1RleHQiLCJ0aW1lem9uZVRleHQiLCJpc1JUTCIsIl9kZWZhdWx0cyIsInNob3dCdXR0b25QYW5lbCIsInRpbWVPbmx5IiwidGltZU9ubHlTaG93RGF0ZSIsInNob3dIb3VyIiwic2hvd01pbnV0ZSIsInNob3dTZWNvbmQiLCJzaG93TWlsbGlzZWMiLCJzaG93TWljcm9zZWMiLCJzaG93VGltZXpvbmUiLCJzaG93VGltZSIsInN0ZXBIb3VyIiwic3RlcE1pbnV0ZSIsInN0ZXBTZWNvbmQiLCJzdGVwTWlsbGlzZWMiLCJzdGVwTWljcm9zZWMiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWMiLCJtaWNyb3NlYyIsInRpbWV6b25lIiwiaG91ck1pbiIsIm1pbnV0ZU1pbiIsInNlY29uZE1pbiIsIm1pbGxpc2VjTWluIiwibWljcm9zZWNNaW4iLCJob3VyTWF4IiwibWludXRlTWF4Iiwic2Vjb25kTWF4IiwibWlsbGlzZWNNYXgiLCJtaWNyb3NlY01heCIsIm1pbkRhdGVUaW1lIiwibWF4RGF0ZVRpbWUiLCJtYXhUaW1lIiwibWluVGltZSIsIm9uU2VsZWN0IiwiaG91ckdyaWQiLCJtaW51dGVHcmlkIiwic2Vjb25kR3JpZCIsIm1pbGxpc2VjR3JpZCIsIm1pY3Jvc2VjR3JpZCIsImFsd2F5c1NldFRpbWUiLCJzZXBhcmF0b3IiLCJhbHRGaWVsZFRpbWVPbmx5IiwiYWx0VGltZUZvcm1hdCIsImFsdFNlcGFyYXRvciIsImFsdFRpbWVTdWZmaXgiLCJhbHRSZWRpcmVjdEZvY3VzIiwicGlja2VyVGltZUZvcm1hdCIsInBpY2tlclRpbWVTdWZmaXgiLCJzaG93VGltZXBpY2tlciIsInRpbWV6b25lTGlzdCIsImFkZFNsaWRlckFjY2VzcyIsInNsaWRlckFjY2Vzc0FyZ3MiLCJjb250cm9sVHlwZSIsIm9uZUxpbmUiLCJkZWZhdWx0VmFsdWUiLCJwYXJzZSIsImFmdGVySW5qZWN0IiwicHJvdG90eXBlIiwiJGlucHV0IiwiJGFsdElucHV0IiwiJHRpbWVPYmoiLCJpbnN0IiwiaG91cl9zbGlkZXIiLCJtaW51dGVfc2xpZGVyIiwic2Vjb25kX3NsaWRlciIsIm1pbGxpc2VjX3NsaWRlciIsIm1pY3Jvc2VjX3NsaWRlciIsInRpbWV6b25lX3NlbGVjdCIsImhvdXJNaW5PcmlnaW5hbCIsIm1pbnV0ZU1pbk9yaWdpbmFsIiwic2Vjb25kTWluT3JpZ2luYWwiLCJtaWxsaXNlY01pbk9yaWdpbmFsIiwibWljcm9zZWNNaW5PcmlnaW5hbCIsImhvdXJNYXhPcmlnaW5hbCIsIm1pbnV0ZU1heE9yaWdpbmFsIiwic2Vjb25kTWF4T3JpZ2luYWwiLCJtaWxsaXNlY01heE9yaWdpbmFsIiwibWljcm9zZWNNYXhPcmlnaW5hbCIsImFtcG0iLCJmb3JtYXR0ZWREYXRlIiwiZm9ybWF0dGVkVGltZSIsImZvcm1hdHRlZERhdGVUaW1lIiwidW5pdHMiLCJzdXBwb3J0IiwiY29udHJvbCIsInNldERlZmF1bHRzIiwic2V0dGluZ3MiLCJleHRlbmRSZW1vdmUiLCJfbmV3SW5zdCIsIm9wdHMiLCJ0cF9pbnN0IiwiaW5saW5lU2V0dGluZ3MiLCJmbnMiLCJvdmVycmlkZXMiLCJhdHRyTmFtZSIsImF0dHJWYWx1ZSIsImV2YWwiLCJlcnIiLCJiZWZvcmVTaG93IiwiZHBfaW5zdCIsImlzRnVuY3Rpb24iLCJldm50cyIsImNhbGwiLCJvbkNoYW5nZU1vbnRoWWVhciIsInllYXIiLCJtb250aCIsIm9uQ2xvc2UiLCJkYXRlVGV4dCIsInRpbWVEZWZpbmVkIiwiX3VwZGF0ZURhdGVUaW1lIiwidG9VcHBlckNhc2UiLCJkZXRlY3RTdXBwb3J0Iiwic2xpZGVyIiwiX2NvbnRyb2xzIiwidHpsIiwidHppIiwidHp2IiwibGFiZWwiLCJ0aW1lem9uZU9mZnNldFN0cmluZyIsImlzbzg2MDEiLCJ0aW1lem9uZU9mZnNldE51bWJlciIsIkRhdGUiLCJnZXRUaW1lem9uZU9mZnNldCIsImFsdEZpZWxkIiwiY3NzIiwiY3Vyc29yIiwiZm9jdXMiLCJ0cmlnZ2VyIiwibWluRGF0ZSIsIm1heERhdGUiLCJnZXRUaW1lIiwiYmluZCIsIl9vbkZvY3VzIiwiX2FkZFRpbWVQaWNrZXIiLCJjdXJyRFQiLCJ0cmltIiwiX3BhcnNlVGltZSIsIl9saW1pdE1pbk1heERhdGVUaW1lIiwiX2luamVjdFRpbWVQaWNrZXIiLCJfYWZ0ZXJJbmplY3QiLCJ0aW1lU3RyaW5nIiwid2l0aERhdGUiLCJkYXRlcGlja2VyIiwiX2dldEluc3QiLCJkcF9kYXRlRm9ybWF0IiwiX2dldCIsInBhcnNlUmVzIiwicGFyc2VEYXRlVGltZUludGVybmFsIiwiX2dldEZvcm1hdENvbmZpZyIsInRpbWVPYmoiLCJsb2ciLCJwYXJzZVRpbWUiLCJvIiwiJGRwIiwiZHBEaXYiLCJsaXRlbSIsInVpdGVtIiwic2hvdyIsIm1heCIsImdyaWRTaXplIiwic2l6ZSIsImwiLCJub0Rpc3BsYXkiLCJodG1sIiwidGltZUlucHV0Iiwic3Vic3RyIiwiaCIsInRtcGgiLCJmb3JtYXRUaW1lIiwibSIsInNob3dUeiIsIiR0cCIsInByZXBlbmQiLCJoaWRlIiwiY3JlYXRlIiwid2lkdGgiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJib3JkZXJDb2xsYXBzZSIsImUiLCIkdCIsIm4iLCJhcCIsImYiLCJkYXRhIiwiX29uVGltZUNoYW5nZSIsIl9vblNlbGVjdEhhbmRsZXIiLCJ0ZXh0QWxpZ24iLCJvdmVyZmxvdyIsImFwcGx5IiwiaWR4IiwidGV4dCIsImxvY2FsX3RpbWV6b25lIiwic2VsZWN0ZWRZZWFyIiwic2VsZWN0ZWRNb250aCIsInNlbGVjdGVkRGF5Iiwic2VsZWN0TG9jYWxUaW1lem9uZSIsImNoYW5nZSIsIiRidXR0b25QYW5lbCIsImJlZm9yZSIsInBhcnNlZFRpbWUiLCJ1cGRhdGUiLCJzZXRIb3VycyIsInNldE1pbnV0ZXMiLCJzZXRTZWNvbmRzIiwiX3NldFRpbWUiLCJibHVyIiwicnRsIiwic2xpZGVyQWNjZXNzIiwic2xpZGVyQWNjZXNzV2lkdGgiLCJvdXRlcldpZHRoIiwiZWFjaCIsIiRnIiwib2xkV2lkdGgiLCJvbGRNYXJnaW5MZWZ0IiwidG9TdHJpbmciLCJuZXdXaWR0aCIsIm5ld01hcmdpbkxlZnQiLCJhZGp1c3RTbGlkZXJzIiwiZHBfZGF0ZSIsIm1pbkRhdGVUaW1lRGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImdldE1pY3Jvc2Vjb25kcyIsIm1heERhdGVUaW1lRGF0ZSIsInRlbXBNaW5UaW1lIiwidGVtcE1heFRpbWUiLCJtaW5NYXgiLCJzZWNNYXgiLCJvcHRpb25zIiwibWluIiwic3RlcCIsImhhc0NoYW5nZWQiLCJpbkFycmF5Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJzUG9zIiwic2VsZWN0aW9uU3RhcnQiLCJlUG9zIiwic2VsZWN0aW9uRW5kIiwiaW5wdXRFbCIsImR0VG1wIiwiY3VycmVudFllYXIiLCJjdXJyZW50TW9udGgiLCJjdXJyZW50RGF5IiwiZHQiLCJfZGF5bGlnaHRTYXZpbmdBZGp1c3QiLCJkYXRlRm10IiwiZm9ybWF0Q2ZnIiwidGltZUF2YWlsYWJsZSIsImZvcm1hdERhdGUiLCJsYXN0VmFsIiwiYWx0Rm9ybWF0dGVkRGF0ZVRpbWUiLCJhbHRGb3JtYXQiLCJnZXQiLCJfdXBkYXRlRGF0ZXBpY2tlciIsInVuaXQiLCJwcm9wIiwib3JpZW50YXRpb24iLCJzbGlkZSIsImV2ZW50Iiwic3RvcCIsIk1hdGgiLCJhYnMiLCJzZWxlY3QiLCJzZWwiLCJmb3JtYXQiLCJjaGlsZHJlbiIsImFwcGVuZFRvIiwidG1wX2FyZ3MiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwiZGF0ZXRpbWVwaWNrZXIiLCJwYXJzZURhdGVUaW1lIiwiZGF0ZUZvcm1hdCIsImRhdGVUaW1lU3RyaW5nIiwiZGF0ZVNldHRpbmdzIiwidGltZVNldHRpbmdzIiwidCIsImRhdGUiLCJzZXRNaWNyb3NlY29uZHMiLCJzdHJpY3RQYXJzZSIsInMiLCJnZXRQYXR0ZXJuQW1wbSIsIm1hcmtlcnMiLCJqb2luIiwiZ2V0Rm9ybWF0UG9zaXRpb25zIiwiZmluZHMiLCJ0b0xvd2VyQ2FzZSIsIm9yZGVycyIsImMiLCJ6IiwiY2hhckF0IiwicmVnc3RyIiwibWwiLCJvcmRlciIsInRyZWciLCJyZXNUaW1lIiwieCIsImxvb3NlUGFyc2UiLCJkIiwiZXJyMiIsInRpbWUiLCJ0bXB0aW1lIiwiYW1wbU5hbWUiLCJjb252ZXJ0MjR0bzEyIiwiX2Jhc2Vfc2VsZWN0RGF0ZSIsIl9zZWxlY3REYXRlIiwiaWQiLCJkYXRlU3RyIiwid2FzX2lubGluZSIsImlubGluZSIsInN0YXlfb3BlbiIsIl9ub3RpZnlDaGFuZ2UiLCJfYmFzZV91cGRhdGVEYXRlcGlja2VyIiwiX2N1ckluc3QiLCJfZGF0ZXBpY2tlclNob3dpbmciLCJfbGFzdElucHV0IiwiX2Jhc2VfZG9LZXlQcmVzcyIsIl9kb0tleVByZXNzIiwidGFyZ2V0IiwidHoiLCJkYXRlQ2hhcnMiLCJfcG9zc2libGVDaGFycyIsImRhdGV0aW1lQ2hhcnMiLCJjaHIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZSIsImtleUNvZGUiLCJjdHJsS2V5IiwiX2Jhc2VfdXBkYXRlQWx0ZXJuYXRlIiwiX3VwZGF0ZUFsdGVybmF0ZSIsIl9nZXREYXRlIiwiX2Jhc2VfZG9LZXlVcCIsIl9kb0tleVVwIiwiX2Jhc2VfZ290b1RvZGF5IiwiX2dvdG9Ub2RheSIsInR6b2Zmc2V0Iiwibm93IiwiX3NldERhdGUiLCJfZGlzYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyIiwiX2VuYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyIiwiZGVmYXVsdHMiLCJfc2V0VGltZURhdGVwaWNrZXIiLCJfc2V0RGF0ZUZyb21GaWVsZCIsInRwX2RhdGUiLCJfYmFzZV9zZXREYXRlRGF0ZXBpY2tlciIsIl9zZXREYXRlRGF0ZXBpY2tlciIsIl9kYXRlIiwidGltZXpvbmVBZGp1c3QiLCJfYmFzZV9nZXREYXRlRGF0ZXBpY2tlciIsIl9nZXREYXRlRGF0ZXBpY2tlciIsIm5vRGVmYXVsdCIsInRhZ05hbWUiLCJfYmFzZV9wYXJzZURhdGUiLCJwYXJzZURhdGUiLCJzdWJzdHJpbmciLCJfYmFzZV9mb3JtYXREYXRlIiwiX2Zvcm1hdERhdGUiLCJkYXkiLCJfYmFzZV9vcHRpb25EYXRlcGlja2VyIiwiX29wdGlvbkRhdGVwaWNrZXIiLCJuYW1lX2Nsb25lIiwib25zZWxlY3QiLCJyZXQiLCJvbGRWYWwiLCIkdGFyZ2V0IiwiaXNFbXB0eU9iamVjdCIsInByb3BzIiwidGYiLCJpc0luIiwiY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmciLCJwcm9wZXJ0eSIsInNwbGl0RGF0ZVRpbWUiLCJ0aW1lUGFydHMiLCJ0aW1lUGFydHNMZW4iLCJhbGxQYXJ0cyIsImFsbFBhcnRzTGVuIiwiZGF0ZVN0cmluZyIsInNwbGljZSIsInBhcnRzIiwidHpNaW51dGVzIiwib2ZmIiwibWludXRlcyIsImhvdXJzIiwiaXNvIiwidHpTdHJpbmciLCJub3JtYWxpemVkIiwiZnJvbVRpbWV6b25lIiwidG9UaW1lem9uZSIsImZyb21UeiIsInRvVHoiLCJ0aW1lUmFuZ2UiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiaGFuZGxlUmFuZ2UiLCJkYXRldGltZVJhbmdlIiwiZGF0ZVJhbmdlIiwibWV0aG9kIiwibWluSW50ZXJ2YWwiLCJtYXhJbnRlcnZhbCIsInN0YXJ0IiwiZW5kIiwiY2hlY2tEYXRlcyIsImNoYW5nZWQiLCJvdGhlciIsInN0YXJ0ZHQiLCJlbmRkdCIsImNoYW5nZWRkdCIsInNldE1pbGxpc2Vjb25kcyIsInNlbGVjdGVkIiwib3B0aW9uIiwic2VsZWN0ZWREYXRlVGltZSIsImNvbnNvbGUiLCJfdXRpbCIsIl9leHRlbmRSZW1vdmUiLCJfaXNFbXB0eU9iamVjdCIsIl9jb252ZXJ0MjR0bzEyIiwiX2RldGVjdFN1cHBvcnQiLCJfc2VsZWN0TG9jYWxUaW1lem9uZSIsIl9jb21wdXRlRWZmZWN0aXZlU2V0dGluZyIsIl9zcGxpdERhdGVUaW1lIiwiX3BhcnNlRGF0ZVRpbWVJbnRlcm5hbCIsIm1pY3Jvc2Vjb25kcyIsImZsb29yIiwiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJuYXRpdmVIaW50cyIsImlzTmF0aXZlIiwic29tZSIsImhpbnQiLCJpc0Jyb3dzZXIiLCJsb25nZXJUaW1lb3V0QnJvd3NlcnMiLCJ0aW1lb3V0RHVyYXRpb24iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtaWNyb3Rhc2tEZWJvdW5jZSIsInNjaGVkdWxlZCIsImVsZW0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwic2V0QXR0cmlidXRlIiwidGFza0RlYm91bmNlIiwic3VwcG9ydHNOYXRpdmVNdXRhdGlvbk9ic2VydmVyIiwiZGVib3VuY2UiLCJmdW5jdGlvblRvQ2hlY2siLCJnZXRUeXBlIiwiZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5IiwiZWxlbWVudCIsIm5vZGVUeXBlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFBhcmVudE5vZGUiLCJub2RlTmFtZSIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0U2Nyb2xsUGFyZW50IiwiYm9keSIsIl9nZXRTdHlsZUNvbXB1dGVkUHJvcCIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImRvY3VtZW50RWxlbWVudCIsImlzT2Zmc2V0Q29udGFpbmVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJnZXRSb290Iiwibm9kZSIsImZpbmRDb21tb25PZmZzZXRQYXJlbnQiLCJlbGVtZW50MSIsImVsZW1lbnQyIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJjb250YWlucyIsImVsZW1lbnQxcm9vdCIsImdldFNjcm9sbCIsInNpZGUiLCJ1cHBlclNpZGUiLCJzY3JvbGxpbmdFbGVtZW50IiwiaW5jbHVkZVNjcm9sbCIsInJlY3QiLCJzdWJ0cmFjdCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJtb2RpZmllciIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImdldEJvcmRlcnNTaXplIiwic3R5bGVzIiwiYXhpcyIsInNpZGVBIiwic2lkZUIiLCJpc0lFMTAiLCJpc0lFMTAkMSIsImFwcFZlcnNpb24iLCJnZXRTaXplIiwiY29tcHV0ZWRTdHlsZSIsImdldFdpbmRvd1NpemVzIiwiaGVpZ2h0IiwiY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJzb3VyY2UiLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJlc3VsdCIsInNpemVzIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJob3JpelNjcm9sbGJhciIsIm9mZnNldFdpZHRoIiwidmVydFNjcm9sbGJhciIsIm9mZnNldEhlaWdodCIsImdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSIsImlzSFRNTCIsImNoaWxkcmVuUmVjdCIsInBhcmVudFJlY3QiLCJzY3JvbGxQYXJlbnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsIm1hcmdpblRvcCIsImdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZSIsInJlbGF0aXZlT2Zmc2V0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwib2Zmc2V0IiwiaXNGaXhlZCIsImdldEJvdW5kYXJpZXMiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJwYWRkaW5nIiwiYm91bmRhcmllc0VsZW1lbnQiLCJib3VuZGFyaWVzIiwiYm91bmRhcmllc05vZGUiLCJfZ2V0V2luZG93U2l6ZXMiLCJnZXRBcmVhIiwiX3JlZiIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwicGxhY2VtZW50IiwicmVmUmVjdCIsInJlY3RzIiwic29ydGVkQXJlYXMiLCJhcmVhIiwic29ydCIsImEiLCJiIiwiZmlsdGVyZWRBcmVhcyIsImZpbHRlciIsIl9yZWYyIiwiY29tcHV0ZWRQbGFjZW1lbnQiLCJ2YXJpYXRpb24iLCJnZXRSZWZlcmVuY2VPZmZzZXRzIiwic3RhdGUiLCJjb21tb25PZmZzZXRQYXJlbnQiLCJnZXRPdXRlclNpemVzIiwicGFyc2VGbG9hdCIsIm1hcmdpbkJvdHRvbSIsInkiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImhhc2giLCJtYXRjaGVkIiwiZ2V0UG9wcGVyT2Zmc2V0cyIsInJlZmVyZW5jZU9mZnNldHMiLCJwb3BwZXJSZWN0IiwicG9wcGVyT2Zmc2V0cyIsImlzSG9yaXoiLCJtYWluU2lkZSIsInNlY29uZGFyeVNpZGUiLCJtZWFzdXJlbWVudCIsInNlY29uZGFyeU1lYXN1cmVtZW50IiwiYXJyIiwiY2hlY2siLCJmaW5kSW5kZXgiLCJjdXIiLCJydW5Nb2RpZmllcnMiLCJtb2RpZmllcnMiLCJlbmRzIiwibW9kaWZpZXJzVG9SdW4iLCJmb3JFYWNoIiwiZnVuY3Rpb24iLCJ3YXJuIiwiZW5hYmxlZCIsImlzRGVzdHJveWVkIiwiZmxpcHBlZCIsImZsaXAiLCJvcmlnaW5hbFBsYWNlbWVudCIsInBvc2l0aW9uIiwiaXNDcmVhdGVkIiwib25DcmVhdGUiLCJvblVwZGF0ZSIsImlzTW9kaWZpZXJFbmFibGVkIiwibW9kaWZpZXJOYW1lIiwiZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIiwicHJlZml4ZXMiLCJ1cHBlclByb3AiLCJwcmVmaXgiLCJ0b0NoZWNrIiwic3R5bGUiLCJkZXN0cm95IiwicmVtb3ZlQXR0cmlidXRlIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlT25EZXN0cm95IiwicmVtb3ZlQ2hpbGQiLCJhdHRhY2hUb1Njcm9sbFBhcmVudHMiLCJjYWxsYmFjayIsInNjcm9sbFBhcmVudHMiLCJpc0JvZHkiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVCb3VuZCIsInNjcm9sbEVsZW1lbnQiLCJldmVudHNFbmFibGVkIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMiLCJzY2hlZHVsZVVwZGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaXNOdW1lcmljIiwic2V0U3R5bGVzIiwic2V0QXR0cmlidXRlcyIsImFwcGx5U3R5bGUiLCJhcnJvdyIsImFycm93RWxlbWVudCIsImFwcGx5U3R5bGVPbkxvYWQiLCJtb2RpZmllck9wdGlvbnMiLCJjb21wdXRlU3R5bGUiLCJsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24iLCJncHVBY2NlbGVyYXRpb24iLCJvZmZzZXRQYXJlbnRSZWN0IiwicHJlZml4ZWRQcm9wZXJ0eSIsIndpbGxDaGFuZ2UiLCJpbnZlcnRUb3AiLCJpbnZlcnRMZWZ0IiwiaXNNb2RpZmllclJlcXVpcmVkIiwicmVxdWVzdGluZ05hbWUiLCJyZXF1ZXN0ZWROYW1lIiwicmVxdWVzdGluZyIsImlzUmVxdWlyZWQiLCJfcmVxdWVzdGluZyIsInJlcXVlc3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJfZGF0YSRvZmZzZXRzIiwiaXNWZXJ0aWNhbCIsImxlbiIsImFsdFNpZGUiLCJvcFNpZGUiLCJhcnJvd0VsZW1lbnRTaXplIiwiY2VudGVyIiwic2lkZVZhbHVlIiwicm91bmQiLCJnZXRPcHBvc2l0ZVZhcmlhdGlvbiIsInBsYWNlbWVudHMiLCJ2YWxpZFBsYWNlbWVudHMiLCJjbG9ja3dpc2UiLCJjb3VudGVyIiwiaW5kZXgiLCJjb25jYXQiLCJyZXZlcnNlIiwiQkVIQVZJT1JTIiwiRkxJUCIsIkNMT0NLV0lTRSIsIkNPVU5URVJDTE9DS1dJU0UiLCJwbGFjZW1lbnRPcHBvc2l0ZSIsImZsaXBPcmRlciIsImJlaGF2aW9yIiwicmVmT2Zmc2V0cyIsIm92ZXJsYXBzUmVmIiwib3ZlcmZsb3dzTGVmdCIsIm92ZXJmbG93c1JpZ2h0Iiwib3ZlcmZsb3dzVG9wIiwib3ZlcmZsb3dzQm90dG9tIiwib3ZlcmZsb3dzQm91bmRhcmllcyIsImZsaXBwZWRWYXJpYXRpb24iLCJmbGlwVmFyaWF0aW9ucyIsImtlZXBUb2dldGhlciIsInRvVmFsdWUiLCJzdHIiLCJwYXJzZU9mZnNldCIsImJhc2VQbGFjZW1lbnQiLCJ1c2VIZWlnaHQiLCJmcmFnbWVudHMiLCJmcmFnIiwiZGl2aWRlciIsInNlYXJjaCIsInNwbGl0UmVnZXgiLCJvcHMiLCJvcCIsIm1lcmdlV2l0aFByZXZpb3VzIiwiaW5kZXgyIiwicHJldmVudE92ZXJmbG93IiwicHJpb3JpdHkiLCJwcmltYXJ5IiwiZXNjYXBlV2l0aFJlZmVyZW5jZSIsInNlY29uZGFyeSIsInNoaWZ0Iiwic2hpZnR2YXJpYXRpb24iLCJzaGlmdE9mZnNldHMiLCJib3VuZCIsImlubmVyIiwic3VidHJhY3RMZW5ndGgiLCJvbkxvYWQiLCJEZWZhdWx0cyIsIl90aGlzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwianF1ZXJ5IiwidXBkYXRlJCQxIiwiZGVzdHJveSQkMSIsImVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxIiwiVXRpbHMiLCJQb3BwZXJVdGlscyIsIkVycm9yIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfY3JlYXRlQ2xhc3MiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJVdGlsIiwidHJhbnNpdGlvbiIsIk1BWF9VSUQiLCJUcmFuc2l0aW9uRW5kRXZlbnQiLCJXZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIk9UcmFuc2l0aW9uIiwidG9UeXBlIiwiaXNFbGVtZW50IiwiZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCIsImJpbmRUeXBlIiwiZGVsZWdhdGVUeXBlIiwiaGFuZGxlIiwiaGFuZGxlT2JqIiwiaGFuZGxlciIsInRyYW5zaXRpb25FbmRUZXN0IiwiUVVuaXQiLCJlbCIsInRyYW5zaXRpb25FbmRFbXVsYXRvciIsImR1cmF0aW9uIiwiY2FsbGVkIiwib25lIiwiVFJBTlNJVElPTl9FTkQiLCJ0cmlnZ2VyVHJhbnNpdGlvbkVuZCIsInNldFRyYW5zaXRpb25FbmRTdXBwb3J0IiwiZW11bGF0ZVRyYW5zaXRpb25FbmQiLCJzdXBwb3J0c1RyYW5zaXRpb25FbmQiLCJzcGVjaWFsIiwiZ2V0VUlEIiwicmFuZG9tIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTZWxlY3RvckZyb21FbGVtZW50Iiwic2VsZWN0b3IiLCJnZXRBdHRyaWJ1dGUiLCIkc2VsZWN0b3IiLCJlcnJvciIsInJlZmxvdyIsIkJvb2xlYW4iLCJ0eXBlQ2hlY2tDb25maWciLCJjb21wb25lbnROYW1lIiwiY29uZmlnIiwiY29uZmlnVHlwZXMiLCJleHBlY3RlZFR5cGVzIiwidmFsdWVUeXBlIiwiQWxlcnQiLCJOQU1FIiwiVkVSU0lPTiIsIkRBVEFfS0VZIiwiRVZFTlRfS0VZIiwiREFUQV9BUElfS0VZIiwiSlFVRVJZX05PX0NPTkZMSUNUIiwiVFJBTlNJVElPTl9EVVJBVElPTiIsIlNlbGVjdG9yIiwiRElTTUlTUyIsIkV2ZW50IiwiQ0xPU0UiLCJDTE9TRUQiLCJDTElDS19EQVRBX0FQSSIsIkNsYXNzTmFtZSIsIkFMRVJUIiwiRkFERSIsIlNIT1ciLCJfZWxlbWVudCIsImNsb3NlIiwicm9vdEVsZW1lbnQiLCJfZ2V0Um9vdEVsZW1lbnQiLCJjdXN0b21FdmVudCIsIl90cmlnZ2VyQ2xvc2VFdmVudCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIl9yZW1vdmVFbGVtZW50IiwiZGlzcG9zZSIsInJlbW92ZURhdGEiLCJjbG9zZUV2ZW50IiwiX3RoaXMyIiwiX2Rlc3Ryb3lFbGVtZW50IiwiZGV0YWNoIiwiX2pRdWVyeUludGVyZmFjZSIsIiRlbGVtZW50IiwiX2hhbmRsZURpc21pc3MiLCJhbGVydEluc3RhbmNlIiwicHJldmVudERlZmF1bHQiLCJvbiIsIm5vQ29uZmxpY3QiLCJCdXR0b24iLCJBQ1RJVkUiLCJCVVRUT04iLCJGT0NVUyIsIkRBVEFfVE9HR0xFX0NBUlJPVCIsIkRBVEFfVE9HR0xFIiwiSU5QVVQiLCJGT0NVU19CTFVSX0RBVEFfQVBJIiwidG9nZ2xlIiwidHJpZ2dlckNoYW5nZUV2ZW50IiwiYWRkQXJpYVByZXNzZWQiLCJ0eXBlIiwiY2hlY2tlZCIsImFjdGl2ZUVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJ0b2dnbGVDbGFzcyIsImJ1dHRvbiIsIkNhcm91c2VsIiwiQVJST1dfTEVGVF9LRVlDT0RFIiwiQVJST1dfUklHSFRfS0VZQ09ERSIsIlRPVUNIRVZFTlRfQ09NUEFUX1dBSVQiLCJEZWZhdWx0IiwiaW50ZXJ2YWwiLCJrZXlib2FyZCIsInBhdXNlIiwid3JhcCIsIkRlZmF1bHRUeXBlIiwiRGlyZWN0aW9uIiwiTkVYVCIsIlBSRVYiLCJMRUZUIiwiUklHSFQiLCJTTElERSIsIlNMSUQiLCJLRVlET1dOIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJUT1VDSEVORCIsIkxPQURfREFUQV9BUEkiLCJDQVJPVVNFTCIsIklURU0iLCJBQ1RJVkVfSVRFTSIsIk5FWFRfUFJFViIsIklORElDQVRPUlMiLCJEQVRBX1NMSURFIiwiREFUQV9SSURFIiwiX2l0ZW1zIiwiX2ludGVydmFsIiwiX2FjdGl2ZUVsZW1lbnQiLCJfaXNQYXVzZWQiLCJfaXNTbGlkaW5nIiwidG91Y2hUaW1lb3V0IiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJuZXh0IiwiX3NsaWRlIiwibmV4dFdoZW5WaXNpYmxlIiwiaGlkZGVuIiwiY3ljbGUiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ2aXNpYmlsaXR5U3RhdGUiLCJ0byIsIl90aGlzMyIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsImRpcmVjdGlvbiIsIl90aGlzNCIsIl9rZXlkb3duIiwid2hpY2giLCJtYWtlQXJyYXkiLCJfZ2V0SXRlbUJ5RGlyZWN0aW9uIiwiaXNOZXh0RGlyZWN0aW9uIiwiaXNQcmV2RGlyZWN0aW9uIiwibGFzdEl0ZW1JbmRleCIsImlzR29pbmdUb1dyYXAiLCJkZWx0YSIsIml0ZW1JbmRleCIsIl90cmlnZ2VyU2xpZGVFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJldmVudERpcmVjdGlvbk5hbWUiLCJ0YXJnZXRJbmRleCIsImZyb21JbmRleCIsInNsaWRlRXZlbnQiLCJmcm9tIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJuZXh0SW5kaWNhdG9yIiwiX3RoaXM1IiwiYWN0aXZlRWxlbWVudEluZGV4IiwibmV4dEVsZW1lbnQiLCJuZXh0RWxlbWVudEluZGV4IiwiaXNDeWNsaW5nIiwiZGlyZWN0aW9uYWxDbGFzc05hbWUiLCJvcmRlckNsYXNzTmFtZSIsInNsaWRFdmVudCIsImFjdGlvbiIsIl9kYXRhQXBpQ2xpY2tIYW5kbGVyIiwic2xpZGVJbmRleCIsIiRjYXJvdXNlbCIsIkNvbGxhcHNlIiwiU0hPV04iLCJISURFIiwiSElEREVOIiwiQ09MTEFQU0UiLCJDT0xMQVBTSU5HIiwiQ09MTEFQU0VEIiwiRGltZW5zaW9uIiwiV0lEVEgiLCJIRUlHSFQiLCJBQ1RJVkVTIiwiX2lzVHJhbnNpdGlvbmluZyIsIl90cmlnZ2VyQXJyYXkiLCJ0YWJUb2dnbGVzIiwiX3BhcmVudCIsIl9nZXRQYXJlbnQiLCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiX3RoaXM2IiwiYWN0aXZlcyIsImFjdGl2ZXNEYXRhIiwic3RhcnRFdmVudCIsImRpbWVuc2lvbiIsIl9nZXREaW1lbnNpb24iLCJzZXRUcmFuc2l0aW9uaW5nIiwiY29tcGxldGUiLCJjYXBpdGFsaXplZERpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJfdGhpczciLCIkZWxlbSIsImlzVHJhbnNpdGlvbmluZyIsImhhc1dpZHRoIiwiX3RoaXM4IiwiX2dldFRhcmdldEZyb21FbGVtZW50IiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwiJHRyaWdnZXIiLCJEcm9wZG93biIsIkVTQ0FQRV9LRVlDT0RFIiwiU1BBQ0VfS0VZQ09ERSIsIlRBQl9LRVlDT0RFIiwiQVJST1dfVVBfS0VZQ09ERSIsIkFSUk9XX0RPV05fS0VZQ09ERSIsIlJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCIsIlJFR0VYUF9LRVlET1dOIiwiQ0xJQ0siLCJLRVlET1dOX0RBVEFfQVBJIiwiS0VZVVBfREFUQV9BUEkiLCJESVNBQkxFRCIsIkRST1BVUCIsIk1FTlVSSUdIVCIsIk1FTlVMRUZUIiwiRk9STV9DSElMRCIsIk1FTlUiLCJOQVZCQVJfTkFWIiwiVklTSUJMRV9JVEVNUyIsIkF0dGFjaG1lbnRNYXAiLCJUT1AiLCJUT1BFTkQiLCJCT1RUT00iLCJCT1RUT01FTkQiLCJfcG9wcGVyIiwiX21lbnUiLCJfZ2V0TWVudUVsZW1lbnQiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwiZGlzYWJsZWQiLCJfZ2V0UGFyZW50RnJvbUVsZW1lbnQiLCJpc0FjdGl2ZSIsIl9jbGVhck1lbnVzIiwic2hvd0V2ZW50IiwiX2dldFBvcHBlckNvbmZpZyIsIm5vb3AiLCJfdGhpczkiLCJzdG9wUHJvcGFnYXRpb24iLCJlbGVtZW50RGF0YSIsIl9nZXRQbGFjZW1lbnQiLCIkcGFyZW50RHJvcGRvd24iLCJwb3BwZXJDb25maWciLCJ0b2dnbGVzIiwiY29udGV4dCIsImRyb3Bkb3duTWVudSIsImhpZGVFdmVudCIsIl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJpdGVtcyIsIk1vZGFsIiwiQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiIsImJhY2tkcm9wIiwiRk9DVVNJTiIsIlJFU0laRSIsIkNMSUNLX0RJU01JU1MiLCJLRVlET1dOX0RJU01JU1MiLCJNT1VTRVVQX0RJU01JU1MiLCJNT1VTRURPV05fRElTTUlTUyIsIlNDUk9MTEJBUl9NRUFTVVJFUiIsIkJBQ0tEUk9QIiwiT1BFTiIsIkRJQUxPRyIsIkRBVEFfRElTTUlTUyIsIkZJWEVEX0NPTlRFTlQiLCJOQVZCQVJfVE9HR0xFUiIsIl9kaWFsb2ciLCJfYmFja2Ryb3AiLCJfaXNTaG93biIsIl9pc0JvZHlPdmVyZmxvd2luZyIsIl9pZ25vcmVCYWNrZHJvcENsaWNrIiwiX29yaWdpbmFsQm9keVBhZGRpbmciLCJfc2Nyb2xsYmFyV2lkdGgiLCJfdGhpczEwIiwiX2NoZWNrU2Nyb2xsYmFyIiwiX3NldFNjcm9sbGJhciIsIl9zZXRFc2NhcGVFdmVudCIsIl9zZXRSZXNpemVFdmVudCIsIl9zaG93QmFja2Ryb3AiLCJfc2hvd0VsZW1lbnQiLCJfdGhpczExIiwiX2hpZGVNb2RhbCIsImhhbmRsZVVwZGF0ZSIsIl9hZGp1c3REaWFsb2ciLCJfdGhpczEyIiwiRUxFTUVOVF9OT0RFIiwiYXBwZW5kQ2hpbGQiLCJkaXNwbGF5IiwiX2VuZm9yY2VGb2N1cyIsInNob3duRXZlbnQiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJfdGhpczEzIiwiaGFzIiwiX3RoaXMxNCIsIl90aGlzMTUiLCJfdGhpczE2IiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJfcmVzZXRTY3JvbGxiYXIiLCJfcmVtb3ZlQmFja2Ryb3AiLCJfdGhpczE3IiwiYW5pbWF0ZSIsImRvQW5pbWF0ZSIsImNsYXNzTmFtZSIsImN1cnJlbnRUYXJnZXQiLCJjYWxsYmFja1JlbW92ZSIsImlzTW9kYWxPdmVyZmxvd2luZyIsInNjcm9sbEhlaWdodCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiX2dldFNjcm9sbGJhcldpZHRoIiwiX3RoaXMxOCIsImFjdHVhbFBhZGRpbmciLCJjYWxjdWxhdGVkUGFkZGluZyIsImFjdHVhbE1hcmdpbiIsImNhbGN1bGF0ZWRNYXJnaW4iLCJtYXJnaW4iLCJzY3JvbGxEaXYiLCJzY3JvbGxiYXJXaWR0aCIsIl90aGlzMTkiLCJTY3JvbGxTcHkiLCJBQ1RJVkFURSIsIlNDUk9MTCIsIkRST1BET1dOX0lURU0iLCJEUk9QRE9XTl9NRU5VIiwiREFUQV9TUFkiLCJOQVZfTElTVF9HUk9VUCIsIk5BVl9MSU5LUyIsIkxJU1RfSVRFTVMiLCJEUk9QRE9XTiIsIkRST1BET1dOX0lURU1TIiwiRFJPUERPV05fVE9HR0xFIiwiT2Zmc2V0TWV0aG9kIiwiT0ZGU0VUIiwiUE9TSVRJT04iLCJfdGhpczIwIiwiX3Njcm9sbEVsZW1lbnQiLCJfc2VsZWN0b3IiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJfdGhpczIxIiwiYXV0b01ldGhvZCIsIm9mZnNldE1ldGhvZCIsIm9mZnNldEJhc2UiLCJfZ2V0U2Nyb2xsVG9wIiwiX2dldFNjcm9sbEhlaWdodCIsInRhcmdldHMiLCJ0YXJnZXRTZWxlY3RvciIsInRhcmdldEJDUiIsIml0ZW0iLCJwYWdlWU9mZnNldCIsIl9nZXRPZmZzZXRIZWlnaHQiLCJtYXhTY3JvbGwiLCJfYWN0aXZhdGUiLCJfY2xlYXIiLCJpc0FjdGl2ZVRhcmdldCIsInF1ZXJpZXMiLCIkbGluayIsInBhcmVudHMiLCJzY3JvbGxTcHlzIiwiJHNweSIsIlRhYiIsIkRST1BET1dOX0FDVElWRV9DSElMRCIsIl90aGlzMjIiLCJwcmV2aW91cyIsImxpc3RFbGVtZW50IiwiaGlkZGVuRXZlbnQiLCJjb250YWluZXIiLCJfdGhpczIzIiwiYWN0aXZlIiwiX3RyYW5zaXRpb25Db21wbGV0ZSIsImRyb3Bkb3duQ2hpbGQiLCJkcm9wZG93bkVsZW1lbnQiLCJUb29sdGlwIiwiQ0xBU1NfUFJFRklYIiwiQlNDTFNfUFJFRklYX1JFR0VYIiwiYW5pbWF0aW9uIiwidGVtcGxhdGUiLCJ0aXRsZSIsImRlbGF5IiwiZmFsbGJhY2tQbGFjZW1lbnQiLCJBVVRPIiwiSG92ZXJTdGF0ZSIsIk9VVCIsIklOU0VSVEVEIiwiRk9DVVNPVVQiLCJUT09MVElQIiwiVE9PTFRJUF9JTk5FUiIsIkFSUk9XIiwiVHJpZ2dlciIsIkhPVkVSIiwiTUFOVUFMIiwiX2lzRW5hYmxlZCIsIl90aW1lb3V0IiwiX2hvdmVyU3RhdGUiLCJfYWN0aXZlVHJpZ2dlciIsInRpcCIsIl9zZXRMaXN0ZW5lcnMiLCJlbmFibGUiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsImRhdGFLZXkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJfaXNXaXRoQWN0aXZlVHJpZ2dlciIsIl9lbnRlciIsIl9sZWF2ZSIsImdldFRpcEVsZW1lbnQiLCJfdGhpczI0IiwiaXNXaXRoQ29udGVudCIsImlzSW5UaGVEb20iLCJvd25lckRvY3VtZW50IiwidGlwSWQiLCJzZXRDb250ZW50IiwiYXR0YWNobWVudCIsIl9nZXRBdHRhY2htZW50IiwiYWRkQXR0YWNobWVudENsYXNzIiwiX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSIsIl9maXhUcmFuc2l0aW9uIiwicHJldkhvdmVyU3RhdGUiLCJfVFJBTlNJVElPTl9EVVJBVElPTiIsIl90aGlzMjUiLCJfY2xlYW5UaXBDbGFzcyIsImdldFRpdGxlIiwiJHRpcCIsInNldEVsZW1lbnRDb250ZW50IiwiY29udGVudCIsImVtcHR5IiwiX3RoaXMyNiIsInRyaWdnZXJzIiwiZXZlbnRJbiIsImV2ZW50T3V0IiwiX2ZpeFRpdGxlIiwidGl0bGVUeXBlIiwidGFiQ2xhc3MiLCJpbml0Q29uZmlnQW5pbWF0aW9uIiwiUG9wb3ZlciIsIlRJVExFIiwiQ09OVEVOVCIsIl9Ub29sdGlwIiwiX2dldENvbnRlbnQiLCJyZSIsImNoIiwiciIsIkRFRkFVTFRTIiwic2VsZWN0cGlja2VyIiwiRnVuY3Rpb24iLCJpbmNsdWRlcyIsInN0YXJ0c1dpdGgiLCJjaGFyQ29kZUF0IiwidXNlRGVmYXVsdCIsIl9zZXQiLCJ2YWxIb29rcyIsInNldCIsInRyaWdnZXJOYXRpdmUiLCJleHByIiwicHNldWRvcyIsImljb250YWlucyIsImliZWdpbnMiLCJhaWNvbnRhaW5zIiwiYWliZWdpbnMiLCIkbmV3RWxlbWVudCIsIiRidXR0b24iLCIkbWVudSIsIiRsaXMiLCJ3aW5kb3dQYWRkaW5nIiwicmVuZGVyIiwic2V0U3R5bGUiLCJzZWxlY3RBbGwiLCJkZXNlbGVjdEFsbCIsImluaXQiLCJub25lU2VsZWN0ZWRUZXh0Iiwibm9uZVJlc3VsdHNUZXh0IiwiY291bnRTZWxlY3RlZFRleHQiLCJtYXhPcHRpb25zVGV4dCIsInNlbGVjdEFsbFRleHQiLCJkZXNlbGVjdEFsbFRleHQiLCJkb25lQnV0dG9uIiwiZG9uZUJ1dHRvblRleHQiLCJtdWx0aXBsZVNlcGFyYXRvciIsInN0eWxlQmFzZSIsInNlbGVjdGVkVGV4dEZvcm1hdCIsImhpZGVEaXNhYmxlZCIsInNob3dTdWJ0ZXh0Iiwic2hvd0ljb24iLCJzaG93Q29udGVudCIsImRyb3B1cEF1dG8iLCJoZWFkZXIiLCJsaXZlU2VhcmNoIiwibGl2ZVNlYXJjaFBsYWNlaG9sZGVyIiwibGl2ZVNlYXJjaE5vcm1hbGl6ZSIsImxpdmVTZWFyY2hTdHlsZSIsImFjdGlvbnNCb3giLCJpY29uQmFzZSIsInRpY2tJY29uIiwic2hvd1RpY2siLCJjYXJldCIsIm1heE9wdGlvbnMiLCJtb2JpbGUiLCJzZWxlY3RPblRhYiIsImRyb3Bkb3duQWxpZ25SaWdodCIsImxpT2JqIiwibXVsdGlwbGUiLCJhdXRvZm9jdXMiLCJjcmVhdGVWaWV3IiwiYWZ0ZXIiLCIkbWVudUlubmVyIiwiJHNlYXJjaGJveCIsImNoZWNrRGlzYWJsZWQiLCJjbGlja0xpc3RlbmVyIiwibGl2ZVNlYXJjaExpc3RlbmVyIiwic2V0V2lkdGgiLCJzZWxlY3RQb3NpdGlvbiIsInZhbGlkaXR5IiwidmFsaWQiLCJjcmVhdGVEcm9wZG93biIsImNyZWF0ZUxpIiwiaW5uZXJIVE1MIiwicmVsb2FkTGkiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwic2VsZWN0ZWRJbmRleCIsInAiLCJ1IiwiY3NzVGV4dCIsImciLCJ2IiwidyIsIkMiLCJTIiwiSSIsIlQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiRSIsImVxIiwiZmluZExpcyIsInNldERpc2FibGVkIiwic2V0U2VsZWN0ZWQiLCJ0b2dnbGVQbGFjZWhvbGRlciIsInRhYkluZGV4IiwidG9BcnJheSIsImxpSGVpZ2h0Iiwic2l6ZUluZm8iLCJjbG9uZU5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm91dGVySGVpZ2h0IiwidmVydCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJob3JpeiIsImJvcmRlclJpZ2h0V2lkdGgiLCJoZWFkZXJIZWlnaHQiLCJzZWFyY2hIZWlnaHQiLCJhY3Rpb25zSGVpZ2h0IiwiZG9uZUJ1dHRvbkhlaWdodCIsImRpdmlkZXJIZWlnaHQiLCJtZW51UGFkZGluZyIsIm1lbnVFeHRyYXMiLCJzZXRTaXplIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJsYXN0IiwiY2xvbmUiLCIkYnNDb250YWluZXIiLCJpc0Rpc2FibGVkIiwicmVtb3ZlQXR0ciIsIm9mZnNldFRvcCIsIl9zZWFyY2hTdHlsZSIsImJlZ2lucyIsImNoYW5nZUFsbCIsImtleWRvd24iLCJkZWZpbmUiLCJDaGFydCIsImNvZGUiLCJjb2xvck5hbWVzIiwiZ2V0UmdiYSIsImdldEhzbGEiLCJnZXRSZ2IiLCJnZXRIc2wiLCJnZXRId2IiLCJnZXRBbHBoYSIsImhleFN0cmluZyIsInJnYlN0cmluZyIsInJnYmFTdHJpbmciLCJwZXJjZW50U3RyaW5nIiwicGVyY2VudGFTdHJpbmciLCJoc2xTdHJpbmciLCJoc2xhU3RyaW5nIiwiaHdiU3RyaW5nIiwia2V5d29yZCIsInN0cmluZyIsImFiYnIiLCJoZXgiLCJyZ2JhIiwicGVyIiwicmdiIiwic2NhbGUiLCJoc2wiLCJhbHBoYSIsImh3YiIsImhzbGEiLCJ2YWxzIiwiaGV4RG91YmxlIiwicmV2ZXJzZU5hbWVzIiwibnVtIiwiY29udmVydCIsIkNvbG9yIiwidmFsdWVzIiwiaHN2IiwiY215ayIsInNldFZhbHVlcyIsInJlZCIsImxpZ2h0bmVzcyIsIndoaXRlbmVzcyIsImN5YW4iLCJzZXRTcGFjZSIsInJnYkFycmF5IiwiaHNsQXJyYXkiLCJoc3ZBcnJheSIsImh3YkFycmF5IiwiY215a0FycmF5IiwicmdiYUFycmF5IiwiaHNsYUFycmF5Iiwic2V0Q2hhbm5lbCIsImdyZWVuIiwiYmx1ZSIsImh1ZSIsInNhdHVyYXRpb24iLCJzYXR1cmF0aW9udiIsImJsYWNrbmVzcyIsIm1hZ2VudGEiLCJ5ZWxsb3ciLCJibGFjayIsInJnYk51bWJlciIsImx1bWlub3NpdHkiLCJsdW0iLCJjaGFuIiwicG93IiwiY29udHJhc3QiLCJjb2xvcjIiLCJsdW0xIiwibHVtMiIsImxldmVsIiwiY29udHJhc3RSYXRpbyIsImRhcmsiLCJ5aXEiLCJsaWdodCIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJyYXRpbyIsImRhcmtlbiIsInNhdHVyYXRlIiwiZGVzYXR1cmF0ZSIsIndoaXRlbiIsImJsYWNrZW4iLCJncmV5c2NhbGUiLCJjbGVhcmVyIiwib3BhcXVlciIsInJvdGF0ZSIsImRlZ3JlZXMiLCJtaXgiLCJtaXhpbkNvbG9yIiwid2VpZ2h0IiwiY29sb3IxIiwidzEiLCJ3MiIsInRvSlNPTiIsInNwYWNlcyIsIm1heGVzIiwiZ2V0VmFsdWVzIiwic3BhY2UiLCJjaGFucyIsImNhcHBlZCIsInNuYW1lIiwiYXJncyIsInN2YWx1ZXMiLCJyZ2IyaHNsIiwicmdiMmhzdiIsInJnYjJod2IiLCJyZ2IyY215ayIsInJnYjJrZXl3b3JkIiwicmdiMnh5eiIsInJnYjJsYWIiLCJyZ2IybGNoIiwiaHNsMnJnYiIsImhzbDJoc3YiLCJoc2wyaHdiIiwiaHNsMmNteWsiLCJoc2wya2V5d29yZCIsImhzdjJyZ2IiLCJoc3YyaHNsIiwiaHN2Mmh3YiIsImhzdjJjbXlrIiwiaHN2MmtleXdvcmQiLCJod2IycmdiIiwiaHdiMmhzbCIsImh3YjJoc3YiLCJod2IyY215ayIsImh3YjJrZXl3b3JkIiwiY215azJyZ2IiLCJjbXlrMmhzbCIsImNteWsyaHN2IiwiY215azJod2IiLCJjbXlrMmtleXdvcmQiLCJrZXl3b3JkMnJnYiIsImtleXdvcmQyaHNsIiwia2V5d29yZDJoc3YiLCJrZXl3b3JkMmh3YiIsImtleXdvcmQyY215ayIsImtleXdvcmQybGFiIiwia2V5d29yZDJ4eXoiLCJ4eXoycmdiIiwieHl6MmxhYiIsInh5ejJsY2giLCJsYWIyeHl6IiwibGFiMnJnYiIsImxhYjJsY2giLCJsY2gybGFiIiwibGNoMnh5eiIsImxjaDJyZ2IiLCJyZXZlcnNlS2V5d29yZHMiLCJKU09OIiwic3RyaW5naWZ5IiwieHl6IiwidDEiLCJ0MiIsInQzIiwic3YiLCJoaSIsInEiLCJzbCIsIndoIiwiYmwiLCJsYWIiLCJ5MiIsImhyIiwiYXRhbjIiLCJQSSIsInNxcnQiLCJsY2giLCJjb3MiLCJzaW4iLCJjc3NLZXl3b3JkcyIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW55ZWxsb3ciLCJncmV5IiwiaG9uZXlkZXciLCJob3RwaW5rIiwiaW5kaWFucmVkIiwiaW5kaWdvIiwiaXZvcnkiLCJraGFraSIsImxhdmVuZGVyIiwibGF2ZW5kZXJibHVzaCIsImxhd25ncmVlbiIsImxlbW9uY2hpZmZvbiIsImxpZ2h0Ymx1ZSIsImxpZ2h0Y29yYWwiLCJsaWdodGN5YW4iLCJsaWdodGdvbGRlbnJvZHllbGxvdyIsImxpZ2h0Z3JheSIsImxpZ2h0Z3JlZW4iLCJsaWdodGdyZXkiLCJsaWdodHBpbmsiLCJsaWdodHNhbG1vbiIsImxpZ2h0c2VhZ3JlZW4iLCJsaWdodHNreWJsdWUiLCJsaWdodHNsYXRlZ3JheSIsImxpZ2h0c2xhdGVncmV5IiwibGlnaHRzdGVlbGJsdWUiLCJsaWdodHllbGxvdyIsImxpbWUiLCJsaW1lZ3JlZW4iLCJsaW5lbiIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93Z3JlZW4iLCJjb252ZXJzaW9ucyIsIkNvbnZlcnRlciIsImZ1bmMiLCJhcmciLCJwYWlyIiwiZXhlYyIsImNvbnZzIiwicm91dGVTcGFjZSIsImZzcGFjZSIsImhlbHBlcnMiLCJFbGVtZW50IiwiZWxlbWVudHMiLCJJbnRlcmFjdGlvbiIsInBsYXRmb3JtIiwicGx1Z2lucyIsInJlZ2lzdGVyIiwiaW5pdGlhbGl6ZSIsImNhbnZhc0hlbHBlcnMiLCJjYW52YXMiLCJCYXIiLCJCdWJibGUiLCJEb3VnaG51dCIsIkxpbmUiLCJQb2xhckFyZWEiLCJSYWRhciIsIlNjYXR0ZXIiLCJob3ZlciIsIm1vZGUiLCJzY2FsZXMiLCJ4QXhlcyIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJncmlkTGluZXMiLCJvZmZzZXRHcmlkTGluZXMiLCJ5QXhlcyIsInJlY3RhbmdsZSIsImJvcmRlclNraXBwZWQiLCJ0b29sdGlwcyIsImNhbGxiYWNrcyIsInlMYWJlbCIsImxhYmVscyIsImRhdGFzZXRMYWJlbCIsImRhdGFzZXRzIiwiZGF0YXNldEluZGV4IiwieExhYmVsIiwiY29udHJvbGxlcnMiLCJiYXIiLCJEYXRhc2V0Q29udHJvbGxlciIsImRhdGFFbGVtZW50VHlwZSIsIlJlY3RhbmdsZSIsIm1lIiwibWV0YSIsImdldE1ldGEiLCJzdGFjayIsImdldERhdGFzZXQiLCJyZXNldCIsImlsZW4iLCJfcnVsZXIiLCJnZXRSdWxlciIsInVwZGF0ZUVsZW1lbnQiLCJjaGFydCIsImRhdGFzZXQiLCJjdXN0b20iLCJyZWN0YW5nbGVPcHRpb25zIiwiX3hTY2FsZSIsImdldFNjYWxlRm9ySWQiLCJ4QXhpc0lEIiwiX3lTY2FsZSIsInlBeGlzSUQiLCJfZGF0YXNldEluZGV4IiwiX2luZGV4IiwiX21vZGVsIiwiYmFja2dyb3VuZENvbG9yIiwidmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsInVwZGF0ZUVsZW1lbnRHZW9tZXRyeSIsInBpdm90IiwibW9kZWwiLCJ2c2NhbGUiLCJnZXRWYWx1ZVNjYWxlIiwiZ2V0QmFzZVBpeGVsIiwiaG9yaXpvbnRhbCIsImlzSG9yaXpvbnRhbCIsInJ1bGVyIiwidnBpeGVscyIsImNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsImNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwiaGVhZCIsImdldFZhbHVlU2NhbGVJZCIsImdldEluZGV4U2NhbGVJZCIsImdldEluZGV4U2NhbGUiLCJnZXRTdGFja0NvdW50Iiwic3RhY2tlZCIsInN0YWNrcyIsImdldERhdGFzZXRNZXRhIiwiaXNEYXRhc2V0VmlzaWJsZSIsImdldFN0YWNrSW5kZXgiLCJzdGFja0NvdW50IiwicGl4ZWxzIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsImdldFJpZ2h0VmFsdWUiLCJpbWV0YSIsIml2YWx1ZSIsImNvbnRyb2xsZXIiLCJzdGFja0luZGV4IiwibGVmdFNhbXBsZVNpemUiLCJyaWdodFNhbXBsZVNpemUiLCJsZWZ0Q2F0ZWdvcnlTaXplIiwicmlnaHRDYXRlZ29yeVNpemUiLCJmdWxsQmFyU2l6ZSIsInZhbHVlT3JEZWZhdWx0IiwiYmFyVGhpY2tuZXNzIiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJkcmF3IiwiY2xpcEFyZWEiLCJjdHgiLCJjaGFydEFyZWEiLCJ1bmNsaXBBcmVhIiwic2V0SG92ZXJTdHlsZSIsImhvdmVyQmFja2dyb3VuZENvbG9yIiwiZ2V0SG92ZXJDb2xvciIsImhvdmVyQm9yZGVyQ29sb3IiLCJob3ZlckJvcmRlcldpZHRoIiwicmVtb3ZlSG92ZXJTdHlsZSIsInJlY3RhbmdsZUVsZW1lbnRPcHRpb25zIiwiaG9yaXpvbnRhbEJhciIsImRhdGFQb2ludCIsImJ1YmJsZSIsIlBvaW50IiwicG9pbnRzIiwicG9pbnQiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZHNJbmRleCIsImdldFBpeGVsRm9yRGVjaW1hbCIsIk5hTiIsIl9vcHRpb25zIiwiaGl0UmFkaXVzIiwicG9pbnRTdHlsZSIsInJhZGl1cyIsInNraXAiLCJob3ZlclJhZGl1cyIsImRhdGFJbmRleCIsImFuaW1hdGVSb3RhdGUiLCJhbmltYXRlU2NhbGUiLCJsZWdlbmRDYWxsYmFjayIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwiZHMiLCJhcmMiLCJhcmNPcHRzIiwiZmlsbCIsInN0cm9rZSIsImJ3IiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJvbkNsaWNrIiwibGVnZW5kSXRlbSIsImN1dG91dFBlcmNlbnRhZ2UiLCJyb3RhdGlvbiIsImNpcmN1bWZlcmVuY2UiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImlzQXJyYXkiLCJkb3VnaG51dCIsInBpZSIsIkFyYyIsImxpbmtTY2FsZXMiLCJnZXRSaW5nSW5kZXgiLCJyaW5nSW5kZXgiLCJqIiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJtaW5TaXplIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiY29udGFpbnMwIiwiY29udGFpbnM5MCIsImNvbnRhaW5zMTgwIiwiY29udGFpbnMyNzAiLCJjdXRvdXQiLCJnZXRNYXhCb3JkZXJXaWR0aCIsIm91dGVyUmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJyYWRpdXNMZW5ndGgiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJ0b3RhbCIsImNhbGN1bGF0ZVRvdGFsIiwiYW5pbWF0aW9uT3B0cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImFyY3MiLCJob3ZlcldpZHRoIiwiX2NoYXJ0Iiwic2hvd0xpbmVzIiwic3BhbkdhcHMiLCJsaW5lRW5hYmxlZCIsInNob3dMaW5lIiwibGluZSIsImRhdGFzZXRFbGVtZW50VHlwZSIsImxpbmVFbGVtZW50T3B0aW9ucyIsInRlbnNpb24iLCJsaW5lVGVuc2lvbiIsIl9zY2FsZSIsIl9jaGlsZHJlbiIsImJvcmRlckNhcFN0eWxlIiwiYm9yZGVyRGFzaCIsImJvcmRlckRhc2hPZmZzZXQiLCJib3JkZXJKb2luU3R5bGUiLCJzdGVwcGVkTGluZSIsInN0ZXBwZWQiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwidXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImdldFBvaW50QmFja2dyb3VuZENvbG9yIiwicG9pbnRCYWNrZ3JvdW5kQ29sb3IiLCJnZXRQb2ludEJvcmRlckNvbG9yIiwicG9pbnRCb3JkZXJDb2xvciIsImdldFBvaW50Qm9yZGVyV2lkdGgiLCJwb2ludEJvcmRlcldpZHRoIiwicG9pbnRPcHRpb25zIiwicG9pbnRSYWRpdXMiLCJwb2ludEhpdFJhZGl1cyIsImNhbGN1bGF0ZVBvaW50WSIsInN1bVBvcyIsInN1bU5lZyIsImRzTWV0YSIsInN0YWNrZWRSaWdodFZhbHVlIiwicmlnaHRWYWx1ZSIsImNvbnRyb2xQb2ludHMiLCJwdCIsImNhcENvbnRyb2xQb2ludCIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJzcGxpbmVDdXJ2ZSIsInByZXZpb3VzSXRlbSIsIm5leHRJdGVtIiwiY29udHJvbFBvaW50UHJldmlvdXNYIiwiY29udHJvbFBvaW50UHJldmlvdXNZIiwiY29udHJvbFBvaW50TmV4dFgiLCJjb250cm9sUG9pbnROZXh0WSIsImNhcEJlemllclBvaW50cyIsInBvaW50SG92ZXJSYWRpdXMiLCJwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yIiwicG9pbnRIb3ZlckJvcmRlckNvbG9yIiwicG9pbnRIb3ZlckJvcmRlcldpZHRoIiwiYW5nbGVMaW5lcyIsImNpcmN1bGFyIiwicG9pbnRMYWJlbHMiLCJ0aWNrcyIsImJlZ2luQXRaZXJvIiwicG9sYXJBcmVhIiwiY291bnQiLCJjb3VudFZpc2libGVFbGVtZW50cyIsInhDZW50ZXIiLCJ5Q2VudGVyIiwidmlzaWJsZUNvdW50IiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJkaXN0YW5jZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwicmVzZXRSYWRpdXMiLCJyYWRhciIsIl9sb29wIiwicG9pbnRFbGVtZW50T3B0aW9ucyIsInBvaW50UG9zaXRpb24iLCJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCJzY2F0dGVyIiwiZWFzaW5nIiwib25Qcm9ncmVzcyIsIm9uQ29tcGxldGUiLCJBbmltYXRpb24iLCJjdXJyZW50U3RlcCIsIm51bVN0ZXBzIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uQW5pbWF0aW9uQ29tcGxldGUiLCJhbmltYXRpb25TZXJ2aWNlIiwiZnJhbWVEdXJhdGlvbiIsImFuaW1hdGlvbnMiLCJkcm9wRnJhbWVzIiwicmVxdWVzdCIsImFkZEFuaW1hdGlvbiIsImxhenkiLCJhbmltYXRpbmciLCJjYW5jZWxBbmltYXRpb24iLCJyZXF1ZXN0QW5pbUZyYW1lIiwic3RhcnREaWdlc3QiLCJmcmFtZXNUb0Ryb3AiLCJhZHZhbmNlIiwidHlwZXMiLCJpbnN0YW5jZXMiLCJpbml0Q29uZmlnIiwiY29uZmlnTWVyZ2UiLCJ1cGRhdGVDb25maWciLCJuZXdPcHRpb25zIiwic2NhbGVPcHRpb25zIiwidG9vbHRpcCIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiY29uc3RydWN0IiwiYWNxdWlyZUNvbnRleHQiLCJ1aWQiLCJhc3BlY3RSYXRpbyIsIl9idWZmZXJlZFJlbmRlciIsIm5vdGlmeSIsInJldGluYVNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJpbmRFdmVudHMiLCJyZXNwb25zaXZlIiwicmVzaXplIiwiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsImJ1aWxkU2NhbGVzIiwiaW5pdFRvb2xUaXAiLCJjbGVhciIsInNpbGVudCIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJnZXRNYXhpbXVtV2lkdGgiLCJuZXdIZWlnaHQiLCJnZXRNYXhpbXVtSGVpZ2h0IiwibmV3U2l6ZSIsIm9uUmVzaXplIiwicmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uIiwic2NhbGVzT3B0aW9ucyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsImR0eXBlIiwiZHBvc2l0aW9uIiwiaXNEZWZhdWx0Iiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsInNjYWxlU2VydmljZSIsImdldFNjYWxlQ29uc3RydWN0b3IiLCJtZXJnZVRpY2tzT3B0aW9ucyIsImFkZFNjYWxlc1RvTGF5b3V0IiwiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwibmV3Q29udHJvbGxlcnMiLCJkZXN0cm95RGF0YXNldE1ldGEiLCJ1cGRhdGVJbmRleCIsIkNvbnRyb2xsZXJDbGFzcyIsInJlc2V0RWxlbWVudHMiLCJfZGF0YSIsImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsInVwZGF0ZUxheW91dCIsInVwZGF0ZURhdGFzZXRzIiwiX2J1ZmZlcmVkUmVxdWVzdCIsImxheW91dFNlcnZpY2UiLCJ1cGRhdGVEYXRhc2V0IiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbk9iamVjdCIsImVhc2luZ0Z1bmN0aW9uIiwiZWZmZWN0cyIsInN0ZXBEZWNpbWFsIiwiZWFzaW5nVmFsdWUiLCJpc051bGxPclVuZGVmIiwiYm94ZXMiLCJib3giLCJkcmF3RGF0YXNldHMiLCJkcmF3RGF0YXNldCIsImdldEVsZW1lbnRBdEV2ZW50IiwibW9kZXMiLCJzaW5nbGUiLCJnZXRFbGVtZW50c0F0RXZlbnQiLCJpbnRlcnNlY3QiLCJnZXRFbGVtZW50c0F0WEF4aXMiLCJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwiZ2V0RGF0YXNldEF0RXZlbnQiLCJfbWV0YSIsImdlbmVyYXRlTGVnZW5kIiwidW5iaW5kRXZlbnRzIiwicmVsZWFzZUNvbnRleHQiLCJ0b0Jhc2U2NEltYWdlIiwidG9EYXRhVVJMIiwiX2NoYXJ0SW5zdGFuY2UiLCJsaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwibGlzdGVuZXIiLCJldmVudEhhbmRsZXIiLCJldmVudHMiLCJ1cGRhdGVIb3ZlclN0eWxlIiwiaGFuZGxlRXZlbnQiLCJidWZmZXJlZFJlcXVlc3QiLCJhbmltYXRpb25EdXJhdGlvbiIsImhvdmVyT3B0aW9ucyIsImxhc3RBY3RpdmUiLCJvbkhvdmVyIiwibmF0aXZlIiwiYXJyYXlFcXVhbHMiLCJDb250cm9sbGVyIiwiYXJyYXlFdmVudHMiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImFycmF5IiwiX2NoYXJ0anMiLCJyZXMiLCJvYmplY3QiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsImFkZEVsZW1lbnRzIiwic2NhbGVJRCIsImNyZWF0ZU1ldGFEYXRhc2V0IiwiY3JlYXRlTWV0YURhdGEiLCJtZXRhRGF0YSIsImFkZEVsZW1lbnRBbmRSZXNldCIsInJlc3luY0VsZW1lbnRzIiwiZWxlbWVudE9wdHMiLCJudW1NZXRhIiwibnVtRGF0YSIsImluc2VydEVsZW1lbnRzIiwib25EYXRhUHVzaCIsIm9uRGF0YVBvcCIsIm9uRGF0YVNoaWZ0Iiwib25EYXRhU3BsaWNlIiwib25EYXRhVW5zaGlmdCIsImluaGVyaXRzIiwic2NvcGUiLCJjb2xvciIsImludGVycG9sYXRlIiwidmlldyIsImVhc2UiLCJhY3R1YWwiLCJvcmlnaW4iLCJjMCIsImMxIiwiY29uZmlndXJhdGlvbiIsIl92aWV3IiwiX3N0YXJ0IiwidG9vbHRpcFBvc2l0aW9uIiwiaGFzVmFsdWUiLCJpc051bWJlciIsInNldEZuIiwibWVyZ2VyIiwidHZhbCIsInN2YWwiLCJzY2FsZU1lcmdlIiwiZ2V0U2NhbGVEZWZhdWx0cyIsIl9tZXJnZXIiLCJzbGVuIiwid2hlcmUiLCJjb2xsZWN0aW9uIiwiZmlsdGVyQ2FsbGJhY2siLCJmaWx0ZXJlZCIsImZpbmROZXh0V2hlcmUiLCJhcnJheVRvU2VhcmNoIiwic3RhcnRJbmRleCIsImN1cnJlbnRJdGVtIiwiZmluZFByZXZpb3VzV2hlcmUiLCJleHRlbnNpb25zIiwiQ2hhcnRFbGVtZW50IiwiU3Vycm9nYXRlIiwiX19zdXBlcl9fIiwiYWxtb3N0RXF1YWxzIiwiZXBzaWxvbiIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJzaWduIiwibG9nMTAiLCJMTjEwIiwidG9SYWRpYW5zIiwidG9EZWdyZWVzIiwicmFkaWFucyIsImdldEFuZ2xlRnJvbVBvaW50IiwiY2VudHJlUG9pbnQiLCJhbmdsZVBvaW50IiwiZGlzdGFuY2VGcm9tWENlbnRlciIsImRpc3RhbmNlRnJvbVlDZW50ZXIiLCJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJhbmdsZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsImFsaWFzUGl4ZWwiLCJwaXhlbFdpZHRoIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsImN1cnJlbnQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwiRVBTSUxPTiIsInBvaW50c1dpdGhUYW5nZW50cyIsImRlbHRhSyIsIm1LIiwicG9pbnRzTGVuIiwicG9pbnRCZWZvcmUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwic2xvcGVEZWx0YVgiLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwiZGVsdGFYIiwibG9vcCIsIm5pY2VOdW0iLCJleHBvbmVudCIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsImV2dCIsIm1vdXNlWCIsIm1vdXNlWSIsIm9yaWdpbmFsRXZlbnQiLCJzcmNFbGVtZW50IiwiYm91bmRpbmdSZWN0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwiZ2V0U3R5bGUiLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsInBhcnNlTWF4U3R5bGUiLCJzdHlsZVZhbHVlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiaXNDb25zdHJhaW5lZFZhbHVlIiwiZ2V0Q29uc3RyYWludERpbWVuc2lvbiIsImRvbU5vZGUiLCJtYXhTdHlsZSIsInBlcmNlbnRhZ2VQcm9wZXJ0eSIsImRlZmF1bHRWaWV3IiwiY29uc3RyYWluZWROb2RlIiwiY29uc3RyYWluZWRDb250YWluZXIiLCJoYXNDTm9kZSIsImhhc0NDb250YWluZXIiLCJpbmZpbml0eSIsImdldENvbnN0cmFpbnRXaWR0aCIsImdldENvbnN0cmFpbnRIZWlnaHQiLCJjdyIsImN1cnJlbnRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJmb3JjZVJhdGlvIiwicGl4ZWxSYXRpbyIsImZvbnRTdHJpbmciLCJwaXhlbFNpemUiLCJmb250U3R5bGUiLCJmb250RmFtaWx5IiwibG9uZ2VzdFRleHQiLCJmb250IiwiYXJyYXlPZlRoaW5ncyIsImNhY2hlIiwiZ2MiLCJnYXJiYWdlQ29sbGVjdCIsImxvbmdlc3QiLCJ0aGluZyIsIm1lYXN1cmVUZXh0IiwibmVzdGVkVGhpbmciLCJnY0xlbiIsInRleHRXaWR0aCIsIm51bWJlck9mTGFiZWxMaW5lcyIsIm51bWJlck9mTGluZXMiLCJDYW52YXNHcmFkaWVudCIsImRlZmF1bHRDb2xvciIsImNvbG9yVmFsdWUiLCJDYW52YXNQYXR0ZXJuIiwicGFyc2VWaXNpYmxlSXRlbXMiLCJqbGVuIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJpblJhbmdlIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiZGlzdGFuY2VNZXRyaWMiLCJtaW5EaXN0YW5jZSIsIm5lYXJlc3RJdGVtcyIsImdldENlbnRlclBvaW50IiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJkZWx0YVkiLCJpbmRleE1vZGUiLCJuZWFyZXN0Iiwic2l6ZUEiLCJzaXplQiIsImludGVyc2VjdHNJdGVtIiwiaW5YUmFuZ2UiLCJpbllSYW5nZSIsImRlZmF1bHRGb250Q29sb3IiLCJkZWZhdWx0Rm9udEZhbWlseSIsImRlZmF1bHRGb250U2l6ZSIsImRlZmF1bHRGb250U3R5bGUiLCJsYXlvdXQiLCJmaWx0ZXJCeVBvc2l0aW9uIiwic29ydEJ5V2VpZ2h0IiwiX3RtcEluZGV4XyIsInYwIiwidjEiLCJhZGRCb3giLCJmdWxsV2lkdGgiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwiY29uZmlndXJlIiwibGF5b3V0T3B0aW9ucyIsInRvUGFkZGluZyIsImxlZnRQYWRkaW5nIiwicmlnaHRQYWRkaW5nIiwidG9wUGFkZGluZyIsImJvdHRvbVBhZGRpbmciLCJsZWZ0Qm94ZXMiLCJyaWdodEJveGVzIiwidG9wQm94ZXMiLCJib3R0b21Cb3hlcyIsImNoYXJ0QXJlYUJveGVzIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwiY2hhcnRBcmVhV2lkdGgiLCJjaGFydEFyZWFIZWlnaHQiLCJ2ZXJ0aWNhbEJveFdpZHRoIiwiaG9yaXpvbnRhbEJveEhlaWdodCIsIm1heENoYXJ0QXJlYVdpZHRoIiwibWF4Q2hhcnRBcmVhSGVpZ2h0IiwibWluQm94U2l6ZXMiLCJnZXRNaW5pbXVtQm94U2l6ZSIsIm1heEhvcml6b250YWxMZWZ0UGFkZGluZyIsIm1heEhvcml6b250YWxSaWdodFBhZGRpbmciLCJtYXhWZXJ0aWNhbFRvcFBhZGRpbmciLCJtYXhWZXJ0aWNhbEJvdHRvbVBhZGRpbmciLCJob3Jpem9udGFsQm94IiwiZ2V0UGFkZGluZyIsImJveFBhZGRpbmciLCJ2ZXJ0aWNhbEJveCIsInRvdGFsTGVmdEJveGVzV2lkdGgiLCJ0b3RhbFJpZ2h0Qm94ZXNXaWR0aCIsInRvdGFsVG9wQm94ZXNIZWlnaHQiLCJ0b3RhbEJvdHRvbUJveGVzSGVpZ2h0IiwiZml0Qm94IiwibWluQm94U2l6ZSIsIm1pbkJveCIsInNjYWxlTWFyZ2luIiwiZmluYWxGaXRWZXJ0aWNhbEJveCIsImxlZnRQYWRkaW5nQWRkaXRpb24iLCJ0b3BQYWRkaW5nQWRkaXRpb24iLCJuZXdNYXhDaGFydEFyZWFIZWlnaHQiLCJuZXdNYXhDaGFydEFyZWFXaWR0aCIsInBsYWNlQm94IiwiX3BsdWdpbnMiLCJfY2FjaGVJZCIsInBsdWdpbiIsInVucmVnaXN0ZXIiLCJnZXRBbGwiLCJob29rIiwiZGVzY3JpcHRvcnMiLCJwYXJhbXMiLCJwbHVnaW5TZXJ2aWNlIiwiUGx1Z2luQmFzZSIsIlRpY2tzIiwiZHJhd0JvcmRlciIsImRyYXdPbkNoYXJ0QXJlYSIsImRyYXdUaWNrcyIsInRpY2tNYXJrTGVuZ3RoIiwiemVyb0xpbmVXaWR0aCIsInplcm9MaW5lQ29sb3IiLCJ6ZXJvTGluZUJvcmRlckRhc2giLCJ6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQiLCJzY2FsZUxhYmVsIiwibGFiZWxTdHJpbmciLCJsaW5lSGVpZ2h0IiwibWluUm90YXRpb24iLCJtYXhSb3RhdGlvbiIsIm1pcnJvciIsImF1dG9Ta2lwIiwiYXV0b1NraXBQYWRkaW5nIiwibGFiZWxPZmZzZXQiLCJmb3JtYXR0ZXJzIiwibWlub3IiLCJtYWpvciIsImxhYmVsc0Zyb21UaWNrcyIsImdldExpbmVWYWx1ZSIsImxpbmVWYWx1ZSIsImdldFBpeGVsRm9yVGljayIsImNvbXB1dGVUZXh0U2l6ZSIsInRpY2siLCJwYXJzZUZvbnRPcHRpb25zIiwiZ2xvYmFsRGVmYXVsdHMiLCJmb250U2l6ZSIsImZhbWlseSIsInBhcnNlTGluZUhlaWdodCIsInRvTGluZUhlaWdodCIsIlNjYWxlIiwiZ2V0VGlja3MiLCJfdGlja3MiLCJiZWZvcmVVcGRhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1hcmdpbnMiLCJsb25nZXN0VGV4dENhY2hlIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiY29udmVydFRpY2tzVG9MYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInRpY2tPcHRzIiwidXNlckNhbGxiYWNrIiwidGlja0ZvbnQiLCJsYWJlbFJvdGF0aW9uIiwib3JpZ2luYWxMYWJlbFdpZHRoIiwibGFiZWxXaWR0aCIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJ0aWNrV2lkdGgiLCJhbmdsZVJhZGlhbnMiLCJzY2FsZUxhYmVsT3B0cyIsImdyaWRMaW5lT3B0cyIsImlzRnVsbFdpZHRoIiwic2NhbGVMYWJlbExpbmVIZWlnaHQiLCJzY2FsZUxhYmVsUGFkZGluZyIsImRlbHRhSGVpZ2h0IiwibGFyZ2VzdFRleHRXaWR0aCIsInRhbGxlc3RMYWJlbEhlaWdodEluTGluZXMiLCJsaW5lU3BhY2UiLCJ0aWNrUGFkZGluZyIsImxvbmdlc3RMYWJlbFdpZHRoIiwibGFiZWxIZWlnaHQiLCJmaXJzdExhYmVsV2lkdGgiLCJsYXN0TGFiZWxXaWR0aCIsImhhbmRsZU1hcmdpbnMiLCJyYXdWYWx1ZSIsImdldExhYmVsRm9ySW5kZXgiLCJnZXRWYWx1ZUZvclBpeGVsIiwicGl4ZWwiLCJmaW5hbFZhbCIsImRlY2ltYWwiLCJ2YWx1ZU9mZnNldCIsImdldEJhc2VWYWx1ZSIsIl9hdXRvU2tpcCIsInNraXBSYXRpbyIsIm9wdGlvblRpY2tzIiwidGlja0NvdW50IiwibGFiZWxSb3RhdGlvblJhZGlhbnMiLCJsb25nZXN0Um90YXRlZExhYmVsIiwic2hvdWxkU2tpcCIsIm1heFRpY2tzIiwibWF4VGlja3NMaW1pdCIsIm9wdGlvbk1ham9yVGlja3MiLCJpc1JvdGF0ZWQiLCJ0aWNrRm9udENvbG9yIiwiZm9udENvbG9yIiwibWFqb3JUaWNrRm9udENvbG9yIiwibWFqb3JUaWNrRm9udCIsInRsIiwic2NhbGVMYWJlbEZvbnRDb2xvciIsInNjYWxlTGFiZWxGb250IiwiaXRlbXNUb0RyYXciLCJ4VGlja1N0YXJ0IiwieFRpY2tFbmQiLCJ5VGlja1N0YXJ0IiwieVRpY2tFbmQiLCJsaW5lQ29sb3IiLCJ6ZXJvTGluZUluZGV4IiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwieDEiLCJ5MSIsIngyIiwibGFiZWxYIiwibGFiZWxZIiwidGV4dEJhc2VsaW5lIiwibGFiZWxZT2Zmc2V0IiwieExpbmVWYWx1ZSIsImlzTGVmdCIsImxhYmVsWE9mZnNldCIsInlMaW5lVmFsdWUiLCJnbFdpZHRoIiwiZ2xDb2xvciIsImdsQm9yZGVyRGFzaCIsImdsQm9yZGVyRGFzaE9mZnNldCIsIml0ZW1Ub0RyYXciLCJzYXZlIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInJlc3RvcmUiLCJ0cmFuc2xhdGUiLCJmaWxsVGV4dCIsInNjYWxlTGFiZWxYIiwic2NhbGVMYWJlbFkiLCJoYWxmTGluZUhlaWdodCIsImNvbnN0cnVjdG9ycyIsInJlZ2lzdGVyU2NhbGVUeXBlIiwic2NhbGVDb25zdHJ1Y3RvciIsInNjYWxlRGVmYXVsdHMiLCJ1cGRhdGVTY2FsZURlZmF1bHRzIiwiYWRkaXRpb25zIiwiZ2VuZXJhdG9ycyIsImxpbmVhciIsImdlbmVyYXRpb25PcHRpb25zIiwiZGF0YVJhbmdlIiwic3BhY2luZyIsInN0ZXBTaXplIiwibmljZVJhbmdlIiwibmljZU1pbiIsIm5pY2VNYXgiLCJjZWlsIiwibnVtU3BhY2VzIiwibG9nYXJpdGhtaWMiLCJ0aWNrVmFsIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJleHAiLCJzaWduaWZpY2FuZCIsIm1pbk5vdFplcm8iLCJsYXN0VGljayIsInRpY2tWYWx1ZSIsImxvZ0RlbHRhIiwidGlja1N0cmluZyIsIm51bURlY2ltYWwiLCJ0b0ZpeGVkIiwicmVtYWluIiwidG9FeHBvbmVudGlhbCIsInRpdGxlRm9udFN0eWxlIiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJ0aXRsZUZvbnRDb2xvciIsInRpdGxlQWxpZ24iLCJib2R5U3BhY2luZyIsImJvZHlGb250Q29sb3IiLCJib2R5QWxpZ24iLCJmb290ZXJGb250U3R5bGUiLCJmb290ZXJTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyRm9udENvbG9yIiwiZm9vdGVyQWxpZ24iLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiY2FyZXRTaXplIiwiY29ybmVyUmFkaXVzIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwiZGlzcGxheUNvbG9ycyIsImJlZm9yZVRpdGxlIiwidG9vbHRpcEl0ZW1zIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVCb2R5IiwiYmVmb3JlTGFiZWwiLCJsYWJlbENvbG9yIiwibGFiZWxUZXh0Q29sb3IiLCJhZnRlckxhYmVsIiwiYWZ0ZXJCb2R5IiwiYmVmb3JlRm9vdGVyIiwiZm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJtZXJnZU9wYWNpdHkiLCJjb2xvclN0cmluZyIsIm9wYWNpdHkiLCJwdXNoT3JDb25jYXQiLCJ0b1B1c2giLCJjcmVhdGVUb29sdGlwSXRlbSIsImdldEJhc2VNb2RlbCIsInRvb2x0aXBPcHRzIiwieEFsaWduIiwieUFsaWduIiwiX2JvZHlGb250RmFtaWx5IiwiYm9keUZvbnRGYW1pbHkiLCJfYm9keUZvbnRTdHlsZSIsImJvZHlGb250U3R5bGUiLCJfYm9keUFsaWduIiwiYm9keUZvbnRTaXplIiwiX3RpdGxlRm9udEZhbWlseSIsInRpdGxlRm9udEZhbWlseSIsIl90aXRsZUZvbnRTdHlsZSIsInRpdGxlRm9udFNpemUiLCJfdGl0bGVBbGlnbiIsIl9mb290ZXJGb250RmFtaWx5IiwiZm9vdGVyRm9udEZhbWlseSIsIl9mb290ZXJGb250U3R5bGUiLCJmb290ZXJGb250U2l6ZSIsIl9mb290ZXJBbGlnbiIsImxlZ2VuZENvbG9yQmFja2dyb3VuZCIsImdldFRvb2x0aXBTaXplIiwiY29tYmluZWRCb2R5TGVuZ3RoIiwiYm9keUl0ZW0iLCJsaW5lcyIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50Iiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwiZGV0ZXJtaW5lQWxpZ25tZW50IiwibGYiLCJyZiIsIm9sZiIsIm9yZiIsInlmIiwibWlkWCIsIm1pZFkiLCJnZXRCYWNrZ3JvdW5kUG9pbnQiLCJ2bSIsImFsaWdubWVudCIsInBhZGRpbmdBbmRTaXplIiwicmFkaXVzQW5kUGFkZGluZyIsImdldEJlZm9yZUJvZHkiLCJnZXRCb2R5IiwiYm9keUl0ZW1zIiwiZ2V0QWZ0ZXJCb2R5IiwiZ2V0Rm9vdGVyIiwiZXhpc3RpbmdNb2RlbCIsIl9hY3RpdmUiLCJiYWNrZ3JvdW5kUG9pbnQiLCJ0b29sdGlwU2l6ZSIsImNhcmV0WCIsImNhcmV0WSIsImxhYmVsQ29sb3JzIiwibGFiZWxUZXh0Q29sb3JzIiwicG9zaXRpb25lcnMiLCJfZXZlbnRQb3NpdGlvbiIsIml0ZW1Tb3J0IiwiZGF0YVBvaW50cyIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsInRtcCIsImRyYXdUaXRsZSIsImRyYXdCb2R5IiwieExpbmVQYWRkaW5nIiwiZmlsbExpbmVPZlRleHQiLCJkcmF3Q29sb3JCb3hlcyIsImZpbGxSZWN0Iiwic3Ryb2tlUmVjdCIsInRleHRDb2xvciIsImRyYXdGb290ZXIiLCJkcmF3QmFja2dyb3VuZCIsInF1YWRyYXRpY0N1cnZlVG8iLCJjbG9zZVBhdGgiLCJoYXNUb29sdGlwQ29udGVudCIsIl9sYXN0QWN0aXZlIiwiYXZlcmFnZSIsInBvcyIsImV2ZW50UG9zaXRpb24iLCJuZWFyZXN0RWxlbWVudCIsInRwIiwiaW5MYWJlbFJhbmdlIiwiY2hhcnRYIiwiY2hhcnRZIiwicG9pbnRSZWxhdGl2ZVBvc2l0aW9uIiwiYmV0d2VlbkFuZ2xlcyIsIndpdGhpblJhZGl1cyIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJjZW50cmVBbmdsZSIsInJhbmdlRnJvbUNlbnRyZSIsInNBIiwiZUEiLCJsaW5lSm9pbiIsImdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyIsImxhc3REcmF3bkluZGV4IiwiY3VycmVudFZNIiwibGluZUNhcCIsInhSYW5nZSIsInlSYW5nZSIsImVyck1hcmdpbiIsImRyYXdQb2ludCIsImdldEJhckJvdW5kcyIsImhhbGZXaWR0aCIsImhhbGZIZWlnaHQiLCJzaWduWCIsInNpZ25ZIiwiYmFyU2l6ZSIsImhhbGZTdHJva2UiLCJib3JkZXJMZWZ0IiwiYm9yZGVyUmlnaHQiLCJib3JkZXJUb3AiLCJib3JkZXJCb3R0b20iLCJjb3JuZXJzIiwiYm9yZGVycyIsInN0YXJ0Q29ybmVyIiwiY29ybmVyQXQiLCJjb3JuZXIiLCJib3VuZHMiLCJjbGVhclJlY3QiLCJyb3VuZGVkUmVjdCIsInJ4IiwicnkiLCJlZGdlTGVuZ3RoIiwieE9mZnNldCIsInlPZmZzZXQiLCJkcmF3SW1hZ2UiLCJTUVJUMiIsImxlZnRYIiwidG9wWSIsInNpZGVTaXplIiwiY2xpcCIsImJlemllckN1cnZlVG8iLCJkcmF3Um91bmRlZFJlY3RhbmdsZSIsImlzT2JqZWN0IiwidGhpc0FyZyIsImxvb3BhYmxlIiwiYTAiLCJhMSIsImtsZW4iLCJfbWVyZ2VySWYiLCJtZXJnZUlmIiwic291cmNlcyIsImNhbGxDYWxsYmFjayIsImdldFZhbHVlT3JEZWZhdWx0IiwiZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJhc2luIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJlYXNpbmdFZmZlY3RzIiwibWF0Y2hlcyIsImlucHV0cyIsImdldENvbnRleHQiLCJFWFBBTkRPX0tFWSIsIkNTU19QUkVGSVgiLCJDU1NfUkVOREVSX01PTklUT1IiLCJDU1NfUkVOREVSX0FOSU1BVElPTiIsIkFOSU1BVElPTl9TVEFSVF9FVkVOVFMiLCJFVkVOVF9UWVBFUyIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVybGVhdmUiLCJwb2ludGVyb3V0IiwicmVhZFVzZWRTaXplIiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsInJlbmRlcldpZHRoIiwiaW5pdGlhbCIsImRpc3BsYXlXaWR0aCIsImRpc3BsYXlIZWlnaHQiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHMiLCJldmVudExpc3RlbmVyT3B0aW9ucyIsImNyZWF0ZUV2ZW50IiwibmF0aXZlRXZlbnQiLCJmcm9tTmF0aXZlRXZlbnQiLCJ0aHJvdHRsZWQiLCJ0aWNraW5nIiwiY3JlYXRlUmVzaXplciIsInJlc2l6ZXIiLCJjbHMiLCJtYXhTaXplIiwiZXhwYW5kIiwiY2hpbGROb2RlcyIsInNocmluayIsIl9yZXNldCIsIm9uU2Nyb2xsIiwid2F0Y2hGb3JSZW5kZXIiLCJleHBhbmRvIiwicHJveHkiLCJyZW5kZXJQcm94eSIsImFuaW1hdGlvbk5hbWUiLCJhZGQiLCJ1bndhdGNoRm9yUmVuZGVyIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJyZW1vdmVSZXNpemVMaXN0ZW5lciIsImluamVjdENTUyIsIl9zdHlsZSIsIl9lbmFibGVkIiwia2V5ZnJhbWVzIiwicHJveGllcyIsImFkZEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJiYXNpYyIsImRvbSIsImltcGxlbWVudGF0aW9uIiwiZmlsbGVyIiwicHJvcGFnYXRlIiwibWFwcGVycyIsInZpc2libGUiLCJib3VuZGFyeSIsImRlY29kZUZpbGwiLCJjb21wdXRlQm91bmRhcnkiLCJzY2FsZUJvdHRvbSIsInNjYWxlVG9wIiwic2NhbGVaZXJvIiwiZ2V0QmFzZVBvc2l0aW9uIiwicmVzb2x2ZVRhcmdldCIsInZpc2l0ZWQiLCJjcmVhdGVNYXBwZXIiLCJpc0RyYXdhYmxlIiwiZHJhd0FyZWEiLCJjdXJ2ZTAiLCJjdXJ2ZTEiLCJsZW4wIiwibGVuMSIsImRvRmlsbCIsIm1hcHBlciIsInNwYW4iLCJwMCIsInAxIiwiZDAiLCJkMSIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCIkZmlsbGVyIiwiYmVmb3JlRGF0YXNldERyYXciLCJjaSIsImJveFdpZHRoIiwibGluZURhc2giLCJnZXRCb3hXaWR0aCIsImxhYmVsT3B0cyIsInVzZVBvaW50U3R5bGUiLCJMZWdlbmQiLCJsZWdlbmRIaXRCb3hlcyIsImRvdWdobnV0TW9kZSIsImJlZm9yZUJ1aWxkTGFiZWxzIiwiYnVpbGRMYWJlbHMiLCJhZnRlckJ1aWxkTGFiZWxzIiwibGVnZW5kSXRlbXMiLCJnbG9iYWxEZWZhdWx0IiwibGFiZWxGb250IiwiaGl0Ym94ZXMiLCJsaW5lV2lkdGhzIiwidG90YWxIZWlnaHQiLCJ2UGFkZGluZyIsImNvbHVtbldpZHRocyIsInRvdGFsV2lkdGgiLCJjdXJyZW50Q29sV2lkdGgiLCJjdXJyZW50Q29sSGVpZ2h0IiwiaXRlbUhlaWdodCIsIml0ZW1XaWR0aCIsImxpbmVEZWZhdWx0IiwibGVnZW5kV2lkdGgiLCJkcmF3TGVnZW5kQm94IiwiaXNMaW5lV2lkdGhaZXJvIiwib2ZmU2V0IiwiaGFsZkZvbnRTaXplIiwieExlZnQiLCJ5TWlkZGxlIiwibGgiLCJoaXRCb3giLCJjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2giLCJsZWdlbmRPcHRzIiwiYmVmb3JlSW5pdCIsImFmdGVyRXZlbnQiLCJUaXRsZSIsImxpbmVDb3VudCIsInRleHRTaXplIiwidGl0bGVGb250IiwidGl0bGVYIiwidGl0bGVZIiwiY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaCIsInRpdGxlT3B0cyIsInRpdGxlQmxvY2siLCJkZWZhdWx0Q29uZmlnIiwiRGF0YXNldFNjYWxlIiwiZ2V0TGFiZWxzIiwieExhYmVscyIsInlMYWJlbHMiLCJtaW5JbmRleCIsIm1heEluZGV4Iiwib2Zmc2V0QW10IiwidmFsdWVDYXRlZ29yeSIsInZhbHVlV2lkdGgiLCJ3aWR0aE9mZnNldCIsInZhbHVlSGVpZ2h0IiwiaGVpZ2h0T2Zmc2V0IiwiaG9yeiIsInZhbHVlRGltZW5zaW9uIiwiTGluZWFyU2NhbGUiLCJMaW5lYXJTY2FsZUJhc2UiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwiSURNYXRjaGVzIiwiaGFzU3RhY2tzIiwidmFsdWVzUGVyU3RhY2siLCJwb3NpdGl2ZVZhbHVlcyIsIm5lZ2F0aXZlVmFsdWVzIiwicmVsYXRpdmVQb2ludHMiLCJ2YWx1ZXNGb3JUeXBlIiwibWluVmFsIiwibWF4VmFsIiwiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsImdldFRpY2tMaW1pdCIsInRpY2tGb250U2l6ZSIsImhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcyIsImlubmVyRGltZW5zaW9uIiwidGlja3NBc051bWJlcnMiLCJtaW5TaWduIiwibWF4U2lnbiIsInNldE1pbiIsInN1Z2dlc3RlZE1pbiIsInNldE1heCIsInN1Z2dlc3RlZE1heCIsIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwiZml4ZWRTdGVwU2l6ZSIsIkxvZ2FyaXRobWljU2NhbGUiLCJ0aWNrVmFsdWVzIiwibmV3VmFsIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nWSIsImJhY2tkcm9wUGFkZGluZ1giLCJnZXRWYWx1ZUNvdW50IiwiZ2V0UG9pbnRMYWJlbEZvbnRPcHRpb25zIiwicG9pbnRMYWJlbE9wdGlvbnMiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwicGxGb250IiwibGFyZ2VzdFBvc3NpYmxlUmFkaXVzIiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsIl9wb2ludExhYmVsU2l6ZXMiLCJ2YWx1ZUNvdW50IiwiZ2V0UG9pbnRQb3NpdGlvbiIsImdldEluZGV4QW5nbGUiLCJoTGltaXRzIiwidkxpbWl0cyIsInNldFJlZHVjdGlvbnMiLCJkcmF3aW5nQXJlYSIsInNldENlbnRlclBvaW50IiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJhbmdsZUxpbmVPcHRzIiwicG9pbnRMYWJlbE9wdHMiLCJvdXRlckRpc3RhbmNlIiwib3V0ZXJQb3NpdGlvbiIsInBvaW50TGFiZWxQb3NpdGlvbiIsInBvaW50TGFiZWxGb250Q29sb3IiLCJkcmF3UmFkaXVzTGluZSIsIm51bWJlck9yWmVybyIsInBhcmFtIiwiTGluZWFyUmFkaWFsU2NhbGUiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInN0YXJ0QW5nbGVSYWRpYW5zIiwic2NhbGluZ0ZhY3RvciIsImRpc3RhbmNlRnJvbUNlbnRlciIsInRoaXNBbmdsZSIsInRpY2tGb250U3R5bGUiLCJ0aWNrRm9udEZhbWlseSIsInRpY2tMYWJlbEZvbnQiLCJ5Q2VudGVyT2Zmc2V0IiwibW9tZW50IiwiTUlOX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiSU5URVJWQUxTIiwibWlsbGlzZWNvbmQiLCJzdGVwcyIsIndlZWsiLCJxdWFydGVyIiwiVU5JVFMiLCJzb3J0ZXIiLCJhcnJheVVuaXF1ZSIsIm91dCIsImJ1aWxkTG9va3VwVGFibGUiLCJ0aW1lc3RhbXBzIiwiZGlzdHJpYnV0aW9uIiwidGFibGUiLCJsb29rdXAiLCJsbyIsIm1pZCIsImkwIiwiaTEiLCJza2V5IiwidGtleSIsIm1vbWVudGlmeSIsInBhcnNlciIsInN0YXJ0T2YiLCJ2YWx1ZU9mIiwiZGV0ZXJtaW5lU3RlcFNpemUiLCJjYXBhY2l0eSIsIm1pbGxpc2Vjb25kcyIsImZhY3RvciIsImRldGVybWluZVVuaXQiLCJtaW5Vbml0IiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwiZ2VuZXJhdGUiLCJ0aW1lT3B0cyIsInVuaXRTdGVwU2l6ZSIsIndlZWtkYXkiLCJpc29XZWVrZGF5IiwibWFqb3JUaWNrc0VuYWJsZWQiLCJjb21wdXRlT2Zmc2V0cyIsInVwcGVyIiwibG93ZXIiLCJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwibWFqb3JVbml0IiwiZGlzcGxheUZvcm1hdCIsImRpc3BsYXlGb3JtYXRzIiwiVGltZVNjYWxlIiwidGltZXN0YW1wIiwiZW5kT2YiLCJfaG9yaXpvbnRhbCIsIl90YWJsZSIsIl90aW1lc3RhbXBzIiwiZm9ybWF0cyIsImdldExhYmVsQ2FwYWNpdHkiLCJfdW5pdCIsIl9tYWpvclVuaXQiLCJfbWlub3JGb3JtYXQiLCJfbWFqb3JGb3JtYXQiLCJ0b29sdGlwRm9ybWF0IiwidGlja0Zvcm1hdEZ1bmN0aW9uIiwibWFqb3JGb3JtYXQiLCJtYWpvclRpbWUiLCJtYWpvclRpY2tPcHRzIiwiZm9ybWF0dGVyIiwiZ2V0UGl4ZWxGb3JPZmZzZXQiLCJnZXRMYWJlbFdpZHRoIiwidGlja3NPcHRzIiwidGlja0xhYmVsV2lkdGgiLCJleGFtcGxlVGltZSIsImV4YW1wbGVMYWJlbCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxzQ0FBc0M7QUFDOUMsUUFBUTtBQUNSLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUF1RDtBQUM5RTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhCQUE4QjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsY0FBYyxXQUFXO0FBQ3hFLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0Esc0JBQXNCLGNBQWMsc0JBQXNCLGdCQUFnQjtBQUMxRSxnQkFBZ0IsV0FBVyxZQUFZO0FBQ3ZDLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Is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Q0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFDRjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUMzblVEO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQSxDQUFDOzs7Ozs7OztBQ2hCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQzVDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7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Q0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QyxFQUFFOztBQUVGO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QyxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFF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OztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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RUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN2a0VEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNB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QUM7Ozs7Ozs7O0FDL3VCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QXNELEdBQUcsR0FBRyx1QkFBdUIsWUFBWSxRQUFRLDBGQUEwRixlQUFlLG1oQkFBbWhCLEdBQUcsdUJBQXVCLFVBQVUsbUJBQW1CLGdGQUFnRixjQUFjLDBEQUEwRCxjQUFjLE1BQU0sOERBQThELGNBQWMsNkJBQTZCLGdCQUFnQixZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUEscUdBQXVILGE7Ozs7Ozs7QUNMOTlIO0FBQ0EiLCJmaWxlIjoiL2pzL3ZlbmRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDU3KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAwMmE5NmM2NDYyYzU1ZTA0YTIyNCIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE4LTAxLTIwVDE3OjI0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBub2RlWyBpIF0gKSB7XG5cdFx0XHRcdFx0c2NyaXB0WyBpIF0gPSBub2RlWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjMuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jLCBub2RlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgXCJhYnNvbHV0ZVwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuXHRpZiAoICFyZXQgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblx0XHQpICk7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3g7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHR2YWx1ZUlzQm9yZGVyQm94ID0gdmFsdWVJc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gKTtcblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0aWYgKCB2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSB7XG5cblx0XHR2YWwgPSBlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF07XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgcHJvdmlkZSBib3JkZXItYm94IHZhbHVlc1xuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgPT09IHN0eWxlcy5wb3NpdGlvbiApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IERhdGUubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIoIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59ICggZnVuY3Rpb24oICQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG5yZXR1cm4gJC51aS52ZXJzaW9uID0gXCIxLjEyLjFcIjtcblxufSApICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvdmVyc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSA3IiwiLyohXG4gKiBqUXVlcnkgVUkgS2V5Y29kZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogS2V5Y29kZVxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFByb3ZpZGUga2V5Y29kZXMgYXMga2V5bmFtZXNcbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkudWkua2V5Q29kZS9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSAoIGZ1bmN0aW9uKCAkICkge1xucmV0dXJuICQudWkua2V5Q29kZSA9IHtcblx0QkFDS1NQQUNFOiA4LFxuXHRDT01NQTogMTg4LFxuXHRERUxFVEU6IDQ2LFxuXHRET1dOOiA0MCxcblx0RU5EOiAzNSxcblx0RU5URVI6IDEzLFxuXHRFU0NBUEU6IDI3LFxuXHRIT01FOiAzNixcblx0TEVGVDogMzcsXG5cdFBBR0VfRE9XTjogMzQsXG5cdFBBR0VfVVA6IDMzLFxuXHRQRVJJT0Q6IDE5MCxcblx0UklHSFQ6IDM5LFxuXHRTUEFDRTogMzIsXG5cdFRBQjogOSxcblx0VVA6IDM4XG59O1xuXG59ICkgKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9rZXljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIvKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFdpZGdldFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgc3RhdGVmdWwgd2lkZ2V0cyB3aXRoIGEgY29tbW9uIEFQSS5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3dpZGdldC9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSggZnVuY3Rpb24oICQgKSB7XG5cbnZhciB3aWRnZXRVdWlkID0gMDtcbnZhciB3aWRnZXRTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuJC5jbGVhbkRhdGEgPSAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBldmVudHMsIGVsZW0sIGk7XG5cdFx0Zm9yICggaSA9IDA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdC8vIE9ubHkgdHJpZ2dlciByZW1vdmUgd2hlbiBuZWNlc3NhcnkgdG8gc2F2ZSB0aW1lXG5cdFx0XHRcdGV2ZW50cyA9ICQuX2RhdGEoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHRcdFx0aWYgKCBldmVudHMgJiYgZXZlbnRzLnJlbW92ZSApIHtcblx0XHRcdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIdHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0fVxuXHRcdG9yaWcoIGVsZW1zICk7XG5cdH07XG59ICkoICQuY2xlYW5EYXRhICk7XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlO1xuXG5cdC8vIFByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0dmFyIHByb3hpZWRQcm90b3R5cGUgPSB7fTtcblxuXHR2YXIgbmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHR2YXIgZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0aWYgKCAkLmlzQXJyYXkoIHByb3RvdHlwZSApICkge1xuXHRcdHByb3RvdHlwZSA9ICQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIHt9IF0uY29uY2F0KCBwcm90b3R5cGUgKSApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gRXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXG5cdFx0Ly8gQ29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblxuXHRcdC8vIFRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9ICk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cblx0Ly8gV2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggISQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuY3Rpb24gX3N1cGVyKCkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIF9zdXBlckFwcGx5KCBhcmdzICkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXI7XG5cdFx0XHRcdHZhciBfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5O1xuXHRcdFx0XHR2YXIgcmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9ICkoKTtcblx0fSApO1xuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoIGJhc2VQcm90b3R5cGUsIHtcblxuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/ICggYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCB8fCBuYW1lICkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSApO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gUmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLFxuXHRcdFx0XHRjaGlsZC5fcHJvdG8gKTtcblx0XHR9ICk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xuXG5cdHJldHVybiBjb25zdHJ1Y3Rvcjtcbn07XG5cbiQud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdHZhciBpbnB1dCA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHR2YXIgaW5wdXRJbmRleCA9IDA7XG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0dmFyIGtleTtcblx0dmFyIHZhbHVlO1xuXG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIENsb25lIG9iamVjdHNcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9ICQuaXNQbGFpbk9iamVjdCggdGFyZ2V0WyBrZXkgXSApID9cblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHRhcmdldFsga2V5IF0sIHZhbHVlICkgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiO1xuXHRcdHZhciBhcmdzID0gd2lkZ2V0U2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGVtcHR5IGNvbGxlY3Rpb24sIHdlIG5lZWQgdG8gaGF2ZSB0aGUgaW5zdGFuY2UgbWV0aG9kXG5cdFx0XHQvLyByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgdGhlIGpRdWVyeSBpbnN0YW5jZVxuXHRcdFx0aWYgKCAhdGhpcy5sZW5ndGggJiYgb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblxuXHRcdFx0XHRcdGlmICggb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBpbnN0YW5jZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVsgb3B0aW9ucyBdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdFx0aWYgKCBhcmdzLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KCBhcmdzICkgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyB8fCB7fSApO1xuXHRcdFx0XHRcdGlmICggaW5zdGFuY2UuX2luaXQgKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5faW5pdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcbn07XG5cbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcbiQuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdO1xuXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XG5cdHdpZGdldE5hbWU6IFwid2lkZ2V0XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcIlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRjbGFzc2VzOiB7fSxcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB3aWRnZXRVdWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblx0XHR0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwID0ge307XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblxuXHRcdFx0XHQvLyBFbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFsgMCBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbIDAgXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblxuXHRfY3JlYXRlOiAkLm5vb3AsXG5cblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0JC5lYWNoKCB0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCB2YWx1ZSwga2V5ICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gV2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIENsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0fSxcblxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5O1xuXHRcdHZhciBwYXJ0cztcblx0XHR2YXIgY3VyT3B0aW9uO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHQvLyBEb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJjbGFzc2VzXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25DbGFzc2VzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uQ2xhc3NlczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc0tleSwgZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50cztcblxuXHRcdGZvciAoIGNsYXNzS2V5IGluIHZhbHVlICkge1xuXHRcdFx0Y3VycmVudEVsZW1lbnRzID0gdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cFsgY2xhc3NLZXkgXTtcblx0XHRcdGlmICggdmFsdWVbIGNsYXNzS2V5IF0gPT09IHRoaXMub3B0aW9ucy5jbGFzc2VzWyBjbGFzc0tleSBdIHx8XG5cdFx0XHRcdFx0IWN1cnJlbnRFbGVtZW50cyB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgYXJlIGRvaW5nIHRoaXMgdG8gY3JlYXRlIGEgbmV3IGpRdWVyeSBvYmplY3QgYmVjYXVzZSB0aGUgX3JlbW92ZUNsYXNzKCkgY2FsbFxuXHRcdFx0Ly8gb24gdGhlIG5leHQgbGluZSBpcyBnb2luZyB0byBkZXN0cm95IHRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZWxlbWVudHMgYmVpbmdcblx0XHRcdC8vIHRyYWNrZWQuIFdlIG5lZWQgdG8gc2F2ZSBhIGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCB0aGUgbmV3IGNsYXNzZXNcblx0XHRcdC8vIGJlbG93LlxuXHRcdFx0ZWxlbWVudHMgPSAkKCBjdXJyZW50RWxlbWVudHMuZ2V0KCkgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50RWxlbWVudHMsIGNsYXNzS2V5ICk7XG5cblx0XHRcdC8vIFdlIGRvbid0IHVzZSBfYWRkQ2xhc3MoKSBoZXJlLCBiZWNhdXNlIHRoYXQgdXNlcyB0aGlzLm9wdGlvbnMuY2xhc3Nlc1xuXHRcdFx0Ly8gZm9yIGdlbmVyYXRpbmcgdGhlIHN0cmluZyBvZiBjbGFzc2VzLiBXZSB3YW50IHRvIHVzZSB0aGUgdmFsdWUgcGFzc2VkIGluIGZyb21cblx0XHRcdC8vIF9zZXRPcHRpb24oKSwgdGhpcyBpcyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBjbGFzc2VzIG9wdGlvbiB3aGljaCB3YXMgcGFzc2VkIHRvXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCkuIFdlIHBhc3MgdGhpcyB2YWx1ZSBkaXJlY3RseSB0byBfY2xhc3NlcygpLlxuXHRcdFx0ZWxlbWVudHMuYWRkQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudHMsXG5cdFx0XHRcdGtleXM6IGNsYXNzS2V5LFxuXHRcdFx0XHRjbGFzc2VzOiB2YWx1ZSxcblx0XHRcdFx0YWRkOiB0cnVlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0KCksIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZFwiLCBudWxsLCAhIXZhbHVlICk7XG5cblx0XHQvLyBJZiB0aGUgd2lkZ2V0IGlzIGJlY29taW5nIGRpc2FibGVkLCB0aGVuIG5vdGhpbmcgaXMgaW50ZXJhY3RpdmVcblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaG92ZXJhYmxlLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmZvY3VzYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IGZhbHNlIH0gKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyggeyBkaXNhYmxlZDogdHJ1ZSB9ICk7XG5cdH0sXG5cblx0X2NsYXNzZXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBmdWxsID0gW107XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7XG5cdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRjbGFzc2VzOiB0aGlzLm9wdGlvbnMuY2xhc3NlcyB8fCB7fVxuXHRcdH0sIG9wdGlvbnMgKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NDbGFzc1N0cmluZyggY2xhc3NlcywgY2hlY2tPcHRpb24gKSB7XG5cdFx0XHR2YXIgY3VycmVudCwgaTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Y3VycmVudCA9IHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdIHx8ICQoKTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmFkZCApIHtcblx0XHRcdFx0XHRjdXJyZW50ID0gJCggJC51bmlxdWUoIGN1cnJlbnQuZ2V0KCkuY29uY2F0KCBvcHRpb25zLmVsZW1lbnQuZ2V0KCkgKSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoIGN1cnJlbnQubm90KCBvcHRpb25zLmVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdID0gY3VycmVudDtcblx0XHRcdFx0ZnVsbC5wdXNoKCBjbGFzc2VzWyBpIF0gKTtcblx0XHRcdFx0aWYgKCBjaGVja09wdGlvbiAmJiBvcHRpb25zLmNsYXNzZXNbIGNsYXNzZXNbIGkgXSBdICkge1xuXHRcdFx0XHRcdGZ1bGwucHVzaCggb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fb24oIG9wdGlvbnMuZWxlbWVudCwge1xuXHRcdFx0XCJyZW1vdmVcIjogXCJfdW50cmFja0NsYXNzZXNFbGVtZW50XCJcblx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMua2V5cyApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5rZXlzLm1hdGNoKCAvXFxTKy9nICkgfHwgW10sIHRydWUgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmV4dHJhICkge1xuXHRcdFx0cHJvY2Vzc0NsYXNzU3RyaW5nKCBvcHRpb25zLmV4dHJhLm1hdGNoKCAvXFxTKy9nICkgfHwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVsbC5qb2luKCBcIiBcIiApO1xuXHR9LFxuXG5cdF91bnRyYWNrQ2xhc3Nlc0VsZW1lbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0JC5lYWNoKCB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdGlmICggJC5pbkFycmF5KCBldmVudC50YXJnZXQsIHZhbHVlICkgIT09IC0xICkge1xuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBrZXkgXSA9ICQoIHZhbHVlLm5vdCggZXZlbnQudGFyZ2V0ICkuZ2V0KCkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X3JlbW92ZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgZmFsc2UgKTtcblx0fSxcblxuXHRfYWRkQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBrZXlzLCBleHRyYSApIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3MoIGVsZW1lbnQsIGtleXMsIGV4dHJhLCB0cnVlICk7XG5cdH0sXG5cblx0X3RvZ2dsZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEsIGFkZCApIHtcblx0XHRhZGQgPSAoIHR5cGVvZiBhZGQgPT09IFwiYm9vbGVhblwiICkgPyBhZGQgOiBleHRyYTtcblx0XHR2YXIgc2hpZnQgPSAoIHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiIHx8IGVsZW1lbnQgPT09IG51bGwgKSxcblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGV4dHJhOiBzaGlmdCA/IGtleXMgOiBleHRyYSxcblx0XHRcdFx0a2V5czogc2hpZnQgPyBlbGVtZW50IDoga2V5cyxcblx0XHRcdFx0ZWxlbWVudDogc2hpZnQgPyB0aGlzLmVsZW1lbnQgOiBlbGVtZW50LFxuXHRcdFx0XHRhZGQ6IGFkZFxuXHRcdFx0fTtcblx0XHRvcHRpb25zLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIG9wdGlvbnMgKSwgYWRkICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50O1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBObyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXG5cdFx0XHRcdC8vIEFsbG93IHdpZGdldHMgdG8gY3VzdG9taXplIHRoZSBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGFzIGFuIGFycmF5IGluc3RlYWQgb2YgYm9vbGVhblxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcblx0XHRcdFx0aWYgKCAhc3VwcHJlc3NEaXNhYmxlZENoZWNrICYmXG5cdFx0XHRcdFx0XHQoIGluc3RhbmNlLm9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFtcXHc6LV0qKVxccyooLiopJC8gKTtcblx0XHRcdHZhciBldmVudE5hbWUgPSBtYXRjaFsgMSBdICsgaW5zdGFuY2UuZXZlbnROYW1lc3BhY2U7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQub24oIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5vbiggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoIGV2ZW50TmFtZSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgK1xuXHRcdFx0dGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50Lm9mZiggZXZlbnROYW1lICkub2ZmKCBldmVudE5hbWUgKTtcblxuXHRcdC8vIENsZWFyIHRoZSBzdGFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1Nilcblx0XHR0aGlzLmJpbmRpbmdzID0gJCggdGhpcy5iaW5kaW5ncy5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCggdGhpcy5mb2N1c2FibGUubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoIHRoaXMuaG92ZXJhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fSxcblx0XHRcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXNvdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWc7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIFRoZSBvcmlnaW5hbCBldmVudCBtYXkgY29tZSBmcm9tIGFueSBlbGVtZW50XG5cdFx0Ly8gc28gd2UgbmVlZCB0byByZXNldCB0aGUgdGFyZ2V0IG9uIHRoZSBuZXcgZXZlbnRcblx0XHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbIDAgXTtcblxuXHRcdC8vIENvcHkgb3JpZ2luYWwgZXZlbnQgcHJvcGVydGllcyBvdmVyIHRvIHRoZSBuZXcgZXZlbnRcblx0XHRvcmlnID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoIG9yaWcgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGlmICggISggcHJvcCBpbiBldmVudCApICkge1xuXHRcdFx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggZXZlbnQsIGRhdGEgKTtcblx0XHRyZXR1cm4gISggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICYmXG5cdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcy5lbGVtZW50WyAwIF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIGhhc09wdGlvbnM7XG5cdFx0dmFyIGVmZmVjdE5hbWUgPSAhb3B0aW9ucyA/XG5cdFx0XHRtZXRob2QgOlxuXHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdGRlZmF1bHRFZmZlY3QgOlxuXHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNPcHRpb25zICYmICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBtZXRob2QgXSggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIGVmZmVjdE5hbWUgIT09IG1ldGhvZCAmJiBlbGVtZW50WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBlZmZlY3ROYW1lIF0oIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnF1ZXVlKCBmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbnJldHVybiAkLndpZGdldDtcblxufSApICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCJ3aW5kb3cuJCA9IHdpbmRvdy5qUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuXG4vLyBEYXRlcGlja2VyXG5yZXF1aXJlKFwianF1ZXJ5LXVpL3VpL3dpZGdldHMvZGF0ZXBpY2tlclwiKTtcblxuLy8gVGltZXBpY2tlclxucmVxdWlyZShcImpxdWVyeS11aS91aS93aWRnZXRzL3NsaWRlclwiKTtcbnJlcXVpcmUoXCIuL2pxdWVyeS11aS10aW1lcGlja2VyLWFkZG9uXCIpO1xuXG4vLyBCb290c3RyYXBcbndpbmRvdy5Qb3BwZXIgPSByZXF1aXJlKFwiLi9wb3BwZXJcIik7XG5yZXF1aXJlKFwiLi9ib290c3RyYXBcIik7XG5yZXF1aXJlKFwiLi9ib290c3RyYXAtc2VsZWN0XCIpO1xuXG4vLyBNZXRyaWNzXG5yZXF1aXJlKFwiLi9jaGFydC5qc1wiKTtcblxuLy8gVHVyYm9saW5rc1xud2luZG93LlR1cmJvbGlua3MgPSByZXF1aXJlKFwidHVyYm9saW5rc1wiKTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg0MDc3NzEvMjk1NzY3N1xuLy8gTW9kaWZpZWQgYnkgLzE1NDk4MTggdG8gc3VwcG9ydCBkb3Qgbm90YXRpb25cbihmdW5jdGlvbigkKXtcblx0JC5mbi5zZXJpYWxpemVPYmplY3QgPSBmdW5jdGlvbihzaG91bGRWYWxpZGF0ZSA9IGZhbHNlKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0anNvbiA9IHt9LFxuXHRcdFx0cHVzaF9jb3VudGVycyA9IHt9LFxuXHRcdFx0cGF0dGVybnMgPSB7XG5cdFx0XHRcdFwidmFsaWRhdGVcIjogL15bYS16QS1aXVthLXpBLVowLTlfXSooPzpbXFxbXFwuXSg/OlxcZCp8W2EtekEtWjAtOV9dKylbXFxdXT8pKiQvLFxuXHRcdFx0XHRcImtleVwiOiAgICAgIC9bYS16QS1aMC05X10rfCg/PVxcW1xcXSkvZyxcblx0XHRcdFx0XCJwdXNoXCI6ICAgICAvXiQvLFxuXHRcdFx0XHRcImZpeGVkXCI6ICAgIC9eXFxkKyQvLFxuXHRcdFx0XHRcIm5hbWVkXCI6ICAgIC9eW2EtekEtWjAtOV9dKyQvXG5cdFx0XHR9LFxuXHRcdFx0aXNWYWxpZCA9IHRydWUsXG5cdFx0XHQkZmllbGRzID0gJCh0aGlzKS5maW5kKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpLm5vdCgnaW5wdXRbdHlwZT1yYWRpb106bm90KDpjaGVja2VkKScpOyAvLyBmaWx0ZXJzIG91dCBub24tY2hlY2tlZCByYWRpbyBmaWVsZHNcblxuXHRcdHRoaXMuYnVpbGQgPSBmdW5jdGlvbihiYXNlLCBrZXksIHZhbHVlKSB7XG5cdFx0XHRiYXNlW2tleV0gPSB2YWx1ZTtcblx0XHRcdHJldHVybiBiYXNlO1xuXHRcdH07XG5cblx0XHR0aGlzLnB1c2hfY291bnRlciA9IGZ1bmN0aW9uKGtleSl7XG5cdFx0XHRpZiAocHVzaF9jb3VudGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHVzaF9jb3VudGVyc1trZXldID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHB1c2hfY291bnRlcnNba2V5XSsrO1xuXHRcdH07XG5cblx0XHRpZiAoc2hvdWxkVmFsaWRhdGUpIHtcblx0XHRcdCQoJy5pbnZhbGlkLWZlZWRiYWNrJykucmVtb3ZlKCk7XG5cdFx0XHQkKCcuaXMtdmFsaWQsIC5pcy1pbnZhbGlkLCAuY2FyZC1oZWFkZXIucmVkLWhpZ2hsaWdodCwgLmNhcmQtaGVhZGVyLmdyZWVuLWhpZ2hsaWdodCcpLnJlbW92ZUNsYXNzKCdpcy12YWxpZCBpcy1pbnZhbGlkIHJlZC1oaWdobGlnaHQgZ3JlZW4taGlnaGxpZ2h0Jyk7XG5cdFx0XG5cdFx0XHRjbGVhclRpbWVvdXQodmFsaWRhdGlvblRpbWVvdXQpO1xuXG5cdFx0XHR2YWxpZGF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoJy5pcy12YWxpZCwgLmlzLWludmFsaWQsIC5jYXJkLWhlYWRlci5yZWQtaGlnaGxpZ2h0LCAuY2FyZC1oZWFkZXIuZ3JlZW4taGlnaGxpZ2h0JykucmVtb3ZlQ2xhc3MoJ2lzLXZhbGlkIGlzLWludmFsaWQgcmVkLWhpZ2hsaWdodCBncmVlbi1oaWdobGlnaHQnKTtcblx0XHRcdFx0JCgnLmludmFsaWQtZmVlZGJhY2snKS5mYWRlT3V0KDI1MCwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5yZW1vdmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAxNTAwMCk7XG5cdFx0fVxuXG5cdFx0JGZpZWxkcy5ub3QoJzpkaXNhYmxlZCcpLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdC8vIHNraXAgaW52YWxpZCBrZXlzXG5cdFx0XHRpZiAoIXBhdHRlcm5zLnZhbGlkYXRlLnRlc3QodGhpcy5uYW1lKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrLFxuXHRcdFx0XHRrZXlzID0gdGhpcy5uYW1lLm1hdGNoKHBhdHRlcm5zLmtleSksXG5cdFx0XHRcdG1lcmdlID0gdGhpcy52YWx1ZSxcblx0XHRcdFx0cmV2ZXJzZV9rZXkgPSB0aGlzLm5hbWUsXG5cdFx0XHRcdHZhbGlkYXRpb25fcnVsZXMgPSB0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoJ3ZhbGlkYXRpb24nKSA/IHRoaXMuYXR0cmlidXRlcy52YWxpZGF0aW9uLnZhbHVlIDogbnVsbDtcblxuXHRcdFx0aWYgKHNob3VsZFZhbGlkYXRlICYmIHZhbGlkYXRpb25fcnVsZXMgIT09IG51bGwpIHtcblx0XHRcdFx0dmFyIHJlc3BvbnNlID0gJCh0aGlzKS52YWxpZGF0ZSgpO1xuXG5cdFx0XHRcdGlmIChpc1ZhbGlkKSB7XG5cdFx0XHRcdFx0aXNWYWxpZCA9IHJlc3BvbnNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICgoayA9IGtleXMucG9wKCkpICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHQvLyBhZGp1c3QgcmV2ZXJzZV9rZXlcblx0XHRcdFx0cmV2ZXJzZV9rZXkgPSByZXZlcnNlX2tleS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcW1wiICsgayArIFwiXFxcXF0kXCIpLCAnJyk7XG5cblx0XHRcdFx0Ly8gcHVzaFxuXHRcdFx0XHRpZiAoay5tYXRjaChwYXR0ZXJucy5wdXNoKSkge1xuXHRcdFx0XHRcdG1lcmdlID0gc2VsZi5idWlsZCh7fSwgc2VsZi5wdXNoX2NvdW50ZXIocmV2ZXJzZV9rZXkpLCBtZXJnZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaXhlZCBvciBuYW1lZFxuXHRcdFx0XHRlbHNlIGlmIChrLm1hdGNoKHBhdHRlcm5zLmZpeGVkKSB8fCBrLm1hdGNoKHBhdHRlcm5zLm5hbWVkKSkge1xuXHRcdFx0XHRcdG1lcmdlID0gc2VsZi5idWlsZCh7fSwgaywgbWVyZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGpzb24gPSAkLmV4dGVuZCh0cnVlLCBqc29uLCBtZXJnZSk7XG5cdFx0fSk7XG5cblx0XHRqc29uLmlzVmFsaWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpc1ZhbGlkO1xuXHRcdH07XG5cblx0XHRpZiAoc2hvdWxkVmFsaWRhdGUpIHtcblx0XHRcdCQodGhpcykuZmluZCgnLmNhcmQ6bm90KC5leGlzdGluZykgLmlzLXZhbGlkJykuY2xvc2VzdCgnLmNhcmQnKS5maW5kKCcuY2FyZC1oZWFkZXInKS5hZGRDbGFzcygnZ3JlZW4taGlnaGxpZ2h0Jyk7IC8vIGhpZ2hsaWdodCBhbGwgY2FyZHMgZ3JlZW4gZmlyc3Rcblx0XHRcdCQodGhpcykuZmluZCgnLmNhcmQ6bm90KC5leGlzdGluZykgLmlzLWludmFsaWQnKS5jbG9zZXN0KCcuY2FyZCcpLmZpbmQoJy5jYXJkLWhlYWRlcicpLnJlbW92ZUNsYXNzKCdncmVlbi1oaWdobGlnaHQnKS5hZGRDbGFzcygncmVkLWhpZ2hsaWdodCcpOyAvLyBoaWdobGlnaHQgYW55IGNhcmRzIHdpdGggZXJyb3JzIGluIHRoZW1cblx0XHRcdFxuXHRcdFx0Ly8gb3BlbiBhY2NvcmRpb24gd2l0aCBlcnJvclxuXHRcdFx0aWYgKCQodGhpcykuZmluZCgnLnZpZXctYWNjb3JkaW9uLmZhLWNoZXZyb24tZG93bicpLmZpcnN0KCkuY2xvc2VzdCgnLmNhcmQtaGVhZGVyLmdyZWVuLWhpZ2hsaWdodCcpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHQkKHRoaXMpLmZpbmQoJy5jYXJkLWhlYWRlci5yZWQtaGlnaGxpZ2h0IC52aWV3LWFjY29yZGlvbicpLmNsaWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpzb247XG5cdH07XG5cblx0JC5mbi52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciAkdGhpcyAgICAgICAgICAgPSAkKHRoaXMpLFxuXHRcdFx0dmFsdWUgICAgICAgICAgID0gJHRoaXMudmFsKCksXG5cdFx0XHR2YWxpZGF0aW9uUnVsZXMgPSAkdGhpcy5hdHRyKCd2YWxpZGF0aW9uJykuc3BsaXQoJ3wnKSxcblx0XHRcdGZhaWxlZFJ1bGVzICAgICA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZGF0aW9uUnVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBydWxlID0gdmFsaWRhdGlvblJ1bGVzW2ldO1xuXG5cdFx0XHRzd2l0Y2ggKHJ1bGUpIHtcblx0XHRcdFx0Y2FzZSBcIm51bGxhYmxlXCI6XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuXHRcdFx0XHRcdFx0dmFsaWRhdGlvblJ1bGVzID0gW107IC8vIGJyZWFrIG91dCBvZiBmb3Jcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAocnVsZS5tYXRjaCgvcmVxdWlyZWQvKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuXHRcdFx0XHRcdFx0aWYgKHJ1bGUuc3BsaXQoJzonKS5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0ZmFpbGVkUnVsZXMucHVzaCgnVGhpcyBmaWVsZCBpcyByZXF1aXJlZC4nKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2gocnVsZS5zcGxpdCgnOicpWzFdKTsgLy8gY3VzdG9tIG1lc3NhZ2UgY2FuIGJlIGF0dGFjaGVkIHRvIHJlcXVpcmVkXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhbGlkYXRpb25SdWxlcyA9IFtdOyAvLyBicmVhayBvdXQgb2YgZm9yXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJpbnRlZ2VyXCI6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgKGlzTmFOKHBhcnNlSW50KHZhbHVlKSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBiZSBhbiB3aG9sZSBudW1iZXIuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgKHJ1bGUubWF0Y2goL21heDovKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUubGVuZ3RoID4gTnVtYmVyKHJ1bGUuc3BsaXQoJzonKVsxXSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBoYXZlIGxlc3MgdGhhbiAnICsgKE51bWJlcihydWxlLnNwbGl0KCc6JylbMV0pICsgMSkgKyAnIGNoYXJhY3RlcnMuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgKHJ1bGUubWF0Y2goL21pbjovKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA8IE51bWJlcihydWxlLnNwbGl0KCc6JylbMV0pKSB7XG5cdFx0XHRcdFx0XHRmYWlsZWRSdWxlcy5wdXNoKCdUaGlzIGZpZWxkIG11c3QgaGF2ZSBhdCBsZWFzdCAnICsgcnVsZS5zcGxpdCgnOicpWzFdICsgJyBjaGFyYWN0ZXJzLicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIChydWxlLm1hdGNoKC9pbjovKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgKHJ1bGUuc3BsaXQoJzonKVsxXS5zcGxpdCgnLCcpLmluZGV4T2YodmFsdWUpID09PSAtMSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBjb250YWluIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAnICsgcnVsZS5zcGxpdCgnOicpWzFdLnNwbGl0KCcsJykgKyAnLicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIChydWxlLm1hdGNoKC9ub3Q6LykgfHwge30pLmlucHV0OlxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gcnVsZS5zcGxpdCgnOicpWzFdLnNwbGl0KC8nLylbMV0pIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgaGFzIGFuIGludmFsaWQgdmFsdWUuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgKHJ1bGUubWF0Y2goL3JlcXVpcmVzOi8pIHx8IHt9KS5pbnB1dDpcblx0XHRcdFx0XHRpZiAoJHRoaXMuY2xvc2VzdCgnZm9ybScpLmZpbmQoJ2lucHV0W25hbWU9XCInICsgcnVsZS5zcGxpdCgnOicpWzFdICsgJ1wiXScpLnZhbCgpID09PSAnJykge1xuXHRcdFx0XHRcdFx0ZmFpbGVkUnVsZXMucHVzaCgnVGhpcyBmaWVsZCBpcyByZXF1aXJlZC4nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImVtYWlsXCI6XG5cdFx0XHRcdFx0aWYgKCEvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRmYWlsZWRSdWxlcy5wdXNoKCdUaGlzIGZpZWxkIG11c3QgYmUgYW4gZW1haWwuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwaG9uZVwiOlxuXHRcdFx0XHRcdGlmICghL15bXFwrXT9bKF0/WzAtOV17M31bKV0/Wy1cXHNcXC5dP1swLTldezN9Wy1cXHNcXC5dP1swLTldezQsNn0kL2ltLnRlc3QodmFsdWUucmVwbGFjZSgnICcsICcnKSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBiZSBhIHBob25lIG51bWJlci4nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoJHRoaXMuaXMoJ3NlbGVjdCcpKSB7IC8vIHN0eWxlIHN1cHBvcnQgZm9yIGJvb3RzdHJhcC1zZWxlY3Rcblx0XHRcdGlmICgkdGhpcy5oYXNDbGFzcygnYWRkLWhhcmR3YXJlLWRldmljZScpKSB7XG5cdFx0XHRcdGlmICgkdGhpcy5jbG9zZXN0KCcuYWZmZWN0ZWQtaXRlbXMtc2VjdGlvbicpLmZpbmQoJy5hZmZlY3RlZC1pdGVtcycpLmZpbmQoJ2xpW2RhdGEtdHlwZT1cImhhcmR3YXJlXCJdJykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0ZmFpbGVkUnVsZXMucHVzaCgnQWRkIGF0IGxlYXN0IG9uZSBoYXJkd2FyZSBkZXZpY2UuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0JHRoaXMgPSAkdGhpcy5zaWJsaW5ncygnYnV0dG9uLmRyb3Bkb3duLXRvZ2dsZScpO1xuXHRcdH1cblxuXHRcdGlmIChmYWlsZWRSdWxlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHQkdGhpcy5hZGRDbGFzcygnaXMtaW52YWxpZCcpO1xuXG5cdFx0XHRpZiAoISR0aGlzLnBhcmVudCgpLmlzKCcuYXNzaWduZWQtdG8tb3B0aW9ucycpKSB7XG5cdFx0XHRcdHZhciAkaW52YWxpZEZlZWRiYWNrID0gJCgnPGRpdiBjbGFzcz1cImludmFsaWQtZmVlZGJhY2tcIj4nKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZhaWxlZFJ1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0JGludmFsaWRGZWVkYmFjay5hcHBlbmQoZmFpbGVkUnVsZXNbaV0gKyAoaSA+PSAxID8gJzxiciAvPicgOiAnJykpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JHRoaXMuY2xvc2VzdCgnLmZvcm0tZ3JvdXAnKS5hcHBlbmQoJGludmFsaWRGZWVkYmFjayk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0JHRoaXMuYWRkQ2xhc3MoJ2lzLXZhbGlkJyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn0pKGpRdWVyeSk7XG5cbi8qKlxuICogUmVzb2x2ZSBhIGRvdCBub3RhdGlvbiBwYXRoIHN0cmluZyB0aHJvdWdoIGFuIG9iamVjdFxuICogRnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjIxMjk5NjAvMTU0OTgxOFxuICovXG5PYmplY3QucmVzb2x2ZSA9IGZ1bmN0aW9uKHBhdGgsIG9iaikge1xuXHRyZXR1cm4gcGF0aC5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXJyKSB7XG5cdFx0cmV0dXJuIHByZXYgPyBwcmV2W2N1cnJdIDogdW5kZWZpbmVkO1xuXHR9LCBvYmogfHwgc2VsZik7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvdmVuZG9yLmpzIiwiLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vKiBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnMgKi9cbi8qIVxuICogalF1ZXJ5IFVJIERhdGVwaWNrZXIgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IERhdGVwaWNrZXJcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBEaXNwbGF5cyBhIGNhbGVuZGFyIGZyb20gYW4gaW5wdXQgb3IgaW5saW5lIGZvciBzZWxlY3RpbmcgZGF0ZXMuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZGF0ZXBpY2tlci9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9kYXRlcGlja2VyL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvZGF0ZXBpY2tlci5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG4oIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggW1xuXHRcdFx0XCJqcXVlcnlcIixcblx0XHRcdFwiLi4vdmVyc2lvblwiLFxuXHRcdFx0XCIuLi9rZXljb2RlXCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSggZnVuY3Rpb24oICQgKSB7XG5cbiQuZXh0ZW5kKCAkLnVpLCB7IGRhdGVwaWNrZXI6IHsgdmVyc2lvbjogXCIxLjEyLjFcIiB9IH0gKTtcblxudmFyIGRhdGVwaWNrZXJfaW5zdEFjdGl2ZTtcblxuZnVuY3Rpb24gZGF0ZXBpY2tlcl9nZXRaaW5kZXgoIGVsZW0gKSB7XG5cdHZhciBwb3NpdGlvbiwgdmFsdWU7XG5cdHdoaWxlICggZWxlbS5sZW5ndGggJiYgZWxlbVsgMCBdICE9PSBkb2N1bWVudCApIHtcblxuXHRcdC8vIElnbm9yZSB6LWluZGV4IGlmIHBvc2l0aW9uIGlzIHNldCB0byBhIHZhbHVlIHdoZXJlIHotaW5kZXggaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlclxuXHRcdC8vIFRoaXMgbWFrZXMgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbiBjb25zaXN0ZW50IGFjcm9zcyBicm93c2Vyc1xuXHRcdC8vIFdlYktpdCBhbHdheXMgcmV0dXJucyBhdXRvIGlmIHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWRcblx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHRpZiAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBJRSByZXR1cm5zIDAgd2hlbiB6SW5kZXggaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0Ly8gb3RoZXIgYnJvd3NlcnMgcmV0dXJuIGEgc3RyaW5nXG5cdFx0XHQvLyB3ZSBpZ25vcmUgdGhlIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzIHdpdGggYW4gZXhwbGljaXQgdmFsdWUgb2YgMFxuXHRcdFx0Ly8gPGRpdiBzdHlsZT1cInotaW5kZXg6IC0xMDtcIj48ZGl2IHN0eWxlPVwiei1pbmRleDogMDtcIj48L2Rpdj48L2Rpdj5cblx0XHRcdHZhbHVlID0gcGFyc2VJbnQoIGVsZW0uY3NzKCBcInpJbmRleFwiICksIDEwICk7XG5cdFx0XHRpZiAoICFpc05hTiggdmFsdWUgKSAmJiB2YWx1ZSAhPT0gMCApIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbGVtID0gZWxlbS5wYXJlbnQoKTtcblx0fVxuXG5cdHJldHVybiAwO1xufVxuLyogRGF0ZSBwaWNrZXIgbWFuYWdlci5cbiAgIFVzZSB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MsICQuZGF0ZXBpY2tlciwgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZGF0ZSBwaWNrZXIuXG4gICBTZXR0aW5ncyBmb3IgKGdyb3VwcyBvZikgZGF0ZSBwaWNrZXJzIGFyZSBtYWludGFpbmVkIGluIGFuIGluc3RhbmNlIG9iamVjdCxcbiAgIGFsbG93aW5nIG11bHRpcGxlIGRpZmZlcmVudCBzZXR0aW5ncyBvbiB0aGUgc2FtZSBwYWdlLiAqL1xuXG5mdW5jdGlvbiBEYXRlcGlja2VyKCkge1xuXHR0aGlzLl9jdXJJbnN0ID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgaW5zdGFuY2UgaW4gdXNlXG5cdHRoaXMuX2tleUV2ZW50ID0gZmFsc2U7IC8vIElmIHRoZSBsYXN0IGV2ZW50IHdhcyBhIGtleSBldmVudFxuXHR0aGlzLl9kaXNhYmxlZElucHV0cyA9IFtdOyAvLyBMaXN0IG9mIGRhdGUgcGlja2VyIGlucHV0cyB0aGF0IGhhdmUgYmVlbiBkaXNhYmxlZFxuXHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBwb3B1cCBwaWNrZXIgaXMgc2hvd2luZyAsIGZhbHNlIGlmIG5vdFxuXHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHNob3dpbmcgd2l0aGluIGEgXCJkaWFsb2dcIiwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX21haW5EaXZJZCA9IFwidWktZGF0ZXBpY2tlci1kaXZcIjsgLy8gVGhlIElEIG9mIHRoZSBtYWluIGRhdGVwaWNrZXIgZGl2aXNpb25cblx0dGhpcy5faW5saW5lQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItaW5saW5lXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2FwcGVuZENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWFwcGVuZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgYXBwZW5kIG1hcmtlciBjbGFzc1xuXHR0aGlzLl90cmlnZ2VyQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdHJpZ2dlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlhbG9nQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItZGlhbG9nXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaWFsb2cgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2Rpc2FibGVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaXNhYmxlZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGlzYWJsZWQgY292ZXJpbmcgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLXVuc2VsZWN0YWJsZVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdW5zZWxlY3RhYmxlIGNlbGwgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2N1cnJlbnRDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1jdXJyZW50LWRheVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBkYXkgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2RheU92ZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kYXlzLWNlbGwtb3ZlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGF5IGhvdmVyIG1hcmtlciBjbGFzc1xuXHR0aGlzLnJlZ2lvbmFsID0gW107IC8vIEF2YWlsYWJsZSByZWdpb25hbCBzZXR0aW5ncywgaW5kZXhlZCBieSBsYW5ndWFnZSBjb2RlXG5cdHRoaXMucmVnaW9uYWxbIFwiXCIgXSA9IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5nc1xuXHRcdGNsb3NlVGV4dDogXCJEb25lXCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgY2xvc2UgbGlua1xuXHRcdHByZXZUZXh0OiBcIlByZXZcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBwcmV2aW91cyBtb250aCBsaW5rXG5cdFx0bmV4dFRleHQ6IFwiTmV4dFwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIG5leHQgbW9udGggbGlua1xuXHRcdGN1cnJlbnRUZXh0OiBcIlRvZGF5XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgY3VycmVudCBtb250aCBsaW5rXG5cdFx0bW9udGhOYW1lczogWyBcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFxuXHRcdFx0XCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCIgXSwgLy8gTmFtZXMgb2YgbW9udGhzIGZvciBkcm9wLWRvd24gYW5kIGZvcm1hdHRpbmdcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIiBdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzOiBbIFwiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiBdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzU2hvcnQ6IFsgXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiBdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzTWluOiBbIFwiU3VcIixcIk1vXCIsXCJUdVwiLFwiV2VcIixcIlRoXCIsXCJGclwiLFwiU2FcIiBdLCAvLyBDb2x1bW4gaGVhZGluZ3MgZm9yIGRheXMgc3RhcnRpbmcgYXQgU3VuZGF5XG5cdFx0d2Vla0hlYWRlcjogXCJXa1wiLCAvLyBDb2x1bW4gaGVhZGVyIGZvciB3ZWVrIG9mIHRoZSB5ZWFyXG5cdFx0ZGF0ZUZvcm1hdDogXCJtbS9kZC95eVwiLCAvLyBTZWUgZm9ybWF0IG9wdGlvbnMgb24gcGFyc2VEYXRlXG5cdFx0Zmlyc3REYXk6IDAsIC8vIFRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWssIFN1biA9IDAsIE1vbiA9IDEsIC4uLlxuXHRcdGlzUlRMOiBmYWxzZSwgLy8gVHJ1ZSBpZiByaWdodC10by1sZWZ0IGxhbmd1YWdlLCBmYWxzZSBpZiBsZWZ0LXRvLXJpZ2h0XG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB0aGUgeWVhciBzZWxlY3QgcHJlY2VkZXMgbW9udGgsIGZhbHNlIGZvciBtb250aCB0aGVuIHllYXJcblx0XHR5ZWFyU3VmZml4OiBcIlwiIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIG1vbnRoIGhlYWRlcnNcblx0fTtcblx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRlIHBpY2tlciBpbnN0YW5jZXNcblx0XHRzaG93T246IFwiZm9jdXNcIiwgLy8gXCJmb2N1c1wiIGZvciBwb3B1cCBvbiBmb2N1cyxcblx0XHRcdC8vIFwiYnV0dG9uXCIgZm9yIHRyaWdnZXIgYnV0dG9uLCBvciBcImJvdGhcIiBmb3IgZWl0aGVyXG5cdFx0c2hvd0FuaW06IFwiZmFkZUluXCIsIC8vIE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXBcblx0XHRzaG93T3B0aW9uczoge30sIC8vIE9wdGlvbnMgZm9yIGVuaGFuY2VkIGFuaW1hdGlvbnNcblx0XHRkZWZhdWx0RGF0ZTogbnVsbCwgLy8gVXNlZCB3aGVuIGZpZWxkIGlzIGJsYW5rOiBhY3R1YWwgZGF0ZSxcblx0XHRcdC8vICsvLW51bWJlciBmb3Igb2Zmc2V0IGZyb20gdG9kYXksIG51bGwgZm9yIHRvZGF5XG5cdFx0YXBwZW5kVGV4dDogXCJcIiwgLy8gRGlzcGxheSB0ZXh0IGZvbGxvd2luZyB0aGUgaW5wdXQgYm94LCBlLmcuIHNob3dpbmcgdGhlIGZvcm1hdFxuXHRcdGJ1dHRvblRleHQ6IFwiLi4uXCIsIC8vIFRleHQgZm9yIHRyaWdnZXIgYnV0dG9uXG5cdFx0YnV0dG9uSW1hZ2U6IFwiXCIsIC8vIFVSTCBmb3IgdHJpZ2dlciBidXR0b24gaW1hZ2Vcblx0XHRidXR0b25JbWFnZU9ubHk6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSBpbWFnZSBhcHBlYXJzIGFsb25lLCBmYWxzZSBpZiBpdCBhcHBlYXJzIG9uIGEgYnV0dG9uXG5cdFx0aGlkZUlmTm9QcmV2TmV4dDogZmFsc2UsIC8vIFRydWUgdG8gaGlkZSBuZXh0L3ByZXZpb3VzIG1vbnRoIGxpbmtzXG5cdFx0XHQvLyBpZiBub3QgYXBwbGljYWJsZSwgZmFsc2UgdG8ganVzdCBkaXNhYmxlIHRoZW1cblx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0OiBmYWxzZSwgLy8gVHJ1ZSBpZiBkYXRlIGZvcm1hdHRpbmcgYXBwbGllZCB0byBwcmV2L3RvZGF5L25leHQgbGlua3Ncblx0XHRnb3RvQ3VycmVudDogZmFsc2UsIC8vIFRydWUgaWYgdG9kYXkgbGluayBnb2VzIGJhY2sgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5zdGVhZFxuXHRcdGNoYW5nZU1vbnRoOiBmYWxzZSwgLy8gVHJ1ZSBpZiBtb250aCBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0Y2hhbmdlWWVhcjogZmFsc2UsIC8vIFRydWUgaWYgeWVhciBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0eWVhclJhbmdlOiBcImMtMTA6YysxMFwiLCAvLyBSYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5IGluIGRyb3AtZG93bixcblx0XHRcdC8vIGVpdGhlciByZWxhdGl2ZSB0byB0b2RheSdzIHllYXIgKC1ubjorbm4pLCByZWxhdGl2ZSB0byBjdXJyZW50bHkgZGlzcGxheWVkIHllYXJcblx0XHRcdC8vIChjLW5uOmMrbm4pLCBhYnNvbHV0ZSAobm5ubjpubm5uKSwgb3IgYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUgKG5ubm46LW4pXG5cdFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgdG8gbGVhdmUgYmxhbmtcblx0XHRzZWxlY3RPdGhlck1vbnRoczogZmFsc2UsIC8vIFRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgZm9yIHVuc2VsZWN0YWJsZVxuXHRcdHNob3dXZWVrOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IHdlZWsgb2YgdGhlIHllYXIsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0Y2FsY3VsYXRlV2VlazogdGhpcy5pc284NjAxV2VlaywgLy8gSG93IHRvIGNhbGN1bGF0ZSB0aGUgd2VlayBvZiB0aGUgeWVhcixcblx0XHRcdC8vIHRha2VzIGEgRGF0ZSBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIGZvciBpdFxuXHRcdHNob3J0WWVhckN1dG9mZjogXCIrMTBcIiwgLy8gU2hvcnQgeWVhciB2YWx1ZXMgPCB0aGlzIGFyZSBpbiB0aGUgY3VycmVudCBjZW50dXJ5LFxuXHRcdFx0Ly8gPiB0aGlzIGFyZSBpbiB0aGUgcHJldmlvdXMgY2VudHVyeSxcblx0XHRcdC8vIHN0cmluZyB2YWx1ZSBzdGFydGluZyB3aXRoIFwiK1wiIGZvciBjdXJyZW50IHllYXIgKyB2YWx1ZVxuXHRcdG1pbkRhdGU6IG51bGwsIC8vIFRoZSBlYXJsaWVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0bWF4RGF0ZTogbnVsbCwgLy8gVGhlIGxhdGVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0ZHVyYXRpb246IFwiZmFzdFwiLCAvLyBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmVcblx0XHRiZWZvcmVTaG93RGF5OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGEgZGF0ZSBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoXG5cdFx0XHQvLyBbMF0gPSB0cnVlIGlmIHNlbGVjdGFibGUsIGZhbHNlIGlmIG5vdCwgWzFdID0gY3VzdG9tIENTUyBjbGFzcyBuYW1lKHMpIG9yIFwiXCIsXG5cdFx0XHQvLyBbMl0gPSBjZWxsIHRpdGxlIChvcHRpb25hbCksIGUuZy4gJC5kYXRlcGlja2VyLm5vV2Vla2VuZHNcblx0XHRiZWZvcmVTaG93OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGlucHV0IGZpZWxkIGFuZFxuXHRcdFx0Ly8gcmV0dXJucyBhIHNldCBvZiBjdXN0b20gc2V0dGluZ3MgZm9yIHRoZSBkYXRlIHBpY2tlclxuXHRcdG9uU2VsZWN0OiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZFxuXHRcdG9uQ2hhbmdlTW9udGhZZWFyOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBtb250aCBvciB5ZWFyIGlzIGNoYW5nZWRcblx0XHRvbkNsb3NlOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkYXRlcGlja2VyIGlzIGNsb3NlZFxuXHRcdG51bWJlck9mTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHNob3cgYXQgYSB0aW1lXG5cdFx0c2hvd0N1cnJlbnRBdFBvczogMCwgLy8gVGhlIHBvc2l0aW9uIGluIG11bHRpcGUgbW9udGhzIGF0IHdoaWNoIHRvIHNob3cgdGhlIGN1cnJlbnQgbW9udGggKHN0YXJ0aW5nIGF0IDApXG5cdFx0c3RlcE1vbnRoczogMSwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzdGVwIGJhY2svZm9yd2FyZFxuXHRcdHN0ZXBCaWdNb250aHM6IDEyLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkIGZvciB0aGUgYmlnIGxpbmtzXG5cdFx0YWx0RmllbGQ6IFwiXCIsIC8vIFNlbGVjdG9yIGZvciBhbiBhbHRlcm5hdGUgZmllbGQgdG8gc3RvcmUgc2VsZWN0ZWQgZGF0ZXMgaW50b1xuXHRcdGFsdEZvcm1hdDogXCJcIiwgLy8gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSBmb3IgdGhlIGFsdGVybmF0ZSBmaWVsZFxuXHRcdGNvbnN0cmFpbklucHV0OiB0cnVlLCAvLyBUaGUgaW5wdXQgaXMgY29uc3RyYWluZWQgYnkgdGhlIGN1cnJlbnQgZGF0ZSBmb3JtYXRcblx0XHRzaG93QnV0dG9uUGFuZWw6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgYnV0dG9uIHBhbmVsLCBmYWxzZSB0byBub3Qgc2hvdyBpdFxuXHRcdGF1dG9TaXplOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaXplIHRoZSBpbnB1dCBmb3IgdGhlIGRhdGUgZm9ybWF0LCBmYWxzZSB0byBsZWF2ZSBhcyBpc1xuXHRcdGRpc2FibGVkOiBmYWxzZSAvLyBUaGUgaW5pdGlhbCBkaXNhYmxlZCBzdGF0ZVxuXHR9O1xuXHQkLmV4dGVuZCggdGhpcy5fZGVmYXVsdHMsIHRoaXMucmVnaW9uYWxbIFwiXCIgXSApO1xuXHR0aGlzLnJlZ2lvbmFsLmVuID0gJC5leHRlbmQoIHRydWUsIHt9LCB0aGlzLnJlZ2lvbmFsWyBcIlwiIF0gKTtcblx0dGhpcy5yZWdpb25hbFsgXCJlbi1VU1wiIF0gPSAkLmV4dGVuZCggdHJ1ZSwge30sIHRoaXMucmVnaW9uYWwuZW4gKTtcblx0dGhpcy5kcERpdiA9IGRhdGVwaWNrZXJfYmluZEhvdmVyKCAkKCBcIjxkaXYgaWQ9J1wiICsgdGhpcy5fbWFpbkRpdklkICsgXCInIGNsYXNzPSd1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XCIgKSApO1xufVxuXG4kLmV4dGVuZCggRGF0ZXBpY2tlci5wcm90b3R5cGUsIHtcblx0LyogQ2xhc3MgbmFtZSBhZGRlZCB0byBlbGVtZW50cyB0byBpbmRpY2F0ZSBhbHJlYWR5IGNvbmZpZ3VyZWQgd2l0aCBhIGRhdGUgcGlja2VyLiAqL1xuXHRtYXJrZXJDbGFzc05hbWU6IFwiaGFzRGF0ZXBpY2tlclwiLFxuXG5cdC8vS2VlcCB0cmFjayBvZiB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgKHNlZSAjNzA0Mylcblx0bWF4Um93czogNCxcblxuXHQvLyBUT0RPIHJlbmFtZSB0byBcIndpZGdldFwiIHdoZW4gc3dpdGNoaW5nIHRvIHdpZGdldCBmYWN0b3J5XG5cdF93aWRnZXREYXRlcGlja2VyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kcERpdjtcblx0fSxcblxuXHQvKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGUgZGF0ZSBwaWNrZXIuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGFzIGRlZmF1bHRzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHQgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxuXHQgKi9cblx0c2V0RGVmYXVsdHM6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHRkYXRlcGlja2VyX2V4dGVuZFJlbW92ZSggdGhpcy5fZGVmYXVsdHMsIHNldHRpbmdzIHx8IHt9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGZvciB0aGlzIGRhdGUgcGlja2VyIGluc3RhbmNlIChhbm9ueW1vdXMpXG5cdCAqL1xuXHRfYXR0YWNoRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsIGluc3Q7XG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpbmxpbmUgPSAoIG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIiApO1xuXHRcdGlmICggIXRhcmdldC5pZCApIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0dGFyZ2V0LmlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdH1cblx0XHRpbnN0ID0gdGhpcy5fbmV3SW5zdCggJCggdGFyZ2V0ICksIGlubGluZSApO1xuXHRcdGluc3Quc2V0dGluZ3MgPSAkLmV4dGVuZCgge30sIHNldHRpbmdzIHx8IHt9ICk7XG5cdFx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0dGhpcy5fY29ubmVjdERhdGVwaWNrZXIoIHRhcmdldCwgaW5zdCApO1xuXHRcdH0gZWxzZSBpZiAoIGlubGluZSApIHtcblx0XHRcdHRoaXMuX2lubGluZURhdGVwaWNrZXIoIHRhcmdldCwgaW5zdCApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2JqZWN0LiAqL1xuXHRfbmV3SW5zdDogZnVuY3Rpb24oIHRhcmdldCwgaW5saW5lICkge1xuXHRcdHZhciBpZCA9IHRhcmdldFsgMCBdLmlkLnJlcGxhY2UoIC8oW15BLVphLXowLTlfXFwtXSkvZywgXCJcXFxcXFxcXCQxXCIgKTsgLy8gZXNjYXBlIGpRdWVyeSBtZXRhIGNoYXJzXG5cdFx0cmV0dXJuIHsgaWQ6IGlkLCBpbnB1dDogdGFyZ2V0LCAvLyBhc3NvY2lhdGVkIHRhcmdldFxuXHRcdFx0c2VsZWN0ZWREYXk6IDAsIHNlbGVjdGVkTW9udGg6IDAsIHNlbGVjdGVkWWVhcjogMCwgLy8gY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdGRyYXdNb250aDogMCwgZHJhd1llYXI6IDAsIC8vIG1vbnRoIGJlaW5nIGRyYXduXG5cdFx0XHRpbmxpbmU6IGlubGluZSwgLy8gaXMgZGF0ZXBpY2tlciBpbmxpbmUgb3Igbm90XG5cdFx0XHRkcERpdjogKCAhaW5saW5lID8gdGhpcy5kcERpdiA6IC8vIHByZXNlbnRhdGlvbiBkaXZcblx0XHRcdGRhdGVwaWNrZXJfYmluZEhvdmVyKCAkKCBcIjxkaXYgY2xhc3M9J1wiICsgdGhpcy5faW5saW5lQ2xhc3MgKyBcIiB1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XCIgKSApICkgfTtcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGFuIGlucHV0IGZpZWxkLiAqL1xuXHRfY29ubmVjdERhdGVwaWNrZXI6IGZ1bmN0aW9uKCB0YXJnZXQsIGluc3QgKSB7XG5cdFx0dmFyIGlucHV0ID0gJCggdGFyZ2V0ICk7XG5cdFx0aW5zdC5hcHBlbmQgPSAkKCBbXSApO1xuXHRcdGluc3QudHJpZ2dlciA9ICQoIFtdICk7XG5cdFx0aWYgKCBpbnB1dC5oYXNDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYXR0YWNobWVudHMoIGlucHV0LCBpbnN0ICk7XG5cdFx0aW5wdXQuYWRkQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkub24oIFwia2V5ZG93blwiLCB0aGlzLl9kb0tleURvd24gKS5cblx0XHRcdG9uKCBcImtleXByZXNzXCIsIHRoaXMuX2RvS2V5UHJlc3MgKS5vbiggXCJrZXl1cFwiLCB0aGlzLl9kb0tleVVwICk7XG5cdFx0dGhpcy5fYXV0b1NpemUoIGluc3QgKTtcblx0XHQkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIsIGluc3QgKTtcblxuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgb25jZSBpdCBoYXMgYmVlbiBhdHRhY2hlZCB0byB0aGUgaW5wdXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYgKCBpbnN0LnNldHRpbmdzLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIoIHRhcmdldCApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBNYWtlIGF0dGFjaG1lbnRzIGJhc2VkIG9uIHNldHRpbmdzLiAqL1xuXHRfYXR0YWNobWVudHM6IGZ1bmN0aW9uKCBpbnB1dCwgaW5zdCApIHtcblx0XHR2YXIgc2hvd09uLCBidXR0b25UZXh0LCBidXR0b25JbWFnZSxcblx0XHRcdGFwcGVuZFRleHQgPSB0aGlzLl9nZXQoIGluc3QsIFwiYXBwZW5kVGV4dFwiICksXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldCggaW5zdCwgXCJpc1JUTFwiICk7XG5cblx0XHRpZiAoIGluc3QuYXBwZW5kICkge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmICggYXBwZW5kVGV4dCApIHtcblx0XHRcdGluc3QuYXBwZW5kID0gJCggXCI8c3BhbiBjbGFzcz0nXCIgKyB0aGlzLl9hcHBlbmRDbGFzcyArIFwiJz5cIiArIGFwcGVuZFRleHQgKyBcIjwvc3Bhbj5cIiApO1xuXHRcdFx0aW5wdXRbIGlzUlRMID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiBdKCBpbnN0LmFwcGVuZCApO1xuXHRcdH1cblxuXHRcdGlucHV0Lm9mZiggXCJmb2N1c1wiLCB0aGlzLl9zaG93RGF0ZXBpY2tlciApO1xuXG5cdFx0aWYgKCBpbnN0LnRyaWdnZXIgKSB7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0c2hvd09uID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dPblwiICk7XG5cdFx0aWYgKCBzaG93T24gPT09IFwiZm9jdXNcIiB8fCBzaG93T24gPT09IFwiYm90aFwiICkgeyAvLyBwb3AtdXAgZGF0ZSBwaWNrZXIgd2hlbiBpbiB0aGUgbWFya2VkIGZpZWxkXG5cdFx0XHRpbnB1dC5vbiggXCJmb2N1c1wiLCB0aGlzLl9zaG93RGF0ZXBpY2tlciApO1xuXHRcdH1cblx0XHRpZiAoIHNob3dPbiA9PT0gXCJidXR0b25cIiB8fCBzaG93T24gPT09IFwiYm90aFwiICkgeyAvLyBwb3AtdXAgZGF0ZSBwaWNrZXIgd2hlbiBidXR0b24gY2xpY2tlZFxuXHRcdFx0YnV0dG9uVGV4dCA9IHRoaXMuX2dldCggaW5zdCwgXCJidXR0b25UZXh0XCIgKTtcblx0XHRcdGJ1dHRvbkltYWdlID0gdGhpcy5fZ2V0KCBpbnN0LCBcImJ1dHRvbkltYWdlXCIgKTtcblx0XHRcdGluc3QudHJpZ2dlciA9ICQoIHRoaXMuX2dldCggaW5zdCwgXCJidXR0b25JbWFnZU9ubHlcIiApID9cblx0XHRcdFx0JCggXCI8aW1nLz5cIiApLmFkZENsYXNzKCB0aGlzLl90cmlnZ2VyQ2xhc3MgKS5cblx0XHRcdFx0XHRhdHRyKCB7IHNyYzogYnV0dG9uSW1hZ2UsIGFsdDogYnV0dG9uVGV4dCwgdGl0bGU6IGJ1dHRvblRleHQgfSApIDpcblx0XHRcdFx0JCggXCI8YnV0dG9uIHR5cGU9J2J1dHRvbic+PC9idXR0b24+XCIgKS5hZGRDbGFzcyggdGhpcy5fdHJpZ2dlckNsYXNzICkuXG5cdFx0XHRcdFx0aHRtbCggIWJ1dHRvbkltYWdlID8gYnV0dG9uVGV4dCA6ICQoIFwiPGltZy8+XCIgKS5hdHRyKFxuXHRcdFx0XHRcdHsgc3JjOmJ1dHRvbkltYWdlLCBhbHQ6YnV0dG9uVGV4dCwgdGl0bGU6YnV0dG9uVGV4dCB9ICkgKSApO1xuXHRcdFx0aW5wdXRbIGlzUlRMID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiBdKCBpbnN0LnRyaWdnZXIgKTtcblx0XHRcdGluc3QudHJpZ2dlci5vbiggXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dFsgMCBdICkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0fSBlbHNlIGlmICggJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCAhPT0gaW5wdXRbIDAgXSApIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlciggaW5wdXRbIDAgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIoIGlucHV0WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFwcGx5IHRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfYXV0b1NpemU6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdGlmICggdGhpcy5fZ2V0KCBpbnN0LCBcImF1dG9TaXplXCIgKSAmJiAhaW5zdC5pbmxpbmUgKSB7XG5cdFx0XHR2YXIgZmluZE1heCwgbWF4LCBtYXhJLCBpLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoIDIwMDksIDEyIC0gMSwgMjAgKSwgLy8gRW5zdXJlIGRvdWJsZSBkaWdpdHNcblx0XHRcdFx0ZGF0ZUZvcm1hdCA9IHRoaXMuX2dldCggaW5zdCwgXCJkYXRlRm9ybWF0XCIgKTtcblxuXHRcdFx0aWYgKCBkYXRlRm9ybWF0Lm1hdGNoKCAvW0RNXS8gKSApIHtcblx0XHRcdFx0ZmluZE1heCA9IGZ1bmN0aW9uKCBuYW1lcyApIHtcblx0XHRcdFx0XHRtYXggPSAwO1xuXHRcdFx0XHRcdG1heEkgPSAwO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5hbWVzWyBpIF0ubGVuZ3RoID4gbWF4ICkge1xuXHRcdFx0XHRcdFx0XHRtYXggPSBuYW1lc1sgaSBdLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bWF4SSA9IGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXhJO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRkYXRlLnNldE1vbnRoKCBmaW5kTWF4KCB0aGlzLl9nZXQoIGluc3QsICggZGF0ZUZvcm1hdC5tYXRjaCggL01NLyApID9cblx0XHRcdFx0XHRcIm1vbnRoTmFtZXNcIiA6IFwibW9udGhOYW1lc1Nob3J0XCIgKSApICkgKTtcblx0XHRcdFx0ZGF0ZS5zZXREYXRlKCBmaW5kTWF4KCB0aGlzLl9nZXQoIGluc3QsICggZGF0ZUZvcm1hdC5tYXRjaCggL0RELyApID9cblx0XHRcdFx0XHRcImRheU5hbWVzXCIgOiBcImRheU5hbWVzU2hvcnRcIiApICkgKSArIDIwIC0gZGF0ZS5nZXREYXkoKSApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdC5pbnB1dC5hdHRyKCBcInNpemVcIiwgdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCwgZGF0ZSApLmxlbmd0aCApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBBdHRhY2ggYW4gaW5saW5lIGRhdGUgcGlja2VyIHRvIGEgZGl2LiAqL1xuXHRfaW5saW5lRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCwgaW5zdCApIHtcblx0XHR2YXIgZGl2U3BhbiA9ICQoIHRhcmdldCApO1xuXHRcdGlmICggZGl2U3Bhbi5oYXNDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZGl2U3Bhbi5hZGRDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKS5hcHBlbmQoIGluc3QuZHBEaXYgKTtcblx0XHQkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIsIGluc3QgKTtcblx0XHR0aGlzLl9zZXREYXRlKCBpbnN0LCB0aGlzLl9nZXREZWZhdWx0RGF0ZSggaW5zdCApLCB0cnVlICk7XG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlciggaW5zdCApO1xuXHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZSggaW5zdCApO1xuXG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBiZWZvcmUgc2hvd2luZyBpdCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiAoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGRpc3BsYXk6YmxvY2sgaW4gcGxhY2Ugb2YgaW5zdC5kcERpdi5zaG93KCkgd2hpY2ggd29uJ3Qgd29yayBvbiBkaXNjb25uZWN0ZWQgZWxlbWVudHNcblx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnl1aS5jb20vdGlja2V0Lzc1NTIgLSBBIERhdGVwaWNrZXIgY3JlYXRlZCBvbiBhIGRldGFjaGVkIGRpdiBoYXMgemVybyBoZWlnaHRcblx0XHRpbnN0LmRwRGl2LmNzcyggXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiApO1xuXHR9LFxuXG5cdC8qIFBvcC11cCB0aGUgZGF0ZSBwaWNrZXIgaW4gYSBcImRpYWxvZ1wiIGJveC5cblx0ICogQHBhcmFtICBpbnB1dCBlbGVtZW50IC0gaWdub3JlZFxuXHQgKiBAcGFyYW0gIGRhdGVcdHN0cmluZyBvciBEYXRlIC0gdGhlIGluaXRpYWwgZGF0ZSB0byBkaXNwbGF5XG5cdCAqIEBwYXJhbSAgb25TZWxlY3QgIGZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdXBkYXRlIHRoZSBkaWFsb2cgZGF0ZSBwaWNrZXIgaW5zdGFuY2UncyBzZXR0aW5ncyAoYW5vbnltb3VzIG9iamVjdClcblx0ICogQHBhcmFtICBwb3MgaW50WzJdIC0gY29vcmRpbmF0ZXMgZm9yIHRoZSBkaWFsb2cncyBwb3NpdGlvbiB3aXRoaW4gdGhlIHNjcmVlbiBvclxuXHQgKlx0XHRcdFx0XHRldmVudCAtIHdpdGggeC95IGNvb3JkaW5hdGVzIG9yXG5cdCAqXHRcdFx0XHRcdGxlYXZlIGVtcHR5IGZvciBkZWZhdWx0IChzY3JlZW4gY2VudHJlKVxuXHQgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxuXHQgKi9cblx0X2RpYWxvZ0RhdGVwaWNrZXI6IGZ1bmN0aW9uKCBpbnB1dCwgZGF0ZSwgb25TZWxlY3QsIHNldHRpbmdzLCBwb3MgKSB7XG5cdFx0dmFyIGlkLCBicm93c2VyV2lkdGgsIGJyb3dzZXJIZWlnaHQsIHNjcm9sbFgsIHNjcm9sbFksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdDsgLy8gaW50ZXJuYWwgaW5zdGFuY2VcblxuXHRcdGlmICggIWluc3QgKSB7XG5cdFx0XHR0aGlzLnV1aWQgKz0gMTtcblx0XHRcdGlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQgPSAkKCBcIjxpbnB1dCB0eXBlPSd0ZXh0JyBpZD0nXCIgKyBpZCArXG5cdFx0XHRcdFwiJyBzdHlsZT0ncG9zaXRpb246IGFic29sdXRlOyB0b3A6IC0xMDBweDsgd2lkdGg6IDBweDsnLz5cIiApO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQub24oIFwia2V5ZG93blwiLCB0aGlzLl9kb0tleURvd24gKTtcblx0XHRcdCQoIFwiYm9keVwiICkuYXBwZW5kKCB0aGlzLl9kaWFsb2dJbnB1dCApO1xuXHRcdFx0aW5zdCA9IHRoaXMuX2RpYWxvZ0luc3QgPSB0aGlzLl9uZXdJbnN0KCB0aGlzLl9kaWFsb2dJbnB1dCwgZmFsc2UgKTtcblx0XHRcdGluc3Quc2V0dGluZ3MgPSB7fTtcblx0XHRcdCQuZGF0YSggdGhpcy5fZGlhbG9nSW5wdXRbIDAgXSwgXCJkYXRlcGlja2VyXCIsIGluc3QgKTtcblx0XHR9XG5cdFx0ZGF0ZXBpY2tlcl9leHRlbmRSZW1vdmUoIGluc3Quc2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9ICk7XG5cdFx0ZGF0ZSA9ICggZGF0ZSAmJiBkYXRlLmNvbnN0cnVjdG9yID09PSBEYXRlID8gdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCwgZGF0ZSApIDogZGF0ZSApO1xuXHRcdHRoaXMuX2RpYWxvZ0lucHV0LnZhbCggZGF0ZSApO1xuXG5cdFx0dGhpcy5fcG9zID0gKCBwb3MgPyAoIHBvcy5sZW5ndGggPyBwb3MgOiBbIHBvcy5wYWdlWCwgcG9zLnBhZ2VZIF0gKSA6IG51bGwgKTtcblx0XHRpZiAoICF0aGlzLl9wb3MgKSB7XG5cdFx0XHRicm93c2VyV2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0XHRicm93c2VySGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblx0XHRcdHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcblx0XHRcdHRoaXMuX3BvcyA9IC8vIHNob3VsZCB1c2UgYWN0dWFsIHdpZHRoL2hlaWdodCBiZWxvd1xuXHRcdFx0XHRbICggYnJvd3NlcldpZHRoIC8gMiApIC0gMTAwICsgc2Nyb2xsWCwgKCBicm93c2VySGVpZ2h0IC8gMiApIC0gMTUwICsgc2Nyb2xsWSBdO1xuXHRcdH1cblxuXHRcdC8vIE1vdmUgaW5wdXQgb24gc2NyZWVuIGZvciBmb2N1cywgYnV0IGhpZGRlbiBiZWhpbmQgZGlhbG9nXG5cdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKCBcImxlZnRcIiwgKCB0aGlzLl9wb3NbIDAgXSArIDIwICkgKyBcInB4XCIgKS5jc3MoIFwidG9wXCIsIHRoaXMuX3Bvc1sgMSBdICsgXCJweFwiICk7XG5cdFx0aW5zdC5zZXR0aW5ncy5vblNlbGVjdCA9IG9uU2VsZWN0O1xuXHRcdHRoaXMuX2luRGlhbG9nID0gdHJ1ZTtcblx0XHR0aGlzLmRwRGl2LmFkZENsYXNzKCB0aGlzLl9kaWFsb2dDbGFzcyApO1xuXHRcdHRoaXMuX3Nob3dEYXRlcGlja2VyKCB0aGlzLl9kaWFsb2dJbnB1dFsgMCBdICk7XG5cdFx0aWYgKCAkLmJsb2NrVUkgKSB7XG5cdFx0XHQkLmJsb2NrVUkoIHRoaXMuZHBEaXYgKTtcblx0XHR9XG5cdFx0JC5kYXRhKCB0aGlzLl9kaWFsb2dJbnB1dFsgMCBdLCBcImRhdGVwaWNrZXJcIiwgaW5zdCApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIERldGFjaCBhIGRhdGVwaWNrZXIgZnJvbSBpdHMgY29udHJvbC5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9kZXN0cm95RGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgbm9kZU5hbWUsXG5cdFx0XHQkdGFyZ2V0ID0gJCggdGFyZ2V0ICksXG5cdFx0XHRpbnN0ID0gJC5kYXRhKCB0YXJnZXQsIFwiZGF0ZXBpY2tlclwiICk7XG5cblx0XHRpZiAoICEkdGFyZ2V0Lmhhc0NsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0JC5yZW1vdmVEYXRhKCB0YXJnZXQsIFwiZGF0ZXBpY2tlclwiICk7XG5cdFx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0XHQkdGFyZ2V0LnJlbW92ZUNsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApLlxuXHRcdFx0XHRvZmYoIFwiZm9jdXNcIiwgdGhpcy5fc2hvd0RhdGVwaWNrZXIgKS5cblx0XHRcdFx0b2ZmKCBcImtleWRvd25cIiwgdGhpcy5fZG9LZXlEb3duICkuXG5cdFx0XHRcdG9mZiggXCJrZXlwcmVzc1wiLCB0aGlzLl9kb0tleVByZXNzICkuXG5cdFx0XHRcdG9mZiggXCJrZXl1cFwiLCB0aGlzLl9kb0tleVVwICk7XG5cdFx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiZGl2XCIgfHwgbm9kZU5hbWUgPT09IFwic3BhblwiICkge1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKS5lbXB0eSgpO1xuXHRcdH1cblxuXHRcdGlmICggZGF0ZXBpY2tlcl9pbnN0QWN0aXZlID09PSBpbnN0ICkge1xuXHRcdFx0ZGF0ZXBpY2tlcl9pbnN0QWN0aXZlID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyogRW5hYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZW5hYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgbm9kZU5hbWUsIGlubGluZSxcblx0XHRcdCR0YXJnZXQgPSAkKCB0YXJnZXQgKSxcblx0XHRcdGluc3QgPSAkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblxuXHRcdGlmICggISR0YXJnZXQuaGFzQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHR0YXJnZXQuZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdGluc3QudHJpZ2dlci5maWx0ZXIoIFwiYnV0dG9uXCIgKS5cblx0XHRcdFx0ZWFjaCggZnVuY3Rpb24oKSB7IHRoaXMuZGlzYWJsZWQgPSBmYWxzZTsgfSApLmVuZCgpLlxuXHRcdFx0XHRmaWx0ZXIoIFwiaW1nXCIgKS5jc3MoIHsgb3BhY2l0eTogXCIxLjBcIiwgY3Vyc29yOiBcIlwiIH0gKTtcblx0XHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIgKSB7XG5cdFx0XHRpbmxpbmUgPSAkdGFyZ2V0LmNoaWxkcmVuKCBcIi5cIiArIHRoaXMuX2lubGluZUNsYXNzICk7XG5cdFx0XHRpbmxpbmUuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cdFx0XHRpbmxpbmUuZmluZCggXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclwiICkuXG5cdFx0XHRcdHByb3AoIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0XHR9XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCggdGhpcy5fZGlzYWJsZWRJbnB1dHMsXG5cdFx0XHRmdW5jdGlvbiggdmFsdWUgKSB7IHJldHVybiAoIHZhbHVlID09PSB0YXJnZXQgPyBudWxsIDogdmFsdWUgKTsgfSApOyAvLyBkZWxldGUgZW50cnlcblx0fSxcblxuXHQvKiBEaXNhYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZGlzYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsXG5cdFx0XHQkdGFyZ2V0ID0gJCggdGFyZ2V0ICksXG5cdFx0XHRpbnN0ID0gJC5kYXRhKCB0YXJnZXQsIFwiZGF0ZXBpY2tlclwiICk7XG5cblx0XHRpZiAoICEkdGFyZ2V0Lmhhc0NsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0dGFyZ2V0LmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGluc3QudHJpZ2dlci5maWx0ZXIoIFwiYnV0dG9uXCIgKS5cblx0XHRcdFx0ZWFjaCggZnVuY3Rpb24oKSB7IHRoaXMuZGlzYWJsZWQgPSB0cnVlOyB9ICkuZW5kKCkuXG5cdFx0XHRcdGZpbHRlciggXCJpbWdcIiApLmNzcyggeyBvcGFjaXR5OiBcIjAuNVwiLCBjdXJzb3I6IFwiZGVmYXVsdFwiIH0gKTtcblx0XHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIgKSB7XG5cdFx0XHRpbmxpbmUgPSAkdGFyZ2V0LmNoaWxkcmVuKCBcIi5cIiArIHRoaXMuX2lubGluZUNsYXNzICk7XG5cdFx0XHRpbmxpbmUuY2hpbGRyZW4oKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cdFx0XHRpbmxpbmUuZmluZCggXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclwiICkuXG5cdFx0XHRcdHByb3AoIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHRcdH1cblx0XHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKCB0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKCB2YWx1ZSApIHsgcmV0dXJuICggdmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSApOyB9ICk7IC8vIGRlbGV0ZSBlbnRyeVxuXHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzWyB0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGggXSA9IHRhcmdldDtcblx0fSxcblxuXHQvKiBJcyB0aGUgZmlyc3QgZmllbGQgaW4gYSBqUXVlcnkgY29sbGVjdGlvbiBkaXNhYmxlZCBhcyBhIGRhdGVwaWNrZXI/XG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEByZXR1cm4gYm9vbGVhbiAtIHRydWUgaWYgZGlzYWJsZWQsIGZhbHNlIGlmIGVuYWJsZWRcblx0ICovXG5cdF9pc0Rpc2FibGVkRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHRpZiAoICF0YXJnZXQgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuX2Rpc2FibGVkSW5wdXRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzLl9kaXNhYmxlZElucHV0c1sgaSBdID09PSB0YXJnZXQgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGluc3RhbmNlIGRhdGEgZm9yIHRoZSB0YXJnZXQgY29udHJvbC5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHJldHVybiAgb2JqZWN0IC0gdGhlIGFzc29jaWF0ZWQgaW5zdGFuY2UgZGF0YVxuXHQgKiBAdGhyb3dzICBlcnJvciBpZiBhIGpRdWVyeSBwcm9ibGVtIGdldHRpbmcgZGF0YVxuXHQgKi9cblx0X2dldEluc3Q6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHR0aHJvdyBcIk1pc3NpbmcgaW5zdGFuY2UgZGF0YSBmb3IgdGhpcyBkYXRlcGlja2VyXCI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBvciByZXRyaWV2ZSB0aGUgc2V0dGluZ3MgZm9yIGEgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgbmFtZVx0b2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1cGRhdGUgb3Jcblx0ICpcdFx0XHRcdHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nIHRvIGNoYW5nZSBvciByZXRyaWV2ZSxcblx0ICpcdFx0XHRcdHdoZW4gcmV0cmlldmluZyBhbHNvIFwiYWxsXCIgZm9yIGFsbCBpbnN0YW5jZSBzZXR0aW5ncyBvclxuXHQgKlx0XHRcdFx0XCJkZWZhdWx0c1wiIGZvciBhbGwgZ2xvYmFsIGRlZmF1bHRzXG5cdCAqIEBwYXJhbSAgdmFsdWUgICBhbnkgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZ1xuXHQgKlx0XHRcdFx0KG9taXQgaWYgYWJvdmUgaXMgYW4gb2JqZWN0IG9yIHRvIHJldHJpZXZlIGEgdmFsdWUpXG5cdCAqL1xuXHRfb3B0aW9uRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHNldHRpbmdzLCBkYXRlLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldCApO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuICggbmFtZSA9PT0gXCJkZWZhdWx0c1wiID8gJC5leHRlbmQoIHt9LCAkLmRhdGVwaWNrZXIuX2RlZmF1bHRzICkgOlxuXHRcdFx0XHQoIGluc3QgPyAoIG5hbWUgPT09IFwiYWxsXCIgPyAkLmV4dGVuZCgge30sIGluc3Quc2V0dGluZ3MgKSA6XG5cdFx0XHRcdHRoaXMuX2dldCggaW5zdCwgbmFtZSApICkgOiBudWxsICkgKTtcblx0XHR9XG5cblx0XHRzZXR0aW5ncyA9IG5hbWUgfHwge307XG5cdFx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHNldHRpbmdzID0ge307XG5cdFx0XHRzZXR0aW5nc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBpbnN0ICkge1xuXHRcdFx0aWYgKCB0aGlzLl9jdXJJbnN0ID09PSBpbnN0ICkge1xuXHRcdFx0XHR0aGlzLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0fVxuXG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZURhdGVwaWNrZXIoIHRhcmdldCwgdHJ1ZSApO1xuXHRcdFx0bWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWluXCIgKTtcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1heFwiICk7XG5cdFx0XHRkYXRlcGlja2VyX2V4dGVuZFJlbW92ZSggaW5zdC5zZXR0aW5ncywgc2V0dGluZ3MgKTtcblxuXHRcdFx0Ly8gcmVmb3JtYXQgdGhlIG9sZCBtaW5EYXRlL21heERhdGUgdmFsdWVzIGlmIGRhdGVGb3JtYXQgY2hhbmdlcyBhbmQgYSBuZXcgbWluRGF0ZS9tYXhEYXRlIGlzbid0IHByb3ZpZGVkXG5cdFx0XHRpZiAoIG1pbkRhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1pbkRhdGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aW5zdC5zZXR0aW5ncy5taW5EYXRlID0gdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCwgbWluRGF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtYXhEYXRlICE9PSBudWxsICYmIHNldHRpbmdzLmRhdGVGb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5ncy5tYXhEYXRlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGluc3Quc2V0dGluZ3MubWF4RGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoIGluc3QsIG1heERhdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggXCJkaXNhYmxlZFwiIGluIHNldHRpbmdzICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYXR0YWNobWVudHMoICQoIHRhcmdldCApLCBpbnN0ICk7XG5cdFx0XHR0aGlzLl9hdXRvU2l6ZSggaW5zdCApO1xuXHRcdFx0dGhpcy5fc2V0RGF0ZSggaW5zdCwgZGF0ZSApO1xuXHRcdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENoYW5nZSBtZXRob2QgZGVwcmVjYXRlZFxuXHRfY2hhbmdlRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5fb3B0aW9uRGF0ZXBpY2tlciggdGFyZ2V0LCBuYW1lLCB2YWx1ZSApO1xuXHR9LFxuXG5cdC8qIFJlZHJhdyB0aGUgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfcmVmcmVzaERhdGVwaWNrZXI6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXQgKTtcblx0XHRpZiAoIGluc3QgKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFNldCB0aGUgZGF0ZXMgZm9yIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcGFyYW0gIGRhdGVcdERhdGUgLSB0aGUgbmV3IGRhdGVcblx0ICovXG5cdF9zZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCwgZGF0ZSApIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldCApO1xuXHRcdGlmICggaW5zdCApIHtcblx0XHRcdHRoaXMuX3NldERhdGUoIGluc3QsIGRhdGUgKTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0XHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZSggaW5zdCApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZXQgdGhlIGRhdGUocykgZm9yIHRoZSBmaXJzdCBlbnRyeSBpbiBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0IGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBub0RlZmF1bHQgYm9vbGVhbiAtIHRydWUgaWYgbm8gZGVmYXVsdCBkYXRlIGlzIHRvIGJlIHVzZWRcblx0ICogQHJldHVybiBEYXRlIC0gdGhlIGN1cnJlbnQgZGF0ZVxuXHQgKi9cblx0X2dldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBub0RlZmF1bHQgKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXQgKTtcblx0XHRpZiAoIGluc3QgJiYgIWluc3QuaW5saW5lICkge1xuXHRcdFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZCggaW5zdCwgbm9EZWZhdWx0ICk7XG5cdFx0fVxuXHRcdHJldHVybiAoIGluc3QgPyB0aGlzLl9nZXREYXRlKCBpbnN0ICkgOiBudWxsICk7XG5cdH0sXG5cblx0LyogSGFuZGxlIGtleXN0cm9rZXMuICovXG5cdF9kb0tleURvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgb25TZWxlY3QsIGRhdGVTdHIsIHNlbCxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoIGV2ZW50LnRhcmdldCApLFxuXHRcdFx0aGFuZGxlZCA9IHRydWUsXG5cdFx0XHRpc1JUTCA9IGluc3QuZHBEaXYuaXMoIFwiLnVpLWRhdGVwaWNrZXItcnRsXCIgKTtcblxuXHRcdGluc3QuX2tleUV2ZW50ID0gdHJ1ZTtcblx0XHRpZiAoICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgKSB7XG5cdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIDk6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIHRhYiBvdXRcblx0XHRcdFx0Y2FzZSAxMzogc2VsID0gJCggXCJ0ZC5cIiArICQuZGF0ZXBpY2tlci5fZGF5T3ZlckNsYXNzICsgXCI6bm90KC5cIiArXG5cdFx0XHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2N1cnJlbnRDbGFzcyArIFwiKVwiLCBpbnN0LmRwRGl2ICk7XG5cdFx0XHRcdFx0XHRpZiAoIHNlbFsgMCBdICkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheSggZXZlbnQudGFyZ2V0LCBpbnN0LnNlbGVjdGVkTW9udGgsIGluc3Quc2VsZWN0ZWRZZWFyLCBzZWxbIDAgXSApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRvblNlbGVjdCA9ICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcIm9uU2VsZWN0XCIgKTtcblx0XHRcdFx0XHRcdGlmICggb25TZWxlY3QgKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGVTdHIgPSAkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUoIGluc3QgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUcmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0XHRvblNlbGVjdC5hcHBseSggKCBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFsgMCBdIDogbnVsbCApLCBbIGRhdGVTdHIsIGluc3QgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGRvbid0IHN1Ym1pdCB0aGUgZm9ybVxuXHRcdFx0XHRjYXNlIDI3OiAkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gaGlkZSBvbiBlc2NhcGVcblx0XHRcdFx0Y2FzZSAzMzogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBldmVudC50YXJnZXQsICggZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIgKSA6XG5cdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwTW9udGhzXCIgKSApLCBcIk1cIiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIHByZXZpb3VzIG1vbnRoL3llYXIgb24gcGFnZSB1cC8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNDogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBldmVudC50YXJnZXQsICggZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIgKSA6XG5cdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwTW9udGhzXCIgKSApLCBcIk1cIiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIG5leHQgbW9udGgveWVhciBvbiBwYWdlIGRvd24vKyBjdHJsXG5cdFx0XHRcdGNhc2UgMzU6IGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ICkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2NsZWFyRGF0ZSggZXZlbnQudGFyZ2V0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGNsZWFyIG9uIGN0cmwgb3IgY29tbWFuZCArZW5kXG5cdFx0XHRcdGNhc2UgMzY6IGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ICkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheSggZXZlbnQudGFyZ2V0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGN1cnJlbnQgb24gY3RybCBvciBjb21tYW5kICtob21lXG5cdFx0XHRcdGNhc2UgMzc6IGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ICkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKCBpc1JUTCA/ICsxIDogLTEgKSwgXCJEXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cblx0XHRcdFx0XHRcdC8vIC0xIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK2xlZnRcblx0XHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAoIGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIgKSA6XG5cdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApICksIFwiTVwiICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK2xlZnQgb24gTWFjXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzODogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAtNywgXCJEXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gLTEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK3VwXG5cdFx0XHRcdGNhc2UgMzk6IGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ICkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKCBpc1JUTCA/IC0xIDogKzEgKSwgXCJEXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cblx0XHRcdFx0XHRcdC8vICsxIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK3JpZ2h0XG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5ICkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKCBldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwic3RlcEJpZ01vbnRoc1wiICkgOlxuXHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwTW9udGhzXCIgKSApLCBcIk1cIiApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBuZXh0IG1vbnRoL3llYXIgb24gYWx0ICtyaWdodFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDA6IGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ICkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKzcsIFwiRFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vICsxIHdlZWsgb24gY3RybCBvciBjb21tYW5kICtkb3duXG5cdFx0XHRcdGRlZmF1bHQ6IGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCBldmVudC5rZXlDb2RlID09PSAzNiAmJiBldmVudC5jdHJsS2V5ICkgeyAvLyBkaXNwbGF5IHRoZSBkYXRlIHBpY2tlciBvbiBjdHJsK2hvbWVcblx0XHRcdCQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggaGFuZGxlZCApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRmlsdGVyIGVudGVyZWQgY2hhcmFjdGVycyAtIGJhc2VkIG9uIGRhdGUgZm9ybWF0LiAqL1xuXHRfZG9LZXlQcmVzczogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBjaGFycywgY2hyLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCggZXZlbnQudGFyZ2V0ICk7XG5cblx0XHRpZiAoICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImNvbnN0cmFpbklucHV0XCIgKSApIHtcblx0XHRcdGNoYXJzID0gJC5kYXRlcGlja2VyLl9wb3NzaWJsZUNoYXJzKCAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJkYXRlRm9ybWF0XCIgKSApO1xuXHRcdFx0Y2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZSggZXZlbnQuY2hhckNvZGUgPT0gbnVsbCA/IGV2ZW50LmtleUNvZGUgOiBldmVudC5jaGFyQ29kZSApO1xuXHRcdFx0cmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCAoIGNociA8IFwiIFwiIHx8ICFjaGFycyB8fCBjaGFycy5pbmRleE9mKCBjaHIgKSA+IC0xICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFN5bmNocm9uaXNlIG1hbnVhbCBlbnRyeSBhbmQgZmllbGQvYWx0ZXJuYXRlIGZpZWxkLiAqL1xuXHRfZG9LZXlVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCggZXZlbnQudGFyZ2V0ICk7XG5cblx0XHRpZiAoIGluc3QuaW5wdXQudmFsKCkgIT09IGluc3QubGFzdFZhbCApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJkYXRlRm9ybWF0XCIgKSxcblx0XHRcdFx0XHQoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCApLFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKCBpbnN0ICkgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGUgKSB7IC8vIG9ubHkgaWYgdmFsaWRcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NldERhdGVGcm9tRmllbGQoIGluc3QgKTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZSggaW5zdCApO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlciggaW5zdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVyciApIHtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyogUG9wLXVwIHRoZSBkYXRlIHBpY2tlciBmb3IgYSBnaXZlbiBpbnB1dCBmaWVsZC5cblx0ICogSWYgZmFsc2UgcmV0dXJuZWQgZnJvbSBiZWZvcmVTaG93IGV2ZW50IGhhbmRsZXIgZG8gbm90IHNob3cuXG5cdCAqIEBwYXJhbSAgaW5wdXQgIGVsZW1lbnQgLSB0aGUgaW5wdXQgZmllbGQgYXR0YWNoZWQgdG8gdGhlIGRhdGUgcGlja2VyIG9yXG5cdCAqXHRcdFx0XHRcdGV2ZW50IC0gaWYgdHJpZ2dlcmVkIGJ5IGZvY3VzXG5cdCAqL1xuXHRfc2hvd0RhdGVwaWNrZXI6IGZ1bmN0aW9uKCBpbnB1dCApIHtcblx0XHRpbnB1dCA9IGlucHV0LnRhcmdldCB8fCBpbnB1dDtcblx0XHRpZiAoIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiaW5wdXRcIiApIHsgLy8gZmluZCBmcm9tIGJ1dHRvbi9pbWFnZSB0cmlnZ2VyXG5cdFx0XHRpbnB1dCA9ICQoIFwiaW5wdXRcIiwgaW5wdXQucGFyZW50Tm9kZSApWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCAkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKCBpbnB1dCApIHx8ICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dCApIHsgLy8gYWxyZWFkeSBoZXJlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluc3QsIGJlZm9yZVNob3csIGJlZm9yZVNob3dTZXR0aW5ncywgaXNGaXhlZCxcblx0XHRcdG9mZnNldCwgc2hvd0FuaW0sIGR1cmF0aW9uO1xuXG5cdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCggaW5wdXQgKTtcblx0XHRpZiAoICQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT09IGluc3QgKSB7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2N1ckluc3QuZHBEaXYuc3RvcCggdHJ1ZSwgdHJ1ZSApO1xuXHRcdFx0aWYgKCBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoICQuZGF0ZXBpY2tlci5fY3VySW5zdC5pbnB1dFsgMCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YmVmb3JlU2hvdyA9ICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImJlZm9yZVNob3dcIiApO1xuXHRcdGJlZm9yZVNob3dTZXR0aW5ncyA9IGJlZm9yZVNob3cgPyBiZWZvcmVTaG93LmFwcGx5KCBpbnB1dCwgWyBpbnB1dCwgaW5zdCBdICkgOiB7fTtcblx0XHRpZiAoIGJlZm9yZVNob3dTZXR0aW5ncyA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKCBpbnN0LnNldHRpbmdzLCBiZWZvcmVTaG93U2V0dGluZ3MgKTtcblxuXHRcdGluc3QubGFzdFZhbCA9IG51bGw7XG5cdFx0JC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgPSBpbnB1dDtcblx0XHQkLmRhdGVwaWNrZXIuX3NldERhdGVGcm9tRmllbGQoIGluc3QgKTtcblxuXHRcdGlmICggJC5kYXRlcGlja2VyLl9pbkRpYWxvZyApIHsgLy8gaGlkZSBjdXJzb3Jcblx0XHRcdGlucHV0LnZhbHVlID0gXCJcIjtcblx0XHR9XG5cdFx0aWYgKCAhJC5kYXRlcGlja2VyLl9wb3MgKSB7IC8vIHBvc2l0aW9uIGJlbG93IGlucHV0XG5cdFx0XHQkLmRhdGVwaWNrZXIuX3BvcyA9ICQuZGF0ZXBpY2tlci5fZmluZFBvcyggaW5wdXQgKTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zWyAxIF0gKz0gaW5wdXQub2Zmc2V0SGVpZ2h0OyAvLyBhZGQgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdGlzRml4ZWQgPSBmYWxzZTtcblx0XHQkKCBpbnB1dCApLnBhcmVudHMoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlzRml4ZWQgfD0gJCggdGhpcyApLmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIjtcblx0XHRcdHJldHVybiAhaXNGaXhlZDtcblx0XHR9ICk7XG5cblx0XHRvZmZzZXQgPSB7IGxlZnQ6ICQuZGF0ZXBpY2tlci5fcG9zWyAwIF0sIHRvcDogJC5kYXRlcGlja2VyLl9wb3NbIDEgXSB9O1xuXHRcdCQuZGF0ZXBpY2tlci5fcG9zID0gbnVsbDtcblxuXHRcdC8vdG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94XG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHNpemluZyBvZmZzY3JlZW5cblx0XHRpbnN0LmRwRGl2LmNzcyggeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCBkaXNwbGF5OiBcImJsb2NrXCIsIHRvcDogXCItMTAwMHB4XCIgfSApO1xuXHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlciggaW5zdCApO1xuXG5cdFx0Ly8gZml4IHdpZHRoIGZvciBkeW5hbWljIG51bWJlciBvZiBkYXRlIHBpY2tlcnNcblx0XHQvLyBhbmQgYWRqdXN0IHBvc2l0aW9uIGJlZm9yZSBzaG93aW5nXG5cdFx0b2Zmc2V0ID0gJC5kYXRlcGlja2VyLl9jaGVja09mZnNldCggaW5zdCwgb2Zmc2V0LCBpc0ZpeGVkICk7XG5cdFx0aW5zdC5kcERpdi5jc3MoIHsgcG9zaXRpb246ICggJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkgP1xuXHRcdFx0XCJzdGF0aWNcIiA6ICggaXNGaXhlZCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIiApICksIGRpc3BsYXk6IFwibm9uZVwiLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgKyBcInB4XCIsIHRvcDogb2Zmc2V0LnRvcCArIFwicHhcIiB9ICk7XG5cblx0XHRpZiAoICFpbnN0LmlubGluZSApIHtcblx0XHRcdHNob3dBbmltID0gJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwic2hvd0FuaW1cIiApO1xuXHRcdFx0ZHVyYXRpb24gPSAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJkdXJhdGlvblwiICk7XG5cdFx0XHRpbnN0LmRwRGl2LmNzcyggXCJ6LWluZGV4XCIsIGRhdGVwaWNrZXJfZ2V0WmluZGV4KCAkKCBpbnB1dCApICkgKyAxICk7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSApIHtcblx0XHRcdFx0aW5zdC5kcERpdi5zaG93KCBzaG93QW5pbSwgJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwic2hvd09wdGlvbnNcIiApLCBkdXJhdGlvbiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5zdC5kcERpdlsgc2hvd0FuaW0gfHwgXCJzaG93XCIgXSggc2hvd0FuaW0gPyBkdXJhdGlvbiA6IG51bGwgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoIGluc3QgKSApIHtcblx0XHRcdFx0aW5zdC5pbnB1dC50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0ID0gaW5zdDtcblx0XHR9XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIGRhdGUgcGlja2VyIGNvbnRlbnQuICovXG5cdF91cGRhdGVEYXRlcGlja2VyOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHR0aGlzLm1heFJvd3MgPSA0OyAvL1Jlc2V0IHRoZSBtYXggbnVtYmVyIG9mIHJvd3MgYmVpbmcgZGlzcGxheWVkIChzZWUgIzcwNDMpXG5cdFx0ZGF0ZXBpY2tlcl9pbnN0QWN0aXZlID0gaW5zdDsgLy8gZm9yIGRlbGVnYXRlIGhvdmVyIGV2ZW50c1xuXHRcdGluc3QuZHBEaXYuZW1wdHkoKS5hcHBlbmQoIHRoaXMuX2dlbmVyYXRlSFRNTCggaW5zdCApICk7XG5cdFx0dGhpcy5fYXR0YWNoSGFuZGxlcnMoIGluc3QgKTtcblxuXHRcdHZhciBvcmlneWVhcnNodG1sLFxuXHRcdFx0bnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoIGluc3QgKSxcblx0XHRcdGNvbHMgPSBudW1Nb250aHNbIDEgXSxcblx0XHRcdHdpZHRoID0gMTcsXG5cdFx0XHRhY3RpdmVDZWxsID0gaW5zdC5kcERpdi5maW5kKCBcIi5cIiArIHRoaXMuX2RheU92ZXJDbGFzcyArIFwiIGFcIiApO1xuXG5cdFx0aWYgKCBhY3RpdmVDZWxsLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRkYXRlcGlja2VyX2hhbmRsZU1vdXNlb3Zlci5hcHBseSggYWN0aXZlQ2VsbC5nZXQoIDAgKSApO1xuXHRcdH1cblxuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3MoIFwidWktZGF0ZXBpY2tlci1tdWx0aS0yIHVpLWRhdGVwaWNrZXItbXVsdGktMyB1aS1kYXRlcGlja2VyLW11bHRpLTRcIiApLndpZHRoKCBcIlwiICk7XG5cdFx0aWYgKCBjb2xzID4gMSApIHtcblx0XHRcdGluc3QuZHBEaXYuYWRkQ2xhc3MoIFwidWktZGF0ZXBpY2tlci1tdWx0aS1cIiArIGNvbHMgKS5jc3MoIFwid2lkdGhcIiwgKCB3aWR0aCAqIGNvbHMgKSArIFwiZW1cIiApO1xuXHRcdH1cblx0XHRpbnN0LmRwRGl2WyAoIG51bU1vbnRoc1sgMCBdICE9PSAxIHx8IG51bU1vbnRoc1sgMSBdICE9PSAxID8gXCJhZGRcIiA6IFwicmVtb3ZlXCIgKSArXG5cdFx0XHRcIkNsYXNzXCIgXSggXCJ1aS1kYXRlcGlja2VyLW11bHRpXCIgKTtcblx0XHRpbnN0LmRwRGl2WyAoIHRoaXMuX2dldCggaW5zdCwgXCJpc1JUTFwiICkgPyBcImFkZFwiIDogXCJyZW1vdmVcIiApICtcblx0XHRcdFwiQ2xhc3NcIiBdKCBcInVpLWRhdGVwaWNrZXItcnRsXCIgKTtcblxuXHRcdGlmICggaW5zdCA9PT0gJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KCBpbnN0ICkgKSB7XG5cdFx0XHRpbnN0LmlucHV0LnRyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdH1cblxuXHRcdC8vIERlZmZlcmVkIHJlbmRlciBvZiB0aGUgeWVhcnMgc2VsZWN0ICh0byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3gpXG5cdFx0aWYgKCBpbnN0LnllYXJzaHRtbCApIHtcblx0XHRcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vYXNzdXJlIHRoYXQgaW5zdC55ZWFyc2h0bWwgZGlkbid0IGNoYW5nZS5cblx0XHRcdFx0aWYgKCBvcmlneWVhcnNodG1sID09PSBpbnN0LnllYXJzaHRtbCAmJiBpbnN0LnllYXJzaHRtbCApIHtcblx0XHRcdFx0XHRpbnN0LmRwRGl2LmZpbmQoIFwic2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhcjpmaXJzdFwiICkucmVwbGFjZVdpdGgoIGluc3QueWVhcnNodG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3JpZ3llYXJzaHRtbCA9IGluc3QueWVhcnNodG1sID0gbnVsbDtcblx0XHRcdH0sIDAgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gIzY2OTQgLSBkb24ndCBmb2N1cyB0aGUgaW5wdXQgaWYgaXQncyBhbHJlYWR5IGZvY3VzZWRcblx0Ly8gdGhpcyBicmVha3MgdGhlIGNoYW5nZSBldmVudCBpbiBJRVxuXHQvLyBTdXBwb3J0OiBJRSBhbmQgalF1ZXJ5IDwxLjlcblx0X3Nob3VsZEZvY3VzSW5wdXQ6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHJldHVybiBpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQuaXMoIFwiOnZpc2libGVcIiApICYmICFpbnN0LmlucHV0LmlzKCBcIjpkaXNhYmxlZFwiICkgJiYgIWluc3QuaW5wdXQuaXMoIFwiOmZvY3VzXCIgKTtcblx0fSxcblxuXHQvKiBDaGVjayBwb3NpdGlvbmluZyB0byByZW1haW4gb24gc2NyZWVuLiAqL1xuXHRfY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKCBpbnN0LCBvZmZzZXQsIGlzRml4ZWQgKSB7XG5cdFx0dmFyIGRwV2lkdGggPSBpbnN0LmRwRGl2Lm91dGVyV2lkdGgoKSxcblx0XHRcdGRwSGVpZ2h0ID0gaW5zdC5kcERpdi5vdXRlckhlaWdodCgpLFxuXHRcdFx0aW5wdXRXaWR0aCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0Lm91dGVyV2lkdGgoKSA6IDAsXG5cdFx0XHRpbnB1dEhlaWdodCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0Lm91dGVySGVpZ2h0KCkgOiAwLFxuXHRcdFx0dmlld1dpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoICsgKCBpc0ZpeGVkID8gMCA6ICQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdCgpICksXG5cdFx0XHR2aWV3SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCArICggaXNGaXhlZCA/IDAgOiAkKCBkb2N1bWVudCApLnNjcm9sbFRvcCgpICk7XG5cblx0XHRvZmZzZXQubGVmdCAtPSAoIHRoaXMuX2dldCggaW5zdCwgXCJpc1JUTFwiICkgPyAoIGRwV2lkdGggLSBpbnB1dFdpZHRoICkgOiAwICk7XG5cdFx0b2Zmc2V0LmxlZnQgLT0gKCBpc0ZpeGVkICYmIG9mZnNldC5sZWZ0ID09PSBpbnN0LmlucHV0Lm9mZnNldCgpLmxlZnQgKSA/ICQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdCgpIDogMDtcblx0XHRvZmZzZXQudG9wIC09ICggaXNGaXhlZCAmJiBvZmZzZXQudG9wID09PSAoIGluc3QuaW5wdXQub2Zmc2V0KCkudG9wICsgaW5wdXRIZWlnaHQgKSApID8gJCggZG9jdW1lbnQgKS5zY3JvbGxUb3AoKSA6IDA7XG5cblx0XHQvLyBOb3cgY2hlY2sgaWYgZGF0ZXBpY2tlciBpcyBzaG93aW5nIG91dHNpZGUgd2luZG93IHZpZXdwb3J0IC0gbW92ZSB0byBhIGJldHRlciBwbGFjZSBpZiBzby5cblx0XHRvZmZzZXQubGVmdCAtPSBNYXRoLm1pbiggb2Zmc2V0LmxlZnQsICggb2Zmc2V0LmxlZnQgKyBkcFdpZHRoID4gdmlld1dpZHRoICYmIHZpZXdXaWR0aCA+IGRwV2lkdGggKSA/XG5cdFx0XHRNYXRoLmFicyggb2Zmc2V0LmxlZnQgKyBkcFdpZHRoIC0gdmlld1dpZHRoICkgOiAwICk7XG5cdFx0b2Zmc2V0LnRvcCAtPSBNYXRoLm1pbiggb2Zmc2V0LnRvcCwgKCBvZmZzZXQudG9wICsgZHBIZWlnaHQgPiB2aWV3SGVpZ2h0ICYmIHZpZXdIZWlnaHQgPiBkcEhlaWdodCApID9cblx0XHRcdE1hdGguYWJzKCBkcEhlaWdodCArIGlucHV0SGVpZ2h0ICkgOiAwICk7XG5cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9LFxuXG5cdC8qIEZpbmQgYW4gb2JqZWN0J3MgcG9zaXRpb24gb24gdGhlIHNjcmVlbi4gKi9cblx0X2ZpbmRQb3M6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHBvc2l0aW9uLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QoIG9iaiApLFxuXHRcdFx0aXNSVEwgPSB0aGlzLl9nZXQoIGluc3QsIFwiaXNSVExcIiApO1xuXG5cdFx0d2hpbGUgKCBvYmogJiYgKCBvYmoudHlwZSA9PT0gXCJoaWRkZW5cIiB8fCBvYmoubm9kZVR5cGUgIT09IDEgfHwgJC5leHByLmZpbHRlcnMuaGlkZGVuKCBvYmogKSApICkge1xuXHRcdFx0b2JqID0gb2JqWyBpc1JUTCA/IFwicHJldmlvdXNTaWJsaW5nXCIgOiBcIm5leHRTaWJsaW5nXCIgXTtcblx0XHR9XG5cblx0XHRwb3NpdGlvbiA9ICQoIG9iaiApLm9mZnNldCgpO1xuXHRcdHJldHVybiBbIHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcCBdO1xuXHR9LFxuXG5cdC8qIEhpZGUgdGhlIGRhdGUgcGlja2VyIGZyb20gdmlldy5cblx0ICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXJcblx0ICovXG5cdF9oaWRlRGF0ZXBpY2tlcjogZnVuY3Rpb24oIGlucHV0ICkge1xuXHRcdHZhciBzaG93QW5pbSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzLCBvbkNsb3NlLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2N1ckluc3Q7XG5cblx0XHRpZiAoICFpbnN0IHx8ICggaW5wdXQgJiYgaW5zdCAhPT0gJC5kYXRhKCBpbnB1dCwgXCJkYXRlcGlja2VyXCIgKSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fZGF0ZXBpY2tlclNob3dpbmcgKSB7XG5cdFx0XHRzaG93QW5pbSA9IHRoaXMuX2dldCggaW5zdCwgXCJzaG93QW5pbVwiICk7XG5cdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2dldCggaW5zdCwgXCJkdXJhdGlvblwiICk7XG5cdFx0XHRwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX3RpZHlEaWFsb2coIGluc3QgKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIERFUFJFQ0FURUQ6IGFmdGVyIEJDIGZvciAxLjgueCAkLmVmZmVjdHNbIHNob3dBbmltIF0gaXMgbm90IG5lZWRlZFxuXHRcdFx0aWYgKCAkLmVmZmVjdHMgJiYgKCAkLmVmZmVjdHMuZWZmZWN0WyBzaG93QW5pbSBdIHx8ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSApICkge1xuXHRcdFx0XHRpbnN0LmRwRGl2LmhpZGUoIHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzaG93T3B0aW9uc1wiICksIGR1cmF0aW9uLCBwb3N0UHJvY2VzcyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5zdC5kcERpdlsgKCBzaG93QW5pbSA9PT0gXCJzbGlkZURvd25cIiA/IFwic2xpZGVVcFwiIDpcblx0XHRcdFx0XHQoIHNob3dBbmltID09PSBcImZhZGVJblwiID8gXCJmYWRlT3V0XCIgOiBcImhpZGVcIiApICkgXSggKCBzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCApLCBwb3N0UHJvY2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFzaG93QW5pbSApIHtcblx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7XG5cblx0XHRcdG9uQ2xvc2UgPSB0aGlzLl9nZXQoIGluc3QsIFwib25DbG9zZVwiICk7XG5cdFx0XHRpZiAoIG9uQ2xvc2UgKSB7XG5cdFx0XHRcdG9uQ2xvc2UuYXBwbHkoICggaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbIDAgXSA6IG51bGwgKSwgWyAoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogXCJcIiApLCBpbnN0IF0gKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gbnVsbDtcblx0XHRcdGlmICggdGhpcy5faW5EaWFsb2cgKSB7XG5cdFx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmNzcyggeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCBsZWZ0OiBcIjBcIiwgdG9wOiBcIi0xMDBweFwiIH0gKTtcblx0XHRcdFx0aWYgKCAkLmJsb2NrVUkgKSB7XG5cdFx0XHRcdFx0JC51bmJsb2NrVUkoKTtcblx0XHRcdFx0XHQkKCBcImJvZHlcIiApLmFwcGVuZCggdGhpcy5kcERpdiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHQvKiBUaWR5IHVwIGFmdGVyIGEgZGlhbG9nIGRpc3BsYXkuICovXG5cdF90aWR5RGlhbG9nOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHRpbnN0LmRwRGl2LnJlbW92ZUNsYXNzKCB0aGlzLl9kaWFsb2dDbGFzcyApLm9mZiggXCIudWktZGF0ZXBpY2tlci1jYWxlbmRhclwiICk7XG5cdH0sXG5cblx0LyogQ2xvc2UgZGF0ZSBwaWNrZXIgaWYgY2xpY2tlZCBlbHNld2hlcmUuICovXG5cdF9jaGVja0V4dGVybmFsQ2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICEkLmRhdGVwaWNrZXIuX2N1ckluc3QgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyICR0YXJnZXQgPSAkKCBldmVudC50YXJnZXQgKSxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoICR0YXJnZXRbIDAgXSApO1xuXG5cdFx0aWYgKCAoICggJHRhcmdldFsgMCBdLmlkICE9PSAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCAmJlxuXHRcdFx0XHQkdGFyZ2V0LnBhcmVudHMoIFwiI1wiICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQgKS5sZW5ndGggPT09IDAgJiZcblx0XHRcdFx0ISR0YXJnZXQuaGFzQ2xhc3MoICQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUgKSAmJlxuXHRcdFx0XHQhJHRhcmdldC5jbG9zZXN0KCBcIi5cIiArICQuZGF0ZXBpY2tlci5fdHJpZ2dlckNsYXNzICkubGVuZ3RoICYmXG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgISggJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkgKSApICkgfHxcblx0XHRcdCggJHRhcmdldC5oYXNDbGFzcyggJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSApICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCApICkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdERhdGU6IGZ1bmN0aW9uKCBpZCwgb2Zmc2V0LCBwZXJpb2QgKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoIGlkICksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0WyAwIF0gKTtcblxuXHRcdGlmICggdGhpcy5faXNEaXNhYmxlZERhdGVwaWNrZXIoIHRhcmdldFsgMCBdICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKCBpbnN0LCBvZmZzZXQgK1xuXHRcdFx0KCBwZXJpb2QgPT09IFwiTVwiID8gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dDdXJyZW50QXRQb3NcIiApIDogMCApLCAvLyB1bmRvIHBvc2l0aW9uaW5nXG5cdFx0XHRwZXJpb2QgKTtcblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBjdXJyZW50IGxpbmsuICovXG5cdF9nb3RvVG9kYXk6IGZ1bmN0aW9uKCBpZCApIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdHRhcmdldCA9ICQoIGlkICksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0WyAwIF0gKTtcblxuXHRcdGlmICggdGhpcy5fZ2V0KCBpbnN0LCBcImdvdG9DdXJyZW50XCIgKSAmJiBpbnN0LmN1cnJlbnREYXkgKSB7XG5cdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5O1xuXHRcdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aDtcblx0XHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0fVxuXHRcdHRoaXMuX25vdGlmeUNoYW5nZSggaW5zdCApO1xuXHRcdHRoaXMuX2FkanVzdERhdGUoIHRhcmdldCApO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3Igc2VsZWN0aW5nIGEgbmV3IG1vbnRoL3llYXIuICovXG5cdF9zZWxlY3RNb250aFllYXI6IGZ1bmN0aW9uKCBpZCwgc2VsZWN0LCBwZXJpb2QgKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoIGlkICksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0WyAwIF0gKTtcblxuXHRcdGluc3RbIFwic2VsZWN0ZWRcIiArICggcGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiICkgXSA9XG5cdFx0aW5zdFsgXCJkcmF3XCIgKyAoIHBlcmlvZCA9PT0gXCJNXCIgPyBcIk1vbnRoXCIgOiBcIlllYXJcIiApIF0gPVxuXHRcdFx0cGFyc2VJbnQoIHNlbGVjdC5vcHRpb25zWyBzZWxlY3Quc2VsZWN0ZWRJbmRleCBdLnZhbHVlLCAxMCApO1xuXG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKCBpbnN0ICk7XG5cdFx0dGhpcy5fYWRqdXN0RGF0ZSggdGFyZ2V0ICk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBkYXkuICovXG5cdF9zZWxlY3REYXk6IGZ1bmN0aW9uKCBpZCwgbW9udGgsIHllYXIsIHRkICkge1xuXHRcdHZhciBpbnN0LFxuXHRcdFx0dGFyZ2V0ID0gJCggaWQgKTtcblxuXHRcdGlmICggJCggdGQgKS5oYXNDbGFzcyggdGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgKSB8fCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggdGFyZ2V0WyAwIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0WyAwIF0gKTtcblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gJCggXCJhXCIsIHRkICkuaHRtbCgpO1xuXHRcdGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbW9udGg7XG5cdFx0aW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0geWVhcjtcblx0XHR0aGlzLl9zZWxlY3REYXRlKCBpZCwgdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCxcblx0XHRcdGluc3QuY3VycmVudERheSwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudFllYXIgKSApO1xuXHR9LFxuXG5cdC8qIEVyYXNlIHRoZSBpbnB1dCBmaWVsZCBhbmQgaGlkZSB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9jbGVhckRhdGU6IGZ1bmN0aW9uKCBpZCApIHtcblx0XHR2YXIgdGFyZ2V0ID0gJCggaWQgKTtcblx0XHR0aGlzLl9zZWxlY3REYXRlKCB0YXJnZXQsIFwiXCIgKTtcblx0fSxcblxuXHQvKiBVcGRhdGUgdGhlIGlucHV0IGZpZWxkIHdpdGggdGhlIHNlbGVjdGVkIGRhdGUuICovXG5cdF9zZWxlY3REYXRlOiBmdW5jdGlvbiggaWQsIGRhdGVTdHIgKSB7XG5cdFx0dmFyIG9uU2VsZWN0LFxuXHRcdFx0dGFyZ2V0ID0gJCggaWQgKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXG5cdFx0ZGF0ZVN0ciA9ICggZGF0ZVN0ciAhPSBudWxsID8gZGF0ZVN0ciA6IHRoaXMuX2Zvcm1hdERhdGUoIGluc3QgKSApO1xuXHRcdGlmICggaW5zdC5pbnB1dCApIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKCBkYXRlU3RyICk7XG5cdFx0fVxuXHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZSggaW5zdCApO1xuXG5cdFx0b25TZWxlY3QgPSB0aGlzLl9nZXQoIGluc3QsIFwib25TZWxlY3RcIiApO1xuXHRcdGlmICggb25TZWxlY3QgKSB7XG5cdFx0XHRvblNlbGVjdC5hcHBseSggKCBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFsgMCBdIDogbnVsbCApLCBbIGRhdGVTdHIsIGluc3QgXSApOyAgLy8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHR9IGVsc2UgaWYgKCBpbnN0LmlucHV0ICkge1xuXHRcdFx0aW5zdC5pbnB1dC50cmlnZ2VyKCBcImNoYW5nZVwiICk7IC8vIGZpcmUgdGhlIGNoYW5nZSBldmVudFxuXHRcdH1cblxuXHRcdGlmICggaW5zdC5pbmxpbmUgKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBpbnN0LmlucHV0WyAwIF07XG5cdFx0XHRpZiAoIHR5cGVvZiggaW5zdC5pbnB1dFsgMCBdICkgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGluc3QuaW5wdXQudHJpZ2dlciggXCJmb2N1c1wiICk7IC8vIHJlc3RvcmUgZm9jdXNcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBhbnkgYWx0ZXJuYXRlIGZpZWxkIHRvIHN5bmNocm9uaXNlIHdpdGggdGhlIG1haW4gZmllbGQuICovXG5cdF91cGRhdGVBbHRlcm5hdGU6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHZhciBhbHRGb3JtYXQsIGRhdGUsIGRhdGVTdHIsXG5cdFx0XHRhbHRGaWVsZCA9IHRoaXMuX2dldCggaW5zdCwgXCJhbHRGaWVsZFwiICk7XG5cblx0XHRpZiAoIGFsdEZpZWxkICkgeyAvLyB1cGRhdGUgYWx0ZXJuYXRlIGZpZWxkIHRvb1xuXHRcdFx0YWx0Rm9ybWF0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImFsdEZvcm1hdFwiICkgfHwgdGhpcy5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApO1xuXHRcdFx0ZGF0ZSA9IHRoaXMuX2dldERhdGUoIGluc3QgKTtcblx0XHRcdGRhdGVTdHIgPSB0aGlzLmZvcm1hdERhdGUoIGFsdEZvcm1hdCwgZGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKCBpbnN0ICkgKTtcblx0XHRcdCQoIGFsdEZpZWxkICkudmFsKCBkYXRlU3RyICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFNldCBhcyBiZWZvcmVTaG93RGF5IGZ1bmN0aW9uIHRvIHByZXZlbnQgc2VsZWN0aW9uIG9mIHdlZWtlbmRzLlxuXHQgKiBAcGFyYW0gIGRhdGUgIERhdGUgLSB0aGUgZGF0ZSB0byBjdXN0b21pc2Vcblx0ICogQHJldHVybiBbYm9vbGVhbiwgc3RyaW5nXSAtIGlzIHRoaXMgZGF0ZSBzZWxlY3RhYmxlPywgd2hhdCBpcyBpdHMgQ1NTIGNsYXNzP1xuXHQgKi9cblx0bm9XZWVrZW5kczogZnVuY3Rpb24oIGRhdGUgKSB7XG5cdFx0dmFyIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG5cdFx0cmV0dXJuIFsgKCBkYXkgPiAwICYmIGRheSA8IDYgKSwgXCJcIiBdO1xuXHR9LFxuXG5cdC8qIFNldCBhcyBjYWxjdWxhdGVXZWVrIHRvIGRldGVybWluZSB0aGUgd2VlayBvZiB0aGUgeWVhciBiYXNlZCBvbiB0aGUgSVNPIDg2MDEgZGVmaW5pdGlvbi5cblx0ICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gZ2V0IHRoZSB3ZWVrIGZvclxuXHQgKiBAcmV0dXJuICBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIHdpdGhpbiB0aGUgeWVhciB0aGF0IGNvbnRhaW5zIHRoaXMgZGF0ZVxuXHQgKi9cblx0aXNvODYwMVdlZWs6IGZ1bmN0aW9uKCBkYXRlICkge1xuXHRcdHZhciB0aW1lLFxuXHRcdFx0Y2hlY2tEYXRlID0gbmV3IERhdGUoIGRhdGUuZ2V0VGltZSgpICk7XG5cblx0XHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcblx0XHRjaGVja0RhdGUuc2V0RGF0ZSggY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoIGNoZWNrRGF0ZS5nZXREYXkoKSB8fCA3ICkgKTtcblxuXHRcdHRpbWUgPSBjaGVja0RhdGUuZ2V0VGltZSgpO1xuXHRcdGNoZWNrRGF0ZS5zZXRNb250aCggMCApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcblx0XHRjaGVja0RhdGUuc2V0RGF0ZSggMSApO1xuXHRcdHJldHVybiBNYXRoLmZsb29yKCBNYXRoLnJvdW5kKCAoIHRpbWUgLSBjaGVja0RhdGUgKSAvIDg2NDAwMDAwICkgLyA3ICkgKyAxO1xuXHR9LFxuXG5cdC8qIFBhcnNlIGEgc3RyaW5nIHZhbHVlIGludG8gYSBkYXRlIG9iamVjdC5cblx0ICogU2VlIGZvcm1hdERhdGUgYmVsb3cgZm9yIHRoZSBwb3NzaWJsZSBmb3JtYXRzLlxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSBkYXRlXG5cdCAqIEBwYXJhbSAgdmFsdWUgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKiBAcGFyYW0gIHNldHRpbmdzIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0ICpcdFx0XHRcdFx0c2hvcnRZZWFyQ3V0b2ZmICBudW1iZXIgLSB0aGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNTaG9ydFx0c3RyaW5nWzddIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1x0XHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNcdFx0c3RyaW5nWzEyXSAtIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKiBAcmV0dXJuICBEYXRlIC0gdGhlIGV4dHJhY3RlZCBkYXRlIHZhbHVlIG9yIG51bGwgaWYgdmFsdWUgaXMgYmxhbmtcblx0ICovXG5cdHBhcnNlRGF0ZTogZnVuY3Rpb24oIGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzICkge1xuXHRcdGlmICggZm9ybWF0ID09IG51bGwgfHwgdmFsdWUgPT0gbnVsbCApIHtcblx0XHRcdHRocm93IFwiSW52YWxpZCBhcmd1bWVudHNcIjtcblx0XHR9XG5cblx0XHR2YWx1ZSA9ICggdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlICsgXCJcIiApO1xuXHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgaUZvcm1hdCwgZGltLCBleHRyYSxcblx0XHRcdGlWYWx1ZSA9IDAsXG5cdFx0XHRzaG9ydFllYXJDdXRvZmZUZW1wID0gKCBzZXR0aW5ncyA/IHNldHRpbmdzLnNob3J0WWVhckN1dG9mZiA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5zaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRzaG9ydFllYXJDdXRvZmYgPSAoIHR5cGVvZiBzaG9ydFllYXJDdXRvZmZUZW1wICE9PSBcInN0cmluZ1wiID8gc2hvcnRZZWFyQ3V0b2ZmVGVtcCA6XG5cdFx0XHRcdG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArIHBhcnNlSW50KCBzaG9ydFllYXJDdXRvZmZUZW1wLCAxMCApICksXG5cdFx0XHRkYXlOYW1lc1Nob3J0ID0gKCBzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsICkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXNTaG9ydCxcblx0XHRcdGRheU5hbWVzID0gKCBzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzLFxuXHRcdFx0bW9udGhOYW1lc1Nob3J0ID0gKCBzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQsXG5cdFx0XHRtb250aE5hbWVzID0gKCBzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsICkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lcyxcblx0XHRcdHllYXIgPSAtMSxcblx0XHRcdG1vbnRoID0gLTEsXG5cdFx0XHRkYXkgPSAtMSxcblx0XHRcdGRveSA9IC0xLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlLFxuXHRcdFx0ZGF0ZSxcblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICggaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKyAxICkgPT09IG1hdGNoICk7XG5cdFx0XHRcdGlmICggbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBFeHRyYWN0IGEgbnVtYmVyIGZyb20gdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0Z2V0TnVtYmVyID0gZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHR2YXIgaXNEb3VibGVkID0gbG9va0FoZWFkKCBtYXRjaCApLFxuXHRcdFx0XHRcdHNpemUgPSAoIG1hdGNoID09PSBcIkBcIiA/IDE0IDogKCBtYXRjaCA9PT0gXCIhXCIgPyAyMCA6XG5cdFx0XHRcdFx0KCBtYXRjaCA9PT0gXCJ5XCIgJiYgaXNEb3VibGVkID8gNCA6ICggbWF0Y2ggPT09IFwib1wiID8gMyA6IDIgKSApICkgKSxcblx0XHRcdFx0XHRtaW5TaXplID0gKCBtYXRjaCA9PT0gXCJ5XCIgPyBzaXplIDogMSApLFxuXHRcdFx0XHRcdGRpZ2l0cyA9IG5ldyBSZWdFeHAoIFwiXlxcXFxke1wiICsgbWluU2l6ZSArIFwiLFwiICsgc2l6ZSArIFwifVwiICksXG5cdFx0XHRcdFx0bnVtID0gdmFsdWUuc3Vic3RyaW5nKCBpVmFsdWUgKS5tYXRjaCggZGlnaXRzICk7XG5cdFx0XHRcdGlmICggIW51bSApIHtcblx0XHRcdFx0XHR0aHJvdyBcIk1pc3NpbmcgbnVtYmVyIGF0IHBvc2l0aW9uIFwiICsgaVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlWYWx1ZSArPSBudW1bIDAgXS5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBwYXJzZUludCggbnVtWyAwIF0sIDEwICk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBFeHRyYWN0IGEgbmFtZSBmcm9tIHRoZSBzdHJpbmcgdmFsdWUgYW5kIGNvbnZlcnQgdG8gYW4gaW5kZXhcblx0XHRcdGdldE5hbWUgPSBmdW5jdGlvbiggbWF0Y2gsIHNob3J0TmFtZXMsIGxvbmdOYW1lcyApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gLTEsXG5cdFx0XHRcdFx0bmFtZXMgPSAkLm1hcCggbG9va0FoZWFkKCBtYXRjaCApID8gbG9uZ05hbWVzIDogc2hvcnROYW1lcywgZnVuY3Rpb24oIHYsIGsgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBbIGssIHYgXSBdO1xuXHRcdFx0XHRcdH0gKS5zb3J0KCBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdFx0XHRcdHJldHVybiAtKCBhWyAxIF0ubGVuZ3RoIC0gYlsgMSBdLmxlbmd0aCApO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQkLmVhY2goIG5hbWVzLCBmdW5jdGlvbiggaSwgcGFpciApIHtcblx0XHRcdFx0XHR2YXIgbmFtZSA9IHBhaXJbIDEgXTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlLnN1YnN0ciggaVZhbHVlLCBuYW1lLmxlbmd0aCApLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gcGFpclsgMCBdO1xuXHRcdFx0XHRcdFx0aVZhbHVlICs9IG5hbWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5kZXggKyAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBuYW1lIGF0IHBvc2l0aW9uIFwiICsgaVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDb25maXJtIHRoYXQgYSBsaXRlcmFsIGNoYXJhY3RlciBtYXRjaGVzIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHZhbHVlLmNoYXJBdCggaVZhbHVlICkgIT09IGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSApIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVuZXhwZWN0ZWQgbGl0ZXJhbCBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUrKztcblx0XHRcdH07XG5cblx0XHRmb3IgKCBpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKyApIHtcblx0XHRcdGlmICggbGl0ZXJhbCApIHtcblx0XHRcdFx0aWYgKCBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICkgPT09IFwiJ1wiICYmICFsb29rQWhlYWQoIFwiJ1wiICkgKSB7XG5cdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzd2l0Y2ggKCBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICkgKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0XHRcdGRheSA9IGdldE51bWJlciggXCJkXCIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJEXCI6XG5cdFx0XHRcdFx0XHRnZXROYW1lKCBcIkRcIiwgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRkb3kgPSBnZXROdW1iZXIoIFwib1wiICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibVwiOlxuXHRcdFx0XHRcdFx0bW9udGggPSBnZXROdW1iZXIoIFwibVwiICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiTVwiOlxuXHRcdFx0XHRcdFx0bW9udGggPSBnZXROYW1lKCBcIk1cIiwgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHRcdFx0eWVhciA9IGdldE51bWJlciggXCJ5XCIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJAXCI6XG5cdFx0XHRcdFx0XHRkYXRlID0gbmV3IERhdGUoIGdldE51bWJlciggXCJAXCIgKSApO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIiFcIjpcblx0XHRcdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSggKCBnZXROdW1iZXIoIFwiIVwiICkgLSB0aGlzLl90aWNrc1RvMTk3MCApIC8gMTAwMDAgKTtcblx0XHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG5cdFx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAoIGxvb2tBaGVhZCggXCInXCIgKSApIHtcblx0XHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggaVZhbHVlIDwgdmFsdWUubGVuZ3RoICkge1xuXHRcdFx0ZXh0cmEgPSB2YWx1ZS5zdWJzdHIoIGlWYWx1ZSApO1xuXHRcdFx0aWYgKCAhL15cXHMrLy50ZXN0KCBleHRyYSApICkge1xuXHRcdFx0XHR0aHJvdyBcIkV4dHJhL3VucGFyc2VkIGNoYXJhY3RlcnMgZm91bmQgaW4gZGF0ZTogXCIgKyBleHRyYTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHllYXIgPT09IC0xICkge1xuXHRcdFx0eWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblx0XHR9IGVsc2UgaWYgKCB5ZWFyIDwgMTAwICkge1xuXHRcdFx0eWVhciArPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgK1xuXHRcdFx0XHQoIHllYXIgPD0gc2hvcnRZZWFyQ3V0b2ZmID8gMCA6IC0xMDAgKTtcblx0XHR9XG5cblx0XHRpZiAoIGRveSA+IC0xICkge1xuXHRcdFx0bW9udGggPSAxO1xuXHRcdFx0ZGF5ID0gZG95O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRkaW0gPSB0aGlzLl9nZXREYXlzSW5Nb250aCggeWVhciwgbW9udGggLSAxICk7XG5cdFx0XHRcdGlmICggZGF5IDw9IGRpbSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRtb250aCsrO1xuXHRcdFx0XHRkYXkgLT0gZGltO1xuXHRcdFx0fSB3aGlsZSAoIHRydWUgKTtcblx0XHR9XG5cblx0XHRkYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCB5ZWFyLCBtb250aCAtIDEsIGRheSApICk7XG5cdFx0aWYgKCBkYXRlLmdldEZ1bGxZZWFyKCkgIT09IHllYXIgfHwgZGF0ZS5nZXRNb250aCgpICsgMSAhPT0gbW9udGggfHwgZGF0ZS5nZXREYXRlKCkgIT09IGRheSApIHtcblx0XHRcdHRocm93IFwiSW52YWxpZCBkYXRlXCI7IC8vIEUuZy4gMzEvMDIvMDBcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH0sXG5cblx0LyogU3RhbmRhcmQgZGF0ZSBmb3JtYXRzLiAqL1xuXHRBVE9NOiBcInl5LW1tLWRkXCIsIC8vIFJGQyAzMzM5IChJU08gODYwMSlcblx0Q09PS0lFOiBcIkQsIGRkIE0geXlcIixcblx0SVNPXzg2MDE6IFwieXktbW0tZGRcIixcblx0UkZDXzgyMjogXCJELCBkIE0geVwiLFxuXHRSRkNfODUwOiBcIkRELCBkZC1NLXlcIixcblx0UkZDXzEwMzY6IFwiRCwgZCBNIHlcIixcblx0UkZDXzExMjM6IFwiRCwgZCBNIHl5XCIsXG5cdFJGQ18yODIyOiBcIkQsIGQgTSB5eVwiLFxuXHRSU1M6IFwiRCwgZCBNIHlcIiwgLy8gUkZDIDgyMlxuXHRUSUNLUzogXCIhXCIsXG5cdFRJTUVTVEFNUDogXCJAXCIsXG5cdFczQzogXCJ5eS1tbS1kZFwiLCAvLyBJU08gODYwMVxuXG5cdF90aWNrc1RvMTk3MDogKCAoICggMTk3MCAtIDEgKSAqIDM2NSArIE1hdGguZmxvb3IoIDE5NzAgLyA0ICkgLSBNYXRoLmZsb29yKCAxOTcwIC8gMTAwICkgK1xuXHRcdE1hdGguZmxvb3IoIDE5NzAgLyA0MDAgKSApICogMjQgKiA2MCAqIDYwICogMTAwMDAwMDAgKSxcblxuXHQvKiBGb3JtYXQgYSBkYXRlIG9iamVjdCBpbnRvIGEgc3RyaW5nIHZhbHVlLlxuXHQgKiBUaGUgZm9ybWF0IGNhbiBiZSBjb21iaW5hdGlvbnMgb2YgdGhlIGZvbGxvd2luZzpcblx0ICogZCAgLSBkYXkgb2YgbW9udGggKG5vIGxlYWRpbmcgemVybylcblx0ICogZGQgLSBkYXkgb2YgbW9udGggKHR3byBkaWdpdClcblx0ICogbyAgLSBkYXkgb2YgeWVhciAobm8gbGVhZGluZyB6ZXJvcylcblx0ICogb28gLSBkYXkgb2YgeWVhciAodGhyZWUgZGlnaXQpXG5cdCAqIEQgIC0gZGF5IG5hbWUgc2hvcnRcblx0ICogREQgLSBkYXkgbmFtZSBsb25nXG5cdCAqIG0gIC0gbW9udGggb2YgeWVhciAobm8gbGVhZGluZyB6ZXJvKVxuXHQgKiBtbSAtIG1vbnRoIG9mIHllYXIgKHR3byBkaWdpdClcblx0ICogTSAgLSBtb250aCBuYW1lIHNob3J0XG5cdCAqIE1NIC0gbW9udGggbmFtZSBsb25nXG5cdCAqIHkgIC0geWVhciAodHdvIGRpZ2l0KVxuXHQgKiB5eSAtIHllYXIgKGZvdXIgZGlnaXQpXG5cdCAqIEAgLSBVbml4IHRpbWVzdGFtcCAobXMgc2luY2UgMDEvMDEvMTk3MClcblx0ICogISAtIFdpbmRvd3MgdGlja3MgKDEwMG5zIHNpbmNlIDAxLzAxLzAwMDEpXG5cdCAqIFwiLi4uXCIgLSBsaXRlcmFsIHRleHRcblx0ICogJycgLSBzaW5nbGUgcXVvdGVcblx0ICpcblx0ICogQHBhcmFtICBmb3JtYXQgc3RyaW5nIC0gdGhlIGRlc2lyZWQgZm9ybWF0IG9mIHRoZSBkYXRlXG5cdCAqIEBwYXJhbSAgZGF0ZSBEYXRlIC0gdGhlIGRhdGUgdmFsdWUgdG8gZm9ybWF0XG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgT2JqZWN0IC0gYXR0cmlidXRlcyBpbmNsdWRlOlxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1Nob3J0XHRzdHJpbmdbN10gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzXHRcdHN0cmluZ1s3XSAtIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0bW9udGhOYW1lc1Nob3J0IHN0cmluZ1sxMl0gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0bW9udGhOYW1lc1x0XHRzdHJpbmdbMTJdIC0gbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqIEByZXR1cm4gIHN0cmluZyAtIHRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXRcblx0ICovXG5cdGZvcm1hdERhdGU6IGZ1bmN0aW9uKCBmb3JtYXQsIGRhdGUsIHNldHRpbmdzICkge1xuXHRcdGlmICggIWRhdGUgKSB7XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9XG5cblx0XHR2YXIgaUZvcm1hdCxcblx0XHRcdGRheU5hbWVzU2hvcnQgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxuXHRcdFx0ZGF5TmFtZXMgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXMgOiBudWxsICkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxcblx0XHRcdG1vbnRoTmFtZXMgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxuXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gKCBpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdCggaUZvcm1hdCArIDEgKSA9PT0gbWF0Y2ggKTtcblx0XHRcdFx0aWYgKCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdGlGb3JtYXQrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvcm1hdCBhIG51bWJlciwgd2l0aCBsZWFkaW5nIHplcm8gaWYgbmVjZXNzYXJ5XG5cdFx0XHRmb3JtYXROdW1iZXIgPSBmdW5jdGlvbiggbWF0Y2gsIHZhbHVlLCBsZW4gKSB7XG5cdFx0XHRcdHZhciBudW0gPSBcIlwiICsgdmFsdWU7XG5cdFx0XHRcdGlmICggbG9va0FoZWFkKCBtYXRjaCApICkge1xuXHRcdFx0XHRcdHdoaWxlICggbnVtLmxlbmd0aCA8IGxlbiApIHtcblx0XHRcdFx0XHRcdG51bSA9IFwiMFwiICsgbnVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVtO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9ybWF0IGEgbmFtZSwgc2hvcnQgb3IgbG9uZyBhcyByZXF1ZXN0ZWRcblx0XHRcdGZvcm1hdE5hbWUgPSBmdW5jdGlvbiggbWF0Y2gsIHZhbHVlLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMgKSB7XG5cdFx0XHRcdHJldHVybiAoIGxvb2tBaGVhZCggbWF0Y2ggKSA/IGxvbmdOYW1lc1sgdmFsdWUgXSA6IHNob3J0TmFtZXNbIHZhbHVlIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXG5cdFx0aWYgKCBkYXRlICkge1xuXHRcdFx0Zm9yICggaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KysgKSB7XG5cdFx0XHRcdGlmICggbGl0ZXJhbCApIHtcblx0XHRcdFx0XHRpZiAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZCggXCInXCIgKSApIHtcblx0XHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3dpdGNoICggZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApICkge1xuXHRcdFx0XHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlciggXCJkXCIsIGRhdGUuZ2V0RGF0ZSgpLCAyICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoIFwiRFwiLCBkYXRlLmdldERheSgpLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoIFwib1wiLFxuXHRcdFx0XHRcdFx0XHRcdE1hdGgucm91bmQoICggbmV3IERhdGUoIGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSApLmdldFRpbWUoKSAtIG5ldyBEYXRlKCBkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDAgKS5nZXRUaW1lKCkgKSAvIDg2NDAwMDAwICksIDMgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwibVwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKCBcIm1cIiwgZGF0ZS5nZXRNb250aCgpICsgMSwgMiApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROYW1lKCBcIk1cIiwgZGF0ZS5nZXRNb250aCgpLCBtb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXMgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gKCBsb29rQWhlYWQoIFwieVwiICkgPyBkYXRlLmdldEZ1bGxZZWFyKCkgOlxuXHRcdFx0XHRcdFx0XHRcdCggZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwIDwgMTAgPyBcIjBcIiA6IFwiXCIgKSArIGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJAXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmdldFRpbWUoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiIVwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZGF0ZS5nZXRUaW1lKCkgKiAxMDAwMCArIHRoaXMuX3RpY2tzVG8xOTcwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRcdGlmICggbG9va0FoZWFkKCBcIidcIiApICkge1xuXHRcdFx0XHRcdFx0XHRcdG91dHB1dCArPSBcIidcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH0sXG5cblx0LyogRXh0cmFjdCBhbGwgcG9zc2libGUgY2hhcmFjdGVycyBmcm9tIHRoZSBkYXRlIGZvcm1hdC4gKi9cblx0X3Bvc3NpYmxlQ2hhcnM6IGZ1bmN0aW9uKCBmb3JtYXQgKSB7XG5cdFx0dmFyIGlGb3JtYXQsXG5cdFx0XHRjaGFycyA9IFwiXCIsXG5cdFx0XHRsaXRlcmFsID0gZmFsc2UsXG5cblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHRcdGxvb2tBaGVhZCA9IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoIGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICsgMSApID09PSBtYXRjaCApO1xuXHRcdFx0XHRpZiAoIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrICkge1xuXHRcdFx0aWYgKCBsaXRlcmFsICkge1xuXHRcdFx0XHRpZiAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZCggXCInXCIgKSApIHtcblx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hhcnMgKz0gZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzd2l0Y2ggKCBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICkgKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImRcIjogY2FzZSBcIm1cIjogY2FzZSBcInlcIjogY2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdGNoYXJzICs9IFwiMDEyMzQ1Njc4OVwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkRcIjogY2FzZSBcIk1cIjpcblx0XHRcdFx0XHRcdHJldHVybiBudWxsOyAvLyBBY2NlcHQgYW55dGhpbmdcblx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRcdFx0aWYgKCBsb29rQWhlYWQoIFwiJ1wiICkgKSB7XG5cdFx0XHRcdFx0XHRcdGNoYXJzICs9IFwiJ1wiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjaGFycztcblx0fSxcblxuXHQvKiBHZXQgYSBzZXR0aW5nIHZhbHVlLCBkZWZhdWx0aW5nIGlmIG5lY2Vzc2FyeS4gKi9cblx0X2dldDogZnVuY3Rpb24oIGluc3QsIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGluc3Quc2V0dGluZ3NbIG5hbWUgXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGluc3Quc2V0dGluZ3NbIG5hbWUgXSA6IHRoaXMuX2RlZmF1bHRzWyBuYW1lIF07XG5cdH0sXG5cblx0LyogUGFyc2UgZXhpc3RpbmcgZGF0ZSBhbmQgaW5pdGlhbGlzZSBkYXRlIHBpY2tlci4gKi9cblx0X3NldERhdGVGcm9tRmllbGQ6IGZ1bmN0aW9uKCBpbnN0LCBub0RlZmF1bHQgKSB7XG5cdFx0aWYgKCBpbnN0LmlucHV0LnZhbCgpID09PSBpbnN0Lmxhc3RWYWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoIGluc3QsIFwiZGF0ZUZvcm1hdFwiICksXG5cdFx0XHRkYXRlcyA9IGluc3QubGFzdFZhbCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCxcblx0XHRcdGRlZmF1bHREYXRlID0gdGhpcy5fZ2V0RGVmYXVsdERhdGUoIGluc3QgKSxcblx0XHRcdGRhdGUgPSBkZWZhdWx0RGF0ZSxcblx0XHRcdHNldHRpbmdzID0gdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKCBpbnN0ICk7XG5cblx0XHR0cnkge1xuXHRcdFx0ZGF0ZSA9IHRoaXMucGFyc2VEYXRlKCBkYXRlRm9ybWF0LCBkYXRlcywgc2V0dGluZ3MgKSB8fCBkZWZhdWx0RGF0ZTtcblx0XHR9IGNhdGNoICggZXZlbnQgKSB7XG5cdFx0XHRkYXRlcyA9ICggbm9EZWZhdWx0ID8gXCJcIiA6IGRhdGVzICk7XG5cdFx0fVxuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0aW5zdC5jdXJyZW50RGF5ID0gKCBkYXRlcyA/IGRhdGUuZ2V0RGF0ZSgpIDogMCApO1xuXHRcdGluc3QuY3VycmVudE1vbnRoID0gKCBkYXRlcyA/IGRhdGUuZ2V0TW9udGgoKSA6IDAgKTtcblx0XHRpbnN0LmN1cnJlbnRZZWFyID0gKCBkYXRlcyA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6IDAgKTtcblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZSggaW5zdCApO1xuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkZWZhdWx0IGRhdGUgc2hvd24gb24gb3BlbmluZy4gKi9cblx0X2dldERlZmF1bHREYXRlOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVzdHJpY3RNaW5NYXgoIGluc3QsXG5cdFx0XHR0aGlzLl9kZXRlcm1pbmVEYXRlKCBpbnN0LCB0aGlzLl9nZXQoIGluc3QsIFwiZGVmYXVsdERhdGVcIiApLCBuZXcgRGF0ZSgpICkgKTtcblx0fSxcblxuXHQvKiBBIGRhdGUgbWF5IGJlIHNwZWNpZmllZCBhcyBhbiBleGFjdCB2YWx1ZSBvciBhIHJlbGF0aXZlIG9uZS4gKi9cblx0X2RldGVybWluZURhdGU6IGZ1bmN0aW9uKCBpbnN0LCBkYXRlLCBkZWZhdWx0RGF0ZSApIHtcblx0XHR2YXIgb2Zmc2V0TnVtZXJpYyA9IGZ1bmN0aW9uKCBvZmZzZXQgKSB7XG5cdFx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0ZGF0ZS5zZXREYXRlKCBkYXRlLmdldERhdGUoKSArIG9mZnNldCApO1xuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHRcdH0sXG5cdFx0XHRvZmZzZXRTdHJpbmcgPSBmdW5jdGlvbiggb2Zmc2V0ICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJkYXRlRm9ybWF0XCIgKSxcblx0XHRcdFx0XHRcdG9mZnNldCwgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vIElnbm9yZVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGRhdGUgPSAoIG9mZnNldC50b0xvd2VyQ2FzZSgpLm1hdGNoKCAvXmMvICkgP1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0RGF0ZSggaW5zdCApIDogbnVsbCApIHx8IG5ldyBEYXRlKCksXG5cdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSxcblx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSxcblx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKSxcblx0XHRcdFx0XHRwYXR0ZXJuID0gLyhbK1xcLV0/WzAtOV0rKVxccyooZHxEfHd8V3xtfE18eXxZKT8vZyxcblx0XHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKCBvZmZzZXQgKTtcblxuXHRcdFx0XHR3aGlsZSAoIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0c3dpdGNoICggbWF0Y2hlc1sgMiBdIHx8IFwiZFwiICkge1xuXHRcdFx0XHRcdFx0Y2FzZSBcImRcIiA6IGNhc2UgXCJEXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXkgKz0gcGFyc2VJbnQoIG1hdGNoZXNbIDEgXSwgMTAgKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwid1wiIDogY2FzZSBcIldcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludCggbWF0Y2hlc1sgMSBdLCAxMCApICogNzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwibVwiIDogY2FzZSBcIk1cIiA6XG5cdFx0XHRcdFx0XHRcdG1vbnRoICs9IHBhcnNlSW50KCBtYXRjaGVzWyAxIF0sIDEwICk7XG5cdFx0XHRcdFx0XHRcdGRheSA9IE1hdGgubWluKCBkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoIHllYXIsIG1vbnRoICkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwieVwiOiBjYXNlIFwiWVwiIDpcblx0XHRcdFx0XHRcdFx0eWVhciArPSBwYXJzZUludCggbWF0Y2hlc1sgMSBdLCAxMCApO1xuXHRcdFx0XHRcdFx0XHRkYXkgPSBNYXRoLm1pbiggZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKCB5ZWFyLCBtb250aCApICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKCBvZmZzZXQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoIHllYXIsIG1vbnRoLCBkYXkgKTtcblx0XHRcdH0sXG5cdFx0XHRuZXdEYXRlID0gKCBkYXRlID09IG51bGwgfHwgZGF0ZSA9PT0gXCJcIiA/IGRlZmF1bHREYXRlIDogKCB0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIiA/IG9mZnNldFN0cmluZyggZGF0ZSApIDpcblx0XHRcdFx0KCB0eXBlb2YgZGF0ZSA9PT0gXCJudW1iZXJcIiA/ICggaXNOYU4oIGRhdGUgKSA/IGRlZmF1bHREYXRlIDogb2Zmc2V0TnVtZXJpYyggZGF0ZSApICkgOiBuZXcgRGF0ZSggZGF0ZS5nZXRUaW1lKCkgKSApICkgKTtcblxuXHRcdG5ld0RhdGUgPSAoIG5ld0RhdGUgJiYgbmV3RGF0ZS50b1N0cmluZygpID09PSBcIkludmFsaWQgRGF0ZVwiID8gZGVmYXVsdERhdGUgOiBuZXdEYXRlICk7XG5cdFx0aWYgKCBuZXdEYXRlICkge1xuXHRcdFx0bmV3RGF0ZS5zZXRIb3VycyggMCApO1xuXHRcdFx0bmV3RGF0ZS5zZXRNaW51dGVzKCAwICk7XG5cdFx0XHRuZXdEYXRlLnNldFNlY29uZHMoIDAgKTtcblx0XHRcdG5ld0RhdGUuc2V0TWlsbGlzZWNvbmRzKCAwICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3RGF0ZSApO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBzd2l0Y2ggdG8vZnJvbSBkYXlsaWdodCBzYXZpbmcuXG5cdCAqIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XG5cdCAqID4gMTIgd2hlbiBtaWRuaWdodCBjaGFuZ2VvdmVyLCBidXQgdGhlbiBjYW5ub3QgZ2VuZXJhdGVcblx0ICogbWlkbmlnaHQgZGF0ZXRpbWUsIHNvIGp1bXAgdG8gMUFNLCBvdGhlcndpc2UgcmVzZXQuXG5cdCAqIEBwYXJhbSAgZGF0ZSAgKERhdGUpIHRoZSBkYXRlIHRvIGNoZWNrXG5cdCAqIEByZXR1cm4gIChEYXRlKSB0aGUgY29ycmVjdGVkIGRhdGVcblx0ICovXG5cdF9kYXlsaWdodFNhdmluZ0FkanVzdDogZnVuY3Rpb24oIGRhdGUgKSB7XG5cdFx0aWYgKCAhZGF0ZSApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRkYXRlLnNldEhvdXJzKCBkYXRlLmdldEhvdXJzKCkgPiAxMiA/IGRhdGUuZ2V0SG91cnMoKSArIDIgOiAwICk7XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfc2V0RGF0ZTogZnVuY3Rpb24oIGluc3QsIGRhdGUsIG5vQ2hhbmdlICkge1xuXHRcdHZhciBjbGVhciA9ICFkYXRlLFxuXHRcdFx0b3JpZ01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoLFxuXHRcdFx0b3JpZ1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhcixcblx0XHRcdG5ld0RhdGUgPSB0aGlzLl9yZXN0cmljdE1pbk1heCggaW5zdCwgdGhpcy5fZGV0ZXJtaW5lRGF0ZSggaW5zdCwgZGF0ZSwgbmV3IERhdGUoKSApICk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gbmV3RGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0gbmV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmICggKCBvcmlnTW9udGggIT09IGluc3Quc2VsZWN0ZWRNb250aCB8fCBvcmlnWWVhciAhPT0gaW5zdC5zZWxlY3RlZFllYXIgKSAmJiAhbm9DaGFuZ2UgKSB7XG5cdFx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoIGluc3QgKTtcblx0XHR9XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoIGluc3QgKTtcblx0XHRpZiAoIGluc3QuaW5wdXQgKSB7XG5cdFx0XHRpbnN0LmlucHV0LnZhbCggY2xlYXIgPyBcIlwiIDogdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCApICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfZ2V0RGF0ZTogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIHN0YXJ0RGF0ZSA9ICggIWluc3QuY3VycmVudFllYXIgfHwgKCBpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQudmFsKCkgPT09IFwiXCIgKSA/IG51bGwgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKFxuXHRcdFx0aW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSApICkgKTtcblx0XHRcdHJldHVybiBzdGFydERhdGU7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBvbnh4eCBoYW5kbGVycy4gIFRoZXNlIGFyZSBkZWNsYXJlZCBzdGF0aWNhbGx5IHNvXG5cdCAqIHRoZXkgd29yayB3aXRoIHN0YXRpYyBjb2RlIHRyYW5zZm9ybWVycyBsaWtlIENhamEuXG5cdCAqL1xuXHRfYXR0YWNoSGFuZGxlcnM6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHZhciBzdGVwTW9udGhzID0gdGhpcy5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApLFxuXHRcdFx0aWQgPSBcIiNcIiArIGluc3QuaWQucmVwbGFjZSggL1xcXFxcXFxcL2csIFwiXFxcXFwiICk7XG5cdFx0aW5zdC5kcERpdi5maW5kKCBcIltkYXRhLWhhbmRsZXJdXCIgKS5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB7XG5cdFx0XHRcdHByZXY6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggaWQsIC1zdGVwTW9udGhzLCBcIk1cIiApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGlkLCArc3RlcE1vbnRocywgXCJNXCIgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b2RheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nb3RvVG9kYXkoIGlkICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdERheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXkoIGlkLCArdGhpcy5nZXRBdHRyaWJ1dGUoIFwiZGF0YS1tb250aFwiICksICt0aGlzLmdldEF0dHJpYnV0ZSggXCJkYXRhLXllYXJcIiApLCB0aGlzICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RNb250aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoIGlkLCB0aGlzLCBcIk1cIiApO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0WWVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoIGlkLCB0aGlzLCBcIllcIiApO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdCQoIHRoaXMgKS5vbiggdGhpcy5nZXRBdHRyaWJ1dGUoIFwiZGF0YS1ldmVudFwiICksIGhhbmRsZXJbIHRoaXMuZ2V0QXR0cmlidXRlKCBcImRhdGEtaGFuZGxlclwiICkgXSApO1xuXHRcdH0gKTtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgSFRNTCBmb3IgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRfZ2VuZXJhdGVIVE1MOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHR2YXIgbWF4RHJhdywgcHJldlRleHQsIHByZXYsIG5leHRUZXh0LCBuZXh0LCBjdXJyZW50VGV4dCwgZ290b0RhdGUsXG5cdFx0XHRjb250cm9scywgYnV0dG9uUGFuZWwsIGZpcnN0RGF5LCBzaG93V2VlaywgZGF5TmFtZXMsIGRheU5hbWVzTWluLFxuXHRcdFx0bW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0LCBiZWZvcmVTaG93RGF5LCBzaG93T3RoZXJNb250aHMsXG5cdFx0XHRzZWxlY3RPdGhlck1vbnRocywgZGVmYXVsdERhdGUsIGh0bWwsIGRvdywgcm93LCBncm91cCwgY29sLCBzZWxlY3RlZERhdGUsXG5cdFx0XHRjb3JuZXJDbGFzcywgY2FsZW5kZXIsIHRoZWFkLCBkYXksIGRheXNJbk1vbnRoLCBsZWFkRGF5cywgY3VyUm93cywgbnVtUm93cyxcblx0XHRcdHByaW50RGF0ZSwgZFJvdywgdGJvZHksIGRheVNldHRpbmdzLCBvdGhlck1vbnRoLCB1bnNlbGVjdGFibGUsXG5cdFx0XHR0ZW1wRGF0ZSA9IG5ldyBEYXRlKCksXG5cdFx0XHR0b2RheSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KFxuXHRcdFx0XHRuZXcgRGF0ZSggdGVtcERhdGUuZ2V0RnVsbFllYXIoKSwgdGVtcERhdGUuZ2V0TW9udGgoKSwgdGVtcERhdGUuZ2V0RGF0ZSgpICkgKSwgLy8gY2xlYXIgdGltZVxuXHRcdFx0aXNSVEwgPSB0aGlzLl9nZXQoIGluc3QsIFwiaXNSVExcIiApLFxuXHRcdFx0c2hvd0J1dHRvblBhbmVsID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dCdXR0b25QYW5lbFwiICksXG5cdFx0XHRoaWRlSWZOb1ByZXZOZXh0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImhpZGVJZk5vUHJldk5leHRcIiApLFxuXHRcdFx0bmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA9IHRoaXMuX2dldCggaW5zdCwgXCJuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0XCIgKSxcblx0XHRcdG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKCBpbnN0ICksXG5cdFx0XHRzaG93Q3VycmVudEF0UG9zID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dDdXJyZW50QXRQb3NcIiApLFxuXHRcdFx0c3RlcE1vbnRocyA9IHRoaXMuX2dldCggaW5zdCwgXCJzdGVwTW9udGhzXCIgKSxcblx0XHRcdGlzTXVsdGlNb250aCA9ICggbnVtTW9udGhzWyAwIF0gIT09IDEgfHwgbnVtTW9udGhzWyAxIF0gIT09IDEgKSxcblx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoICggIWluc3QuY3VycmVudERheSA/IG5ldyBEYXRlKCA5OTk5LCA5LCA5ICkgOlxuXHRcdFx0XHRuZXcgRGF0ZSggaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSApICkgKSxcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1pblwiICksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZSggaW5zdCwgXCJtYXhcIiApLFxuXHRcdFx0ZHJhd01vbnRoID0gaW5zdC5kcmF3TW9udGggLSBzaG93Q3VycmVudEF0UG9zLFxuXHRcdFx0ZHJhd1llYXIgPSBpbnN0LmRyYXdZZWFyO1xuXG5cdFx0aWYgKCBkcmF3TW9udGggPCAwICkge1xuXHRcdFx0ZHJhd01vbnRoICs9IDEyO1xuXHRcdFx0ZHJhd1llYXItLTtcblx0XHR9XG5cdFx0aWYgKCBtYXhEYXRlICkge1xuXHRcdFx0bWF4RHJhdyA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggbWF4RGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRtYXhEYXRlLmdldE1vbnRoKCkgLSAoIG51bU1vbnRoc1sgMCBdICogbnVtTW9udGhzWyAxIF0gKSArIDEsIG1heERhdGUuZ2V0RGF0ZSgpICkgKTtcblx0XHRcdG1heERyYXcgPSAoIG1pbkRhdGUgJiYgbWF4RHJhdyA8IG1pbkRhdGUgPyBtaW5EYXRlIDogbWF4RHJhdyApO1xuXHRcdFx0d2hpbGUgKCB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGRyYXdZZWFyLCBkcmF3TW9udGgsIDEgKSApID4gbWF4RHJhdyApIHtcblx0XHRcdFx0ZHJhd01vbnRoLS07XG5cdFx0XHRcdGlmICggZHJhd01vbnRoIDwgMCApIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAxMTtcblx0XHRcdFx0XHRkcmF3WWVhci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGluc3QuZHJhd01vbnRoID0gZHJhd01vbnRoO1xuXHRcdGluc3QuZHJhd1llYXIgPSBkcmF3WWVhcjtcblxuXHRcdHByZXZUZXh0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcInByZXZUZXh0XCIgKTtcblx0XHRwcmV2VGV4dCA9ICggIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBwcmV2VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZSggcHJldlRleHQsXG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGRyYXdZZWFyLCBkcmF3TW9udGggLSBzdGVwTW9udGhzLCAxICkgKSxcblx0XHRcdHRoaXMuX2dldEZvcm1hdENvbmZpZyggaW5zdCApICkgKTtcblxuXHRcdHByZXYgPSAoIHRoaXMuX2NhbkFkanVzdE1vbnRoKCBpbnN0LCAtMSwgZHJhd1llYXIsIGRyYXdNb250aCApID9cblx0XHRcdFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItcHJldiB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3ByZXYnIGRhdGEtZXZlbnQ9J2NsaWNrJ1wiICtcblx0XHRcdFwiIHRpdGxlPSdcIiArIHByZXZUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwiZVwiIDogXCJ3XCIgKSArIFwiJz5cIiArIHByZXZUZXh0ICsgXCI8L3NwYW4+PC9hPlwiIDpcblx0XHRcdCggaGlkZUlmTm9QcmV2TmV4dCA/IFwiXCIgOiBcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kaXNhYmxlZCcgdGl0bGU9J1wiICsgcHJldlRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJlXCIgOiBcIndcIiApICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIgKSApO1xuXG5cdFx0bmV4dFRleHQgPSB0aGlzLl9nZXQoIGluc3QsIFwibmV4dFRleHRcIiApO1xuXHRcdG5leHRUZXh0ID0gKCAhbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IG5leHRUZXh0IDogdGhpcy5mb3JtYXREYXRlKCBuZXh0VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggZHJhd1llYXIsIGRyYXdNb250aCArIHN0ZXBNb250aHMsIDEgKSApLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKCBpbnN0ICkgKSApO1xuXG5cdFx0bmV4dCA9ICggdGhpcy5fY2FuQWRqdXN0TW9udGgoIGluc3QsICsxLCBkcmF3WWVhciwgZHJhd01vbnRoICkgP1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0nbmV4dCcgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCIgdGl0bGU9J1wiICsgbmV4dFRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJ3XCIgOiBcImVcIiApICsgXCInPlwiICsgbmV4dFRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KCBoaWRlSWZOb1ByZXZOZXh0ID8gXCJcIiA6IFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkJyB0aXRsZT0nXCIgKyBuZXh0VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcIndcIiA6IFwiZVwiICkgKyBcIic+XCIgKyBuZXh0VGV4dCArIFwiPC9zcGFuPjwvYT5cIiApICk7XG5cblx0XHRjdXJyZW50VGV4dCA9IHRoaXMuX2dldCggaW5zdCwgXCJjdXJyZW50VGV4dFwiICk7XG5cdFx0Z290b0RhdGUgPSAoIHRoaXMuX2dldCggaW5zdCwgXCJnb3RvQ3VycmVudFwiICkgJiYgaW5zdC5jdXJyZW50RGF5ID8gY3VycmVudERhdGUgOiB0b2RheSApO1xuXHRcdGN1cnJlbnRUZXh0ID0gKCAhbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IGN1cnJlbnRUZXh0IDpcblx0XHRcdHRoaXMuZm9ybWF0RGF0ZSggY3VycmVudFRleHQsIGdvdG9EYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApICk7XG5cblx0XHRjb250cm9scyA9ICggIWluc3QuaW5saW5lID8gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY2xvc2UgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1wcmltYXJ5IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0naGlkZScgZGF0YS1ldmVudD0nY2xpY2snPlwiICtcblx0XHRcdHRoaXMuX2dldCggaW5zdCwgXCJjbG9zZVRleHRcIiApICsgXCI8L2J1dHRvbj5cIiA6IFwiXCIgKTtcblxuXHRcdGJ1dHRvblBhbmVsID0gKCBzaG93QnV0dG9uUGFuZWwgKSA/IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1idXR0b25wYW5lIHVpLXdpZGdldC1jb250ZW50Jz5cIiArICggaXNSVEwgPyBjb250cm9scyA6IFwiXCIgKSArXG5cdFx0XHQoIHRoaXMuX2lzSW5SYW5nZSggaW5zdCwgZ290b0RhdGUgKSA/IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWN1cnJlbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1zZWNvbmRhcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSd0b2RheScgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCI+XCIgKyBjdXJyZW50VGV4dCArIFwiPC9idXR0b24+XCIgOiBcIlwiICkgKyAoIGlzUlRMID8gXCJcIiA6IGNvbnRyb2xzICkgKyBcIjwvZGl2PlwiIDogXCJcIjtcblxuXHRcdGZpcnN0RGF5ID0gcGFyc2VJbnQoIHRoaXMuX2dldCggaW5zdCwgXCJmaXJzdERheVwiICksIDEwICk7XG5cdFx0Zmlyc3REYXkgPSAoIGlzTmFOKCBmaXJzdERheSApID8gMCA6IGZpcnN0RGF5ICk7XG5cblx0XHRzaG93V2VlayA9IHRoaXMuX2dldCggaW5zdCwgXCJzaG93V2Vla1wiICk7XG5cdFx0ZGF5TmFtZXMgPSB0aGlzLl9nZXQoIGluc3QsIFwiZGF5TmFtZXNcIiApO1xuXHRcdGRheU5hbWVzTWluID0gdGhpcy5fZ2V0KCBpbnN0LCBcImRheU5hbWVzTWluXCIgKTtcblx0XHRtb250aE5hbWVzID0gdGhpcy5fZ2V0KCBpbnN0LCBcIm1vbnRoTmFtZXNcIiApO1xuXHRcdG1vbnRoTmFtZXNTaG9ydCA9IHRoaXMuX2dldCggaW5zdCwgXCJtb250aE5hbWVzU2hvcnRcIiApO1xuXHRcdGJlZm9yZVNob3dEYXkgPSB0aGlzLl9nZXQoIGluc3QsIFwiYmVmb3JlU2hvd0RheVwiICk7XG5cdFx0c2hvd090aGVyTW9udGhzID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dPdGhlck1vbnRoc1wiICk7XG5cdFx0c2VsZWN0T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoIGluc3QsIFwic2VsZWN0T3RoZXJNb250aHNcIiApO1xuXHRcdGRlZmF1bHREYXRlID0gdGhpcy5fZ2V0RGVmYXVsdERhdGUoIGluc3QgKTtcblx0XHRodG1sID0gXCJcIjtcblxuXHRcdGZvciAoIHJvdyA9IDA7IHJvdyA8IG51bU1vbnRoc1sgMCBdOyByb3crKyApIHtcblx0XHRcdGdyb3VwID0gXCJcIjtcblx0XHRcdHRoaXMubWF4Um93cyA9IDQ7XG5cdFx0XHRmb3IgKCBjb2wgPSAwOyBjb2wgPCBudW1Nb250aHNbIDEgXTsgY29sKysgKSB7XG5cdFx0XHRcdHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggZHJhd1llYXIsIGRyYXdNb250aCwgaW5zdC5zZWxlY3RlZERheSApICk7XG5cdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLWFsbFwiO1xuXHRcdFx0XHRjYWxlbmRlciA9IFwiXCI7XG5cdFx0XHRcdGlmICggaXNNdWx0aU1vbnRoICkge1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1ncm91cFwiO1xuXHRcdFx0XHRcdGlmICggbnVtTW9udGhzWyAxIF0gPiAxICkge1xuXHRcdFx0XHRcdFx0c3dpdGNoICggY29sICkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIDA6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtZmlyc3RcIjtcblx0XHRcdFx0XHRcdFx0XHRjb3JuZXJDbGFzcyA9IFwiIHVpLWNvcm5lci1cIiArICggaXNSVEwgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiApOyBicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBudW1Nb250aHNbIDEgXSAtIDE6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtbGFzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKCBpc1JUTCA/IFwibGVmdFwiIDogXCJyaWdodFwiICk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjYWxlbmRlciArPSBcIiB1aS1kYXRlcGlja2VyLWdyb3VwLW1pZGRsZVwiOyBjb3JuZXJDbGFzcyA9IFwiXCI7IGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxlbmRlciArPSBcIic+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeFwiICsgY29ybmVyQ2xhc3MgKyBcIic+XCIgK1xuXHRcdFx0XHRcdCggL2FsbHxsZWZ0Ly50ZXN0KCBjb3JuZXJDbGFzcyApICYmIHJvdyA9PT0gMCA/ICggaXNSVEwgPyBuZXh0IDogcHJldiApIDogXCJcIiApICtcblx0XHRcdFx0XHQoIC9hbGx8cmlnaHQvLnRlc3QoIGNvcm5lckNsYXNzICkgJiYgcm93ID09PSAwID8gKCBpc1JUTCA/IHByZXYgOiBuZXh0ICkgOiBcIlwiICkgK1xuXHRcdFx0XHRcdHRoaXMuX2dlbmVyYXRlTW9udGhZZWFySGVhZGVyKCBpbnN0LCBkcmF3TW9udGgsIGRyYXdZZWFyLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0XHRcdHJvdyA+IDAgfHwgY29sID4gMCwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0ICkgKyAvLyBkcmF3IG1vbnRoIGhlYWRlcnNcblx0XHRcdFx0XHRcIjwvZGl2Pjx0YWJsZSBjbGFzcz0ndWktZGF0ZXBpY2tlci1jYWxlbmRhcic+PHRoZWFkPlwiICtcblx0XHRcdFx0XHRcIjx0cj5cIjtcblx0XHRcdFx0dGhlYWQgPSAoIHNob3dXZWVrID8gXCI8dGggY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICsgdGhpcy5fZ2V0KCBpbnN0LCBcIndlZWtIZWFkZXJcIiApICsgXCI8L3RoPlwiIDogXCJcIiApO1xuXHRcdFx0XHRmb3IgKCBkb3cgPSAwOyBkb3cgPCA3OyBkb3crKyApIHsgLy8gZGF5cyBvZiB0aGUgd2Vla1xuXHRcdFx0XHRcdGRheSA9ICggZG93ICsgZmlyc3REYXkgKSAlIDc7XG5cdFx0XHRcdFx0dGhlYWQgKz0gXCI8dGggc2NvcGU9J2NvbCdcIiArICggKCBkb3cgKyBmaXJzdERheSArIDYgKSAlIDcgPj0gNSA/IFwiIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstZW5kJ1wiIDogXCJcIiApICsgXCI+XCIgK1xuXHRcdFx0XHRcdFx0XCI8c3BhbiB0aXRsZT0nXCIgKyBkYXlOYW1lc1sgZGF5IF0gKyBcIic+XCIgKyBkYXlOYW1lc01pblsgZGF5IF0gKyBcIjwvc3Bhbj48L3RoPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IHRoZWFkICsgXCI8L3RyPjwvdGhlYWQ+PHRib2R5PlwiO1xuXHRcdFx0XHRkYXlzSW5Nb250aCA9IHRoaXMuX2dldERheXNJbk1vbnRoKCBkcmF3WWVhciwgZHJhd01vbnRoICk7XG5cdFx0XHRcdGlmICggZHJhd1llYXIgPT09IGluc3Quc2VsZWN0ZWRZZWFyICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoICkge1xuXHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBNYXRoLm1pbiggaW5zdC5zZWxlY3RlZERheSwgZGF5c0luTW9udGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZWFkRGF5cyA9ICggdGhpcy5fZ2V0Rmlyc3REYXlPZk1vbnRoKCBkcmF3WWVhciwgZHJhd01vbnRoICkgLSBmaXJzdERheSArIDcgKSAlIDc7XG5cdFx0XHRcdGN1clJvd3MgPSBNYXRoLmNlaWwoICggbGVhZERheXMgKyBkYXlzSW5Nb250aCApIC8gNyApOyAvLyBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiByb3dzIHRvIGdlbmVyYXRlXG5cdFx0XHRcdG51bVJvd3MgPSAoIGlzTXVsdGlNb250aCA/IHRoaXMubWF4Um93cyA+IGN1clJvd3MgPyB0aGlzLm1heFJvd3MgOiBjdXJSb3dzIDogY3VyUm93cyApOyAvL0lmIG11bHRpcGxlIG1vbnRocywgdXNlIHRoZSBoaWdoZXIgbnVtYmVyIG9mIHJvd3MgKHNlZSAjNzA0Mylcblx0XHRcdFx0dGhpcy5tYXhSb3dzID0gbnVtUm93cztcblx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBkcmF3WWVhciwgZHJhd01vbnRoLCAxIC0gbGVhZERheXMgKSApO1xuXHRcdFx0XHRmb3IgKCBkUm93ID0gMDsgZFJvdyA8IG51bVJvd3M7IGRSb3crKyApIHsgLy8gY3JlYXRlIGRhdGUgcGlja2VyIHJvd3Ncblx0XHRcdFx0XHRjYWxlbmRlciArPSBcIjx0cj5cIjtcblx0XHRcdFx0XHR0Ym9keSA9ICggIXNob3dXZWVrID8gXCJcIiA6IFwiPHRkIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstY29sJz5cIiArXG5cdFx0XHRcdFx0XHR0aGlzLl9nZXQoIGluc3QsIFwiY2FsY3VsYXRlV2Vla1wiICkoIHByaW50RGF0ZSApICsgXCI8L3RkPlwiICk7XG5cdFx0XHRcdFx0Zm9yICggZG93ID0gMDsgZG93IDwgNzsgZG93KysgKSB7IC8vIGNyZWF0ZSBkYXRlIHBpY2tlciBkYXlzXG5cdFx0XHRcdFx0XHRkYXlTZXR0aW5ncyA9ICggYmVmb3JlU2hvd0RheSA/XG5cdFx0XHRcdFx0XHRcdGJlZm9yZVNob3dEYXkuYXBwbHkoICggaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbIDAgXSA6IG51bGwgKSwgWyBwcmludERhdGUgXSApIDogWyB0cnVlLCBcIlwiIF0gKTtcblx0XHRcdFx0XHRcdG90aGVyTW9udGggPSAoIHByaW50RGF0ZS5nZXRNb250aCgpICE9PSBkcmF3TW9udGggKTtcblx0XHRcdFx0XHRcdHVuc2VsZWN0YWJsZSA9ICggb3RoZXJNb250aCAmJiAhc2VsZWN0T3RoZXJNb250aHMgKSB8fCAhZGF5U2V0dGluZ3NbIDAgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG1pbkRhdGUgJiYgcHJpbnREYXRlIDwgbWluRGF0ZSApIHx8ICggbWF4RGF0ZSAmJiBwcmludERhdGUgPiBtYXhEYXRlICk7XG5cdFx0XHRcdFx0XHR0Ym9keSArPSBcIjx0ZCBjbGFzcz0nXCIgK1xuXHRcdFx0XHRcdFx0XHQoICggZG93ICsgZmlyc3REYXkgKyA2ICkgJSA3ID49IDUgPyBcIiB1aS1kYXRlcGlja2VyLXdlZWstZW5kXCIgOiBcIlwiICkgKyAvLyBoaWdobGlnaHQgd2Vla2VuZHNcblx0XHRcdFx0XHRcdFx0KCBvdGhlck1vbnRoID8gXCIgdWktZGF0ZXBpY2tlci1vdGhlci1tb250aFwiIDogXCJcIiApICsgLy8gaGlnaGxpZ2h0IGRheXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KCAoIHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgJiYgZHJhd01vbnRoID09PSBpbnN0LnNlbGVjdGVkTW9udGggJiYgaW5zdC5fa2V5RXZlbnQgKSB8fCAvLyB1c2VyIHByZXNzZWQga2V5XG5cdFx0XHRcdFx0XHRcdCggZGVmYXVsdERhdGUuZ2V0VGltZSgpID09PSBwcmludERhdGUuZ2V0VGltZSgpICYmIGRlZmF1bHREYXRlLmdldFRpbWUoKSA9PT0gc2VsZWN0ZWREYXRlLmdldFRpbWUoKSApID9cblxuXHRcdFx0XHRcdFx0XHQvLyBvciBkZWZhdWx0RGF0ZSBpcyBjdXJyZW50IHByaW50ZWREYXRlIGFuZCBkZWZhdWx0RGF0ZSBpcyBzZWxlY3RlZERhdGVcblx0XHRcdFx0XHRcdFx0XCIgXCIgKyB0aGlzLl9kYXlPdmVyQ2xhc3MgOiBcIlwiICkgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdCggdW5zZWxlY3RhYmxlID8gXCIgXCIgKyB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyArIFwiIHVpLXN0YXRlLWRpc2FibGVkXCIgOiBcIlwiICkgKyAgLy8gaGlnaGxpZ2h0IHVuc2VsZWN0YWJsZSBkYXlzXG5cdFx0XHRcdFx0XHRcdCggb3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gXCJcIiA6IFwiIFwiICsgZGF5U2V0dGluZ3NbIDEgXSArIC8vIGhpZ2hsaWdodCBjdXN0b20gZGF0ZXNcblx0XHRcdFx0XHRcdFx0KCBwcmludERhdGUuZ2V0VGltZSgpID09PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyBcIiBcIiArIHRoaXMuX2N1cnJlbnRDbGFzcyA6IFwiXCIgKSArIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcblx0XHRcdFx0XHRcdFx0KCBwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1kYXRlcGlja2VyLXRvZGF5XCIgOiBcIlwiICkgKSArIFwiJ1wiICsgLy8gaGlnaGxpZ2h0IHRvZGF5IChpZiBkaWZmZXJlbnQpXG5cdFx0XHRcdFx0XHRcdCggKCAhb3RoZXJNb250aCB8fCBzaG93T3RoZXJNb250aHMgKSAmJiBkYXlTZXR0aW5nc1sgMiBdID8gXCIgdGl0bGU9J1wiICsgZGF5U2V0dGluZ3NbIDIgXS5yZXBsYWNlKCAvJy9nLCBcIiYjMzk7XCIgKSArIFwiJ1wiIDogXCJcIiApICsgLy8gY2VsbCB0aXRsZVxuXHRcdFx0XHRcdFx0XHQoIHVuc2VsZWN0YWJsZSA/IFwiXCIgOiBcIiBkYXRhLWhhbmRsZXI9J3NlbGVjdERheScgZGF0YS1ldmVudD0nY2xpY2snIGRhdGEtbW9udGg9J1wiICsgcHJpbnREYXRlLmdldE1vbnRoKCkgKyBcIicgZGF0YS15ZWFyPSdcIiArIHByaW50RGF0ZS5nZXRGdWxsWWVhcigpICsgXCInXCIgKSArIFwiPlwiICsgLy8gYWN0aW9uc1xuXHRcdFx0XHRcdFx0XHQoIG90aGVyTW9udGggJiYgIXNob3dPdGhlck1vbnRocyA/IFwiJiN4YTA7XCIgOiAvLyBkaXNwbGF5IGZvciBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KCB1bnNlbGVjdGFibGUgPyBcIjxzcGFuIGNsYXNzPSd1aS1zdGF0ZS1kZWZhdWx0Jz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvc3Bhbj5cIiA6IFwiPGEgY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHRcIiArXG5cdFx0XHRcdFx0XHRcdCggcHJpbnREYXRlLmdldFRpbWUoKSA9PT0gdG9kYXkuZ2V0VGltZSgpID8gXCIgdWktc3RhdGUtaGlnaGxpZ2h0XCIgOiBcIlwiICkgK1xuXHRcdFx0XHRcdFx0XHQoIHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIHVpLXN0YXRlLWFjdGl2ZVwiIDogXCJcIiApICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQoIG90aGVyTW9udGggPyBcIiB1aS1wcmlvcml0eS1zZWNvbmRhcnlcIiA6IFwiXCIgKSArIC8vIGRpc3Rpbmd1aXNoIGRhdGVzIGZyb20gb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdFwiJyBocmVmPScjJz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvYT5cIiApICkgKyBcIjwvdGQ+XCI7IC8vIGRpc3BsYXkgc2VsZWN0YWJsZSBkYXRlXG5cdFx0XHRcdFx0XHRwcmludERhdGUuc2V0RGF0ZSggcHJpbnREYXRlLmdldERhdGUoKSArIDEgKTtcblx0XHRcdFx0XHRcdHByaW50RGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBwcmludERhdGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gdGJvZHkgKyBcIjwvdHI+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHJhd01vbnRoKys7XG5cdFx0XHRcdGlmICggZHJhd01vbnRoID4gMTEgKSB7XG5cdFx0XHRcdFx0ZHJhd01vbnRoID0gMDtcblx0XHRcdFx0XHRkcmF3WWVhcisrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IFwiPC90Ym9keT48L3RhYmxlPlwiICsgKCBpc011bHRpTW9udGggPyBcIjwvZGl2PlwiICtcblx0XHRcdFx0XHRcdFx0KCAoIG51bU1vbnRoc1sgMCBdID4gMCAmJiBjb2wgPT09IG51bU1vbnRoc1sgMSBdIC0gMSApID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLXJvdy1icmVhayc+PC9kaXY+XCIgOiBcIlwiICkgOiBcIlwiICk7XG5cdFx0XHRcdGdyb3VwICs9IGNhbGVuZGVyO1xuXHRcdFx0fVxuXHRcdFx0aHRtbCArPSBncm91cDtcblx0XHR9XG5cdFx0aHRtbCArPSBidXR0b25QYW5lbDtcblx0XHRpbnN0Ll9rZXlFdmVudCA9IGZhbHNlO1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdC8qIEdlbmVyYXRlIHRoZSBtb250aCBhbmQgeWVhciBoZWFkZXIuICovXG5cdF9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcjogZnVuY3Rpb24oIGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRzZWNvbmRhcnksIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCApIHtcblxuXHRcdHZhciBpbk1pblllYXIsIGluTWF4WWVhciwgbW9udGgsIHllYXJzLCB0aGlzWWVhciwgZGV0ZXJtaW5lWWVhciwgeWVhciwgZW5kWWVhcixcblx0XHRcdGNoYW5nZU1vbnRoID0gdGhpcy5fZ2V0KCBpbnN0LCBcImNoYW5nZU1vbnRoXCIgKSxcblx0XHRcdGNoYW5nZVllYXIgPSB0aGlzLl9nZXQoIGluc3QsIFwiY2hhbmdlWWVhclwiICksXG5cdFx0XHRzaG93TW9udGhBZnRlclllYXIgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd01vbnRoQWZ0ZXJZZWFyXCIgKSxcblx0XHRcdGh0bWwgPSBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItdGl0bGUnPlwiLFxuXHRcdFx0bW9udGhIdG1sID0gXCJcIjtcblxuXHRcdC8vIE1vbnRoIHNlbGVjdGlvblxuXHRcdGlmICggc2Vjb25kYXJ5IHx8ICFjaGFuZ2VNb250aCApIHtcblx0XHRcdG1vbnRoSHRtbCArPSBcIjxzcGFuIGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJz5cIiArIG1vbnRoTmFtZXNbIGRyYXdNb250aCBdICsgXCI8L3NwYW4+XCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluTWluWWVhciA9ICggbWluRGF0ZSAmJiBtaW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyICk7XG5cdFx0XHRpbk1heFllYXIgPSAoIG1heERhdGUgJiYgbWF4RGF0ZS5nZXRGdWxsWWVhcigpID09PSBkcmF3WWVhciApO1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNlbGVjdCBjbGFzcz0ndWktZGF0ZXBpY2tlci1tb250aCcgZGF0YS1oYW5kbGVyPSdzZWxlY3RNb250aCcgZGF0YS1ldmVudD0nY2hhbmdlJz5cIjtcblx0XHRcdGZvciAoIG1vbnRoID0gMDsgbW9udGggPCAxMjsgbW9udGgrKyApIHtcblx0XHRcdFx0aWYgKCAoICFpbk1pblllYXIgfHwgbW9udGggPj0gbWluRGF0ZS5nZXRNb250aCgpICkgJiYgKCAhaW5NYXhZZWFyIHx8IG1vbnRoIDw9IG1heERhdGUuZ2V0TW9udGgoKSApICkge1xuXHRcdFx0XHRcdG1vbnRoSHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgbW9udGggKyBcIidcIiArXG5cdFx0XHRcdFx0XHQoIG1vbnRoID09PSBkcmF3TW9udGggPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiICkgK1xuXHRcdFx0XHRcdFx0XCI+XCIgKyBtb250aE5hbWVzU2hvcnRbIG1vbnRoIF0gKyBcIjwvb3B0aW9uPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtb250aEh0bWwgKz0gXCI8L3NlbGVjdD5cIjtcblx0XHR9XG5cblx0XHRpZiAoICFzaG93TW9udGhBZnRlclllYXIgKSB7XG5cdFx0XHRodG1sICs9IG1vbnRoSHRtbCArICggc2Vjb25kYXJ5IHx8ICEoIGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIgKSA/IFwiJiN4YTA7XCIgOiBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gWWVhciBzZWxlY3Rpb25cblx0XHRpZiAoICFpbnN0LnllYXJzaHRtbCApIHtcblx0XHRcdGluc3QueWVhcnNodG1sID0gXCJcIjtcblx0XHRcdGlmICggc2Vjb25kYXJ5IHx8ICFjaGFuZ2VZZWFyICkge1xuXHRcdFx0XHRodG1sICs9IFwiPHNwYW4gY2xhc3M9J3VpLWRhdGVwaWNrZXIteWVhcic+XCIgKyBkcmF3WWVhciArIFwiPC9zcGFuPlwiO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBkZXRlcm1pbmUgcmFuZ2Ugb2YgeWVhcnMgdG8gZGlzcGxheVxuXHRcdFx0XHR5ZWFycyA9IHRoaXMuX2dldCggaW5zdCwgXCJ5ZWFyUmFuZ2VcIiApLnNwbGl0KCBcIjpcIiApO1xuXHRcdFx0XHR0aGlzWWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0ZGV0ZXJtaW5lWWVhciA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgeWVhciA9ICggdmFsdWUubWF0Y2goIC9jWytcXC1dLiovICkgPyBkcmF3WWVhciArIHBhcnNlSW50KCB2YWx1ZS5zdWJzdHJpbmcoIDEgKSwgMTAgKSA6XG5cdFx0XHRcdFx0XHQoIHZhbHVlLm1hdGNoKCAvWytcXC1dLiovICkgPyB0aGlzWWVhciArIHBhcnNlSW50KCB2YWx1ZSwgMTAgKSA6XG5cdFx0XHRcdFx0XHRwYXJzZUludCggdmFsdWUsIDEwICkgKSApO1xuXHRcdFx0XHRcdHJldHVybiAoIGlzTmFOKCB5ZWFyICkgPyB0aGlzWWVhciA6IHllYXIgKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0eWVhciA9IGRldGVybWluZVllYXIoIHllYXJzWyAwIF0gKTtcblx0XHRcdFx0ZW5kWWVhciA9IE1hdGgubWF4KCB5ZWFyLCBkZXRlcm1pbmVZZWFyKCB5ZWFyc1sgMSBdIHx8IFwiXCIgKSApO1xuXHRcdFx0XHR5ZWFyID0gKCBtaW5EYXRlID8gTWF0aC5tYXgoIHllYXIsIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSApIDogeWVhciApO1xuXHRcdFx0XHRlbmRZZWFyID0gKCBtYXhEYXRlID8gTWF0aC5taW4oIGVuZFllYXIsIG1heERhdGUuZ2V0RnVsbFllYXIoKSApIDogZW5kWWVhciApO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCArPSBcIjxzZWxlY3QgY2xhc3M9J3VpLWRhdGVwaWNrZXIteWVhcicgZGF0YS1oYW5kbGVyPSdzZWxlY3RZZWFyJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlwiO1xuXHRcdFx0XHRmb3IgKCA7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrICkge1xuXHRcdFx0XHRcdGluc3QueWVhcnNodG1sICs9IFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyB5ZWFyICsgXCInXCIgK1xuXHRcdFx0XHRcdFx0KCB5ZWFyID09PSBkcmF3WWVhciA/IFwiIHNlbGVjdGVkPSdzZWxlY3RlZCdcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIHllYXIgKyBcIjwvb3B0aW9uPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QueWVhcnNodG1sICs9IFwiPC9zZWxlY3Q+XCI7XG5cblx0XHRcdFx0aHRtbCArPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGh0bWwgKz0gdGhpcy5fZ2V0KCBpbnN0LCBcInllYXJTdWZmaXhcIiApO1xuXHRcdGlmICggc2hvd01vbnRoQWZ0ZXJZZWFyICkge1xuXHRcdFx0aHRtbCArPSAoIHNlY29uZGFyeSB8fCAhKCBjaGFuZ2VNb250aCAmJiBjaGFuZ2VZZWFyICkgPyBcIiYjeGEwO1wiIDogXCJcIiApICsgbW9udGhIdG1sO1xuXHRcdH1cblx0XHRodG1sICs9IFwiPC9kaXY+XCI7IC8vIENsb3NlIGRhdGVwaWNrZXJfaGVhZGVyXG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0SW5zdERhdGU6IGZ1bmN0aW9uKCBpbnN0LCBvZmZzZXQsIHBlcmlvZCApIHtcblx0XHR2YXIgeWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyICsgKCBwZXJpb2QgPT09IFwiWVwiID8gb2Zmc2V0IDogMCApLFxuXHRcdFx0bW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggKyAoIHBlcmlvZCA9PT0gXCJNXCIgPyBvZmZzZXQgOiAwICksXG5cdFx0XHRkYXkgPSBNYXRoLm1pbiggaW5zdC5zZWxlY3RlZERheSwgdGhpcy5fZ2V0RGF5c0luTW9udGgoIHllYXIsIG1vbnRoICkgKSArICggcGVyaW9kID09PSBcIkRcIiA/IG9mZnNldCA6IDAgKSxcblx0XHRcdGRhdGUgPSB0aGlzLl9yZXN0cmljdE1pbk1heCggaW5zdCwgdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCB5ZWFyLCBtb250aCwgZGF5ICkgKSApO1xuXG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpZiAoIHBlcmlvZCA9PT0gXCJNXCIgfHwgcGVyaW9kID09PSBcIllcIiApIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZSggaW5zdCApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBFbnN1cmUgYSBkYXRlIGlzIHdpdGhpbiBhbnkgbWluL21heCBib3VuZHMuICovXG5cdF9yZXN0cmljdE1pbk1heDogZnVuY3Rpb24oIGluc3QsIGRhdGUgKSB7XG5cdFx0dmFyIG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1pblwiICksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZSggaW5zdCwgXCJtYXhcIiApLFxuXHRcdFx0bmV3RGF0ZSA9ICggbWluRGF0ZSAmJiBkYXRlIDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBkYXRlICk7XG5cdFx0cmV0dXJuICggbWF4RGF0ZSAmJiBuZXdEYXRlID4gbWF4RGF0ZSA/IG1heERhdGUgOiBuZXdEYXRlICk7XG5cdH0sXG5cblx0LyogTm90aWZ5IGNoYW5nZSBvZiBtb250aC95ZWFyLiAqL1xuXHRfbm90aWZ5Q2hhbmdlOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHR2YXIgb25DaGFuZ2UgPSB0aGlzLl9nZXQoIGluc3QsIFwib25DaGFuZ2VNb250aFllYXJcIiApO1xuXHRcdGlmICggb25DaGFuZ2UgKSB7XG5cdFx0XHRvbkNoYW5nZS5hcHBseSggKCBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFsgMCBdIDogbnVsbCApLFxuXHRcdFx0XHRbIGluc3Quc2VsZWN0ZWRZZWFyLCBpbnN0LnNlbGVjdGVkTW9udGggKyAxLCBpbnN0IF0gKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgbW9udGhzIHRvIHNob3cuICovXG5cdF9nZXROdW1iZXJPZk1vbnRoczogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldCggaW5zdCwgXCJudW1iZXJPZk1vbnRoc1wiICk7XG5cdFx0cmV0dXJuICggbnVtTW9udGhzID09IG51bGwgPyBbIDEsIDEgXSA6ICggdHlwZW9mIG51bU1vbnRocyA9PT0gXCJudW1iZXJcIiA/IFsgMSwgbnVtTW9udGhzIF0gOiBudW1Nb250aHMgKSApO1xuXHR9LFxuXG5cdC8qIERldGVybWluZSB0aGUgY3VycmVudCBtYXhpbXVtIGRhdGUgLSBlbnN1cmUgbm8gdGltZSBjb21wb25lbnRzIGFyZSBzZXQuICovXG5cdF9nZXRNaW5NYXhEYXRlOiBmdW5jdGlvbiggaW5zdCwgbWluTWF4ICkge1xuXHRcdHJldHVybiB0aGlzLl9kZXRlcm1pbmVEYXRlKCBpbnN0LCB0aGlzLl9nZXQoIGluc3QsIG1pbk1heCArIFwiRGF0ZVwiICksIG51bGwgKTtcblx0fSxcblxuXHQvKiBGaW5kIHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIGdpdmVuIG1vbnRoLiAqL1xuXHRfZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uKCB5ZWFyLCBtb250aCApIHtcblx0XHRyZXR1cm4gMzIgLSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIHllYXIsIG1vbnRoLCAzMiApICkuZ2V0RGF0ZSgpO1xuXHR9LFxuXG5cdC8qIEZpbmQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZmlyc3Qgb2YgYSBtb250aC4gKi9cblx0X2dldEZpcnN0RGF5T2ZNb250aDogZnVuY3Rpb24oIHllYXIsIG1vbnRoICkge1xuXHRcdHJldHVybiBuZXcgRGF0ZSggeWVhciwgbW9udGgsIDEgKS5nZXREYXkoKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmVzIGlmIHdlIHNob3VsZCBhbGxvdyBhIFwibmV4dC9wcmV2XCIgbW9udGggZGlzcGxheSBjaGFuZ2UuICovXG5cdF9jYW5BZGp1c3RNb250aDogZnVuY3Rpb24oIGluc3QsIG9mZnNldCwgY3VyWWVhciwgY3VyTW9udGggKSB7XG5cdFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKCBpbnN0ICksXG5cdFx0XHRkYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBjdXJZZWFyLFxuXHRcdFx0Y3VyTW9udGggKyAoIG9mZnNldCA8IDAgPyBvZmZzZXQgOiBudW1Nb250aHNbIDAgXSAqIG51bU1vbnRoc1sgMSBdICksIDEgKSApO1xuXG5cdFx0aWYgKCBvZmZzZXQgPCAwICkge1xuXHRcdFx0ZGF0ZS5zZXREYXRlKCB0aGlzLl9nZXREYXlzSW5Nb250aCggZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKSApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faXNJblJhbmdlKCBpbnN0LCBkYXRlICk7XG5cdH0sXG5cblx0LyogSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIGFjY2VwdGVkIHJhbmdlPyAqL1xuXHRfaXNJblJhbmdlOiBmdW5jdGlvbiggaW5zdCwgZGF0ZSApIHtcblx0XHR2YXIgeWVhclNwbGl0LCBjdXJyZW50WWVhcixcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1pblwiICksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZSggaW5zdCwgXCJtYXhcIiApLFxuXHRcdFx0bWluWWVhciA9IG51bGwsXG5cdFx0XHRtYXhZZWFyID0gbnVsbCxcblx0XHRcdHllYXJzID0gdGhpcy5fZ2V0KCBpbnN0LCBcInllYXJSYW5nZVwiICk7XG5cdFx0XHRpZiAoIHllYXJzICkge1xuXHRcdFx0XHR5ZWFyU3BsaXQgPSB5ZWFycy5zcGxpdCggXCI6XCIgKTtcblx0XHRcdFx0Y3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdG1pblllYXIgPSBwYXJzZUludCggeWVhclNwbGl0WyAwIF0sIDEwICk7XG5cdFx0XHRcdG1heFllYXIgPSBwYXJzZUludCggeWVhclNwbGl0WyAxIF0sIDEwICk7XG5cdFx0XHRcdGlmICggeWVhclNwbGl0WyAwIF0ubWF0Y2goIC9bK1xcLV0uKi8gKSApIHtcblx0XHRcdFx0XHRtaW5ZZWFyICs9IGN1cnJlbnRZZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggeWVhclNwbGl0WyAxIF0ubWF0Y2goIC9bK1xcLV0uKi8gKSApIHtcblx0XHRcdFx0XHRtYXhZZWFyICs9IGN1cnJlbnRZZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRyZXR1cm4gKCAoICFtaW5EYXRlIHx8IGRhdGUuZ2V0VGltZSgpID49IG1pbkRhdGUuZ2V0VGltZSgpICkgJiZcblx0XHRcdCggIW1heERhdGUgfHwgZGF0ZS5nZXRUaW1lKCkgPD0gbWF4RGF0ZS5nZXRUaW1lKCkgKSAmJlxuXHRcdFx0KCAhbWluWWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPj0gbWluWWVhciApICYmXG5cdFx0XHQoICFtYXhZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA8PSBtYXhZZWFyICkgKTtcblx0fSxcblxuXHQvKiBQcm92aWRlIHRoZSBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBmb3JtYXR0aW5nL3BhcnNpbmcuICovXG5cdF9nZXRGb3JtYXRDb25maWc6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHZhciBzaG9ydFllYXJDdXRvZmYgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvcnRZZWFyQ3V0b2ZmXCIgKTtcblx0XHRzaG9ydFllYXJDdXRvZmYgPSAoIHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmYgOlxuXHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoIHNob3J0WWVhckN1dG9mZiwgMTAgKSApO1xuXHRcdHJldHVybiB7IHNob3J0WWVhckN1dG9mZjogc2hvcnRZZWFyQ3V0b2ZmLFxuXHRcdFx0ZGF5TmFtZXNTaG9ydDogdGhpcy5fZ2V0KCBpbnN0LCBcImRheU5hbWVzU2hvcnRcIiApLCBkYXlOYW1lczogdGhpcy5fZ2V0KCBpbnN0LCBcImRheU5hbWVzXCIgKSxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydDogdGhpcy5fZ2V0KCBpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiICksIG1vbnRoTmFtZXM6IHRoaXMuX2dldCggaW5zdCwgXCJtb250aE5hbWVzXCIgKSB9O1xuXHR9LFxuXG5cdC8qIEZvcm1hdCB0aGUgZ2l2ZW4gZGF0ZSBmb3IgZGlzcGxheS4gKi9cblx0X2Zvcm1hdERhdGU6IGZ1bmN0aW9uKCBpbnN0LCBkYXksIG1vbnRoLCB5ZWFyICkge1xuXHRcdGlmICggIWRheSApIHtcblx0XHRcdGluc3QuY3VycmVudERheSA9IGluc3Quc2VsZWN0ZWREYXk7XG5cdFx0XHRpbnN0LmN1cnJlbnRNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aDtcblx0XHRcdGluc3QuY3VycmVudFllYXIgPSBpbnN0LnNlbGVjdGVkWWVhcjtcblx0XHR9XG5cdFx0dmFyIGRhdGUgPSAoIGRheSA/ICggdHlwZW9mIGRheSA9PT0gXCJvYmplY3RcIiA/IGRheSA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIHllYXIsIG1vbnRoLCBkYXkgKSApICkgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5ICkgKSApO1xuXHRcdHJldHVybiB0aGlzLmZvcm1hdERhdGUoIHRoaXMuX2dldCggaW5zdCwgXCJkYXRlRm9ybWF0XCIgKSwgZGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKCBpbnN0ICkgKTtcblx0fVxufSApO1xuXG4vKlxuICogQmluZCBob3ZlciBldmVudHMgZm9yIGRhdGVwaWNrZXIgZWxlbWVudHMuXG4gKiBEb25lIHZpYSBkZWxlZ2F0ZSBzbyB0aGUgYmluZGluZyBvbmx5IG9jY3VycyBvbmNlIGluIHRoZSBsaWZldGltZSBvZiB0aGUgcGFyZW50IGRpdi5cbiAqIEdsb2JhbCBkYXRlcGlja2VyX2luc3RBY3RpdmUsIHNldCBieSBfdXBkYXRlRGF0ZXBpY2tlciBhbGxvd3MgdGhlIGhhbmRsZXJzIHRvIGZpbmQgdGhlaXIgd2F5IGJhY2sgdG8gdGhlIGFjdGl2ZSBwaWNrZXIuXG4gKi9cbmZ1bmN0aW9uIGRhdGVwaWNrZXJfYmluZEhvdmVyKCBkcERpdiApIHtcblx0dmFyIHNlbGVjdG9yID0gXCJidXR0b24sIC51aS1kYXRlcGlja2VyLXByZXYsIC51aS1kYXRlcGlja2VyLW5leHQsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkIGFcIjtcblx0cmV0dXJuIGRwRGl2Lm9uKCBcIm1vdXNlb3V0XCIsIHNlbGVjdG9yLCBmdW5jdGlvbigpIHtcblx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoIFwidWktZGF0ZXBpY2tlci1wcmV2XCIgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZS5pbmRleE9mKCBcInVpLWRhdGVwaWNrZXItbmV4dFwiICkgIT09IC0xICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQ2xhc3MoIFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIgKTtcblx0XHRcdH1cblx0XHR9IClcblx0XHQub24oIFwibW91c2VvdmVyXCIsIHNlbGVjdG9yLCBkYXRlcGlja2VyX2hhbmRsZU1vdXNlb3ZlciApO1xufVxuXG5mdW5jdGlvbiBkYXRlcGlja2VyX2hhbmRsZU1vdXNlb3ZlcigpIHtcblx0aWYgKCAhJC5kYXRlcGlja2VyLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLmlubGluZSA/IGRhdGVwaWNrZXJfaW5zdEFjdGl2ZS5kcERpdi5wYXJlbnQoKVsgMCBdIDogZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLmlucHV0WyAwIF0gKSApIHtcblx0XHQkKCB0aGlzICkucGFyZW50cyggXCIudWktZGF0ZXBpY2tlci1jYWxlbmRhclwiICkuZmluZCggXCJhXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoIFwidWktZGF0ZXBpY2tlci1wcmV2XCIgKSAhPT0gLTEgKSB7XG5cdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktZGF0ZXBpY2tlci1wcmV2LWhvdmVyXCIgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmNsYXNzTmFtZS5pbmRleE9mKCBcInVpLWRhdGVwaWNrZXItbmV4dFwiICkgIT09IC0xICkge1xuXHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLWRhdGVwaWNrZXItbmV4dC1ob3ZlclwiICk7XG5cdFx0fVxuXHR9XG59XG5cbi8qIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhICovXG5mdW5jdGlvbiBkYXRlcGlja2VyX2V4dGVuZFJlbW92ZSggdGFyZ2V0LCBwcm9wcyApIHtcblx0JC5leHRlbmQoIHRhcmdldCwgcHJvcHMgKTtcblx0Zm9yICggdmFyIG5hbWUgaW4gcHJvcHMgKSB7XG5cdFx0aWYgKCBwcm9wc1sgbmFtZSBdID09IG51bGwgKSB7XG5cdFx0XHR0YXJnZXRbIG5hbWUgXSA9IHByb3BzWyBuYW1lIF07XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEludm9rZSB0aGUgZGF0ZXBpY2tlciBmdW5jdGlvbmFsaXR5LlxuICAgQHBhcmFtICBvcHRpb25zICBzdHJpbmcgLSBhIGNvbW1hbmQsIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIG9yXG5cdFx0XHRcdFx0T2JqZWN0IC0gc2V0dGluZ3MgZm9yIGF0dGFjaGluZyBuZXcgZGF0ZXBpY2tlciBmdW5jdGlvbmFsaXR5XG4gICBAcmV0dXJuICBqUXVlcnkgb2JqZWN0ICovXG4kLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvKiBWZXJpZnkgYW4gZW1wdHkgY29sbGVjdGlvbiB3YXNuJ3QgcGFzc2VkIC0gRml4ZXMgIzY5NzYgKi9cblx0aWYgKCAhdGhpcy5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiBJbml0aWFsaXNlIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0aWYgKCAhJC5kYXRlcGlja2VyLmluaXRpYWxpemVkICkge1xuXHRcdCQoIGRvY3VtZW50ICkub24oIFwibW91c2Vkb3duXCIsICQuZGF0ZXBpY2tlci5fY2hlY2tFeHRlcm5hbENsaWNrICk7XG5cdFx0JC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qIEFwcGVuZCBkYXRlcGlja2VyIG1haW4gY29udGFpbmVyIHRvIGJvZHkgaWYgbm90IGV4aXN0LiAqL1xuXHRpZiAoICQoIFwiI1wiICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQgKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0JCggXCJib2R5XCIgKS5hcHBlbmQoICQuZGF0ZXBpY2tlci5kcERpdiApO1xuXHR9XG5cblx0dmFyIG90aGVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiAmJiAoIG9wdGlvbnMgPT09IFwiaXNEaXNhYmxlZFwiIHx8IG9wdGlvbnMgPT09IFwiZ2V0RGF0ZVwiIHx8IG9wdGlvbnMgPT09IFwid2lkZ2V0XCIgKSApIHtcblx0XHRyZXR1cm4gJC5kYXRlcGlja2VyWyBcIl9cIiArIG9wdGlvbnMgKyBcIkRhdGVwaWNrZXJcIiBdLlxuXHRcdFx0YXBwbHkoICQuZGF0ZXBpY2tlciwgWyB0aGlzWyAwIF0gXS5jb25jYXQoIG90aGVyQXJncyApICk7XG5cdH1cblx0aWYgKCBvcHRpb25zID09PSBcIm9wdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sgMSBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbIFwiX1wiICsgb3B0aW9ucyArIFwiRGF0ZXBpY2tlclwiIF0uXG5cdFx0XHRhcHBseSggJC5kYXRlcGlja2VyLCBbIHRoaXNbIDAgXSBdLmNvbmNhdCggb3RoZXJBcmdzICkgKTtcblx0fVxuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHR0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHQkLmRhdGVwaWNrZXJbIFwiX1wiICsgb3B0aW9ucyArIFwiRGF0ZXBpY2tlclwiIF0uXG5cdFx0XHRcdGFwcGx5KCAkLmRhdGVwaWNrZXIsIFsgdGhpcyBdLmNvbmNhdCggb3RoZXJBcmdzICkgKSA6XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2F0dGFjaERhdGVwaWNrZXIoIHRoaXMsIG9wdGlvbnMgKTtcblx0fSApO1xufTtcblxuJC5kYXRlcGlja2VyID0gbmV3IERhdGVwaWNrZXIoKTsgLy8gc2luZ2xldG9uIGluc3RhbmNlXG4kLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiQuZGF0ZXBpY2tlci51dWlkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4kLmRhdGVwaWNrZXIudmVyc2lvbiA9IFwiMS4xMi4xXCI7XG5cbnJldHVybiAkLmRhdGVwaWNrZXI7XG5cbn0gKSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3dpZGdldHMvZGF0ZXBpY2tlci5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSA3IiwiLyohXG4gKiBqUXVlcnkgVUkgU2xpZGVyIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBTbGlkZXJcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBEaXNwbGF5cyBhIGZsZXhpYmxlIHNsaWRlciB3aXRoIHJhbmdlcyBhbmQgYWNjZXNzaWJpbGl0eSB2aWEga2V5Ym9hcmQuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2xpZGVyL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3NsaWRlci9cbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9jb3JlLmNzc1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL3NsaWRlci5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG4oIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggW1xuXHRcdFx0XCJqcXVlcnlcIixcblx0XHRcdFwiLi9tb3VzZVwiLFxuXHRcdFx0XCIuLi9rZXljb2RlXCIsXG5cdFx0XHRcIi4uL3ZlcnNpb25cIixcblx0XHRcdFwiLi4vd2lkZ2V0XCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSggZnVuY3Rpb24oICQgKSB7XG5cbnJldHVybiAkLndpZGdldCggXCJ1aS5zbGlkZXJcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTIuMVwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJzbGlkZVwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRhbmltYXRlOiBmYWxzZSxcblx0XHRjbGFzc2VzOiB7XG5cdFx0XHRcInVpLXNsaWRlclwiOiBcInVpLWNvcm5lci1hbGxcIixcblx0XHRcdFwidWktc2xpZGVyLWhhbmRsZVwiOiBcInVpLWNvcm5lci1hbGxcIixcblxuXHRcdFx0Ly8gTm90ZTogdWktd2lkZ2V0LWhlYWRlciBpc24ndCB0aGUgbW9zdCBmaXR0aW5nbHkgc2VtYW50aWMgZnJhbWV3b3JrIGNsYXNzIGZvciB0aGlzXG5cdFx0XHQvLyBlbGVtZW50LCBidXQgd29ya2VkIGJlc3QgdmlzdWFsbHkgd2l0aCBhIHZhcmlldHkgb2YgdGhlbWVzXG5cdFx0XHRcInVpLXNsaWRlci1yYW5nZVwiOiBcInVpLWNvcm5lci1hbGwgdWktd2lkZ2V0LWhlYWRlclwiXG5cdFx0fSxcblx0XHRkaXN0YW5jZTogMCxcblx0XHRtYXg6IDEwMCxcblx0XHRtaW46IDAsXG5cdFx0b3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuXHRcdHJhbmdlOiBmYWxzZSxcblx0XHRzdGVwOiAxLFxuXHRcdHZhbHVlOiAwLFxuXHRcdHZhbHVlczogbnVsbCxcblxuXHRcdC8vIENhbGxiYWNrc1xuXHRcdGNoYW5nZTogbnVsbCxcblx0XHRzbGlkZTogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cblx0Ly8gTnVtYmVyIG9mIHBhZ2VzIGluIGEgc2xpZGVyXG5cdC8vIChob3cgbWFueSB0aW1lcyBjYW4geW91IHBhZ2UgdXAvZG93biB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSByYW5nZSlcblx0bnVtUGFnZXM6IDUsXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fa2V5U2xpZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX21vdXNlU2xpZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gbnVsbDtcblx0XHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXHRcdHRoaXMuX2NhbGN1bGF0ZU5ld01heCgpO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIFwidWktc2xpZGVyIHVpLXNsaWRlci1cIiArIHRoaXMub3JpZW50YXRpb24sXG5cdFx0XHRcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudFwiICk7XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NyZWF0ZVJhbmdlKCk7XG5cdFx0dGhpcy5fY3JlYXRlSGFuZGxlcygpO1xuXHRcdHRoaXMuX3NldHVwRXZlbnRzKCk7XG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdH0sXG5cblx0X2NyZWF0ZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpLCBoYW5kbGVDb3VudCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRleGlzdGluZ0hhbmRsZXMgPSB0aGlzLmVsZW1lbnQuZmluZCggXCIudWktc2xpZGVyLWhhbmRsZVwiICksXG5cdFx0XHRoYW5kbGUgPSBcIjxzcGFuIHRhYmluZGV4PScwJz48L3NwYW4+XCIsXG5cdFx0XHRoYW5kbGVzID0gW107XG5cblx0XHRoYW5kbGVDb3VudCA9ICggb3B0aW9ucy52YWx1ZXMgJiYgb3B0aW9ucy52YWx1ZXMubGVuZ3RoICkgfHwgMTtcblxuXHRcdGlmICggZXhpc3RpbmdIYW5kbGVzLmxlbmd0aCA+IGhhbmRsZUNvdW50ICkge1xuXHRcdFx0ZXhpc3RpbmdIYW5kbGVzLnNsaWNlKCBoYW5kbGVDb3VudCApLnJlbW92ZSgpO1xuXHRcdFx0ZXhpc3RpbmdIYW5kbGVzID0gZXhpc3RpbmdIYW5kbGVzLnNsaWNlKCAwLCBoYW5kbGVDb3VudCApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSBleGlzdGluZ0hhbmRsZXMubGVuZ3RoOyBpIDwgaGFuZGxlQ291bnQ7IGkrKyApIHtcblx0XHRcdGhhbmRsZXMucHVzaCggaGFuZGxlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oYW5kbGVzID0gZXhpc3RpbmdIYW5kbGVzLmFkZCggJCggaGFuZGxlcy5qb2luKCBcIlwiICkgKS5hcHBlbmRUbyggdGhpcy5lbGVtZW50ICkgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmhhbmRsZXMsIFwidWktc2xpZGVyLWhhbmRsZVwiLCBcInVpLXN0YXRlLWRlZmF1bHRcIiApO1xuXG5cdFx0dGhpcy5oYW5kbGUgPSB0aGlzLmhhbmRsZXMuZXEoIDAgKTtcblxuXHRcdHRoaXMuaGFuZGxlcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdCQoIHRoaXMgKVxuXHRcdFx0XHQuZGF0YSggXCJ1aS1zbGlkZXItaGFuZGxlLWluZGV4XCIsIGkgKVxuXHRcdFx0XHQuYXR0ciggXCJ0YWJJbmRleFwiLCAwICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9jcmVhdGVSYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoIG9wdGlvbnMucmFuZ2UgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSB7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMudmFsdWVzICkge1xuXHRcdFx0XHRcdG9wdGlvbnMudmFsdWVzID0gWyB0aGlzLl92YWx1ZU1pbigpLCB0aGlzLl92YWx1ZU1pbigpIF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMudmFsdWVzLmxlbmd0aCAmJiBvcHRpb25zLnZhbHVlcy5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBbIG9wdGlvbnMudmFsdWVzWyAwIF0sIG9wdGlvbnMudmFsdWVzWyAwIF0gXTtcblx0XHRcdFx0fSBlbHNlIGlmICggJC5pc0FycmF5KCBvcHRpb25zLnZhbHVlcyApICkge1xuXHRcdFx0XHRcdG9wdGlvbnMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXMuc2xpY2UoIDAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICF0aGlzLnJhbmdlIHx8ICF0aGlzLnJhbmdlLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5yYW5nZSA9ICQoIFwiPGRpdj5cIiApXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5yYW5nZSwgXCJ1aS1zbGlkZXItcmFuZ2VcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMucmFuZ2UsIFwidWktc2xpZGVyLXJhbmdlLW1pbiB1aS1zbGlkZXItcmFuZ2UtbWF4XCIgKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgcmFuZ2Ugc3dpdGNoaW5nIGZyb20gdHJ1ZSB0byBtaW4vbWF4XG5cdFx0XHRcdHRoaXMucmFuZ2UuY3NzKCB7XG5cdFx0XHRcdFx0XCJsZWZ0XCI6IFwiXCIsXG5cdFx0XHRcdFx0XCJib3R0b21cIjogXCJcIlxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMucmFuZ2UgPT09IFwibWluXCIgfHwgb3B0aW9ucy5yYW5nZSA9PT0gXCJtYXhcIiApIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMucmFuZ2UsIFwidWktc2xpZGVyLXJhbmdlLVwiICsgb3B0aW9ucy5yYW5nZSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHRoaXMucmFuZ2UgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2UucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJhbmdlID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3NldHVwRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9vZmYoIHRoaXMuaGFuZGxlcyApO1xuXHRcdHRoaXMuX29uKCB0aGlzLmhhbmRsZXMsIHRoaXMuX2hhbmRsZUV2ZW50cyApO1xuXHRcdHRoaXMuX2hvdmVyYWJsZSggdGhpcy5oYW5kbGVzICk7XG5cdFx0dGhpcy5fZm9jdXNhYmxlKCB0aGlzLmhhbmRsZXMgKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVzLnJlbW92ZSgpO1xuXHRcdGlmICggdGhpcy5yYW5nZSApIHtcblx0XHRcdHRoaXMucmFuZ2UucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBwb3NpdGlvbiwgbm9ybVZhbHVlLCBkaXN0YW5jZSwgY2xvc2VzdEhhbmRsZSwgaW5kZXgsIGFsbG93ZWQsIG9mZnNldCwgbW91c2VPdmVySGFuZGxlLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvLmRpc2FibGVkICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudFNpemUgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHRcdHRoaXMuZWxlbWVudE9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblxuXHRcdHBvc2l0aW9uID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfTtcblx0XHRub3JtVmFsdWUgPSB0aGlzLl9ub3JtVmFsdWVGcm9tTW91c2UoIHBvc2l0aW9uICk7XG5cdFx0ZGlzdGFuY2UgPSB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKSArIDE7XG5cdFx0dGhpcy5oYW5kbGVzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHRoaXNEaXN0YW5jZSA9IE1hdGguYWJzKCBub3JtVmFsdWUgLSB0aGF0LnZhbHVlcyggaSApICk7XG5cdFx0XHRpZiAoICggZGlzdGFuY2UgPiB0aGlzRGlzdGFuY2UgKSB8fFxuXHRcdFx0XHQoIGRpc3RhbmNlID09PSB0aGlzRGlzdGFuY2UgJiZcblx0XHRcdFx0XHQoIGkgPT09IHRoYXQuX2xhc3RDaGFuZ2VkVmFsdWUgfHwgdGhhdC52YWx1ZXMoIGkgKSA9PT0gby5taW4gKSApICkge1xuXHRcdFx0XHRkaXN0YW5jZSA9IHRoaXNEaXN0YW5jZTtcblx0XHRcdFx0Y2xvc2VzdEhhbmRsZSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGFsbG93ZWQgPSB0aGlzLl9zdGFydCggZXZlbnQsIGluZGV4ICk7XG5cdFx0aWYgKCBhbGxvd2VkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gaW5kZXg7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggY2xvc2VzdEhhbmRsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdGNsb3Nlc3RIYW5kbGUudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cblx0XHRvZmZzZXQgPSBjbG9zZXN0SGFuZGxlLm9mZnNldCgpO1xuXHRcdG1vdXNlT3ZlckhhbmRsZSA9ICEkKCBldmVudC50YXJnZXQgKS5wYXJlbnRzKCkuYWRkQmFjaygpLmlzKCBcIi51aS1zbGlkZXItaGFuZGxlXCIgKTtcblx0XHR0aGlzLl9jbGlja09mZnNldCA9IG1vdXNlT3ZlckhhbmRsZSA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiB7XG5cdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gKCBjbG9zZXN0SGFuZGxlLndpZHRoKCkgLyAyICksXG5cdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gb2Zmc2V0LnRvcCAtXG5cdFx0XHRcdCggY2xvc2VzdEhhbmRsZS5oZWlnaHQoKSAvIDIgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKCBcImJvcmRlclRvcFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHQoIHBhcnNlSW50KCBjbG9zZXN0SGFuZGxlLmNzcyggXCJib3JkZXJCb3R0b21XaWR0aFwiICksIDEwICkgfHwgMCApICtcblx0XHRcdFx0KCBwYXJzZUludCggY2xvc2VzdEhhbmRsZS5jc3MoIFwibWFyZ2luVG9wXCIgKSwgMTAgKSB8fCAwIClcblx0XHR9O1xuXG5cdFx0aWYgKCAhdGhpcy5oYW5kbGVzLmhhc0NsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKSApIHtcblx0XHRcdHRoaXMuX3NsaWRlKCBldmVudCwgaW5kZXgsIG5vcm1WYWx1ZSApO1xuXHRcdH1cblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlRHJhZzogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBwb3NpdGlvbiA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH0sXG5cdFx0XHRub3JtVmFsdWUgPSB0aGlzLl9ub3JtVmFsdWVGcm9tTW91c2UoIHBvc2l0aW9uICk7XG5cblx0XHR0aGlzLl9zbGlkZSggZXZlbnQsIHRoaXMuX2hhbmRsZUluZGV4LCBub3JtVmFsdWUgKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaGFuZGxlcywgbnVsbCwgXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdHRoaXMuX21vdXNlU2xpZGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fc3RvcCggZXZlbnQsIHRoaXMuX2hhbmRsZUluZGV4ICk7XG5cdFx0dGhpcy5fY2hhbmdlKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXggKTtcblxuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gbnVsbDtcblx0XHR0aGlzLl9jbGlja09mZnNldCA9IG51bGw7XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9kZXRlY3RPcmllbnRhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vcmllbnRhdGlvbiA9ICggdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgKSA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiO1xuXHR9LFxuXG5cdF9ub3JtVmFsdWVGcm9tTW91c2U6IGZ1bmN0aW9uKCBwb3NpdGlvbiApIHtcblx0XHR2YXIgcGl4ZWxUb3RhbCxcblx0XHRcdHBpeGVsTW91c2UsXG5cdFx0XHRwZXJjZW50TW91c2UsXG5cdFx0XHR2YWx1ZVRvdGFsLFxuXHRcdFx0dmFsdWVNb3VzZTtcblxuXHRcdGlmICggdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRwaXhlbFRvdGFsID0gdGhpcy5lbGVtZW50U2l6ZS53aWR0aDtcblx0XHRcdHBpeGVsTW91c2UgPSBwb3NpdGlvbi54IC0gdGhpcy5lbGVtZW50T2Zmc2V0LmxlZnQgLVxuXHRcdFx0XHQoIHRoaXMuX2NsaWNrT2Zmc2V0ID8gdGhpcy5fY2xpY2tPZmZzZXQubGVmdCA6IDAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGl4ZWxUb3RhbCA9IHRoaXMuZWxlbWVudFNpemUuaGVpZ2h0O1xuXHRcdFx0cGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnkgLSB0aGlzLmVsZW1lbnRPZmZzZXQudG9wIC1cblx0XHRcdFx0KCB0aGlzLl9jbGlja09mZnNldCA/IHRoaXMuX2NsaWNrT2Zmc2V0LnRvcCA6IDAgKTtcblx0XHR9XG5cblx0XHRwZXJjZW50TW91c2UgPSAoIHBpeGVsTW91c2UgLyBwaXhlbFRvdGFsICk7XG5cdFx0aWYgKCBwZXJjZW50TW91c2UgPiAxICkge1xuXHRcdFx0cGVyY2VudE1vdXNlID0gMTtcblx0XHR9XG5cdFx0aWYgKCBwZXJjZW50TW91c2UgPCAwICkge1xuXHRcdFx0cGVyY2VudE1vdXNlID0gMDtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAxIC0gcGVyY2VudE1vdXNlO1xuXHRcdH1cblxuXHRcdHZhbHVlVG90YWwgPSB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHR2YWx1ZU1vdXNlID0gdGhpcy5fdmFsdWVNaW4oKSArIHBlcmNlbnRNb3VzZSAqIHZhbHVlVG90YWw7XG5cblx0XHRyZXR1cm4gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbHVlTW91c2UgKTtcblx0fSxcblxuXHRfdWlIYXNoOiBmdW5jdGlvbiggaW5kZXgsIHZhbHVlLCB2YWx1ZXMgKSB7XG5cdFx0dmFyIHVpSGFzaCA9IHtcblx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0aGFuZGxlSW5kZXg6IGluZGV4LFxuXHRcdFx0dmFsdWU6IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHRoaXMudmFsdWUoKVxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHR1aUhhc2gudmFsdWUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdHVpSGFzaC52YWx1ZXMgPSB2YWx1ZXMgfHwgdGhpcy52YWx1ZXMoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdWlIYXNoO1xuXHR9LFxuXG5cdF9oYXNNdWx0aXBsZVZhbHVlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg7XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdHJldHVybiB0aGlzLl90cmlnZ2VyKCBcInN0YXJ0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIGluZGV4ICkgKTtcblx0fSxcblxuXHRfc2xpZGU6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXgsIG5ld1ZhbCApIHtcblx0XHR2YXIgYWxsb3dlZCwgb3RoZXJWYWwsXG5cdFx0XHRjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlKCksXG5cdFx0XHRuZXdWYWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xuXG5cdFx0aWYgKCB0aGlzLl9oYXNNdWx0aXBsZVZhbHVlcygpICkge1xuXHRcdFx0b3RoZXJWYWwgPSB0aGlzLnZhbHVlcyggaW5kZXggPyAwIDogMSApO1xuXHRcdFx0Y3VycmVudFZhbHVlID0gdGhpcy52YWx1ZXMoIGluZGV4ICk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggPT09IDIgJiYgdGhpcy5vcHRpb25zLnJhbmdlID09PSB0cnVlICkge1xuXHRcdFx0XHRuZXdWYWwgPSAgaW5kZXggPT09IDAgPyBNYXRoLm1pbiggb3RoZXJWYWwsIG5ld1ZhbCApIDogTWF0aC5tYXgoIG90aGVyVmFsLCBuZXdWYWwgKTtcblx0XHRcdH1cblxuXHRcdFx0bmV3VmFsdWVzWyBpbmRleCBdID0gbmV3VmFsO1xuXHRcdH1cblxuXHRcdGlmICggbmV3VmFsID09PSBjdXJyZW50VmFsdWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0YWxsb3dlZCA9IHRoaXMuX3RyaWdnZXIoIFwic2xpZGVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggaW5kZXgsIG5ld1ZhbCwgbmV3VmFsdWVzICkgKTtcblxuXHRcdC8vIEEgc2xpZGUgY2FuIGJlIGNhbmNlbGVkIGJ5IHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBzbGlkZSBjYWxsYmFja1xuXHRcdGlmICggYWxsb3dlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9oYXNNdWx0aXBsZVZhbHVlcygpICkge1xuXHRcdFx0dGhpcy52YWx1ZXMoIGluZGV4LCBuZXdWYWwgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52YWx1ZSggbmV3VmFsICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdG9wOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwic3RvcFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCBpbmRleCApICk7XG5cdH0sXG5cblx0X2NoYW5nZTogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCApIHtcblx0XHRpZiAoICF0aGlzLl9rZXlTbGlkaW5nICYmICF0aGlzLl9tb3VzZVNsaWRpbmcgKSB7XG5cblx0XHRcdC8vc3RvcmUgdGhlIGxhc3QgY2hhbmdlZCB2YWx1ZSBpbmRleCBmb3IgcmVmZXJlbmNlIHdoZW4gaGFuZGxlcyBvdmVybGFwXG5cdFx0XHR0aGlzLl9sYXN0Q2hhbmdlZFZhbHVlID0gaW5kZXg7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNoYW5nZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCBpbmRleCApICk7XG5cdFx0fVxuXHR9LFxuXG5cdHZhbHVlOiBmdW5jdGlvbiggbmV3VmFsdWUgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlICk7XG5cdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgMCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl92YWx1ZSgpO1xuXHR9LFxuXG5cdHZhbHVlczogZnVuY3Rpb24oIGluZGV4LCBuZXdWYWx1ZSApIHtcblx0XHR2YXIgdmFscyxcblx0XHRcdG5ld1ZhbHVlcyxcblx0XHRcdGk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlc1sgaW5kZXggXSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBuZXdWYWx1ZSApO1xuXHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIGluZGV4ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCAkLmlzQXJyYXkoIGFyZ3VtZW50c1sgMCBdICkgKSB7XG5cdFx0XHRcdHZhbHMgPSB0aGlzLm9wdGlvbnMudmFsdWVzO1xuXHRcdFx0XHRuZXdWYWx1ZXMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdHZhbHNbIGkgXSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBuZXdWYWx1ZXNbIGkgXSApO1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB0aGlzLl9oYXNNdWx0aXBsZVZhbHVlcygpICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl92YWx1ZXMoIGluZGV4ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLFxuXHRcdFx0dmFsc0xlbmd0aCA9IDA7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJyYW5nZVwiICYmIHRoaXMub3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IFwibWluXCIgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX3ZhbHVlcyggMCApO1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMudmFsdWVzID0gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSBcIm1heFwiICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl92YWx1ZXMoIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoIC0gMSApO1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMudmFsdWVzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICQuaXNBcnJheSggdGhpcy5vcHRpb25zLnZhbHVlcyApICkge1xuXHRcdFx0dmFsc0xlbmd0aCA9IHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRzd2l0Y2ggKCBrZXkgKSB7XG5cdFx0XHRjYXNlIFwib3JpZW50YXRpb25cIjpcblx0XHRcdFx0dGhpcy5fZGV0ZWN0T3JpZW50YXRpb24oKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIFwidWktc2xpZGVyLWhvcml6b250YWwgdWktc2xpZGVyLXZlcnRpY2FsXCIgKVxuXHRcdFx0XHRcdC5fYWRkQ2xhc3MoIFwidWktc2xpZGVyLVwiICsgdGhpcy5vcmllbnRhdGlvbiApO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucmFuZ2UgKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVmcmVzaFJhbmdlKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzZXQgcG9zaXRpb25pbmcgZnJvbSBwcmV2aW91cyBvcmllbnRhdGlvblxuXHRcdFx0XHR0aGlzLmhhbmRsZXMuY3NzKCB2YWx1ZSA9PT0gXCJob3Jpem9udGFsXCIgPyBcImJvdHRvbVwiIDogXCJsZWZ0XCIsIFwiXCIgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwidmFsdWVcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIDAgKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ2YWx1ZXNcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXG5cdFx0XHRcdC8vIFN0YXJ0IGZyb20gdGhlIGxhc3QgaGFuZGxlIHRvIHByZXZlbnQgdW5yZWFjaGFibGUgaGFuZGxlcyAoIzkwNDYpXG5cdFx0XHRcdGZvciAoIGkgPSB2YWxzTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJzdGVwXCI6XG5cdFx0XHRjYXNlIFwibWluXCI6XG5cdFx0XHRjYXNlIFwibWF4XCI6XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9jYWxjdWxhdGVOZXdNYXgoKTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicmFuZ2VcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2goKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIHZhbHVlICk7XG5cblx0XHR0aGlzLl90b2dnbGVDbGFzcyggbnVsbCwgXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiLCAhIXZhbHVlICk7XG5cdH0sXG5cblx0Ly9pbnRlcm5hbCB2YWx1ZSBnZXR0ZXJcblx0Ly8gX3ZhbHVlKCkgcmV0dXJucyB2YWx1ZSB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4LCBhbGlnbmVkIGJ5IHN0ZXBcblx0X3ZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsID0gdGhpcy5vcHRpb25zLnZhbHVlO1xuXHRcdHZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWwgKTtcblxuXHRcdHJldHVybiB2YWw7XG5cdH0sXG5cblx0Ly9pbnRlcm5hbCB2YWx1ZXMgZ2V0dGVyXG5cdC8vIF92YWx1ZXMoKSByZXR1cm5zIGFycmF5IG9mIHZhbHVlcyB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4LCBhbGlnbmVkIGJ5IHN0ZXBcblx0Ly8gX3ZhbHVlcyggaW5kZXggKSByZXR1cm5zIHNpbmdsZSB2YWx1ZSB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4LCBhbGlnbmVkIGJ5IHN0ZXBcblx0X3ZhbHVlczogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciB2YWwsXG5cdFx0XHR2YWxzLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHZhbCA9IHRoaXMub3B0aW9ucy52YWx1ZXNbIGluZGV4IF07XG5cdFx0XHR2YWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsICk7XG5cblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5faGFzTXVsdGlwbGVWYWx1ZXMoKSApIHtcblxuXHRcdFx0Ly8gLnNsaWNlKCkgY3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFycmF5XG5cdFx0XHQvLyB0aGlzIGNvcHkgZ2V0cyB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4IGFuZCB0aGVuIHJldHVybmVkXG5cdFx0XHR2YWxzID0gdGhpcy5vcHRpb25zLnZhbHVlcy5zbGljZSgpO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHR2YWxzWyBpIF0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsc1sgaSBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWxzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFJldHVybnMgdGhlIHN0ZXAtYWxpZ25lZCB2YWx1ZSB0aGF0IHZhbCBpcyBjbG9zZXN0IHRvLCBiZXR3ZWVuIChpbmNsdXNpdmUpIG1pbiBhbmQgbWF4XG5cdF90cmltQWxpZ25WYWx1ZTogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRpZiAoIHZhbCA8PSB0aGlzLl92YWx1ZU1pbigpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0fVxuXHRcdGlmICggdmFsID49IHRoaXMuX3ZhbHVlTWF4KCkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHR9XG5cdFx0dmFyIHN0ZXAgPSAoIHRoaXMub3B0aW9ucy5zdGVwID4gMCApID8gdGhpcy5vcHRpb25zLnN0ZXAgOiAxLFxuXHRcdFx0dmFsTW9kU3RlcCA9ICggdmFsIC0gdGhpcy5fdmFsdWVNaW4oKSApICUgc3RlcCxcblx0XHRcdGFsaWduVmFsdWUgPSB2YWwgLSB2YWxNb2RTdGVwO1xuXG5cdFx0aWYgKCBNYXRoLmFicyggdmFsTW9kU3RlcCApICogMiA+PSBzdGVwICkge1xuXHRcdFx0YWxpZ25WYWx1ZSArPSAoIHZhbE1vZFN0ZXAgPiAwICkgPyBzdGVwIDogKCAtc3RlcCApO1xuXHRcdH1cblxuXHRcdC8vIFNpbmNlIEphdmFTY3JpcHQgaGFzIHByb2JsZW1zIHdpdGggbGFyZ2UgZmxvYXRzLCByb3VuZFxuXHRcdC8vIHRoZSBmaW5hbCB2YWx1ZSB0byA1IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCAoc2VlICM0MTI0KVxuXHRcdHJldHVybiBwYXJzZUZsb2F0KCBhbGlnblZhbHVlLnRvRml4ZWQoIDUgKSApO1xuXHR9LFxuXG5cdF9jYWxjdWxhdGVOZXdNYXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXggPSB0aGlzLm9wdGlvbnMubWF4LFxuXHRcdFx0bWluID0gdGhpcy5fdmFsdWVNaW4oKSxcblx0XHRcdHN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcCxcblx0XHRcdGFib3ZlTWluID0gTWF0aC5yb3VuZCggKCBtYXggLSBtaW4gKSAvIHN0ZXAgKSAqIHN0ZXA7XG5cdFx0bWF4ID0gYWJvdmVNaW4gKyBtaW47XG5cdFx0aWYgKCBtYXggPiB0aGlzLm9wdGlvbnMubWF4ICkge1xuXG5cdFx0XHQvL0lmIG1heCBpcyBub3QgZGl2aXNpYmxlIGJ5IHN0ZXAsIHJvdW5kaW5nIG9mZiBtYXkgaW5jcmVhc2UgaXRzIHZhbHVlXG5cdFx0XHRtYXggLT0gc3RlcDtcblx0XHR9XG5cdFx0dGhpcy5tYXggPSBwYXJzZUZsb2F0KCBtYXgudG9GaXhlZCggdGhpcy5fcHJlY2lzaW9uKCkgKSApO1xuXHR9LFxuXG5cdF9wcmVjaXNpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmVjaXNpb24gPSB0aGlzLl9wcmVjaXNpb25PZiggdGhpcy5vcHRpb25zLnN0ZXAgKTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5taW4gIT09IG51bGwgKSB7XG5cdFx0XHRwcmVjaXNpb24gPSBNYXRoLm1heCggcHJlY2lzaW9uLCB0aGlzLl9wcmVjaXNpb25PZiggdGhpcy5vcHRpb25zLm1pbiApICk7XG5cdFx0fVxuXHRcdHJldHVybiBwcmVjaXNpb247XG5cdH0sXG5cblx0X3ByZWNpc2lvbk9mOiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHZhciBzdHIgPSBudW0udG9TdHJpbmcoKSxcblx0XHRcdGRlY2ltYWwgPSBzdHIuaW5kZXhPZiggXCIuXCIgKTtcblx0XHRyZXR1cm4gZGVjaW1hbCA9PT0gLTEgPyAwIDogc3RyLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xuXHR9LFxuXG5cdF92YWx1ZU1pbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW47XG5cdH0sXG5cblx0X3ZhbHVlTWF4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXg7XG5cdH0sXG5cblx0X3JlZnJlc2hSYW5nZTogZnVuY3Rpb24oIG9yaWVudGF0aW9uICkge1xuXHRcdGlmICggb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdHRoaXMucmFuZ2UuY3NzKCB7IFwid2lkdGhcIjogXCJcIiwgXCJsZWZ0XCI6IFwiXCIgfSApO1xuXHRcdH1cblx0XHRpZiAoIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdHRoaXMucmFuZ2UuY3NzKCB7IFwiaGVpZ2h0XCI6IFwiXCIsIFwiYm90dG9tXCI6IFwiXCIgfSApO1xuXHRcdH1cblx0fSxcblxuXHRfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdFZhbFBlcmNlbnQsIHZhbFBlcmNlbnQsIHZhbHVlLCB2YWx1ZU1pbiwgdmFsdWVNYXgsXG5cdFx0XHRvUmFuZ2UgPSB0aGlzLm9wdGlvbnMucmFuZ2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRhbmltYXRlID0gKCAhdGhpcy5fYW5pbWF0ZU9mZiApID8gby5hbmltYXRlIDogZmFsc2UsXG5cdFx0XHRfc2V0ID0ge307XG5cblx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHZhbFBlcmNlbnQgPSAoIHRoYXQudmFsdWVzKCBpICkgLSB0aGF0Ll92YWx1ZU1pbigpICkgLyAoIHRoYXQuX3ZhbHVlTWF4KCkgLVxuXHRcdFx0XHRcdHRoYXQuX3ZhbHVlTWluKCkgKSAqIDEwMDtcblx0XHRcdFx0X3NldFsgdGhhdC5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImxlZnRcIiA6IFwiYm90dG9tXCIgXSA9IHZhbFBlcmNlbnQgKyBcIiVcIjtcblx0XHRcdFx0JCggdGhpcyApLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCBfc2V0LCBvLmFuaW1hdGUgKTtcblx0XHRcdFx0aWYgKCB0aGF0Lm9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGF0Lm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSgge1xuXHRcdFx0XHRcdFx0XHRcdGxlZnQ6IHZhbFBlcmNlbnQgKyBcIiVcIlxuXHRcdFx0XHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6ICggdmFsUGVyY2VudCAtIGxhc3RWYWxQZXJjZW50ICkgKyBcIiVcIlxuXHRcdFx0XHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0XHRcdFx0cXVldWU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBvLmFuaW1hdGVcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHRcdFx0XHRib3R0b206ICggdmFsUGVyY2VudCApICsgXCIlXCJcblx0XHRcdFx0XHRcdFx0fSwgby5hbmltYXRlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2VbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSgge1xuXHRcdFx0XHRcdFx0XHRcdGhlaWdodDogKCB2YWxQZXJjZW50IC0gbGFzdFZhbFBlcmNlbnQgKSArIFwiJVwiXG5cdFx0XHRcdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRcdFx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IG8uYW5pbWF0ZVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RWYWxQZXJjZW50ID0gdmFsUGVyY2VudDtcblx0XHRcdH0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZhbHVlKCk7XG5cdFx0XHR2YWx1ZU1pbiA9IHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0XHR2YWx1ZU1heCA9IHRoaXMuX3ZhbHVlTWF4KCk7XG5cdFx0XHR2YWxQZXJjZW50ID0gKCB2YWx1ZU1heCAhPT0gdmFsdWVNaW4gKSA/XG5cdFx0XHRcdFx0KCB2YWx1ZSAtIHZhbHVlTWluICkgLyAoIHZhbHVlTWF4IC0gdmFsdWVNaW4gKSAqIDEwMCA6XG5cdFx0XHRcdFx0MDtcblx0XHRcdF9zZXRbIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiIF0gPSB2YWxQZXJjZW50ICsgXCIlXCI7XG5cdFx0XHR0aGlzLmhhbmRsZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggX3NldCwgby5hbmltYXRlICk7XG5cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1pblwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0d2lkdGg6IHZhbFBlcmNlbnQgKyBcIiVcIlxuXHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1heFwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0d2lkdGg6ICggMTAwIC0gdmFsUGVyY2VudCApICsgXCIlXCJcblx0XHRcdFx0fSwgby5hbmltYXRlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9SYW5nZSA9PT0gXCJtaW5cIiAmJiB0aGlzLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHRoZWlnaHQ6IHZhbFBlcmNlbnQgKyBcIiVcIlxuXHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1heFwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSgge1xuXHRcdFx0XHRcdGhlaWdodDogKCAxMDAgLSB2YWxQZXJjZW50ICkgKyBcIiVcIlxuXHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUV2ZW50czoge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBhbGxvd2VkLCBjdXJWYWwsIG5ld1ZhbCwgc3RlcCxcblx0XHRcdFx0aW5kZXggPSAkKCBldmVudC50YXJnZXQgKS5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiApO1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdFx0XHRcdHRoaXMuX2tleVNsaWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoICQoIGV2ZW50LnRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0XHRhbGxvd2VkID0gdGhpcy5fc3RhcnQoIGV2ZW50LCBpbmRleCApO1xuXHRcdFx0XHRcdFx0aWYgKCBhbGxvd2VkID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0c3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwO1xuXHRcdFx0aWYgKCB0aGlzLl9oYXNNdWx0aXBsZVZhbHVlcygpICkge1xuXHRcdFx0XHRjdXJWYWwgPSBuZXdWYWwgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1clZhbCA9IG5ld1ZhbCA9IHRoaXMudmFsdWUoKTtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZShcblx0XHRcdFx0XHRcdGN1clZhbCArICggKCB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKSApIC8gdGhpcy5udW1QYWdlcyApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKFxuXHRcdFx0XHRcdFx0Y3VyVmFsIC0gKCAoIHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICkgLyB0aGlzLm51bVBhZ2VzICkgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdFx0XHRcdGlmICggY3VyVmFsID09PSB0aGlzLl92YWx1ZU1heCgpICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsICsgc3RlcCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHRcdGlmICggY3VyVmFsID09PSB0aGlzLl92YWx1ZU1pbigpICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsIC0gc3RlcCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zbGlkZSggZXZlbnQsIGluZGV4LCBuZXdWYWwgKTtcblx0XHR9LFxuXHRcdGtleXVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgaW5kZXggPSAkKCBldmVudC50YXJnZXQgKS5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiApO1xuXG5cdFx0XHRpZiAoIHRoaXMuX2tleVNsaWRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuX2tleVNsaWRpbmcgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fc3RvcCggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZSggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC50YXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG59ICkgKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXRzL3NsaWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSA3IiwiLyohXG4gKiBqUXVlcnkgVUkgTW91c2UgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IE1vdXNlXG4vLz4+Z3JvdXA6IFdpZGdldHNcbi8vPj5kZXNjcmlwdGlvbjogQWJzdHJhY3RzIG1vdXNlLWJhc2VkIGludGVyYWN0aW9ucyB0byBhc3Npc3QgaW4gY3JlYXRpbmcgY2VydGFpbiB3aWRnZXRzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL21vdXNlL1xuXG4oIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggW1xuXHRcdFx0XCJqcXVlcnlcIixcblx0XHRcdFwiLi4vaWVcIixcblx0XHRcdFwiLi4vdmVyc2lvblwiLFxuXHRcdFx0XCIuLi93aWRnZXRcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59KCBmdW5jdGlvbiggJCApIHtcblxudmFyIG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuJCggZG9jdW1lbnQgKS5vbiggXCJtb3VzZXVwXCIsIGZ1bmN0aW9uKCkge1xuXHRtb3VzZUhhbmRsZWQgPSBmYWxzZTtcbn0gKTtcblxucmV0dXJuICQud2lkZ2V0KCBcInVpLm1vdXNlXCIsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0b3B0aW9uczoge1xuXHRcdGNhbmNlbDogXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0LCBvcHRpb25cIixcblx0XHRkaXN0YW5jZTogMSxcblx0XHRkZWxheTogMFxuXHR9LFxuXHRfbW91c2VJbml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5vbiggXCJtb3VzZWRvd24uXCIgKyB0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlRG93biggZXZlbnQgKTtcblx0XHRcdH0gKVxuXHRcdFx0Lm9uKCBcImNsaWNrLlwiICsgdGhpcy53aWRnZXROYW1lLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdHJ1ZSA9PT0gJC5kYXRhKCBldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIgKSApIHtcblx0XHRcdFx0XHQkLnJlbW92ZURhdGEoIGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiApO1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0dGhpcy5zdGFydGVkID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVE9ETzogbWFrZSBzdXJlIGRlc3Ryb3lpbmcgb25lIGluc3RhbmNlIG9mIG1vdXNlIGRvZXNuJ3QgbWVzcyB3aXRoXG5cdC8vIG90aGVyIGluc3RhbmNlcyBvZiBtb3VzZVxuXHRfbW91c2VEZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQub2ZmKCBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSApO1xuXHRcdGlmICggdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKSB7XG5cdFx0XHR0aGlzLmRvY3VtZW50XG5cdFx0XHRcdC5vZmYoIFwibW91c2Vtb3ZlLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApXG5cdFx0XHRcdC5vZmYoIFwibW91c2V1cC5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9tb3VzZURvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxuXHRcdGlmICggbW91c2VIYW5kbGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlTW92ZWQgPSBmYWxzZTtcblxuXHRcdC8vIFdlIG1heSBoYXZlIG1pc3NlZCBtb3VzZXVwIChvdXQgb2Ygd2luZG93KVxuXHRcdCggdGhpcy5fbW91c2VTdGFydGVkICYmIHRoaXMuX21vdXNlVXAoIGV2ZW50ICkgKTtcblxuXHRcdHRoaXMuX21vdXNlRG93bkV2ZW50ID0gZXZlbnQ7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRidG5Jc0xlZnQgPSAoIGV2ZW50LndoaWNoID09PSAxICksXG5cblx0XHRcdC8vIGV2ZW50LnRhcmdldC5ub2RlTmFtZSB3b3JrcyBhcm91bmQgYSBidWcgaW4gSUUgOCB3aXRoXG5cdFx0XHQvLyBkaXNhYmxlZCBpbnB1dHMgKCM3NjIwKVxuXHRcdFx0ZWxJc0NhbmNlbCA9ICggdHlwZW9mIHRoaXMub3B0aW9ucy5jYW5jZWwgPT09IFwic3RyaW5nXCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID9cblx0XHRcdFx0JCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggdGhpcy5vcHRpb25zLmNhbmNlbCApLmxlbmd0aCA6IGZhbHNlICk7XG5cdFx0aWYgKCAhYnRuSXNMZWZ0IHx8IGVsSXNDYW5jZWwgfHwgIXRoaXMuX21vdXNlQ2FwdHVyZSggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMubW91c2VEZWxheU1ldCA9ICF0aGlzLm9wdGlvbnMuZGVsYXk7XG5cdFx0aWYgKCAhdGhpcy5tb3VzZURlbGF5TWV0ICkge1xuXHRcdFx0dGhpcy5fbW91c2VEZWxheVRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQubW91c2VEZWxheU1ldCA9IHRydWU7XG5cdFx0XHR9LCB0aGlzLm9wdGlvbnMuZGVsYXkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoIGV2ZW50ICkgJiYgdGhpcy5fbW91c2VEZWxheU1ldCggZXZlbnQgKSApIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9ICggdGhpcy5fbW91c2VTdGFydCggZXZlbnQgKSAhPT0gZmFsc2UgKTtcblx0XHRcdGlmICggIXRoaXMuX21vdXNlU3RhcnRlZCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpY2sgZXZlbnQgbWF5IG5ldmVyIGhhdmUgZmlyZWQgKEdlY2tvICYgT3BlcmEpXG5cdFx0aWYgKCB0cnVlID09PSAkLmRhdGEoIGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiApICkge1xuXHRcdFx0JC5yZW1vdmVEYXRhKCBldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIgKTtcblx0XHR9XG5cblx0XHQvLyBUaGVzZSBkZWxlZ2F0ZXMgYXJlIHJlcXVpcmVkIHRvIGtlZXAgY29udGV4dFxuXHRcdHRoaXMuX21vdXNlTW92ZURlbGVnYXRlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlTW92ZSggZXZlbnQgKTtcblx0XHR9O1xuXHRcdHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZVVwKCBldmVudCApO1xuXHRcdH07XG5cblx0XHR0aGlzLmRvY3VtZW50XG5cdFx0XHQub24oIFwibW91c2Vtb3ZlLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApXG5cdFx0XHQub24oIFwibW91c2V1cC5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlICk7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0bW91c2VIYW5kbGVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VNb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBPbmx5IGNoZWNrIGZvciBtb3VzZXVwcyBvdXRzaWRlIHRoZSBkb2N1bWVudCBpZiB5b3UndmUgbW92ZWQgaW5zaWRlIHRoZSBkb2N1bWVudFxuXHRcdC8vIGF0IGxlYXN0IG9uY2UuIFRoaXMgcHJldmVudHMgdGhlIGZpcmluZyBvZiBtb3VzZXVwIGluIHRoZSBjYXNlIG9mIElFPDksIHdoaWNoIHdpbGxcblx0XHQvLyBmaXJlIGEgbW91c2Vtb3ZlIGV2ZW50IGlmIGNvbnRlbnQgaXMgcGxhY2VkIHVuZGVyIHRoZSBjdXJzb3IuIFNlZSAjNzc3OFxuXHRcdC8vIFN1cHBvcnQ6IElFIDw5XG5cdFx0aWYgKCB0aGlzLl9tb3VzZU1vdmVkICkge1xuXG5cdFx0XHQvLyBJRSBtb3VzZXVwIGNoZWNrIC0gbW91c2V1cCBoYXBwZW5lZCB3aGVuIG1vdXNlIHdhcyBvdXQgb2Ygd2luZG93XG5cdFx0XHRpZiAoICQudWkuaWUgJiYgKCAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDkgKSAmJlxuXHRcdFx0XHRcdCFldmVudC5idXR0b24gKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tb3VzZVVwKCBldmVudCApO1xuXG5cdFx0XHQvLyBJZnJhbWUgbW91c2V1cCBjaGVjayAtIG1vdXNldXAgb2NjdXJyZWQgaW4gYW5vdGhlciBkb2N1bWVudFxuXHRcdFx0fSBlbHNlIGlmICggIWV2ZW50LndoaWNoICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTggLSA5XG5cdFx0XHRcdC8vIFNhZmFyaSBzZXRzIHdoaWNoIHRvIDAgaWYgeW91IHByZXNzIGFueSBvZiB0aGUgZm9sbG93aW5nIGtleXNcblx0XHRcdFx0Ly8gZHVyaW5nIGEgZHJhZyAoIzE0NDYxKVxuXHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY3RybEtleSB8fFxuXHRcdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgKSB7XG5cdFx0XHRcdFx0dGhpcy5pZ25vcmVNaXNzaW5nV2hpY2ggPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAhdGhpcy5pZ25vcmVNaXNzaW5nV2hpY2ggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGV2ZW50LndoaWNoIHx8IGV2ZW50LmJ1dHRvbiApIHtcblx0XHRcdHRoaXMuX21vdXNlTW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fbW91c2VTdGFydGVkICkge1xuXHRcdFx0dGhpcy5fbW91c2VEcmFnKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9tb3VzZURpc3RhbmNlTWV0KCBldmVudCApICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoIGV2ZW50ICkgKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPVxuXHRcdFx0XHQoIHRoaXMuX21vdXNlU3RhcnQoIHRoaXMuX21vdXNlRG93bkV2ZW50LCBldmVudCApICE9PSBmYWxzZSApO1xuXHRcdFx0KCB0aGlzLl9tb3VzZVN0YXJ0ZWQgPyB0aGlzLl9tb3VzZURyYWcoIGV2ZW50ICkgOiB0aGlzLl9tb3VzZVVwKCBldmVudCApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICF0aGlzLl9tb3VzZVN0YXJ0ZWQ7XG5cdH0sXG5cblx0X21vdXNlVXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLmRvY3VtZW50XG5cdFx0XHQub2ZmKCBcIm1vdXNlbW92ZS5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKVxuXHRcdFx0Lm9mZiggXCJtb3VzZXVwLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUgKTtcblxuXHRcdGlmICggdGhpcy5fbW91c2VTdGFydGVkICkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID0gZmFsc2U7XG5cblx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9tb3VzZURvd25FdmVudC50YXJnZXQgKSB7XG5cdFx0XHRcdCQuZGF0YSggZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlU3RvcCggZXZlbnQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX21vdXNlRGVsYXlUaW1lciApIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5fbW91c2VEZWxheVRpbWVyICk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbW91c2VEZWxheVRpbWVyO1xuXHRcdH1cblxuXHRcdHRoaXMuaWdub3JlTWlzc2luZ1doaWNoID0gZmFsc2U7XG5cdFx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRfbW91c2VEaXN0YW5jZU1ldDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHJldHVybiAoIE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLmFicyggdGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVggLSBldmVudC5wYWdlWCApLFxuXHRcdFx0XHRNYXRoLmFicyggdGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVkgLSBldmVudC5wYWdlWSApXG5cdFx0XHQpID49IHRoaXMub3B0aW9ucy5kaXN0YW5jZVxuXHRcdCk7XG5cdH0sXG5cblx0X21vdXNlRGVsYXlNZXQ6IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZURlbGF5TWV0O1xuXHR9LFxuXG5cdC8vIFRoZXNlIGFyZSBwbGFjZWhvbGRlciBtZXRob2RzLCB0byBiZSBvdmVycmlkZW4gYnkgZXh0ZW5kaW5nIHBsdWdpblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oIC8qIGV2ZW50ICovICkge30sXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHt9LFxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbiggLyogZXZlbnQgKi8gKSB7fSxcblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oIC8qIGV2ZW50ICovICkgeyByZXR1cm4gdHJ1ZTsgfVxufSApO1xuXG59ICkgKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXRzL21vdXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIoIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiLCBcIi4vdmVyc2lvblwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59ICggZnVuY3Rpb24oICQgKSB7XG5cbi8vIFRoaXMgZmlsZSBpcyBkZXByZWNhdGVkXG5yZXR1cm4gJC51aS5pZSA9ICEhL21zaWUgW1xcdy5dKy8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICk7XG59ICkgKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9pZS5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSA3IiwiLyohIGpRdWVyeSBUaW1lcGlja2VyIEFkZG9uIC0gdjEuNi4zIC0gMjAxNi0wNC0yMFxuKiBodHRwOi8vdHJlbnRyaWNoYXJkc29uLmNvbS9leGFtcGxlcy90aW1lcGlja2VyXG4qIENvcHlyaWdodCAoYykgMjAxNiBUcmVudCBSaWNoYXJkc29uOyBMaWNlbnNlZCBNSVQgKi9cbihmdW5jdGlvbiAoJCkge1xuXG5cdC8qXG5cdCogTGV0cyBub3QgcmVkZWZpbmUgdGltZXBpY2tlciwgUHJldmVudCBcIlVuY2F1Z2h0IFJhbmdlRXJyb3I6IE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCJcblx0Ki9cblx0JC51aS50aW1lcGlja2VyID0gJC51aS50aW1lcGlja2VyIHx8IHt9O1xuXHRpZiAoJC51aS50aW1lcGlja2VyLnZlcnNpb24pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvKlxuXHQqIEV4dGVuZCBqUXVlcnlVSSwgZ2V0IGl0IHN0YXJ0ZWQgd2l0aCBvdXIgdmVyc2lvbiBudW1iZXJcblx0Ki9cblx0JC5leHRlbmQoJC51aSwge1xuXHRcdHRpbWVwaWNrZXI6IHtcblx0XHRcdHZlcnNpb246IFwiMS42LjNcIlxuXHRcdH1cblx0fSk7XG5cblx0Lypcblx0KiBUaW1lcGlja2VyIG1hbmFnZXIuXG5cdCogVXNlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgJC50aW1lcGlja2VyLCB0byBpbnRlcmFjdCB3aXRoIHRoZSB0aW1lIHBpY2tlci5cblx0KiBTZXR0aW5ncyBmb3IgKGdyb3VwcyBvZikgdGltZSBwaWNrZXJzIGFyZSBtYWludGFpbmVkIGluIGFuIGluc3RhbmNlIG9iamVjdCxcblx0KiBhbGxvd2luZyBtdWx0aXBsZSBkaWZmZXJlbnQgc2V0dGluZ3Mgb24gdGhlIHNhbWUgcGFnZS5cblx0Ki9cblx0dmFyIFRpbWVwaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5yZWdpb25hbCA9IFtdOyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UgY29kZVxuXHRcdHRoaXMucmVnaW9uYWxbJyddID0geyAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzXG5cdFx0XHRjdXJyZW50VGV4dDogJ05vdycsXG5cdFx0XHRjbG9zZVRleHQ6ICdEb25lJyxcblx0XHRcdGFtTmFtZXM6IFsnQU0nLCAnQSddLFxuXHRcdFx0cG1OYW1lczogWydQTScsICdQJ10sXG5cdFx0XHR0aW1lRm9ybWF0OiAnSEg6bW0nLFxuXHRcdFx0dGltZVN1ZmZpeDogJycsXG5cdFx0XHR0aW1lT25seVRpdGxlOiAnQ2hvb3NlIFRpbWUnLFxuXHRcdFx0dGltZVRleHQ6ICdUaW1lJyxcblx0XHRcdGhvdXJUZXh0OiAnSG91cicsXG5cdFx0XHRtaW51dGVUZXh0OiAnTWludXRlJyxcblx0XHRcdHNlY29uZFRleHQ6ICdTZWNvbmQnLFxuXHRcdFx0bWlsbGlzZWNUZXh0OiAnTWlsbGlzZWNvbmQnLFxuXHRcdFx0bWljcm9zZWNUZXh0OiAnTWljcm9zZWNvbmQnLFxuXHRcdFx0dGltZXpvbmVUZXh0OiAnVGltZSBab25lJyxcblx0XHRcdGlzUlRMOiBmYWxzZVxuXHRcdH07XG5cdFx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRldGltZSBwaWNrZXIgaW5zdGFuY2VzXG5cdFx0XHRzaG93QnV0dG9uUGFuZWw6IHRydWUsXG5cdFx0XHR0aW1lT25seTogZmFsc2UsXG5cdFx0XHR0aW1lT25seVNob3dEYXRlOiBmYWxzZSxcblx0XHRcdHNob3dIb3VyOiBudWxsLFxuXHRcdFx0c2hvd01pbnV0ZTogbnVsbCxcblx0XHRcdHNob3dTZWNvbmQ6IG51bGwsXG5cdFx0XHRzaG93TWlsbGlzZWM6IG51bGwsXG5cdFx0XHRzaG93TWljcm9zZWM6IG51bGwsXG5cdFx0XHRzaG93VGltZXpvbmU6IG51bGwsXG5cdFx0XHRzaG93VGltZTogdHJ1ZSxcblx0XHRcdHN0ZXBIb3VyOiAxLFxuXHRcdFx0c3RlcE1pbnV0ZTogMSxcblx0XHRcdHN0ZXBTZWNvbmQ6IDEsXG5cdFx0XHRzdGVwTWlsbGlzZWM6IDEsXG5cdFx0XHRzdGVwTWljcm9zZWM6IDEsXG5cdFx0XHRob3VyOiAwLFxuXHRcdFx0bWludXRlOiAwLFxuXHRcdFx0c2Vjb25kOiAwLFxuXHRcdFx0bWlsbGlzZWM6IDAsXG5cdFx0XHRtaWNyb3NlYzogMCxcblx0XHRcdHRpbWV6b25lOiBudWxsLFxuXHRcdFx0aG91ck1pbjogMCxcblx0XHRcdG1pbnV0ZU1pbjogMCxcblx0XHRcdHNlY29uZE1pbjogMCxcblx0XHRcdG1pbGxpc2VjTWluOiAwLFxuXHRcdFx0bWljcm9zZWNNaW46IDAsXG5cdFx0XHRob3VyTWF4OiAyMyxcblx0XHRcdG1pbnV0ZU1heDogNTksXG5cdFx0XHRzZWNvbmRNYXg6IDU5LFxuXHRcdFx0bWlsbGlzZWNNYXg6IDk5OSxcblx0XHRcdG1pY3Jvc2VjTWF4OiA5OTksXG5cdFx0XHRtaW5EYXRlVGltZTogbnVsbCxcblx0XHRcdG1heERhdGVUaW1lOiBudWxsLFxuXHRcdFx0bWF4VGltZTogbnVsbCxcblx0XHRcdG1pblRpbWU6IG51bGwsXG5cdFx0XHRvblNlbGVjdDogbnVsbCxcblx0XHRcdGhvdXJHcmlkOiAwLFxuXHRcdFx0bWludXRlR3JpZDogMCxcblx0XHRcdHNlY29uZEdyaWQ6IDAsXG5cdFx0XHRtaWxsaXNlY0dyaWQ6IDAsXG5cdFx0XHRtaWNyb3NlY0dyaWQ6IDAsXG5cdFx0XHRhbHdheXNTZXRUaW1lOiB0cnVlLFxuXHRcdFx0c2VwYXJhdG9yOiAnICcsXG5cdFx0XHRhbHRGaWVsZFRpbWVPbmx5OiB0cnVlLFxuXHRcdFx0YWx0VGltZUZvcm1hdDogbnVsbCxcblx0XHRcdGFsdFNlcGFyYXRvcjogbnVsbCxcblx0XHRcdGFsdFRpbWVTdWZmaXg6IG51bGwsXG5cdFx0XHRhbHRSZWRpcmVjdEZvY3VzOiB0cnVlLFxuXHRcdFx0cGlja2VyVGltZUZvcm1hdDogbnVsbCxcblx0XHRcdHBpY2tlclRpbWVTdWZmaXg6IG51bGwsXG5cdFx0XHRzaG93VGltZXBpY2tlcjogdHJ1ZSxcblx0XHRcdHRpbWV6b25lTGlzdDogbnVsbCxcblx0XHRcdGFkZFNsaWRlckFjY2VzczogZmFsc2UsXG5cdFx0XHRzbGlkZXJBY2Nlc3NBcmdzOiBudWxsLFxuXHRcdFx0Y29udHJvbFR5cGU6ICdzbGlkZXInLFxuXHRcdFx0b25lTGluZTogZmFsc2UsXG5cdFx0XHRkZWZhdWx0VmFsdWU6IG51bGwsXG5cdFx0XHRwYXJzZTogJ3N0cmljdCcsXG5cdFx0XHRhZnRlckluamVjdDogbnVsbFxuXHRcdH07XG5cdFx0JC5leHRlbmQodGhpcy5fZGVmYXVsdHMsIHRoaXMucmVnaW9uYWxbJyddKTtcblx0fTtcblxuXHQkLmV4dGVuZChUaW1lcGlja2VyLnByb3RvdHlwZSwge1xuXHRcdCRpbnB1dDogbnVsbCxcblx0XHQkYWx0SW5wdXQ6IG51bGwsXG5cdFx0JHRpbWVPYmo6IG51bGwsXG5cdFx0aW5zdDogbnVsbCxcblx0XHRob3VyX3NsaWRlcjogbnVsbCxcblx0XHRtaW51dGVfc2xpZGVyOiBudWxsLFxuXHRcdHNlY29uZF9zbGlkZXI6IG51bGwsXG5cdFx0bWlsbGlzZWNfc2xpZGVyOiBudWxsLFxuXHRcdG1pY3Jvc2VjX3NsaWRlcjogbnVsbCxcblx0XHR0aW1lem9uZV9zZWxlY3Q6IG51bGwsXG5cdFx0bWF4VGltZTogbnVsbCxcblx0XHRtaW5UaW1lOiBudWxsLFxuXHRcdGhvdXI6IDAsXG5cdFx0bWludXRlOiAwLFxuXHRcdHNlY29uZDogMCxcblx0XHRtaWxsaXNlYzogMCxcblx0XHRtaWNyb3NlYzogMCxcblx0XHR0aW1lem9uZTogbnVsbCxcblx0XHRob3VyTWluT3JpZ2luYWw6IG51bGwsXG5cdFx0bWludXRlTWluT3JpZ2luYWw6IG51bGwsXG5cdFx0c2Vjb25kTWluT3JpZ2luYWw6IG51bGwsXG5cdFx0bWlsbGlzZWNNaW5PcmlnaW5hbDogbnVsbCxcblx0XHRtaWNyb3NlY01pbk9yaWdpbmFsOiBudWxsLFxuXHRcdGhvdXJNYXhPcmlnaW5hbDogbnVsbCxcblx0XHRtaW51dGVNYXhPcmlnaW5hbDogbnVsbCxcblx0XHRzZWNvbmRNYXhPcmlnaW5hbDogbnVsbCxcblx0XHRtaWxsaXNlY01heE9yaWdpbmFsOiBudWxsLFxuXHRcdG1pY3Jvc2VjTWF4T3JpZ2luYWw6IG51bGwsXG5cdFx0YW1wbTogJycsXG5cdFx0Zm9ybWF0dGVkRGF0ZTogJycsXG5cdFx0Zm9ybWF0dGVkVGltZTogJycsXG5cdFx0Zm9ybWF0dGVkRGF0ZVRpbWU6ICcnLFxuXHRcdHRpbWV6b25lTGlzdDogbnVsbCxcblx0XHR1bml0czogWydob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWMnLCAnbWljcm9zZWMnXSxcblx0XHRzdXBwb3J0OiB7fSxcblx0XHRjb250cm9sOiBudWxsLFxuXG5cdFx0Lypcblx0XHQqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoZSB0aW1lIHBpY2tlci5cblx0XHQqIEBwYXJhbSAge09iamVjdH0gc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGFzIGRlZmF1bHRzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHRcdCogQHJldHVybiB7T2JqZWN0fSB0aGUgbWFuYWdlciBvYmplY3Rcblx0XHQqL1xuXHRcdHNldERlZmF1bHRzOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblx0XHRcdGV4dGVuZFJlbW92ZSh0aGlzLl9kZWZhdWx0cywgc2V0dGluZ3MgfHwge30pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBDcmVhdGUgYSBuZXcgVGltZXBpY2tlciBpbnN0YW5jZVxuXHRcdCovXG5cdFx0X25ld0luc3Q6IGZ1bmN0aW9uICgkaW5wdXQsIG9wdHMpIHtcblx0XHRcdHZhciB0cF9pbnN0ID0gbmV3IFRpbWVwaWNrZXIoKSxcblx0XHRcdFx0aW5saW5lU2V0dGluZ3MgPSB7fSxcblx0XHRcdFx0Zm5zID0ge30sXG5cdFx0XHRcdG92ZXJyaWRlcywgaTtcblxuXHRcdFx0Zm9yICh2YXIgYXR0ck5hbWUgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmhhc093blByb3BlcnR5KGF0dHJOYW1lKSkge1xuXHRcdFx0XHRcdHZhciBhdHRyVmFsdWUgPSAkaW5wdXQuYXR0cigndGltZTonICsgYXR0ck5hbWUpO1xuXHRcdFx0XHRcdGlmIChhdHRyVmFsdWUpIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGlubGluZVNldHRpbmdzW2F0dHJOYW1lXSA9IGV2YWwoYXR0clZhbHVlKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRpbmxpbmVTZXR0aW5nc1thdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG92ZXJyaWRlcyA9IHtcblx0XHRcdFx0YmVmb3JlU2hvdzogZnVuY3Rpb24gKGlucHV0LCBkcF9pbnN0KSB7XG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbih0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5iZWZvcmVTaG93KSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLmJlZm9yZVNob3cuY2FsbCgkaW5wdXRbMF0sIGlucHV0LCBkcF9pbnN0LCB0cF9pbnN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9uQ2hhbmdlTW9udGhZZWFyOiBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRwX2luc3QpIHtcblx0XHRcdFx0XHQvLyBVcGRhdGUgdGhlIHRpbWUgYXMgd2VsbCA6IHRoaXMgcHJldmVudHMgdGhlIHRpbWUgZnJvbSBkaXNhcHBlYXJpbmcgZnJvbSB0aGUgJGlucHV0IGZpZWxkLlxuXHRcdFx0XHRcdC8vIHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGRwX2luc3QpO1xuXHRcdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24odHBfaW5zdC5fZGVmYXVsdHMuZXZudHMub25DaGFuZ2VNb250aFllYXIpKSB7XG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNoYW5nZU1vbnRoWWVhci5jYWxsKCRpbnB1dFswXSwgeWVhciwgbW9udGgsIGRwX2luc3QsIHRwX2luc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0b25DbG9zZTogZnVuY3Rpb24gKGRhdGVUZXh0LCBkcF9pbnN0KSB7XG5cdFx0XHRcdFx0aWYgKHRwX2luc3QudGltZURlZmluZWQgPT09IHRydWUgJiYgJGlucHV0LnZhbCgpICE9PSAnJykge1xuXHRcdFx0XHRcdFx0dHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoZHBfaW5zdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24odHBfaW5zdC5fZGVmYXVsdHMuZXZudHMub25DbG9zZSkpIHtcblx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLm9uQ2xvc2UuY2FsbCgkaW5wdXRbMF0sIGRhdGVUZXh0LCBkcF9pbnN0LCB0cF9pbnN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRmb3IgKGkgaW4gb3ZlcnJpZGVzKSB7XG5cdFx0XHRcdGlmIChvdmVycmlkZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRmbnNbaV0gPSBvcHRzW2ldIHx8IHRoaXMuX2RlZmF1bHRzW2ldIHx8IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdHMsIGlubGluZVNldHRpbmdzLCBvcHRzLCBvdmVycmlkZXMsIHtcblx0XHRcdFx0ZXZudHM6IGZucyxcblx0XHRcdFx0dGltZXBpY2tlcjogdHBfaW5zdCAvLyBhZGQgdGltZXBpY2tlciBhcyBhIHByb3BlcnR5IG9mIGRhdGVwaWNrZXI6ICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0XHR9KTtcblx0XHRcdHRwX2luc3QuYW1OYW1lcyA9ICQubWFwKHRwX2luc3QuX2RlZmF1bHRzLmFtTmFtZXMsIGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIHZhbC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0XHR0cF9pbnN0LnBtTmFtZXMgPSAkLm1hcCh0cF9pbnN0Ll9kZWZhdWx0cy5wbU5hbWVzLCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHJldHVybiB2YWwudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBkZXRlY3Qgd2hpY2ggdW5pdHMgYXJlIHN1cHBvcnRlZFxuXHRcdFx0dHBfaW5zdC5zdXBwb3J0ID0gZGV0ZWN0U3VwcG9ydChcblx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy50aW1lRm9ybWF0ICtcblx0XHRcdFx0XHQodHBfaW5zdC5fZGVmYXVsdHMucGlja2VyVGltZUZvcm1hdCA/IHRwX2luc3QuX2RlZmF1bHRzLnBpY2tlclRpbWVGb3JtYXQgOiAnJykgK1xuXHRcdFx0XHRcdCh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0ID8gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCA6ICcnKSk7XG5cblx0XHRcdC8vIGNvbnRyb2xUeXBlIGlzIHN0cmluZyAtIGtleSB0byBvdXIgdGhpcy5fY29udHJvbHNcblx0XHRcdGlmICh0eXBlb2YodHBfaW5zdC5fZGVmYXVsdHMuY29udHJvbFR5cGUpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuY29udHJvbFR5cGUgPT09ICdzbGlkZXInICYmIHR5cGVvZigkLnVpLnNsaWRlcikgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuY29udHJvbFR5cGUgPSAnc2VsZWN0Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR0cF9pbnN0LmNvbnRyb2wgPSB0cF9pbnN0Ll9jb250cm9sc1t0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZV07XG5cdFx0XHR9XG5cdFx0XHQvLyBjb250cm9sVHlwZSBpcyBhbiBvYmplY3QgYW5kIG11c3QgaW1wbGVtZW50IGNyZWF0ZSwgb3B0aW9ucywgdmFsdWUgbWV0aG9kc1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRwX2luc3QuY29udHJvbCA9IHRwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcmVwIHRoZSB0aW1lem9uZSBvcHRpb25zXG5cdFx0XHR2YXIgdGltZXpvbmVMaXN0ID0gWy03MjAsIC02NjAsIC02MDAsIC01NzAsIC01NDAsIC00ODAsIC00MjAsIC0zNjAsIC0zMDAsIC0yNzAsIC0yNDAsIC0yMTAsIC0xODAsIC0xMjAsIC02MCxcblx0XHRcdFx0XHQwLCA2MCwgMTIwLCAxODAsIDIxMCwgMjQwLCAyNzAsIDMwMCwgMzMwLCAzNDUsIDM2MCwgMzkwLCA0MjAsIDQ4MCwgNTI1LCA1NDAsIDU3MCwgNjAwLCA2MzAsIDY2MCwgNjkwLCA3MjAsIDc2NSwgNzgwLCA4NDBdO1xuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lTGlzdCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lem9uZUxpc3QgPSB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3Q7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHpsID0gdGltZXpvbmVMaXN0Lmxlbmd0aCwgdHppID0gMCwgdHp2ID0gbnVsbDtcblx0XHRcdGlmICh0emwgPiAwICYmIHR5cGVvZiB0aW1lem9uZUxpc3RbMF0gIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoOyB0emkgPCB0emw7IHR6aSsrKSB7XG5cdFx0XHRcdFx0dHp2ID0gdGltZXpvbmVMaXN0W3R6aV07XG5cdFx0XHRcdFx0dGltZXpvbmVMaXN0W3R6aV0gPSB7IHZhbHVlOiB0enYsIGxhYmVsOiAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcodHp2LCB0cF9pbnN0LnN1cHBvcnQuaXNvODYwMSkgfTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmVMaXN0ID0gdGltZXpvbmVMaXN0O1xuXG5cdFx0XHQvLyBzZXQgdGhlIGRlZmF1bHQgdW5pdHNcblx0XHRcdHRwX2luc3QudGltZXpvbmUgPSB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSAhPT0gbnVsbCA/ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSkgOlxuXHRcdFx0XHRcdFx0XHQoKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMSk7XG5cdFx0XHR0cF9pbnN0LmhvdXIgPSB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyIDwgdHBfaW5zdC5fZGVmYXVsdHMuaG91ck1pbiA/IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNaW4gOlxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyID4gdHBfaW5zdC5fZGVmYXVsdHMuaG91ck1heCA/IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyO1xuXHRcdFx0dHBfaW5zdC5taW51dGUgPSB0cF9pbnN0Ll9kZWZhdWx0cy5taW51dGUgPCB0cF9pbnN0Ll9kZWZhdWx0cy5taW51dGVNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5taW51dGVNaW4gOlxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taW51dGUgPiB0cF9pbnN0Ll9kZWZhdWx0cy5taW51dGVNYXggPyB0cF9pbnN0Ll9kZWZhdWx0cy5taW51dGVNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5taW51dGU7XG5cdFx0XHR0cF9pbnN0LnNlY29uZCA9IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZCA8IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1pbiA/IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1pbiA6XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZCA+IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1heCA/IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1heCA6IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZDtcblx0XHRcdHRwX2luc3QubWlsbGlzZWMgPSB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlYyA8IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWluID8gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWNNaW4gOlxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlYyA+IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWNNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlYztcblx0XHRcdHRwX2luc3QubWljcm9zZWMgPSB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlYyA8IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID8gdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWNNaW4gOlxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlYyA+IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWNNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlYztcblx0XHRcdHRwX2luc3QuYW1wbSA9ICcnO1xuXHRcdFx0dHBfaW5zdC4kaW5wdXQgPSAkaW5wdXQ7XG5cblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZCkge1xuXHRcdFx0XHR0cF9pbnN0LiRhbHRJbnB1dCA9ICQodHBfaW5zdC5fZGVmYXVsdHMuYWx0RmllbGQpO1xuXHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuYWx0UmVkaXJlY3RGb2N1cyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHRwX2luc3QuJGFsdElucHV0LmNzcyh7XG5cdFx0XHRcdFx0XHRjdXJzb3I6ICdwb2ludGVyJ1xuXHRcdFx0XHRcdH0pLmZvY3VzKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdCRpbnB1dC50cmlnZ2VyKFwiZm9jdXNcIik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgPT09IDAgfHwgdHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgPT09IDApIHtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZSA9PT0gMCB8fCB0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZSA9PT0gMCkge1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGF0ZXBpY2tlciBuZWVkcyBtaW5EYXRlL21heERhdGUsIHRpbWVwaWNrZXIgbmVlZHMgbWluRGF0ZVRpbWUvbWF4RGF0ZVRpbWUuLlxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgIT09IHVuZGVmaW5lZCAmJiB0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlVGltZSA9IG5ldyBEYXRlKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUuZ2V0VGltZSgpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlVGltZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlID0gbmV3IERhdGUodHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUuZ2V0VGltZSgpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlICE9PSB1bmRlZmluZWQgJiYgdHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlLmdldFRpbWUoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUgIT09IHVuZGVmaW5lZCAmJiB0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZSA9IG5ldyBEYXRlKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lLmdldFRpbWUoKSk7XG5cdFx0XHR9XG5cdFx0XHR0cF9pbnN0LiRpbnB1dC5iaW5kKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dHBfaW5zdC5fb25Gb2N1cygpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB0cF9pbnN0O1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogYWRkIG91ciBzbGlkZXJzIHRvIHRoZSBjYWxlbmRhclxuXHRcdCovXG5cdFx0X2FkZFRpbWVQaWNrZXI6IGZ1bmN0aW9uIChkcF9pbnN0KSB7XG5cdFx0XHR2YXIgY3VyckRUID0gJC50cmltKCh0aGlzLiRhbHRJbnB1dCAmJiB0aGlzLl9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5KSA/IHRoaXMuJGlucHV0LnZhbCgpICsgJyAnICsgdGhpcy4kYWx0SW5wdXQudmFsKCkgOiB0aGlzLiRpbnB1dC52YWwoKSk7XG5cblx0XHRcdHRoaXMudGltZURlZmluZWQgPSB0aGlzLl9wYXJzZVRpbWUoY3VyckRUKTtcblx0XHRcdHRoaXMuX2xpbWl0TWluTWF4RGF0ZVRpbWUoZHBfaW5zdCwgZmFsc2UpO1xuXHRcdFx0dGhpcy5faW5qZWN0VGltZVBpY2tlcigpO1xuXHRcdFx0dGhpcy5fYWZ0ZXJJbmplY3QoKTtcblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIHBhcnNlIHRoZSB0aW1lIHN0cmluZyBmcm9tIGlucHV0IHZhbHVlIG9yIF9zZXRUaW1lXG5cdFx0Ki9cblx0XHRfcGFyc2VUaW1lOiBmdW5jdGlvbiAodGltZVN0cmluZywgd2l0aERhdGUpIHtcblx0XHRcdGlmICghdGhpcy5pbnN0KSB7XG5cdFx0XHRcdHRoaXMuaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCh0aGlzLiRpbnB1dFswXSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh3aXRoRGF0ZSB8fCAhdGhpcy5fZGVmYXVsdHMudGltZU9ubHkpIHtcblx0XHRcdFx0dmFyIGRwX2RhdGVGb3JtYXQgPSAkLmRhdGVwaWNrZXIuX2dldCh0aGlzLmluc3QsICdkYXRlRm9ybWF0Jyk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHBhcnNlUmVzID0gcGFyc2VEYXRlVGltZUludGVybmFsKGRwX2RhdGVGb3JtYXQsIHRoaXMuX2RlZmF1bHRzLnRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsICQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKHRoaXMuaW5zdCksIHRoaXMuX2RlZmF1bHRzKTtcblx0XHRcdFx0XHRpZiAoIXBhcnNlUmVzLnRpbWVPYmopIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JC5leHRlbmQodGhpcywgcGFyc2VSZXMudGltZU9iaik7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdCQudGltZXBpY2tlci5sb2coXCJFcnJvciBwYXJzaW5nIHRoZSBkYXRlL3RpbWUgc3RyaW5nOiBcIiArIGVyciArXG5cdFx0XHRcdFx0XHRcdFx0XHRcIlxcbmRhdGUvdGltZSBzdHJpbmcgPSBcIiArIHRpbWVTdHJpbmcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG50aW1lRm9ybWF0ID0gXCIgKyB0aGlzLl9kZWZhdWx0cy50aW1lRm9ybWF0ICtcblx0XHRcdFx0XHRcdFx0XHRcdFwiXFxuZGF0ZUZvcm1hdCA9IFwiICsgZHBfZGF0ZUZvcm1hdCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRpbWVPYmogPSAkLmRhdGVwaWNrZXIucGFyc2VUaW1lKHRoaXMuX2RlZmF1bHRzLnRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIHRoaXMuX2RlZmF1bHRzKTtcblx0XHRcdFx0aWYgKCF0aW1lT2JqKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuZXh0ZW5kKHRoaXMsIHRpbWVPYmopO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIEhhbmRsZSBjYWxsYmFjayBvcHRpb24gYWZ0ZXIgaW5qZWN0aW5nIHRpbWVwaWNrZXJcblx0XHQqL1xuXHRcdF9hZnRlckluamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuaW5zdC5zZXR0aW5ncztcblx0XHRcdGlmICgkLmlzRnVuY3Rpb24oby5hZnRlckluamVjdCkpIHtcblx0XHRcdFx0by5hZnRlckluamVjdC5jYWxsKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogZ2VuZXJhdGUgYW5kIGluamVjdCBodG1sIGZvciB0aW1lcGlja2VyIGludG8gdWkgZGF0ZXBpY2tlclxuXHRcdCovXG5cdFx0X2luamVjdFRpbWVQaWNrZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciAkZHAgPSB0aGlzLmluc3QuZHBEaXYsXG5cdFx0XHRcdG8gPSB0aGlzLmluc3Quc2V0dGluZ3MsXG5cdFx0XHRcdHRwX2luc3QgPSB0aGlzLFxuXHRcdFx0XHRsaXRlbSA9ICcnLFxuXHRcdFx0XHR1aXRlbSA9ICcnLFxuXHRcdFx0XHRzaG93ID0gbnVsbCxcblx0XHRcdFx0bWF4ID0ge30sXG5cdFx0XHRcdGdyaWRTaXplID0ge30sXG5cdFx0XHRcdHNpemUgPSBudWxsLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IDA7XG5cblx0XHRcdC8vIFByZXZlbnQgZGlzcGxheWluZyB0d2ljZVxuXHRcdFx0aWYgKCRkcC5maW5kKFwiZGl2LnVpLXRpbWVwaWNrZXItZGl2XCIpLmxlbmd0aCA9PT0gMCAmJiBvLnNob3dUaW1lcGlja2VyKSB7XG5cdFx0XHRcdHZhciBub0Rpc3BsYXkgPSAnIHVpX3RwaWNrZXJfdW5pdF9oaWRlJyxcblx0XHRcdFx0XHRodG1sID0gJzxkaXYgY2xhc3M9XCJ1aS10aW1lcGlja2VyLWRpdicgKyAoby5pc1JUTCA/ICcgdWktdGltZXBpY2tlci1ydGwnIDogJycpICsgKG8ub25lTGluZSAmJiBvLmNvbnRyb2xUeXBlID09PSAnc2VsZWN0JyA/ICcgdWktdGltZXBpY2tlci1vbmVMaW5lJyA6ICcnKSArICdcIj48ZGw+JyArICc8ZHQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWVfbGFiZWwnICsgKChvLnNob3dUaW1lKSA/ICcnIDogbm9EaXNwbGF5KSArICdcIj4nICsgby50aW1lVGV4dCArICc8L2R0PicgK1xuXHRcdFx0XHRcdFx0XHRcdCc8ZGQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWUgJysgKChvLnNob3dUaW1lKSA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48aW5wdXQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWVfaW5wdXRcIiAnICsgKG8udGltZUlucHV0ID8gJycgOiAnZGlzYWJsZWQnKSArICcvPjwvZGQ+JztcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIG1hcmt1cFxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy51bml0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRsaXRlbSA9IHRoaXMudW5pdHNbaV07XG5cdFx0XHRcdFx0dWl0ZW0gPSBsaXRlbS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGxpdGVtLnN1YnN0cigxKTtcblx0XHRcdFx0XHRzaG93ID0gb1snc2hvdycgKyB1aXRlbV0gIT09IG51bGwgPyBvWydzaG93JyArIHVpdGVtXSA6IHRoaXMuc3VwcG9ydFtsaXRlbV07XG5cblx0XHRcdFx0XHQvLyBBZGRlZCBieSBQZXRlciBNZWRlaXJvczpcblx0XHRcdFx0XHQvLyAtIEZpZ3VyZSBvdXQgd2hhdCB0aGUgaG91ci9taW51dGUvc2Vjb25kIG1heCBzaG91bGQgYmUgYmFzZWQgb24gdGhlIHN0ZXAgdmFsdWVzLlxuXHRcdFx0XHRcdC8vIC0gRXhhbXBsZTogaWYgc3RlcE1pbnV0ZSBpcyAxNSwgdGhlbiBtaW5NYXggaXMgNDUuXG5cdFx0XHRcdFx0bWF4W2xpdGVtXSA9IHBhcnNlSW50KChvW2xpdGVtICsgJ01heCddIC0gKChvW2xpdGVtICsgJ01heCddIC0gb1tsaXRlbSArICdNaW4nXSkgJSBvWydzdGVwJyArIHVpdGVtXSkpLCAxMCk7XG5cdFx0XHRcdFx0Z3JpZFNpemVbbGl0ZW1dID0gMDtcblxuXHRcdFx0XHRcdGh0bWwgKz0gJzxkdCBjbGFzcz1cInVpX3RwaWNrZXJfJyArIGxpdGVtICsgJ19sYWJlbCcgKyAoc2hvdyA/ICcnIDogbm9EaXNwbGF5KSArICdcIj4nICsgb1tsaXRlbSArICdUZXh0J10gKyAnPC9kdD4nICtcblx0XHRcdFx0XHRcdFx0XHQnPGRkIGNsYXNzPVwidWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAoc2hvdyA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48ZGl2IGNsYXNzPVwidWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnX3NsaWRlcicgKyAoc2hvdyA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48L2Rpdj4nO1xuXG5cdFx0XHRcdFx0aWYgKHNob3cgJiYgb1tsaXRlbSArICdHcmlkJ10gPiAwKSB7XG5cdFx0XHRcdFx0XHRodG1sICs9ICc8ZGl2IHN0eWxlPVwicGFkZGluZy1sZWZ0OiAxcHhcIj48dGFibGUgY2xhc3M9XCJ1aS10cGlja2VyLWdyaWQtbGFiZWxcIj48dHI+JztcblxuXHRcdFx0XHRcdFx0aWYgKGxpdGVtID09PSAnaG91cicpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaCA9IG9bbGl0ZW0gKyAnTWluJ107IGggPD0gbWF4W2xpdGVtXTsgaCArPSBwYXJzZUludChvW2xpdGVtICsgJ0dyaWQnXSwgMTApKSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpZFNpemVbbGl0ZW1dKys7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRtcGggPSAkLmRhdGVwaWNrZXIuZm9ybWF0VGltZSh0aGlzLnN1cHBvcnQuYW1wbSA/ICdoaHQnIDogJ0hIJywge2hvdXI6IGh9LCBvKTtcblx0XHRcdFx0XHRcdFx0XHRodG1sICs9ICc8dGQgZGF0YS1mb3I9XCInICsgbGl0ZW0gKyAnXCI+JyArIHRtcGggKyAnPC90ZD4nO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IG9bbGl0ZW0gKyAnTWluJ107IG0gPD0gbWF4W2xpdGVtXTsgbSArPSBwYXJzZUludChvW2xpdGVtICsgJ0dyaWQnXSwgMTApKSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpZFNpemVbbGl0ZW1dKys7XG5cdFx0XHRcdFx0XHRcdFx0aHRtbCArPSAnPHRkIGRhdGEtZm9yPVwiJyArIGxpdGVtICsgJ1wiPicgKyAoKG0gPCAxMCkgPyAnMCcgOiAnJykgKyBtICsgJzwvdGQ+Jztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRodG1sICs9ICc8L3RyPjwvdGFibGU+PC9kaXY+Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aHRtbCArPSAnPC9kZD4nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGltZXpvbmVcblx0XHRcdFx0dmFyIHNob3dUeiA9IG8uc2hvd1RpbWV6b25lICE9PSBudWxsID8gby5zaG93VGltZXpvbmUgOiB0aGlzLnN1cHBvcnQudGltZXpvbmU7XG5cdFx0XHRcdGh0bWwgKz0gJzxkdCBjbGFzcz1cInVpX3RwaWNrZXJfdGltZXpvbmVfbGFiZWwnICsgKHNob3dUeiA/ICcnIDogbm9EaXNwbGF5KSArICdcIj4nICsgby50aW1lem9uZVRleHQgKyAnPC9kdD4nO1xuXHRcdFx0XHRodG1sICs9ICc8ZGQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWV6b25lJyArIChzaG93VHogPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+PC9kZD4nO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgZWxlbWVudHMgZnJvbSBzdHJpbmdcblx0XHRcdFx0aHRtbCArPSAnPC9kbD48L2Rpdj4nO1xuXHRcdFx0XHR2YXIgJHRwID0gJChodG1sKTtcblxuXHRcdFx0XHQvLyBpZiB3ZSBvbmx5IHdhbnQgdGltZSBwaWNrZXIuLi5cblx0XHRcdFx0aWYgKG8udGltZU9ubHkgPT09IHRydWUpIHtcblx0XHRcdFx0XHQkdHAucHJlcGVuZCgnPGRpdiBjbGFzcz1cInVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGxcIj4nICsgJzxkaXYgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXRpdGxlXCI+JyArIG8udGltZU9ubHlUaXRsZSArICc8L2Rpdj4nICsgJzwvZGl2PicpO1xuXHRcdFx0XHRcdCRkcC5maW5kKCcudWktZGF0ZXBpY2tlci1oZWFkZXIsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyJykuaGlkZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWRkIHNsaWRlcnMsIGFkanVzdCBncmlkcywgYWRkIGV2ZW50c1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gdHBfaW5zdC51bml0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRsaXRlbSA9IHRwX2luc3QudW5pdHNbaV07XG5cdFx0XHRcdFx0dWl0ZW0gPSBsaXRlbS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGxpdGVtLnN1YnN0cigxKTtcblx0XHRcdFx0XHRzaG93ID0gb1snc2hvdycgKyB1aXRlbV0gIT09IG51bGwgPyBvWydzaG93JyArIHVpdGVtXSA6IHRoaXMuc3VwcG9ydFtsaXRlbV07XG5cblx0XHRcdFx0XHQvLyBhZGQgdGhlIHNsaWRlclxuXHRcdFx0XHRcdHRwX2luc3RbbGl0ZW0gKyAnX3NsaWRlciddID0gdHBfaW5zdC5jb250cm9sLmNyZWF0ZSh0cF9pbnN0LCAkdHAuZmluZCgnLnVpX3RwaWNrZXJfJyArIGxpdGVtICsgJ19zbGlkZXInKSwgbGl0ZW0sIHRwX2luc3RbbGl0ZW1dLCBvW2xpdGVtICsgJ01pbiddLCBtYXhbbGl0ZW1dLCBvWydzdGVwJyArIHVpdGVtXSk7XG5cblx0XHRcdFx0XHQvLyBhZGp1c3QgdGhlIGdyaWQgYW5kIGFkZCBjbGljayBldmVudFxuXHRcdFx0XHRcdGlmIChzaG93ICYmIG9bbGl0ZW0gKyAnR3JpZCddID4gMCkge1xuXHRcdFx0XHRcdFx0c2l6ZSA9IDEwMCAqIGdyaWRTaXplW2xpdGVtXSAqIG9bbGl0ZW0gKyAnR3JpZCddIC8gKG1heFtsaXRlbV0gLSBvW2xpdGVtICsgJ01pbiddKTtcblx0XHRcdFx0XHRcdCR0cC5maW5kKCcudWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnIHRhYmxlJykuY3NzKHtcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHNpemUgKyBcIiVcIixcblx0XHRcdFx0XHRcdFx0bWFyZ2luTGVmdDogby5pc1JUTCA/ICcwJyA6ICgoc2l6ZSAvICgtMiAqIGdyaWRTaXplW2xpdGVtXSkpICsgXCIlXCIpLFxuXHRcdFx0XHRcdFx0XHRtYXJnaW5SaWdodDogby5pc1JUTCA/ICgoc2l6ZSAvICgtMiAqIGdyaWRTaXplW2xpdGVtXSkpICsgXCIlXCIpIDogJzAnLFxuXHRcdFx0XHRcdFx0XHRib3JkZXJDb2xsYXBzZTogJ2NvbGxhcHNlJ1xuXHRcdFx0XHRcdFx0fSkuZmluZChcInRkXCIpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyICR0ID0gJCh0aGlzKSxcblx0XHRcdFx0XHRcdFx0XHRcdGggPSAkdC5odG1sKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRuID0gcGFyc2VJbnQoaC5yZXBsYWNlKC9bXjAtOV0vZyksIDEwKSxcblx0XHRcdFx0XHRcdFx0XHRcdGFwID0gaC5yZXBsYWNlKC9bXmFwbV0vaWcpLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZiA9ICR0LmRhdGEoJ2ZvcicpOyAvLyBsb3NlcyBzY29wZSwgc28gd2UgdXNlIGRhdGEtZm9yXG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoZiA9PT0gJ2hvdXInKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoYXAuaW5kZXhPZigncCcpICE9PSAtMSAmJiBuIDwgMTIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0biArPSAxMjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoYXAuaW5kZXhPZignYScpICE9PSAtMSAmJiBuID09PSAxMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG4gPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5jb250cm9sLnZhbHVlKHRwX2luc3QsIHRwX2luc3RbZiArICdfc2xpZGVyJ10sIGxpdGVtLCBuKTtcblxuXHRcdFx0XHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xuXHRcdFx0XHRcdFx0XHRcdHRwX2luc3QuX29uU2VsZWN0SGFuZGxlcigpO1xuXHRcdFx0XHRcdFx0XHR9KS5jc3Moe1xuXHRcdFx0XHRcdFx0XHRcdGN1cnNvcjogJ3BvaW50ZXInLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAoMTAwIC8gZ3JpZFNpemVbbGl0ZW1dKSArICclJyxcblx0XHRcdFx0XHRcdFx0XHR0ZXh0QWxpZ246ICdjZW50ZXInLFxuXHRcdFx0XHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IC8vIGVuZCBpZiBncmlkID4gMFxuXHRcdFx0XHR9IC8vIGVuZCBmb3IgbG9vcFxuXG5cdFx0XHRcdC8vIEFkZCB0aW1lem9uZSBvcHRpb25zXG5cdFx0XHRcdHRoaXMudGltZXpvbmVfc2VsZWN0ID0gJHRwLmZpbmQoJy51aV90cGlja2VyX3RpbWV6b25lJykuYXBwZW5kKCc8c2VsZWN0Pjwvc2VsZWN0PicpLmZpbmQoXCJzZWxlY3RcIik7XG5cdFx0XHRcdCQuZm4uYXBwZW5kLmFwcGx5KHRoaXMudGltZXpvbmVfc2VsZWN0LFxuXHRcdFx0XHQkLm1hcChvLnRpbWV6b25lTGlzdCwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG5cdFx0XHRcdFx0cmV0dXJuICQoXCI8b3B0aW9uIC8+XCIpLnZhbCh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiID8gdmFsLnZhbHVlIDogdmFsKS50ZXh0KHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgPyB2YWwubGFiZWwgOiB2YWwpO1xuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdGlmICh0eXBlb2YodGhpcy50aW1lem9uZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy50aW1lem9uZSAhPT0gbnVsbCAmJiB0aGlzLnRpbWV6b25lICE9PSBcIlwiKSB7XG5cdFx0XHRcdFx0dmFyIGxvY2FsX3RpbWV6b25lID0gKG5ldyBEYXRlKHRoaXMuaW5zdC5zZWxlY3RlZFllYXIsIHRoaXMuaW5zdC5zZWxlY3RlZE1vbnRoLCB0aGlzLmluc3Quc2VsZWN0ZWREYXksIDEyKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xO1xuXHRcdFx0XHRcdGlmIChsb2NhbF90aW1lem9uZSA9PT0gdGhpcy50aW1lem9uZSkge1xuXHRcdFx0XHRcdFx0c2VsZWN0TG9jYWxUaW1lem9uZSh0cF9pbnN0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QudmFsKHRoaXMudGltZXpvbmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mKHRoaXMuaG91cikgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5ob3VyICE9PSBudWxsICYmIHRoaXMuaG91ciAhPT0gXCJcIikge1xuXHRcdFx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QudmFsKG8udGltZXpvbmUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RMb2NhbFRpbWV6b25lKHRwX2luc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnRpbWV6b25lX3NlbGVjdC5jaGFuZ2UoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xuXHRcdFx0XHRcdHRwX2luc3QuX29uU2VsZWN0SGFuZGxlcigpO1xuXHRcdFx0XHRcdHRwX2luc3QuX2FmdGVySW5qZWN0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBFbmQgdGltZXpvbmUgb3B0aW9uc1xuXG5cdFx0XHRcdC8vIGluamVjdCB0aW1lcGlja2VyIGludG8gZGF0ZXBpY2tlclxuXHRcdFx0XHR2YXIgJGJ1dHRvblBhbmVsID0gJGRwLmZpbmQoJy51aS1kYXRlcGlja2VyLWJ1dHRvbnBhbmUnKTtcblx0XHRcdFx0aWYgKCRidXR0b25QYW5lbC5sZW5ndGgpIHtcblx0XHRcdFx0XHQkYnV0dG9uUGFuZWwuYmVmb3JlKCR0cCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JGRwLmFwcGVuZCgkdHApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy4kdGltZU9iaiA9ICR0cC5maW5kKCcudWlfdHBpY2tlcl90aW1lX2lucHV0Jyk7XG5cdFx0XHRcdHRoaXMuJHRpbWVPYmouY2hhbmdlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgdGltZUZvcm1hdCA9IHRwX2luc3QuaW5zdC5zZXR0aW5ncy50aW1lRm9ybWF0O1xuXHRcdFx0XHRcdHZhciBwYXJzZWRUaW1lID0gJC5kYXRlcGlja2VyLnBhcnNlVGltZSh0aW1lRm9ybWF0LCB0aGlzLnZhbHVlKTtcblx0XHRcdFx0XHR2YXIgdXBkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0XHRpZiAocGFyc2VkVGltZSkge1xuXHRcdFx0XHRcdFx0dXBkYXRlLnNldEhvdXJzKHBhcnNlZFRpbWUuaG91cik7XG5cdFx0XHRcdFx0XHR1cGRhdGUuc2V0TWludXRlcyhwYXJzZWRUaW1lLm1pbnV0ZSk7XG5cdFx0XHRcdFx0XHR1cGRhdGUuc2V0U2Vjb25kcyhwYXJzZWRUaW1lLnNlY29uZCk7XG5cdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NldFRpbWUodHBfaW5zdC5pbnN0LCB1cGRhdGUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdHBfaW5zdC5mb3JtYXR0ZWRUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAodGhpcy5pbnN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIHRpbWVEZWZpbmVkID0gdGhpcy50aW1lRGVmaW5lZDtcblx0XHRcdFx0XHR0aGlzLl9vblRpbWVDaGFuZ2UoKTtcblx0XHRcdFx0XHR0aGlzLnRpbWVEZWZpbmVkID0gdGltZURlZmluZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzbGlkZUFjY2VzcyBpbnRlZ3JhdGlvbjogaHR0cDovL3RyZW50cmljaGFyZHNvbi5jb20vMjAxMS8xMS8xMS9qcXVlcnktdWktc2xpZGVycy1hbmQtdG91Y2gtYWNjZXNzaWJpbGl0eS9cblx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmFkZFNsaWRlckFjY2Vzcykge1xuXHRcdFx0XHRcdHZhciBzbGlkZXJBY2Nlc3NBcmdzID0gdGhpcy5fZGVmYXVsdHMuc2xpZGVyQWNjZXNzQXJncyxcblx0XHRcdFx0XHRcdHJ0bCA9IHRoaXMuX2RlZmF1bHRzLmlzUlRMO1xuXHRcdFx0XHRcdHNsaWRlckFjY2Vzc0FyZ3MuaXNSVEwgPSBydGw7XG5cblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy8gZml4IGZvciBpbmxpbmUgbW9kZVxuXHRcdFx0XHRcdFx0aWYgKCR0cC5maW5kKCcudWktc2xpZGVyLWFjY2VzcycpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHQkdHAuZmluZCgnLnVpLXNsaWRlcjp2aXNpYmxlJykuc2xpZGVyQWNjZXNzKHNsaWRlckFjY2Vzc0FyZ3MpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGZpeCBhbnkgZ3JpZHMgc2luY2Ugc2xpZGVycyBhcmUgc2hvcnRlclxuXHRcdFx0XHRcdFx0XHR2YXIgc2xpZGVyQWNjZXNzV2lkdGggPSAkdHAuZmluZCgnLnVpLXNsaWRlci1hY2Nlc3M6ZXEoMCknKS5vdXRlcldpZHRoKHRydWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2xpZGVyQWNjZXNzV2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0XHQkdHAuZmluZCgndGFibGU6dmlzaWJsZScpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyICRnID0gJCh0aGlzKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2xkV2lkdGggPSAkZy5vdXRlcldpZHRoKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9sZE1hcmdpbkxlZnQgPSAkZy5jc3MocnRsID8gJ21hcmdpblJpZ2h0JyA6ICdtYXJnaW5MZWZ0JykudG9TdHJpbmcoKS5yZXBsYWNlKCclJywgJycpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXdXaWR0aCA9IG9sZFdpZHRoIC0gc2xpZGVyQWNjZXNzV2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ld01hcmdpbkxlZnQgPSAoKG9sZE1hcmdpbkxlZnQgKiBuZXdXaWR0aCkgLyBvbGRXaWR0aCkgKyAnJScsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNzcyA9IHsgd2lkdGg6IG5ld1dpZHRoLCBtYXJnaW5SaWdodDogMCwgbWFyZ2luTGVmdDogMCB9O1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3NzW3J0bCA/ICdtYXJnaW5SaWdodCcgOiAnbWFyZ2luTGVmdCddID0gbmV3TWFyZ2luTGVmdDtcblx0XHRcdFx0XHRcdFx0XHRcdCRnLmNzcyhjc3MpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMTApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGVuZCBzbGlkZUFjY2VzcyBpbnRlZ3JhdGlvblxuXG5cdFx0XHRcdHRwX2luc3QuX2xpbWl0TWluTWF4RGF0ZVRpbWUodGhpcy5pbnN0LCB0cnVlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gbGltaXQgdGhlIGFiaWxpdHkgdG8gZ28gb3V0c2lkZSB0aGVcblx0XHQqIG1pbi9tYXggZGF0ZSByYW5nZVxuXHRcdCovXG5cdFx0X2xpbWl0TWluTWF4RGF0ZVRpbWU6IGZ1bmN0aW9uIChkcF9pbnN0LCBhZGp1c3RTbGlkZXJzKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuX2RlZmF1bHRzLFxuXHRcdFx0XHRkcF9kYXRlID0gbmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSk7XG5cblx0XHRcdGlmICghdGhpcy5fZGVmYXVsdHMuc2hvd1RpbWVwaWNrZXIpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSAvLyBObyB0aW1lIHNvIG5vdGhpbmcgdG8gY2hlY2sgaGVyZVxuXG5cdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJykgIT09IG51bGwgJiYgJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJykgIT09IHVuZGVmaW5lZCAmJiBkcF9kYXRlKSB7XG5cdFx0XHRcdHZhciBtaW5EYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtaW5EYXRlVGltZScpLFxuXHRcdFx0XHRcdG1pbkRhdGVUaW1lRGF0ZSA9IG5ldyBEYXRlKG1pbkRhdGVUaW1lLmdldEZ1bGxZZWFyKCksIG1pbkRhdGVUaW1lLmdldE1vbnRoKCksIG1pbkRhdGVUaW1lLmdldERhdGUoKSwgMCwgMCwgMCwgMCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuaG91ck1pbk9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWludXRlTWluT3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5zZWNvbmRNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5ob3VyTWluT3JpZ2luYWwgPSBvLmhvdXJNaW47XG5cdFx0XHRcdFx0dGhpcy5taW51dGVNaW5PcmlnaW5hbCA9IG8ubWludXRlTWluO1xuXHRcdFx0XHRcdHRoaXMuc2Vjb25kTWluT3JpZ2luYWwgPSBvLnNlY29uZE1pbjtcblx0XHRcdFx0XHR0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWwgPSBvLm1pbGxpc2VjTWluO1xuXHRcdFx0XHRcdHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbCA9IG8ubWljcm9zZWNNaW47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy50aW1lT25seSB8fCBtaW5EYXRlVGltZURhdGUuZ2V0VGltZSgpID09PSBkcF9kYXRlLmdldFRpbWUoKSkge1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4gPSBtaW5EYXRlVGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdGlmICh0aGlzLmhvdXIgPD0gdGhpcy5fZGVmYXVsdHMuaG91ck1pbikge1xuXHRcdFx0XHRcdFx0dGhpcy5ob3VyID0gdGhpcy5fZGVmYXVsdHMuaG91ck1pbjtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbiA9IG1pbkRhdGVUaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbnV0ZSA8PSB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5taW51dGUgPSB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW47XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IG1pbkRhdGVUaW1lLmdldFNlY29uZHMoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuc2Vjb25kIDw9IHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbikge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2Vjb25kID0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gbWluRGF0ZVRpbWUuZ2V0TWlsbGlzZWNvbmRzKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMubWlsbGlzZWMgPD0gdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbjtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gbWluRGF0ZVRpbWUuZ2V0TWljcm9zZWNvbmRzKCk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pY3Jvc2VjIDwgdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5taWNyb3NlYyA9IHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4gPSB0aGlzLnNlY29uZE1pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiA9IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbiA9IHRoaXMubWludXRlTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4gPSB0aGlzLnNlY29uZE1pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSB0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbiA9IHRoaXMuaG91ck1pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbiA9IHRoaXMubWludXRlTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluID0gdGhpcy5zZWNvbmRNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiA9IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21heERhdGVUaW1lJykgIT09IG51bGwgJiYgJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21heERhdGVUaW1lJykgIT09IHVuZGVmaW5lZCAmJiBkcF9kYXRlKSB7XG5cdFx0XHRcdHZhciBtYXhEYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpLFxuXHRcdFx0XHRcdG1heERhdGVUaW1lRGF0ZSA9IG5ldyBEYXRlKG1heERhdGVUaW1lLmdldEZ1bGxZZWFyKCksIG1heERhdGVUaW1lLmdldE1vbnRoKCksIG1heERhdGVUaW1lLmdldERhdGUoKSwgMCwgMCwgMCwgMCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuaG91ck1heE9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWludXRlTWF4T3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5zZWNvbmRNYXhPcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWwgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLmhvdXJNYXhPcmlnaW5hbCA9IG8uaG91ck1heDtcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZU1heE9yaWdpbmFsID0gby5taW51dGVNYXg7XG5cdFx0XHRcdFx0dGhpcy5zZWNvbmRNYXhPcmlnaW5hbCA9IG8uc2Vjb25kTWF4O1xuXHRcdFx0XHRcdHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbCA9IG8ubWlsbGlzZWNNYXg7XG5cdFx0XHRcdFx0dGhpcy5taWNyb3NlY01heE9yaWdpbmFsID0gby5taWNyb3NlY01heDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcF9pbnN0LnNldHRpbmdzLnRpbWVPbmx5IHx8IG1heERhdGVUaW1lRGF0ZS5nZXRUaW1lKCkgPT09IGRwX2RhdGUuZ2V0VGltZSgpKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1heCA9IG1heERhdGVUaW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaG91ciA+PSB0aGlzLl9kZWZhdWx0cy5ob3VyTWF4KSB7XG5cdFx0XHRcdFx0XHR0aGlzLmhvdXIgPSB0aGlzLl9kZWZhdWx0cy5ob3VyTWF4O1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubWludXRlID49IHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLm1pbnV0ZSA9IHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0U2Vjb25kcygpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5zZWNvbmQgPj0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWNvbmQgPSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXg7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSBtYXhEYXRlVGltZS5nZXRNaWxsaXNlY29uZHMoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5taWxsaXNlYyA+PSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5taWxsaXNlYyA9IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4O1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSBtYXhEYXRlVGltZS5nZXRNaWNyb3NlY29uZHMoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMubWljcm9zZWMgPiB0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjID0gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXg7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4ID0gdGhpcy5taW51dGVNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCA9IHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gdGhpcy5taWNyb3NlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5ob3VyTWF4ID0gdGhpcy5ob3VyTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4ID0gdGhpcy5taW51dGVNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXggPSB0aGlzLnNlY29uZE1heE9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gdGhpcy5taWNyb3NlY01heE9yaWdpbmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkcF9pbnN0LnNldHRpbmdzLm1pblRpbWUhPT1udWxsKSB7XG5cdFx0XHRcdHZhciB0ZW1wTWluVGltZT1uZXcgRGF0ZShcIjAxLzAxLzE5NzAgXCIgKyBkcF9pbnN0LnNldHRpbmdzLm1pblRpbWUpO1xuXHRcdFx0XHRpZiAodGhpcy5ob3VyPHRlbXBNaW5UaW1lLmdldEhvdXJzKCkpIHtcblx0XHRcdFx0XHR0aGlzLmhvdXI9dGhpcy5fZGVmYXVsdHMuaG91ck1pbj10ZW1wTWluVGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdHRoaXMubWludXRlPXRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5ob3VyPT09dGVtcE1pblRpbWUuZ2V0SG91cnMoKSAmJiB0aGlzLm1pbnV0ZTx0ZW1wTWluVGltZS5nZXRNaW51dGVzKCkpIHtcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWluPHRlbXBNaW5UaW1lLmdldEhvdXJzKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNaW49dGVtcE1pblRpbWUuZ2V0SG91cnMoKTtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWluPT09dGVtcE1pblRpbWUuZ2V0SG91cnMoKT09PXRoaXMuaG91ciAmJiB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW48dGVtcE1pblRpbWUuZ2V0TWludXRlcygpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW49MDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGRwX2luc3Quc2V0dGluZ3MubWF4VGltZSE9PW51bGwpIHtcblx0XHRcdFx0dmFyIHRlbXBNYXhUaW1lPW5ldyBEYXRlKFwiMDEvMDEvMTk3MCBcIiArIGRwX2luc3Quc2V0dGluZ3MubWF4VGltZSk7XG5cdFx0XHRcdGlmICh0aGlzLmhvdXI+dGVtcE1heFRpbWUuZ2V0SG91cnMoKSkge1xuXHRcdFx0XHRcdHRoaXMuaG91cj10aGlzLl9kZWZhdWx0cy5ob3VyTWF4PXRlbXBNYXhUaW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0dGhpcy5taW51dGU9dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmhvdXI9PT10ZW1wTWF4VGltZS5nZXRIb3VycygpICYmIHRoaXMubWludXRlPnRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKSkge1xuXHRcdFx0XHRcdHRoaXMubWludXRlPXRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heD10ZW1wTWF4VGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmhvdXJNYXg+dGVtcE1heFRpbWUuZ2V0SG91cnMoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1heD10ZW1wTWF4VGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2RlZmF1bHRzLmhvdXJNYXg9PT10ZW1wTWF4VGltZS5nZXRIb3VycygpPT09dGhpcy5ob3VyICYmIHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heD50ZW1wTWF4VGltZS5nZXRNaW51dGVzKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heD10ZW1wTWF4VGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heD01OTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGFkanVzdFNsaWRlcnMgIT09IHVuZGVmaW5lZCAmJiBhZGp1c3RTbGlkZXJzID09PSB0cnVlKSB7XG5cdFx0XHRcdHZhciBob3VyTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLmhvdXJNYXggLSAoKHRoaXMuX2RlZmF1bHRzLmhvdXJNYXggLSB0aGlzLl9kZWZhdWx0cy5ob3VyTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBIb3VyKSksIDEwKSxcblx0XHRcdFx0XHRtaW5NYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMubWludXRlTWF4IC0gKCh0aGlzLl9kZWZhdWx0cy5taW51dGVNYXggLSB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbnV0ZSkpLCAxMCksXG5cdFx0XHRcdFx0c2VjTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCAtICgodGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4IC0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBTZWNvbmQpKSwgMTApLFxuXHRcdFx0XHRcdG1pbGxpc2VjTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4IC0gKCh0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCAtIHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWxsaXNlYykpLCAxMCksXG5cdFx0XHRcdFx0bWljcm9zZWNNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggLSAoKHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4IC0gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pY3Jvc2VjKSksIDEwKTtcblxuXHRcdFx0XHRpZiAodGhpcy5ob3VyX3NsaWRlcikge1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMuaG91cl9zbGlkZXIsICdob3VyJywgeyBtaW46IHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4sIG1heDogaG91ck1heCwgc3RlcDogdGhpcy5fZGVmYXVsdHMuc3RlcEhvdXIgfSk7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuaG91cl9zbGlkZXIsICdob3VyJywgdGhpcy5ob3VyIC0gKHRoaXMuaG91ciAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBIb3VyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMubWludXRlX3NsaWRlcikge1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMubWludXRlX3NsaWRlciwgJ21pbnV0ZScsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4sIG1heDogbWluTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwTWludXRlIH0pO1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pbnV0ZV9zbGlkZXIsICdtaW51dGUnLCB0aGlzLm1pbnV0ZSAtICh0aGlzLm1pbnV0ZSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaW51dGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5zZWNvbmRfc2xpZGVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLm9wdGlvbnModGhpcywgdGhpcy5zZWNvbmRfc2xpZGVyLCAnc2Vjb25kJywgeyBtaW46IHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiwgbWF4OiBzZWNNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBTZWNvbmQgfSk7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuc2Vjb25kX3NsaWRlciwgJ3NlY29uZCcsIHRoaXMuc2Vjb25kIC0gKHRoaXMuc2Vjb25kICUgdGhpcy5fZGVmYXVsdHMuc3RlcFNlY29uZCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLm1pbGxpc2VjX3NsaWRlcikge1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMubWlsbGlzZWNfc2xpZGVyLCAnbWlsbGlzZWMnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4sIG1heDogbWlsbGlzZWNNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWxsaXNlYyB9KTtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taWxsaXNlY19zbGlkZXIsICdtaWxsaXNlYycsIHRoaXMubWlsbGlzZWMgLSAodGhpcy5taWxsaXNlYyAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWxsaXNlYykpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLm1pY3Jvc2VjX3NsaWRlcikge1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMubWljcm9zZWNfc2xpZGVyLCAnbWljcm9zZWMnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4sIG1heDogbWljcm9zZWNNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWNyb3NlYyB9KTtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taWNyb3NlY19zbGlkZXIsICdtaWNyb3NlYycsIHRoaXMubWljcm9zZWMgLSAodGhpcy5taWNyb3NlYyAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWNyb3NlYykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIHdoZW4gYSBzbGlkZXIgbW92ZXMsIHNldCB0aGUgaW50ZXJuYWwgdGltZS4uLlxuXHRcdCogb24gdGltZSBjaGFuZ2UgaXMgYWxzbyBjYWxsZWQgd2hlbiB0aGUgdGltZSBpcyB1cGRhdGVkIGluIHRoZSB0ZXh0IGZpZWxkXG5cdFx0Ki9cblx0XHRfb25UaW1lQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBob3VyID0gKHRoaXMuaG91cl9zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuaG91cl9zbGlkZXIsICdob3VyJykgOiBmYWxzZSxcblx0XHRcdFx0bWludXRlID0gKHRoaXMubWludXRlX3NsaWRlcikgPyB0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taW51dGVfc2xpZGVyLCAnbWludXRlJykgOiBmYWxzZSxcblx0XHRcdFx0c2Vjb25kID0gKHRoaXMuc2Vjb25kX3NsaWRlcikgPyB0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5zZWNvbmRfc2xpZGVyLCAnc2Vjb25kJykgOiBmYWxzZSxcblx0XHRcdFx0bWlsbGlzZWMgPSAodGhpcy5taWxsaXNlY19zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWlsbGlzZWNfc2xpZGVyLCAnbWlsbGlzZWMnKSA6IGZhbHNlLFxuXHRcdFx0XHRtaWNyb3NlYyA9ICh0aGlzLm1pY3Jvc2VjX3NsaWRlcikgPyB0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taWNyb3NlY19zbGlkZXIsICdtaWNyb3NlYycpIDogZmFsc2UsXG5cdFx0XHRcdHRpbWV6b25lID0gKHRoaXMudGltZXpvbmVfc2VsZWN0KSA/IHRoaXMudGltZXpvbmVfc2VsZWN0LnZhbCgpIDogZmFsc2UsXG5cdFx0XHRcdG8gPSB0aGlzLl9kZWZhdWx0cyxcblx0XHRcdFx0cGlja2VyVGltZUZvcm1hdCA9IG8ucGlja2VyVGltZUZvcm1hdCB8fCBvLnRpbWVGb3JtYXQsXG5cdFx0XHRcdHBpY2tlclRpbWVTdWZmaXggPSBvLnBpY2tlclRpbWVTdWZmaXggfHwgby50aW1lU3VmZml4O1xuXG5cdFx0XHRpZiAodHlwZW9mKGhvdXIpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRob3VyID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKG1pbnV0ZSkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdG1pbnV0ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZihzZWNvbmQpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRzZWNvbmQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YobWlsbGlzZWMpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRtaWxsaXNlYyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZihtaWNyb3NlYykgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdG1pY3Jvc2VjID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKHRpbWV6b25lKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dGltZXpvbmUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhvdXIgIT09IGZhbHNlKSB7XG5cdFx0XHRcdGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWludXRlICE9PSBmYWxzZSkge1xuXHRcdFx0XHRtaW51dGUgPSBwYXJzZUludChtaW51dGUsIDEwKTtcblx0XHRcdH1cblx0XHRcdGlmIChzZWNvbmQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHNlY29uZCA9IHBhcnNlSW50KHNlY29uZCwgMTApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1pbGxpc2VjICE9PSBmYWxzZSkge1xuXHRcdFx0XHRtaWxsaXNlYyA9IHBhcnNlSW50KG1pbGxpc2VjLCAxMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWljcm9zZWMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG1pY3Jvc2VjID0gcGFyc2VJbnQobWljcm9zZWMsIDEwKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aW1lem9uZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGltZXpvbmUgPSB0aW1lem9uZS50b1N0cmluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYW1wbSA9IG9baG91ciA8IDEyID8gJ2FtTmFtZXMnIDogJ3BtTmFtZXMnXVswXTtcblxuXHRcdFx0Ly8gSWYgdGhlIHVwZGF0ZSB3YXMgZG9uZSBpbiB0aGUgaW5wdXQgZmllbGQsIHRoZSBpbnB1dCBmaWVsZCBzaG91bGQgbm90IGJlIHVwZGF0ZWQuXG5cdFx0XHQvLyBJZiB0aGUgdXBkYXRlIHdhcyBkb25lIHVzaW5nIHRoZSBzbGlkZXJzLCB1cGRhdGUgdGhlIGlucHV0IGZpZWxkLlxuXHRcdFx0dmFyIGhhc0NoYW5nZWQgPSAoXG5cdFx0XHRcdFx0XHRob3VyICE9PSBwYXJzZUludCh0aGlzLmhvdXIsMTApIHx8IC8vIHNsaWRlcnMgc2hvdWxkIGFsbCBiZSBudW1lcmljXG5cdFx0XHRcdFx0XHRtaW51dGUgIT09IHBhcnNlSW50KHRoaXMubWludXRlLDEwKSB8fFxuXHRcdFx0XHRcdFx0c2Vjb25kICE9PSBwYXJzZUludCh0aGlzLnNlY29uZCwxMCkgfHxcblx0XHRcdFx0XHRcdG1pbGxpc2VjICE9PSBwYXJzZUludCh0aGlzLm1pbGxpc2VjLDEwKSB8fFxuXHRcdFx0XHRcdFx0bWljcm9zZWMgIT09IHBhcnNlSW50KHRoaXMubWljcm9zZWMsMTApIHx8XG5cdFx0XHRcdFx0XHQodGhpcy5hbXBtLmxlbmd0aCA+IDAgJiYgKGhvdXIgPCAxMikgIT09ICgkLmluQXJyYXkodGhpcy5hbXBtLnRvVXBwZXJDYXNlKCksIHRoaXMuYW1OYW1lcykgIT09IC0xKSkgfHxcblx0XHRcdFx0XHRcdCh0aGlzLnRpbWV6b25lICE9PSBudWxsICYmIHRpbWV6b25lICE9PSB0aGlzLnRpbWV6b25lLnRvU3RyaW5nKCkpIC8vIGNvdWxkIGJlIG51bWVyaWMgb3IgXCJFU1RcIiBmb3JtYXQsIHNvIHVzZSB0b1N0cmluZygpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0aWYgKGhhc0NoYW5nZWQpIHtcblxuXHRcdFx0XHRpZiAoaG91ciAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLmhvdXIgPSBob3VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtaW51dGUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5taW51dGUgPSBtaW51dGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNlY29uZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLnNlY29uZCA9IHNlY29uZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWlsbGlzZWMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5taWxsaXNlYyA9IG1pbGxpc2VjO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtaWNyb3NlYyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjID0gbWljcm9zZWM7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWV6b25lICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoaXMudGltZXpvbmUgPSB0aW1lem9uZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5pbnN0KSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0WzBdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xpbWl0TWluTWF4RGF0ZVRpbWUodGhpcy5pbnN0LCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnN1cHBvcnQuYW1wbSkge1xuXHRcdFx0XHR0aGlzLmFtcG0gPSBhbXBtO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgdGltZXBpY2tlclxuXHRcdFx0dGhpcy5mb3JtYXR0ZWRUaW1lID0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUoby50aW1lRm9ybWF0LCB0aGlzLCBvKTtcblx0XHRcdGlmICh0aGlzLiR0aW1lT2JqKSB7XG5cdFx0XHRcdGlmIChwaWNrZXJUaW1lRm9ybWF0ID09PSBvLnRpbWVGb3JtYXQpIHtcblx0XHRcdFx0XHR0aGlzLiR0aW1lT2JqLnZhbCh0aGlzLmZvcm1hdHRlZFRpbWUgKyBwaWNrZXJUaW1lU3VmZml4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLiR0aW1lT2JqLnZhbCgkLmRhdGVwaWNrZXIuZm9ybWF0VGltZShwaWNrZXJUaW1lRm9ybWF0LCB0aGlzLCBvKSArIHBpY2tlclRpbWVTdWZmaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLiR0aW1lT2JqWzBdLnNldFNlbGVjdGlvblJhbmdlKSB7XG5cdFx0XHRcdFx0dmFyIHNQb3MgPSB0aGlzLiR0aW1lT2JqWzBdLnNlbGVjdGlvblN0YXJ0O1xuXHRcdFx0XHRcdHZhciBlUG9zID0gdGhpcy4kdGltZU9ialswXS5zZWxlY3Rpb25FbmQ7XG5cdFx0XHRcdFx0dGhpcy4kdGltZU9ialswXS5zZXRTZWxlY3Rpb25SYW5nZShzUG9zLCBlUG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRpbWVEZWZpbmVkID0gdHJ1ZTtcblx0XHRcdGlmIChoYXNDaGFuZ2VkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZURhdGVUaW1lKCk7XG5cdFx0XHRcdC8vdGhpcy4kaW5wdXQuZm9jdXMoKTsgLy8gbWF5IGF1dG9tYXRpY2FsbHkgb3BlbiB0aGUgcGlja2VyIG9uIHNldERhdGVcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIGNhbGwgY3VzdG9tIG9uU2VsZWN0LlxuXHRcdCogYmluZCB0byBzbGlkZXJzIHNsaWRlc3RvcCwgYW5kIGdyaWQgY2xpY2suXG5cdFx0Ki9cblx0XHRfb25TZWxlY3RIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgb25TZWxlY3QgPSB0aGlzLl9kZWZhdWx0cy5vblNlbGVjdCB8fCB0aGlzLmluc3Quc2V0dGluZ3Mub25TZWxlY3Q7XG5cdFx0XHR2YXIgaW5wdXRFbCA9IHRoaXMuJGlucHV0ID8gdGhpcy4kaW5wdXRbMF0gOiBudWxsO1xuXHRcdFx0aWYgKG9uU2VsZWN0ICYmIGlucHV0RWwpIHtcblx0XHRcdFx0b25TZWxlY3QuYXBwbHkoaW5wdXRFbCwgW3RoaXMuZm9ybWF0dGVkRGF0ZVRpbWUsIHRoaXNdKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIHVwZGF0ZSBvdXIgaW5wdXQgd2l0aCB0aGUgbmV3IGRhdGUgdGltZS4uXG5cdFx0Ki9cblx0XHRfdXBkYXRlRGF0ZVRpbWU6IGZ1bmN0aW9uIChkcF9pbnN0KSB7XG5cdFx0XHRkcF9pbnN0ID0gdGhpcy5pbnN0IHx8IGRwX2luc3Q7XG5cdFx0XHR2YXIgZHRUbXAgPSAoZHBfaW5zdC5jdXJyZW50WWVhciA+IDA/XG5cdFx0XHRcdFx0XHRcdG5ldyBEYXRlKGRwX2luc3QuY3VycmVudFllYXIsIGRwX2luc3QuY3VycmVudE1vbnRoLCBkcF9pbnN0LmN1cnJlbnREYXkpIDpcblx0XHRcdFx0XHRcdFx0bmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSkpLFxuXHRcdFx0XHRkdCA9ICQuZGF0ZXBpY2tlci5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoZHRUbXApLFxuXHRcdFx0XHQvL2R0ID0gJC5kYXRlcGlja2VyLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcF9pbnN0LnNlbGVjdGVkWWVhciwgZHBfaW5zdC5zZWxlY3RlZE1vbnRoLCBkcF9pbnN0LnNlbGVjdGVkRGF5KSksXG5cdFx0XHRcdC8vZHQgPSAkLmRhdGVwaWNrZXIuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRwX2luc3QuY3VycmVudFllYXIsIGRwX2luc3QuY3VycmVudE1vbnRoLCBkcF9pbnN0LmN1cnJlbnREYXkpKSxcblx0XHRcdFx0ZGF0ZUZtdCA9ICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdkYXRlRm9ybWF0JyksXG5cdFx0XHRcdGZvcm1hdENmZyA9ICQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGRwX2luc3QpLFxuXHRcdFx0XHR0aW1lQXZhaWxhYmxlID0gZHQgIT09IG51bGwgJiYgdGhpcy50aW1lRGVmaW5lZDtcblx0XHRcdHRoaXMuZm9ybWF0dGVkRGF0ZSA9ICQuZGF0ZXBpY2tlci5mb3JtYXREYXRlKGRhdGVGbXQsIChkdCA9PT0gbnVsbCA/IG5ldyBEYXRlKCkgOiBkdCksIGZvcm1hdENmZyk7XG5cdFx0XHR2YXIgZm9ybWF0dGVkRGF0ZVRpbWUgPSB0aGlzLmZvcm1hdHRlZERhdGU7XG5cblx0XHRcdC8vIGlmIGEgc2xpZGVyIHdhcyBjaGFuZ2VkIGJ1dCBkYXRlcGlja2VyIGRvZXNuJ3QgaGF2ZSBhIHZhbHVlIHlldCwgc2V0IGl0XG5cdFx0XHRpZiAoZHBfaW5zdC5sYXN0VmFsID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgZHBfaW5zdC5jdXJyZW50WWVhciA9IGRwX2luc3Quc2VsZWN0ZWRZZWFyO1xuICAgICAgICAgICAgICAgIGRwX2luc3QuY3VycmVudE1vbnRoID0gZHBfaW5zdC5zZWxlY3RlZE1vbnRoO1xuICAgICAgICAgICAgICAgIGRwX2luc3QuY3VycmVudERheSA9IGRwX2luc3Quc2VsZWN0ZWREYXk7XG4gICAgICAgICAgICB9XG5cblx0XHRcdC8qXG5cdFx0XHQqIHJlbW92ZSBmb2xsb3dpbmcgbGluZXMgdG8gZm9yY2UgZXZlcnkgY2hhbmdlcyBpbiBkYXRlIHBpY2tlciB0byBjaGFuZ2UgdGhlIGlucHV0IHZhbHVlXG5cdFx0XHQqIEJ1ZyBkZXNjcmlwdGlvbnM6IHdoZW4gYW4gaW5wdXQgZmllbGQgaGFzIGEgZGVmYXVsdCB2YWx1ZSwgYW5kIGNsaWNrIG9uIHRoZSBmaWVsZCB0byBwb3AgdXAgdGhlIGRhdGUgcGlja2VyLlxuXHRcdFx0KiBJZiB0aGUgdXNlciBtYW51YWxseSBlbXB0eSB0aGUgdmFsdWUgaW4gdGhlIGlucHV0IGZpZWxkLCB0aGUgZGF0ZSBwaWNrZXIgd2lsbCBuZXZlciBjaGFuZ2Ugc2VsZWN0ZWQgdmFsdWUuXG5cdFx0XHQqL1xuXHRcdFx0Ly9pZiAoZHBfaW5zdC5sYXN0VmFsICE9PSB1bmRlZmluZWQgJiYgKGRwX2luc3QubGFzdFZhbC5sZW5ndGggPiAwICYmIHRoaXMuJGlucHV0LnZhbCgpLmxlbmd0aCA9PT0gMCkpIHtcblx0XHRcdC8vXHRyZXR1cm47XG5cdFx0XHQvL31cblxuXHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ID09PSB0cnVlICYmIHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5U2hvd0RhdGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGZvcm1hdHRlZERhdGVUaW1lID0gdGhpcy5mb3JtYXR0ZWRUaW1lO1xuXHRcdFx0fSBlbHNlIGlmICgodGhpcy5fZGVmYXVsdHMudGltZU9ubHkgIT09IHRydWUgJiYgKHRoaXMuX2RlZmF1bHRzLmFsd2F5c1NldFRpbWUgfHwgdGltZUF2YWlsYWJsZSkpIHx8ICh0aGlzLl9kZWZhdWx0cy50aW1lT25seSA9PT0gdHJ1ZSAmJiB0aGlzLl9kZWZhdWx0cy50aW1lT25seVNob3dEYXRlID09PSB0cnVlKSkge1xuXHRcdFx0XHRmb3JtYXR0ZWREYXRlVGltZSArPSB0aGlzLl9kZWZhdWx0cy5zZXBhcmF0b3IgKyB0aGlzLmZvcm1hdHRlZFRpbWUgKyB0aGlzLl9kZWZhdWx0cy50aW1lU3VmZml4O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvcm1hdHRlZERhdGVUaW1lID0gZm9ybWF0dGVkRGF0ZVRpbWU7XG5cblx0XHRcdGlmICghdGhpcy5fZGVmYXVsdHMuc2hvd1RpbWVwaWNrZXIpIHtcblx0XHRcdFx0dGhpcy4kaW5wdXQudmFsKHRoaXMuZm9ybWF0dGVkRGF0ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuJGFsdElucHV0ICYmIHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ID09PSBmYWxzZSAmJiB0aGlzLl9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5ID09PSB0cnVlKSB7XG5cdFx0XHRcdHRoaXMuJGFsdElucHV0LnZhbCh0aGlzLmZvcm1hdHRlZFRpbWUpO1xuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwodGhpcy5mb3JtYXR0ZWREYXRlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy4kYWx0SW5wdXQpIHtcblx0XHRcdFx0dGhpcy4kaW5wdXQudmFsKGZvcm1hdHRlZERhdGVUaW1lKTtcblx0XHRcdFx0dmFyIGFsdEZvcm1hdHRlZERhdGVUaW1lID0gJycsXG5cdFx0XHRcdFx0YWx0U2VwYXJhdG9yID0gdGhpcy5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yICE9PSBudWxsID8gdGhpcy5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yIDogdGhpcy5fZGVmYXVsdHMuc2VwYXJhdG9yLFxuXHRcdFx0XHRcdGFsdFRpbWVTdWZmaXggPSB0aGlzLl9kZWZhdWx0cy5hbHRUaW1lU3VmZml4ICE9PSBudWxsID8gdGhpcy5fZGVmYXVsdHMuYWx0VGltZVN1ZmZpeCA6IHRoaXMuX2RlZmF1bHRzLnRpbWVTdWZmaXg7XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy50aW1lT25seSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5hbHRGb3JtYXQpIHtcblx0XHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lID0gJC5kYXRlcGlja2VyLmZvcm1hdERhdGUodGhpcy5fZGVmYXVsdHMuYWx0Rm9ybWF0LCAoZHQgPT09IG51bGwgPyBuZXcgRGF0ZSgpIDogZHQpLCBmb3JtYXRDZmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lID0gdGhpcy5mb3JtYXR0ZWREYXRlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChhbHRGb3JtYXR0ZWREYXRlVGltZSkge1xuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gYWx0U2VwYXJhdG9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUodGhpcy5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCwgdGhpcywgdGhpcy5fZGVmYXVsdHMpICsgYWx0VGltZVN1ZmZpeDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSArPSB0aGlzLmZvcm1hdHRlZFRpbWUgKyBhbHRUaW1lU3VmZml4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJGFsdElucHV0LnZhbChhbHRGb3JtYXR0ZWREYXRlVGltZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwoZm9ybWF0dGVkRGF0ZVRpbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLiRpbnB1dC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuXHRcdH0sXG5cblx0XHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLiRpbnB1dC52YWwoKSAmJiB0aGlzLl9kZWZhdWx0cy5kZWZhdWx0VmFsdWUpIHtcblx0XHRcdFx0dGhpcy4kaW5wdXQudmFsKHRoaXMuX2RlZmF1bHRzLmRlZmF1bHRWYWx1ZSk7XG5cdFx0XHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0LmdldCgwKSksXG5cdFx0XHRcdFx0dHBfaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0XHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLnRpbWVPbmx5ICYmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0JC50aW1lcGlja2VyLmxvZyhlcnIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogU21hbGwgYWJzdHJhY3Rpb24gdG8gY29udHJvbCB0eXBlc1xuXHRcdCogV2UgY2FuIGFkZCBtb3JlLCBqdXN0IGJlIHN1cmUgdG8gZm9sbG93IHRoZSBwYXR0ZXJuOiBjcmVhdGUsIG9wdGlvbnMsIHZhbHVlXG5cdFx0Ki9cblx0XHRfY29udHJvbHM6IHtcblx0XHRcdC8vIHNsaWRlciBtZXRob2RzXG5cdFx0XHRzbGlkZXI6IHtcblx0XHRcdFx0Y3JlYXRlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwsIG1pbiwgbWF4LCBzdGVwKSB7XG5cdFx0XHRcdFx0dmFyIHJ0bCA9IHRwX2luc3QuX2RlZmF1bHRzLmlzUlRMOyAvLyBpZiBydGwgZ28gLTYwLT4wIGluc3RlYWQgb2YgMC0+NjBcblx0XHRcdFx0XHRyZXR1cm4gb2JqLnByb3AoJ3NsaWRlJywgbnVsbCkuc2xpZGVyKHtcblx0XHRcdFx0XHRcdG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblx0XHRcdFx0XHRcdHZhbHVlOiBydGwgPyB2YWwgKiAtMSA6IHZhbCxcblx0XHRcdFx0XHRcdG1pbjogcnRsID8gbWF4ICogLTEgOiBtaW4sXG5cdFx0XHRcdFx0XHRtYXg6IHJ0bCA/IG1pbiAqIC0xIDogbWF4LFxuXHRcdFx0XHRcdFx0c3RlcDogc3RlcCxcblx0XHRcdFx0XHRcdHNsaWRlOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuY29udHJvbC52YWx1ZSh0cF9pbnN0LCAkKHRoaXMpLCB1bml0LCBydGwgPyB1aS52YWx1ZSAqIC0xIDogdWkudmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblRpbWVDaGFuZ2UoKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRzdG9wOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX29uU2VsZWN0SGFuZGxlcigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvcHRpb25zOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCBvcHRzLCB2YWwpIHtcblx0XHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuaXNSVEwpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2Yob3B0cykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRzID09PSAnbWluJyB8fCBvcHRzID09PSAnbWF4Jykge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIob3B0cywgdmFsICogLTEpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5hYnMob2JqLnNsaWRlcihvcHRzKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIob3B0cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgbWluID0gb3B0cy5taW4sXG5cdFx0XHRcdFx0XHRcdG1heCA9IG9wdHMubWF4O1xuXHRcdFx0XHRcdFx0b3B0cy5taW4gPSBvcHRzLm1heCA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAobWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0b3B0cy5tYXggPSBtaW4gKiAtMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRvcHRzLm1pbiA9IG1heCAqIC0xO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIob3B0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlb2Yob3B0cykgPT09ICdzdHJpbmcnICYmIHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzLCB2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uICh0cF9pbnN0LCBvYmosIHVuaXQsIHZhbCkge1xuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5pc1JUTCkge1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKCd2YWx1ZScsIHZhbCAqIC0xKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBNYXRoLmFicyhvYmouc2xpZGVyKCd2YWx1ZScpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcigndmFsdWUnLCB2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcigndmFsdWUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIHNlbGVjdCBtZXRob2RzXG5cdFx0XHRzZWxlY3Q6IHtcblx0XHRcdFx0Y3JlYXRlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwsIG1pbiwgbWF4LCBzdGVwKSB7XG5cdFx0XHRcdFx0dmFyIHNlbCA9ICc8c2VsZWN0IGNsYXNzPVwidWktdGltZXBpY2tlci1zZWxlY3QgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIgZGF0YS11bml0PVwiJyArIHVuaXQgKyAnXCIgZGF0YS1taW49XCInICsgbWluICsgJ1wiIGRhdGEtbWF4PVwiJyArIG1heCArICdcIiBkYXRhLXN0ZXA9XCInICsgc3RlcCArICdcIj4nLFxuXHRcdFx0XHRcdFx0Zm9ybWF0ID0gdHBfaW5zdC5fZGVmYXVsdHMucGlja2VyVGltZUZvcm1hdCB8fCB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lRm9ybWF0O1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkgKz0gc3RlcCkge1xuXHRcdFx0XHRcdFx0c2VsICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCInICsgKGkgPT09IHZhbCA/ICcgc2VsZWN0ZWQnIDogJycpICsgJz4nO1xuXHRcdFx0XHRcdFx0aWYgKHVuaXQgPT09ICdob3VyJykge1xuXHRcdFx0XHRcdFx0XHRzZWwgKz0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUoJC50cmltKGZvcm1hdC5yZXBsYWNlKC9bXmh0IF0vaWcsICcnKSksIHtob3VyOiBpfSwgdHBfaW5zdC5fZGVmYXVsdHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodW5pdCA9PT0gJ21pbGxpc2VjJyB8fCB1bml0ID09PSAnbWljcm9zZWMnIHx8IGkgPj0gMTApIHsgc2VsICs9IGk7IH1cblx0XHRcdFx0XHRcdGVsc2Uge3NlbCArPSAnMCcgKyBpLnRvU3RyaW5nKCk7IH1cblx0XHRcdFx0XHRcdHNlbCArPSAnPC9vcHRpb24+Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsICs9ICc8L3NlbGVjdD4nO1xuXG5cdFx0XHRcdFx0b2JqLmNoaWxkcmVuKCdzZWxlY3QnKS5yZW1vdmUoKTtcblxuXHRcdFx0XHRcdCQoc2VsKS5hcHBlbmRUbyhvYmopLmNoYW5nZShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dHBfaW5zdC5fb25UaW1lQ2hhbmdlKCk7XG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcblx0XHRcdFx0XHRcdHRwX2luc3QuX2FmdGVySW5qZWN0KCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvcHRpb25zOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCBvcHRzLCB2YWwpIHtcblx0XHRcdFx0XHR2YXIgbyA9IHt9LFxuXHRcdFx0XHRcdFx0JHQgPSBvYmouY2hpbGRyZW4oJ3NlbGVjdCcpO1xuXHRcdFx0XHRcdGlmICh0eXBlb2Yob3B0cykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICR0LmRhdGEob3B0cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvW29wdHNdID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgbyA9IG9wdHM7IH1cblx0XHRcdFx0XHRyZXR1cm4gdHBfaW5zdC5jb250cm9sLmNyZWF0ZSh0cF9pbnN0LCBvYmosICR0LmRhdGEoJ3VuaXQnKSwgJHQudmFsKCksIG8ubWluPj0wID8gby5taW4gOiAkdC5kYXRhKCdtaW4nKSwgby5tYXggfHwgJHQuZGF0YSgnbWF4JyksIG8uc3RlcCB8fCAkdC5kYXRhKCdzdGVwJykpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR2YWx1ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsKSB7XG5cdFx0XHRcdFx0dmFyICR0ID0gb2JqLmNoaWxkcmVuKCdzZWxlY3QnKTtcblx0XHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkdC52YWwodmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICR0LnZhbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSAvLyBlbmQgX2NvbnRyb2xzXG5cblx0fSk7XG5cblx0JC5mbi5leHRlbmQoe1xuXHRcdC8qXG5cdFx0KiBzaG9ydGhhbmQganVzdCB0byB1c2UgdGltZXBpY2tlci5cblx0XHQqL1xuXHRcdHRpbWVwaWNrZXI6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRvID0gbyB8fCB7fTtcblx0XHRcdHZhciB0bXBfYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cblx0XHRcdGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dG1wX2FyZ3NbMF0gPSAkLmV4dGVuZChvLCB7XG5cdFx0XHRcdFx0dGltZU9ubHk6IHRydWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQkLmZuLmRhdGV0aW1lcGlja2VyLmFwcGx5KCQodGhpcyksIHRtcF9hcmdzKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogZXh0ZW5kIHRpbWVwaWNrZXIgdG8gZGF0ZXBpY2tlclxuXHRcdCovXG5cdFx0ZGF0ZXRpbWVwaWNrZXI6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRvID0gbyB8fCB7fTtcblx0XHRcdHZhciB0bXBfYXJncyA9IGFyZ3VtZW50cztcblxuXHRcdFx0aWYgKHR5cGVvZihvKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKG8gPT09ICdnZXREYXRlJyAgfHwgKG8gPT09ICdvcHRpb24nICYmIHRtcF9hcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgKHRtcF9hcmdzWzFdKSA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZm4uZGF0ZXBpY2tlci5hcHBseSgkKHRoaXNbMF0pLCB0bXBfYXJncyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR2YXIgJHQgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdFx0JHQuZGF0ZXBpY2tlci5hcHBseSgkdCwgdG1wX2FyZ3MpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgJHQgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdCR0LmRhdGVwaWNrZXIoJC50aW1lcGlja2VyLl9uZXdJbnN0KCR0LCBvKS5fZGVmYXVsdHMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8qXG5cdCogUHVibGljIFV0aWxpdHkgdG8gcGFyc2UgZGF0ZSBhbmQgdGltZVxuXHQqL1xuXHQkLmRhdGVwaWNrZXIucGFyc2VEYXRlVGltZSA9IGZ1bmN0aW9uIChkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCBkYXRlVGltZVN0cmluZywgZGF0ZVNldHRpbmdzLCB0aW1lU2V0dGluZ3MpIHtcblx0XHR2YXIgcGFyc2VSZXMgPSBwYXJzZURhdGVUaW1lSW50ZXJuYWwoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKTtcblx0XHRpZiAocGFyc2VSZXMudGltZU9iaikge1xuXHRcdFx0dmFyIHQgPSBwYXJzZVJlcy50aW1lT2JqO1xuXHRcdFx0cGFyc2VSZXMuZGF0ZS5zZXRIb3Vycyh0LmhvdXIsIHQubWludXRlLCB0LnNlY29uZCwgdC5taWxsaXNlYyk7XG5cdFx0XHRwYXJzZVJlcy5kYXRlLnNldE1pY3Jvc2Vjb25kcyh0Lm1pY3Jvc2VjKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyc2VSZXMuZGF0ZTtcblx0fTtcblxuXHQvKlxuXHQqIFB1YmxpYyB1dGlsaXR5IHRvIHBhcnNlIHRpbWVcblx0Ki9cblx0JC5kYXRlcGlja2VyLnBhcnNlVGltZSA9IGZ1bmN0aW9uICh0aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCBvcHRpb25zKSB7XG5cdFx0dmFyIG8gPSBleHRlbmRSZW1vdmUoZXh0ZW5kUmVtb3ZlKHt9LCAkLnRpbWVwaWNrZXIuX2RlZmF1bHRzKSwgb3B0aW9ucyB8fCB7fSksXG5cdFx0XHRpc284NjAxID0gKHRpbWVGb3JtYXQucmVwbGFjZSgvXFwnLio/XFwnL2csICcnKS5pbmRleE9mKCdaJykgIT09IC0xKTtcblxuXHRcdC8vIFN0cmljdCBwYXJzZSByZXF1aXJlcyB0aGUgdGltZVN0cmluZyB0byBtYXRjaCB0aGUgdGltZUZvcm1hdCBleGFjdGx5XG5cdFx0dmFyIHN0cmljdFBhcnNlID0gZnVuY3Rpb24gKGYsIHMsIG8pIHtcblxuXHRcdFx0Ly8gcGF0dGVybiBmb3Igc3RhbmRhcmQgYW5kIGxvY2FsaXplZCBBTS9QTSBtYXJrZXJzXG5cdFx0XHR2YXIgZ2V0UGF0dGVybkFtcG0gPSBmdW5jdGlvbiAoYW1OYW1lcywgcG1OYW1lcykge1xuXHRcdFx0XHR2YXIgbWFya2VycyA9IFtdO1xuXHRcdFx0XHRpZiAoYW1OYW1lcykge1xuXHRcdFx0XHRcdCQubWVyZ2UobWFya2VycywgYW1OYW1lcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBtTmFtZXMpIHtcblx0XHRcdFx0XHQkLm1lcmdlKG1hcmtlcnMsIHBtTmFtZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hcmtlcnMgPSAkLm1hcChtYXJrZXJzLCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKC9bLiorP3woKVxcW1xcXXt9XFxcXF0vZywgJ1xcXFwkJicpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuICcoJyArIG1hcmtlcnMuam9pbignfCcpICsgJyk/Jztcblx0XHRcdH07XG5cblx0XHRcdC8vIGZpZ3VyZSBvdXQgcG9zaXRpb24gb2YgdGltZSBlbGVtZW50cy4uIGNhdXNlIGpzIGNhbnQgZG8gbmFtZWQgY2FwdHVyZXNcblx0XHRcdHZhciBnZXRGb3JtYXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAodGltZUZvcm1hdCkge1xuXHRcdFx0XHR2YXIgZmluZHMgPSB0aW1lRm9ybWF0LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhoezEsMn18bXsxLDJ9fHN7MSwyfXxsezF9fGN7MX18dHsxLDJ9fHp8Jy4qPycpL2cpLFxuXHRcdFx0XHRcdG9yZGVycyA9IHtcblx0XHRcdFx0XHRcdGg6IC0xLFxuXHRcdFx0XHRcdFx0bTogLTEsXG5cdFx0XHRcdFx0XHRzOiAtMSxcblx0XHRcdFx0XHRcdGw6IC0xLFxuXHRcdFx0XHRcdFx0YzogLTEsXG5cdFx0XHRcdFx0XHR0OiAtMSxcblx0XHRcdFx0XHRcdHo6IC0xXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoZmluZHMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZpbmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob3JkZXJzW2ZpbmRzW2ldLnRvU3RyaW5nKCkuY2hhckF0KDApXSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0b3JkZXJzW2ZpbmRzW2ldLnRvU3RyaW5nKCkuY2hhckF0KDApXSA9IGkgKyAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3JkZXJzO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHJlZ3N0ciA9ICdeJyArIGYudG9TdHJpbmcoKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8oW2hIXXsxLDJ9fG1tP3xzcz98W3RUXXsxLDJ9fFt6Wl18W2xjXXwnLio/JykvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtbCA9IG1hdGNoLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0c3dpdGNoIChtYXRjaC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdoJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBtbCA9PT0gMSA/ICcoXFxcXGQ/XFxcXGQpJyA6ICcoXFxcXGR7JyArIG1sICsgJ30pJztcblx0XHRcdFx0XHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG1sID09PSAxID8gJyhcXFxcZD9cXFxcZCknIDogJyhcXFxcZHsnICsgbWwgKyAnfSknO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJyhcXFxcZD9cXFxcZD9cXFxcZCknO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJyhcXFxcZD9cXFxcZD9cXFxcZCknO1xuXHRcdFx0XHRcdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJyh6fFstK11cXFxcZFxcXFxkOj9cXFxcZFxcXFxkfFxcXFxTKyk/Jztcblx0XHRcdFx0XHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFBhdHRlcm5BbXBtKG8uYW1OYW1lcywgby5wbU5hbWVzKTtcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDogICAgLy8gbGl0ZXJhbCBlc2NhcGVkIGluIHF1b3Rlc1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAnKCcgKyBtYXRjaC5yZXBsYWNlKC9cXCcvZywgXCJcIikucmVwbGFjZSgvKFxcLnxcXCR8XFxefFxcXFx8XFwvfFxcKHxcXCl8XFxbfFxcXXxcXD98XFwrfFxcKikvZywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIFwiXFxcXFwiICsgbTsgfSkgKyAnKT8nO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXHMvZywgJ1xcXFxzPycpICtcblx0XHRcdFx0XHRvLnRpbWVTdWZmaXggKyAnJCcsXG5cdFx0XHRcdG9yZGVyID0gZ2V0Rm9ybWF0UG9zaXRpb25zKGYpLFxuXHRcdFx0XHRhbXBtID0gJycsXG5cdFx0XHRcdHRyZWc7XG5cblx0XHRcdHRyZWcgPSBzLm1hdGNoKG5ldyBSZWdFeHAocmVnc3RyLCAnaScpKTtcblxuXHRcdFx0dmFyIHJlc1RpbWUgPSB7XG5cdFx0XHRcdGhvdXI6IDAsXG5cdFx0XHRcdG1pbnV0ZTogMCxcblx0XHRcdFx0c2Vjb25kOiAwLFxuXHRcdFx0XHRtaWxsaXNlYzogMCxcblx0XHRcdFx0bWljcm9zZWM6IDBcblx0XHRcdH07XG5cblx0XHRcdGlmICh0cmVnKSB7XG5cdFx0XHRcdGlmIChvcmRlci50ICE9PSAtMSkge1xuXHRcdFx0XHRcdGlmICh0cmVnW29yZGVyLnRdID09PSB1bmRlZmluZWQgfHwgdHJlZ1tvcmRlci50XS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdGFtcG0gPSAnJztcblx0XHRcdFx0XHRcdHJlc1RpbWUuYW1wbSA9ICcnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhbXBtID0gJC5pbkFycmF5KHRyZWdbb3JkZXIudF0udG9VcHBlckNhc2UoKSwgJC5tYXAoby5hbU5hbWVzLCBmdW5jdGlvbiAoeCxpKSB7IHJldHVybiB4LnRvVXBwZXJDYXNlKCk7IH0pKSAhPT0gLTEgPyAnQU0nIDogJ1BNJztcblx0XHRcdFx0XHRcdHJlc1RpbWUuYW1wbSA9IG9bYW1wbSA9PT0gJ0FNJyA/ICdhbU5hbWVzJyA6ICdwbU5hbWVzJ11bMF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9yZGVyLmggIT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGFtcG0gPT09ICdBTScgJiYgdHJlZ1tvcmRlci5oXSA9PT0gJzEyJykge1xuXHRcdFx0XHRcdFx0cmVzVGltZS5ob3VyID0gMDsgLy8gMTJhbSA9IDAgaG91clxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoYW1wbSA9PT0gJ1BNJyAmJiB0cmVnW29yZGVyLmhdICE9PSAnMTInKSB7XG5cdFx0XHRcdFx0XHRcdHJlc1RpbWUuaG91ciA9IHBhcnNlSW50KHRyZWdbb3JkZXIuaF0sIDEwKSArIDEyOyAvLyAxMnBtID0gMTIgaG91ciwgYW55IG90aGVyIHBtID0gaG91ciArIDEyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXNUaW1lLmhvdXIgPSBOdW1iZXIodHJlZ1tvcmRlci5oXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9yZGVyLm0gIT09IC0xKSB7XG5cdFx0XHRcdFx0cmVzVGltZS5taW51dGUgPSBOdW1iZXIodHJlZ1tvcmRlci5tXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9yZGVyLnMgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmVzVGltZS5zZWNvbmQgPSBOdW1iZXIodHJlZ1tvcmRlci5zXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9yZGVyLmwgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmVzVGltZS5taWxsaXNlYyA9IE51bWJlcih0cmVnW29yZGVyLmxdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3JkZXIuYyAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXNUaW1lLm1pY3Jvc2VjID0gTnVtYmVyKHRyZWdbb3JkZXIuY10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcmRlci56ICE9PSAtMSAmJiB0cmVnW29yZGVyLnpdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXNUaW1lLnRpbWV6b25lID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKHRyZWdbb3JkZXIuel0pO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRyZXR1cm4gcmVzVGltZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9Oy8vIGVuZCBzdHJpY3RQYXJzZVxuXG5cdFx0Ly8gRmlyc3QgdHJ5IEpTIERhdGUsIGlmIHRoYXQgZmFpbHMsIHVzZSBzdHJpY3RQYXJzZVxuXHRcdHZhciBsb29zZVBhcnNlID0gZnVuY3Rpb24gKGYsIHMsIG8pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBkID0gbmV3IERhdGUoJzIwMTItMDEtMDEgJyArIHMpO1xuXHRcdFx0XHRpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSB7XG5cdFx0XHRcdFx0ZCA9IG5ldyBEYXRlKCcyMDEyLTAxLTAxVCcgKyBzKTtcblx0XHRcdFx0XHRpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSB7XG5cdFx0XHRcdFx0XHRkID0gbmV3IERhdGUoJzAxLzAxLzIwMTIgJyArIHMpO1xuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKGQuZ2V0VGltZSgpKSkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBcIlVuYWJsZSB0byBwYXJzZSB0aW1lIHdpdGggbmF0aXZlIERhdGU6IFwiICsgcztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGhvdXI6IGQuZ2V0SG91cnMoKSxcblx0XHRcdFx0XHRtaW51dGU6IGQuZ2V0TWludXRlcygpLFxuXHRcdFx0XHRcdHNlY29uZDogZC5nZXRTZWNvbmRzKCksXG5cdFx0XHRcdFx0bWlsbGlzZWM6IGQuZ2V0TWlsbGlzZWNvbmRzKCksXG5cdFx0XHRcdFx0bWljcm9zZWM6IGQuZ2V0TWljcm9zZWNvbmRzKCksXG5cdFx0XHRcdFx0dGltZXpvbmU6IGQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmljdFBhcnNlKGYsIHMsIG8pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlcnIyKSB7XG5cdFx0XHRcdFx0JC50aW1lcGlja2VyLmxvZyhcIlVuYWJsZSB0byBwYXJzZSBcXG50aW1lU3RyaW5nOiBcIiArIHMgKyBcIlxcbnRpbWVGb3JtYXQ6IFwiICsgZik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9OyAvLyBlbmQgbG9vc2VQYXJzZVxuXG5cdFx0aWYgKHR5cGVvZiBvLnBhcnNlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHJldHVybiBvLnBhcnNlKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG8pO1xuXHRcdH1cblx0XHRpZiAoby5wYXJzZSA9PT0gJ2xvb3NlJykge1xuXHRcdFx0cmV0dXJuIGxvb3NlUGFyc2UodGltZUZvcm1hdCwgdGltZVN0cmluZywgbyk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHJpY3RQYXJzZSh0aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCBvKTtcblx0fTtcblxuXHQvKipcblx0ICogUHVibGljIHV0aWxpdHkgdG8gZm9ybWF0IHRoZSB0aW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0IG9mIHRoZSB0aW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0aW1lIE9iamVjdCBub3QgYSBEYXRlIGZvciB0aW1lem9uZXNcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBlc3NlbnRpYWxseSB0aGUgcmVnaW9uYWxbXS4uIGFtTmFtZXMsIHBtTmFtZXMsIGFtcG1cblx0ICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCB0aW1lXG5cdCAqL1xuXHQkLmRhdGVwaWNrZXIuZm9ybWF0VGltZSA9IGZ1bmN0aW9uIChmb3JtYXQsIHRpbWUsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRvcHRpb25zID0gJC5leHRlbmQoe30sICQudGltZXBpY2tlci5fZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdHRpbWUgPSAkLmV4dGVuZCh7XG5cdFx0XHRob3VyOiAwLFxuXHRcdFx0bWludXRlOiAwLFxuXHRcdFx0c2Vjb25kOiAwLFxuXHRcdFx0bWlsbGlzZWM6IDAsXG5cdFx0XHRtaWNyb3NlYzogMCxcblx0XHRcdHRpbWV6b25lOiBudWxsXG5cdFx0fSwgdGltZSk7XG5cblx0XHR2YXIgdG1wdGltZSA9IGZvcm1hdCxcblx0XHRcdGFtcG1OYW1lID0gb3B0aW9ucy5hbU5hbWVzWzBdLFxuXHRcdFx0aG91ciA9IHBhcnNlSW50KHRpbWUuaG91ciwgMTApO1xuXG5cdFx0aWYgKGhvdXIgPiAxMSkge1xuXHRcdFx0YW1wbU5hbWUgPSBvcHRpb25zLnBtTmFtZXNbMF07XG5cdFx0fVxuXG5cdFx0dG1wdGltZSA9IHRtcHRpbWUucmVwbGFjZSgvKD86SEg/fGhoP3xtbT98c3M/fFt0VF17MSwyfXxbelpdfFtsY118Jy4qPycpL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuXHRcdFx0c3dpdGNoIChtYXRjaCkge1xuXHRcdFx0Y2FzZSAnSEgnOlxuXHRcdFx0XHRyZXR1cm4gKCcwJyArIGhvdXIpLnNsaWNlKC0yKTtcblx0XHRcdGNhc2UgJ0gnOlxuXHRcdFx0XHRyZXR1cm4gaG91cjtcblx0XHRcdGNhc2UgJ2hoJzpcblx0XHRcdFx0cmV0dXJuICgnMCcgKyBjb252ZXJ0MjR0bzEyKGhvdXIpKS5zbGljZSgtMik7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdFx0cmV0dXJuIGNvbnZlcnQyNHRvMTIoaG91cik7XG5cdFx0XHRjYXNlICdtbSc6XG5cdFx0XHRcdHJldHVybiAoJzAnICsgdGltZS5taW51dGUpLnNsaWNlKC0yKTtcblx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0XHRyZXR1cm4gdGltZS5taW51dGU7XG5cdFx0XHRjYXNlICdzcyc6XG5cdFx0XHRcdHJldHVybiAoJzAnICsgdGltZS5zZWNvbmQpLnNsaWNlKC0yKTtcblx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRyZXR1cm4gdGltZS5zZWNvbmQ7XG5cdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0cmV0dXJuICgnMDAnICsgdGltZS5taWxsaXNlYykuc2xpY2UoLTMpO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdHJldHVybiAoJzAwJyArIHRpbWUubWljcm9zZWMpLnNsaWNlKC0zKTtcblx0XHRcdGNhc2UgJ3onOlxuXHRcdFx0XHRyZXR1cm4gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKHRpbWUudGltZXpvbmUgPT09IG51bGwgPyBvcHRpb25zLnRpbWV6b25lIDogdGltZS50aW1lem9uZSwgZmFsc2UpO1xuXHRcdFx0Y2FzZSAnWic6XG5cdFx0XHRcdHJldHVybiAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcodGltZS50aW1lem9uZSA9PT0gbnVsbCA/IG9wdGlvbnMudGltZXpvbmUgOiB0aW1lLnRpbWV6b25lLCB0cnVlKTtcblx0XHRcdGNhc2UgJ1QnOlxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRjYXNlICdUVCc6XG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNhc2UgJ3R0Jzpcblx0XHRcdFx0cmV0dXJuIGFtcG1OYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSgvJy9nLCBcIlwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB0bXB0aW1lO1xuXHR9O1xuXG5cdC8qXG5cdCogdGhlIGJhZCBoYWNrIDovIG92ZXJyaWRlIGRhdGVwaWNrZXIgc28gaXQgZG9lc24ndCBjbG9zZSBvbiBzZWxlY3Rcblx0Ly8gaW5zcGlyZWQ6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1MjUxMi9qcXVlcnktZGF0ZXBpY2tlci1wcmV2ZW50LWNsb3NpbmctcGlja2VyLXdoZW4tY2xpY2tpbmctYS1kYXRlLzE3NjIzNzgjMTc2MjM3OFxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2Vfc2VsZWN0RGF0ZSA9ICQuZGF0ZXBpY2tlci5fc2VsZWN0RGF0ZTtcblx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXRlID0gZnVuY3Rpb24gKGlkLCBkYXRlU3RyKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KCQoaWQpWzBdKSxcblx0XHRcdHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKSxcblx0XHRcdHdhc19pbmxpbmU7XG5cblx0XHRpZiAodHBfaW5zdCAmJiBpbnN0LnNldHRpbmdzLnNob3dUaW1lcGlja2VyKSB7XG5cdFx0XHR0cF9pbnN0Ll9saW1pdE1pbk1heERhdGVUaW1lKGluc3QsIHRydWUpO1xuXHRcdFx0d2FzX2lubGluZSA9IGluc3QuaW5saW5lO1xuXHRcdFx0aW5zdC5pbmxpbmUgPSBpbnN0LnN0YXlfb3BlbiA9IHRydWU7XG5cdFx0XHQvL1RoaXMgd2F5IHRoZSBvblNlbGVjdCBoYW5kbGVyIGNhbGxlZCBmcm9tIGNhbGVuZGFycGlja2VyIGdldCB0aGUgZnVsbCBkYXRlVGltZVxuXHRcdFx0dGhpcy5fYmFzZV9zZWxlY3REYXRlKGlkLCBkYXRlU3RyKTtcblx0XHRcdGluc3QuaW5saW5lID0gd2FzX2lubGluZTtcblx0XHRcdGluc3Quc3RheV9vcGVuID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9iYXNlX3NlbGVjdERhdGUoaWQsIGRhdGVTdHIpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHQqIHNlY29uZCBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IHRyaWdnZXJzIGFuIGV2ZW50IHdoZW4gY2hhbmdpbmcgdGhlIGlucHV0IGZpZWxkXG5cdCogYW5kIGRvZXMgbm90IHJlZHJhdyB0aGUgZGF0ZXBpY2tlciBvbiBldmVyeSBzZWxlY3REYXRlIGV2ZW50XG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV91cGRhdGVEYXRlcGlja2VyID0gJC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyO1xuXHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIgPSBmdW5jdGlvbiAoaW5zdCkge1xuXG5cdFx0Ly8gZG9uJ3QgcG9wdXAgdGhlIGRhdGVwaWNrZXIgaWYgdGhlcmUgaXMgYW5vdGhlciBpbnN0YW5jZSBhbHJlYWR5IG9wZW5lZFxuXHRcdHZhciBpbnB1dCA9IGluc3QuaW5wdXRbMF07XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT09IGluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCAhPT0gaW5wdXQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mKGluc3Quc3RheV9vcGVuKSAhPT0gJ2Jvb2xlYW4nIHx8IGluc3Quc3RheV9vcGVuID09PSBmYWxzZSkge1xuXG5cdFx0XHR0aGlzLl9iYXNlX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cblx0XHRcdC8vIFJlbG9hZCB0aGUgdGltZSBjb250cm9sIHdoZW4gY2hhbmdpbmcgc29tZXRoaW5nIGluIHRoZSBpbnB1dCB0ZXh0IGZpZWxkLlxuXHRcdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHRcdHRwX2luc3QuX2FkZFRpbWVQaWNrZXIoaW5zdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCogdGhpcmQgYmFkIGhhY2sgOi8gb3ZlcnJpZGUgZGF0ZXBpY2tlciBzbyBpdCBhbGxvd3Mgc3BhY2VzIGFuZCBjb2xvbiBpbiB0aGUgaW5wdXQgZmllbGRcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX2RvS2V5UHJlc3MgPSAkLmRhdGVwaWNrZXIuX2RvS2V5UHJlc3M7XG5cdCQuZGF0ZXBpY2tlci5fZG9LZXlQcmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCksXG5cdFx0XHR0cF9pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblxuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2NvbnN0cmFpbklucHV0JykpIHtcblx0XHRcdFx0dmFyIGFtcG0gPSB0cF9pbnN0LnN1cHBvcnQuYW1wbSxcblx0XHRcdFx0XHR0eiA9IHRwX2luc3QuX2RlZmF1bHRzLnNob3dUaW1lem9uZSAhPT0gbnVsbCA/IHRwX2luc3QuX2RlZmF1bHRzLnNob3dUaW1lem9uZSA6IHRwX2luc3Quc3VwcG9ydC50aW1lem9uZSxcblx0XHRcdFx0XHRkYXRlQ2hhcnMgPSAkLmRhdGVwaWNrZXIuX3Bvc3NpYmxlQ2hhcnMoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKSksXG5cdFx0XHRcdFx0ZGF0ZXRpbWVDaGFycyA9IHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQudG9TdHJpbmcoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9baG1zXS9nLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVFQvZywgYW1wbSA/ICdBUE0nIDogJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1R0L2csIGFtcG0gPyAnQWFQcE1tJyA6ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC90VC9nLCBhbXBtID8gJ0FhUHBNbScgOiAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVC9nLCBhbXBtID8gJ0FQJyA6ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC90dC9nLCBhbXBtID8gJ2FwbScgOiAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvdC9nLCBhbXBtID8gJ2FwJyA6ICcnKSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIgXCIgKyB0cF9pbnN0Ll9kZWZhdWx0cy5zZXBhcmF0b3IgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnRpbWVTdWZmaXggK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCh0eiA/IHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lTGlzdC5qb2luKCcnKSA6ICcnKSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KHRwX2luc3QuX2RlZmF1bHRzLmFtTmFtZXMuam9pbignJykpICsgKHRwX2luc3QuX2RlZmF1bHRzLnBtTmFtZXMuam9pbignJykpICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRlQ2hhcnMsXG5cdFx0XHRcdFx0Y2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PT0gdW5kZWZpbmVkID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgKGNociA8ICcgJyB8fCAhZGF0ZUNoYXJzIHx8IGRhdGV0aW1lQ2hhcnMuaW5kZXhPZihjaHIpID4gLTEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAkLmRhdGVwaWNrZXIuX2Jhc2VfZG9LZXlQcmVzcyhldmVudCk7XG5cdH07XG5cblx0Lypcblx0KiBGb3VydGggYmFkIGhhY2sgOi8gb3ZlcnJpZGUgX3VwZGF0ZUFsdGVybmF0ZSBmdW5jdGlvbiB1c2VkIGluIGlubGluZSBtb2RlIHRvIGluaXQgYWx0RmllbGRcblx0KiBVcGRhdGUgYW55IGFsdGVybmF0ZSBmaWVsZCB0byBzeW5jaHJvbmlzZSB3aXRoIHRoZSBtYWluIGZpZWxkLlxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfdXBkYXRlQWx0ZXJuYXRlID0gJC5kYXRlcGlja2VyLl91cGRhdGVBbHRlcm5hdGU7XG5cdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlID0gZnVuY3Rpb24gKGluc3QpIHtcblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHR2YXIgYWx0RmllbGQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZDtcblx0XHRcdGlmIChhbHRGaWVsZCkgeyAvLyB1cGRhdGUgYWx0ZXJuYXRlIGZpZWxkIHRvb1xuXHRcdFx0XHR2YXIgYWx0Rm9ybWF0ID0gdHBfaW5zdC5fZGVmYXVsdHMuYWx0Rm9ybWF0IHx8IHRwX2luc3QuX2RlZmF1bHRzLmRhdGVGb3JtYXQsXG5cdFx0XHRcdFx0ZGF0ZSA9IHRoaXMuX2dldERhdGUoaW5zdCksXG5cdFx0XHRcdFx0Zm9ybWF0Q2ZnID0gJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoaW5zdCksXG5cdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSAnJyxcblx0XHRcdFx0XHRhbHRTZXBhcmF0b3IgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgOiB0cF9pbnN0Ll9kZWZhdWx0cy5zZXBhcmF0b3IsXG5cdFx0XHRcdFx0YWx0VGltZVN1ZmZpeCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lU3VmZml4IDogdHBfaW5zdC5fZGVmYXVsdHMudGltZVN1ZmZpeCxcblx0XHRcdFx0XHRhbHRUaW1lRm9ybWF0ID0gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCAhPT0gbnVsbCA/IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgOiB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lRm9ybWF0O1xuXG5cdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lICs9ICQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKGFsdFRpbWVGb3JtYXQsIHRwX2luc3QsIHRwX2luc3QuX2RlZmF1bHRzKSArIGFsdFRpbWVTdWZmaXg7XG5cdFx0XHRcdGlmICghdHBfaW5zdC5fZGVmYXVsdHMudGltZU9ubHkgJiYgIXRwX2luc3QuX2RlZmF1bHRzLmFsdEZpZWxkVGltZU9ubHkgJiYgZGF0ZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGb3JtYXQpIHtcblx0XHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lID0gJC5kYXRlcGlja2VyLmZvcm1hdERhdGUodHBfaW5zdC5fZGVmYXVsdHMuYWx0Rm9ybWF0LCBkYXRlLCBmb3JtYXRDZmcpICsgYWx0U2VwYXJhdG9yICsgYWx0Rm9ybWF0dGVkRGF0ZVRpbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSB0cF9pbnN0LmZvcm1hdHRlZERhdGUgKyBhbHRTZXBhcmF0b3IgKyBhbHRGb3JtYXR0ZWREYXRlVGltZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0JChhbHRGaWVsZCkudmFsKCBpbnN0LmlucHV0LnZhbCgpID8gYWx0Rm9ybWF0dGVkRGF0ZVRpbWUgOiBcIlwiKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2Jhc2VfdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHQqIE92ZXJyaWRlIGtleSB1cCBldmVudCB0byBzeW5jIG1hbnVhbCBpbnB1dCBjaGFuZ2VzLlxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZG9LZXlVcCA9ICQuZGF0ZXBpY2tlci5fZG9LZXlVcDtcblx0JC5kYXRlcGlja2VyLl9kb0tleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KSxcblx0XHRcdHRwX2luc3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy50aW1lT25seSAmJiAoaW5zdC5pbnB1dC52YWwoKSAhPT0gaW5zdC5sYXN0VmFsKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0JC50aW1lcGlja2VyLmxvZyhlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVVwKGV2ZW50KTtcblx0fTtcblxuXHQvKlxuXHQqIG92ZXJyaWRlIFwiVG9kYXlcIiBidXR0b24gdG8gYWxzbyBncmFiIHRoZSB0aW1lIGFuZCBzZXQgaXQgdG8gaW5wdXQgZmllbGQuXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9nb3RvVG9kYXkgPSAkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheTtcblx0JC5kYXRlcGlja2VyLl9nb3RvVG9kYXkgPSBmdW5jdGlvbiAoaWQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoJChpZClbMF0pO1xuXHRcdHRoaXMuX2Jhc2VfZ290b1RvZGF5KGlkKTtcblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdGlmICghdHBfaW5zdCkge1xuXHRcdCAgcmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0em9mZnNldCA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0cF9pbnN0LnRpbWV6b25lKTtcblx0XHR2YXIgbm93ID0gbmV3IERhdGUoKTtcblx0XHRub3cuc2V0TWludXRlcyhub3cuZ2V0TWludXRlcygpICsgbm93LmdldFRpbWV6b25lT2Zmc2V0KCkgKyBwYXJzZUludCh0em9mZnNldCwgMTApKTtcblx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIG5vdyk7XG5cdFx0dGhpcy5fc2V0RGF0ZShpbnN0LCBub3cpO1xuXHRcdHRwX2luc3QuX29uU2VsZWN0SGFuZGxlcigpO1xuXHR9O1xuXG5cdC8qXG5cdCogRGlzYWJsZSAmIGVuYWJsZSB0aGUgVGltZSBpbiB0aGUgZGF0ZXRpbWVwaWNrZXJcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9kaXNhYmxlVGltZXBpY2tlckRhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHQkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpOyAvLyBJbml0IHNlbGVjdGVkW1llYXJ8TW9udGh8RGF5XVxuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHRpbnN0LnNldHRpbmdzLnNob3dUaW1lcGlja2VyID0gZmFsc2U7XG5cdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXBpY2tlciA9IGZhbHNlO1xuXHRcdFx0dHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoaW5zdCk7XG5cdFx0fVxuXHR9O1xuXG5cdCQuZGF0ZXBpY2tlci5fZW5hYmxlVGltZXBpY2tlckRhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHQkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpOyAvLyBJbml0IHNlbGVjdGVkW1llYXJ8TW9udGh8RGF5XVxuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHRpbnN0LnNldHRpbmdzLnNob3dUaW1lcGlja2VyID0gdHJ1ZTtcblx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyID0gdHJ1ZTtcblx0XHRcdHRwX2luc3QuX2FkZFRpbWVQaWNrZXIoaW5zdCk7IC8vIENvdWxkIGJlIGRpc2FibGVkIG9uIHBhZ2UgbG9hZFxuXHRcdFx0dHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoaW5zdCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCogQ3JlYXRlIG91ciBvd24gc2V0IHRpbWUgZnVuY3Rpb25cblx0Ki9cblx0JC5kYXRlcGlja2VyLl9zZXRUaW1lID0gZnVuY3Rpb24gKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHR2YXIgZGVmYXVsdHMgPSB0cF9pbnN0Ll9kZWZhdWx0cztcblxuXHRcdFx0Ly8gY2FsbGluZyBfc2V0VGltZSB3aXRoIG5vIGRhdGUgc2V0cyB0aW1lIHRvIGRlZmF1bHRzXG5cdFx0XHR0cF9pbnN0LmhvdXIgPSBkYXRlID8gZGF0ZS5nZXRIb3VycygpIDogZGVmYXVsdHMuaG91cjtcblx0XHRcdHRwX2luc3QubWludXRlID0gZGF0ZSA/IGRhdGUuZ2V0TWludXRlcygpIDogZGVmYXVsdHMubWludXRlO1xuXHRcdFx0dHBfaW5zdC5zZWNvbmQgPSBkYXRlID8gZGF0ZS5nZXRTZWNvbmRzKCkgOiBkZWZhdWx0cy5zZWNvbmQ7XG5cdFx0XHR0cF9pbnN0Lm1pbGxpc2VjID0gZGF0ZSA/IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgOiBkZWZhdWx0cy5taWxsaXNlYztcblx0XHRcdHRwX2luc3QubWljcm9zZWMgPSBkYXRlID8gZGF0ZS5nZXRNaWNyb3NlY29uZHMoKSA6IGRlZmF1bHRzLm1pY3Jvc2VjO1xuXG5cdFx0XHQvL2NoZWNrIGlmIHdpdGhpbiBtaW4vbWF4IHRpbWVzLi5cblx0XHRcdHRwX2luc3QuX2xpbWl0TWluTWF4RGF0ZVRpbWUoaW5zdCwgdHJ1ZSk7XG5cblx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xuXHRcdFx0dHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoaW5zdCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCogQ3JlYXRlIG5ldyBwdWJsaWMgbWV0aG9kIHRvIHNldCBvbmx5IHRpbWUsIGNhbGxhYmxlIGFzICQoKS5kYXRlcGlja2VyKCdzZXRUaW1lJywgZGF0ZSlcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9zZXRUaW1lRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGRhdGUsIHdpdGhEYXRlKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblxuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHR0aGlzLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xuXHRcdFx0dmFyIHRwX2RhdGU7XG5cdFx0XHRpZiAoZGF0ZSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHR0cF9pbnN0Ll9wYXJzZVRpbWUoZGF0ZSwgd2l0aERhdGUpO1xuXHRcdFx0XHRcdHRwX2RhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdHRwX2RhdGUuc2V0SG91cnModHBfaW5zdC5ob3VyLCB0cF9pbnN0Lm1pbnV0ZSwgdHBfaW5zdC5zZWNvbmQsIHRwX2luc3QubWlsbGlzZWMpO1xuXHRcdFx0XHRcdHRwX2RhdGUuc2V0TWljcm9zZWNvbmRzKHRwX2luc3QubWljcm9zZWMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRwX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG5cdFx0XHRcdFx0dHBfZGF0ZS5zZXRNaWNyb3NlY29uZHMoZGF0ZS5nZXRNaWNyb3NlY29uZHMoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRwX2RhdGUudG9TdHJpbmcoKSA9PT0gJ0ludmFsaWQgRGF0ZScpIHtcblx0XHRcdFx0XHR0cF9kYXRlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3NldFRpbWUoaW5zdCwgdHBfZGF0ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH07XG5cblx0Lypcblx0KiBvdmVycmlkZSBzZXREYXRlKCkgdG8gYWxsb3cgc2V0dGluZyB0aW1lIHRvbyB3aXRoaW4gRGF0ZSBvYmplY3Rcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX3NldERhdGVEYXRlcGlja2VyID0gJC5kYXRlcGlja2VyLl9zZXREYXRlRGF0ZXBpY2tlcjtcblx0JC5kYXRlcGlja2VyLl9zZXREYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIF9kYXRlKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0dmFyIGRhdGUgPSBfZGF0ZTtcblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mKF9kYXRlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGRhdGUgPSBuZXcgRGF0ZShfZGF0ZSk7XG5cdFx0XHRpZiAoIWRhdGUuZ2V0VGltZSgpKSB7XG5cdFx0XHRcdHRoaXMuX2Jhc2Vfc2V0RGF0ZURhdGVwaWNrZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0ZGF0ZSA9ICQodGFyZ2V0KS5kYXRlcGlja2VyKCdnZXREYXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHR2YXIgdHBfZGF0ZTtcblx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdHRwX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG5cdFx0XHR0cF9kYXRlLnNldE1pY3Jvc2Vjb25kcyhkYXRlLmdldE1pY3Jvc2Vjb25kcygpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHBfZGF0ZSA9IGRhdGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgeW91IGFyZSB1c2luZyB0aGUgdGltZXpvbmUgb3B0aW9uLCBqYXZhc2NyaXB0J3MgRGF0ZVxuXHRcdC8vIG9iamVjdCB3aWxsIG9ubHkgcmV0dXJuIHRoZSB0aW1lem9uZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IGxvY2FsZSwgc28gd2Vcblx0XHQvLyBhZGp1c3QgaXQgYWNjb3JkaW5nbHkuICBJZiBub3QgdXNpbmcgdGltZXpvbmUgb3B0aW9uIHRoaXMgd29uJ3QgbWF0dGVyLi5cblx0XHQvLyBJZiBhIHRpbWV6b25lIGlzIGRpZmZlcmVudCBpbiB0cCwga2VlcCB0aGUgdGltZXpvbmUgYXMgaXNcblx0XHRpZiAodHBfaW5zdCAmJiB0cF9kYXRlKSB7XG5cdFx0XHQvLyBsb29rIG91dCBmb3IgRFNUIGlmIHR6IHdhc24ndCBzcGVjaWZpZWRcblx0XHRcdGlmICghdHBfaW5zdC5zdXBwb3J0LnRpbWV6b25lICYmIHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lID09PSBudWxsKSB7XG5cdFx0XHRcdHRwX2luc3QudGltZXpvbmUgPSB0cF9kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMTtcblx0XHRcdH1cblx0XHRcdGRhdGUgPSAkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QoZGF0ZSwgJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpLCB0cF9pbnN0LnRpbWV6b25lKTtcblx0XHRcdHRwX2RhdGUgPSAkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QodHBfZGF0ZSwgJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKC10cF9kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpLCB0cF9pbnN0LnRpbWV6b25lKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdHRoaXMuX2Jhc2Vfc2V0RGF0ZURhdGVwaWNrZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZXRUaW1lRGF0ZXBpY2tlcih0YXJnZXQsIHRwX2RhdGUsIHRydWUpO1xuXHR9O1xuXG5cdC8qXG5cdCogb3ZlcnJpZGUgZ2V0RGF0ZSgpIHRvIGFsbG93IGdldHRpbmcgdGltZSB0b28gd2l0aGluIERhdGUgb2JqZWN0XG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9nZXREYXRlRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fZ2V0RGF0ZURhdGVwaWNrZXI7XG5cdCQuZGF0ZXBpY2tlci5fZ2V0RGF0ZURhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBub0RlZmF1bHQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdC8vIGlmIGl0IGhhc24ndCB5ZXQgYmVlbiBkZWZpbmVkLCBncmFiIGZyb20gZmllbGRcblx0XHRcdGlmIChpbnN0Lmxhc3RWYWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9zZXREYXRlRnJvbUZpZWxkKGluc3QsIG5vRGVmYXVsdCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkYXRlID0gdGhpcy5fZ2V0RGF0ZShpbnN0KTtcblxuXHRcdFx0dmFyIGN1cnJEVCA9IG51bGw7XG5cblx0XHRcdGlmICh0cF9pbnN0LiRhbHRJbnB1dCAmJiB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5KSB7XG5cdFx0XHRcdGN1cnJEVCA9IHRwX2luc3QuJGlucHV0LnZhbCgpICsgJyAnICsgdHBfaW5zdC4kYWx0SW5wdXQudmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0cF9pbnN0LiRpbnB1dC5nZXQoMCkudGFnTmFtZSAhPT0gJ0lOUFVUJyAmJiB0cF9pbnN0LiRhbHRJbnB1dCkge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogaW4gY2FzZSB0aGUgZGF0ZXRpbWVwaWNrZXIgaGFzIGJlZW4gYXBwbGllZCB0byBhIG5vbi1pbnB1dCB0YWcgZm9yIGlubGluZSBVSSxcblx0XHRcdFx0ICogYW5kIHRoZSB1c2VyIGhhcyBub3QgY29uZmlndXJlZCB0aGUgcGx1Z2luIHRvIGRpc3BsYXkgb25seSB0aW1lIGluIGFsdElucHV0LFxuXHRcdFx0XHQgKiBwaWNrIGN1cnJlbnQgZGF0ZSB0aW1lIGZyb20gdGhlIGFsdElucHV0IChhbmQgaG9wZSBmb3IgdGhlIGJlc3QsIGZvciBub3csIHVudGlsIFwiRVIxXCIgaXMgYXBwbGllZClcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogQHRvZG8gRVIxLiBTaW5jZSBhbHRJbnB1dCBjYW4gaGF2ZSBhIHRvdGFsbHkgZGlmZmVyZW5jZSBmb3JtYXQsIGNvbnZlcnQgaXQgdG8gc3RhbmRhcmQgZm9ybWF0IGJ5IHJlYWRpbmcgaW5wdXQgZm9ybWF0IGZyb20gXCJhbHRGb3JtYXRcIiBhbmQgXCJhbHRUaW1lRm9ybWF0XCIgb3B0aW9uIHZhbHVlc1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0Y3VyckRUID0gdHBfaW5zdC4kYWx0SW5wdXQudmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y3VyckRUID0gdHBfaW5zdC4kaW5wdXQudmFsKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRlICYmIHRwX2luc3QuX3BhcnNlVGltZShjdXJyRFQsICFpbnN0LnNldHRpbmdzLnRpbWVPbmx5KSkge1xuXHRcdFx0XHRkYXRlLnNldEhvdXJzKHRwX2luc3QuaG91ciwgdHBfaW5zdC5taW51dGUsIHRwX2luc3Quc2Vjb25kLCB0cF9pbnN0Lm1pbGxpc2VjKTtcblx0XHRcdFx0ZGF0ZS5zZXRNaWNyb3NlY29uZHModHBfaW5zdC5taWNyb3NlYyk7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgeW91IGFyZSB1c2luZyB0aGUgdGltZXpvbmUgb3B0aW9uLCBqYXZhc2NyaXB0J3MgRGF0ZVxuXHRcdFx0XHQvLyBvYmplY3Qgd2lsbCBvbmx5IHJldHVybiB0aGUgdGltZXpvbmUgb2Zmc2V0IGZvciB0aGUgY3VycmVudCBsb2NhbGUsIHNvIHdlXG5cdFx0XHRcdC8vIGFkanVzdCBpdCBhY2NvcmRpbmdseS4gIElmIG5vdCB1c2luZyB0aW1lem9uZSBvcHRpb24gdGhpcyB3b24ndCBtYXR0ZXIuLlxuXHRcdFx0XHRpZiAodHBfaW5zdC50aW1lem9uZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gbG9vayBvdXQgZm9yIERTVCBpZiB0eiB3YXNuJ3Qgc3BlY2lmaWVkXG5cdFx0XHRcdFx0aWYgKCF0cF9pbnN0LnN1cHBvcnQudGltZXpvbmUgJiYgdHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHRwX2luc3QudGltZXpvbmUgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0ZSA9ICQudGltZXBpY2tlci50aW1lem9uZUFkanVzdChkYXRlLCB0cF9pbnN0LnRpbWV6b25lLCAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcoLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2Jhc2VfZ2V0RGF0ZURhdGVwaWNrZXIodGFyZ2V0LCBub0RlZmF1bHQpO1xuXHR9O1xuXG5cdC8qXG5cdCogb3ZlcnJpZGUgcGFyc2VEYXRlKCkgYmVjYXVzZSBVSSAxLjguMTQgdGhyb3dzIGFuIGVycm9yIGFib3V0IFwiRXh0cmEgY2hhcmFjdGVyc1wiXG5cdCogQW4gb3B0aW9uIGluIGRhdGFwaWNrZXIgdG8gaWdub3JlIGV4dHJhIGZvcm1hdCBjaGFyYWN0ZXJzIHdvdWxkIGJlIG5pY2VyLlxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfcGFyc2VEYXRlID0gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZTtcblx0JC5kYXRlcGlja2VyLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uIChmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xuXHRcdHZhciBkYXRlO1xuXHRcdHRyeSB7XG5cdFx0XHRkYXRlID0gdGhpcy5fYmFzZV9wYXJzZURhdGUoZm9ybWF0LCB2YWx1ZSwgc2V0dGluZ3MpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Ly8gSGFjayEgIFRoZSBlcnJvciBtZXNzYWdlIGVuZHMgd2l0aCBhIGNvbG9uLCBhIHNwYWNlLCBhbmRcblx0XHRcdC8vIHRoZSBcImV4dHJhXCIgY2hhcmFjdGVycy4gIFdlIHJlbHkgb24gdGhhdCBpbnN0ZWFkIG9mXG5cdFx0XHQvLyBhdHRlbXB0aW5nIHRvIHBlcmZlY3RseSByZXByb2R1Y2UgdGhlIHBhcnNpbmcgYWxnb3JpdGhtLlxuXHRcdFx0aWYgKGVyci5pbmRleE9mKFwiOlwiKSA+PSAwKSB7XG5cdFx0XHRcdGRhdGUgPSB0aGlzLl9iYXNlX3BhcnNlRGF0ZShmb3JtYXQsIHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAoZXJyLmxlbmd0aCAtIGVyci5pbmRleE9mKCc6JykgLSAyKSksIHNldHRpbmdzKTtcblx0XHRcdFx0JC50aW1lcGlja2VyLmxvZyhcIkVycm9yIHBhcnNpbmcgdGhlIGRhdGUgc3RyaW5nOiBcIiArIGVyciArIFwiXFxuZGF0ZSBzdHJpbmcgPSBcIiArIHZhbHVlICsgXCJcXG5kYXRlIGZvcm1hdCA9IFwiICsgZm9ybWF0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH07XG5cblx0Lypcblx0KiBvdmVycmlkZSBmb3JtYXREYXRlIHRvIHNldCBkYXRlIHdpdGggdGltZSB0byB0aGUgaW5wdXRcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX2Zvcm1hdERhdGUgPSAkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGU7XG5cdCQuZGF0ZXBpY2tlci5fZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uIChpbnN0LCBkYXksIG1vbnRoLCB5ZWFyKSB7XG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0dHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoaW5zdCk7XG5cdFx0XHRyZXR1cm4gdHBfaW5zdC4kaW5wdXQudmFsKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9iYXNlX2Zvcm1hdERhdGUoaW5zdCk7XG5cdH07XG5cblx0Lypcblx0KiBvdmVycmlkZSBvcHRpb25zIHNldHRlciB0byBhZGQgdGltZSB0byBtYXhEYXRlKFRpbWUpIGFuZCBtaW5EYXRlKFRpbWUpLiBNYXhEYXRlXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9vcHRpb25EYXRlcGlja2VyID0gJC5kYXRlcGlja2VyLl9vcHRpb25EYXRlcGlja2VyO1xuXHQkLmRhdGVwaWNrZXIuX29wdGlvbkRhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpLFxuXHRcdFx0bmFtZV9jbG9uZTtcblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdHZhciBtaW4gPSBudWxsLFxuXHRcdFx0XHRtYXggPSBudWxsLFxuXHRcdFx0XHRvbnNlbGVjdCA9IG51bGwsXG5cdFx0XHRcdG92ZXJyaWRlcyA9IHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLFxuXHRcdFx0XHRmbnMgPSB7fSxcblx0XHRcdFx0cHJvcCxcblx0XHRcdFx0cmV0LFxuXHRcdFx0XHRvbGRWYWwsXG5cdFx0XHRcdCR0YXJnZXQ7XG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7IC8vIGlmIG1pbi9tYXggd2FzIHNldCB3aXRoIHRoZSBzdHJpbmdcblx0XHRcdFx0aWYgKG5hbWUgPT09ICdtaW5EYXRlJyB8fCBuYW1lID09PSAnbWluRGF0ZVRpbWUnKSB7XG5cdFx0XHRcdFx0bWluID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ21heERhdGUnIHx8IG5hbWUgPT09ICdtYXhEYXRlVGltZScpIHtcblx0XHRcdFx0XHRtYXggPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChuYW1lID09PSAnb25TZWxlY3QnKSB7XG5cdFx0XHRcdFx0b25zZWxlY3QgPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChvdmVycmlkZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mICh2YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3ZlcnJpZGVzW25hbWVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmbnNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRuYW1lX2Nsb25lID0ge307IC8vZW1wdHkgcmVzdWx0cyBpbiBleGl0aW5nIGZ1bmN0aW9uIGFmdGVyIG92ZXJyaWRlcyB1cGRhdGVkXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7IC8vaWYgbWluL21heCB3YXMgc2V0IHdpdGggdGhlIEpTT05cblx0XHRcdFx0aWYgKG5hbWUubWluRGF0ZSkge1xuXHRcdFx0XHRcdG1pbiA9IG5hbWUubWluRGF0ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChuYW1lLm1pbkRhdGVUaW1lKSB7XG5cdFx0XHRcdFx0bWluID0gbmFtZS5taW5EYXRlVGltZTtcblx0XHRcdFx0fSBlbHNlIGlmIChuYW1lLm1heERhdGUpIHtcblx0XHRcdFx0XHRtYXggPSBuYW1lLm1heERhdGU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5tYXhEYXRlVGltZSkge1xuXHRcdFx0XHRcdG1heCA9IG5hbWUubWF4RGF0ZVRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwcm9wIGluIG92ZXJyaWRlcykge1xuXHRcdFx0XHRcdGlmIChvdmVycmlkZXMuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgbmFtZVtwcm9wXSkge1xuXHRcdFx0XHRcdFx0Zm5zW3Byb3BdID0gbmFtZVtwcm9wXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAocHJvcCBpbiBmbnMpIHtcblx0XHRcdFx0aWYgKGZucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRcdG92ZXJyaWRlc1twcm9wXSA9IGZuc1twcm9wXTtcblx0XHRcdFx0XHRpZiAoIW5hbWVfY2xvbmUpIHsgbmFtZV9jbG9uZSA9ICQuZXh0ZW5kKHt9LCBuYW1lKTsgfVxuXHRcdFx0XHRcdGRlbGV0ZSBuYW1lX2Nsb25lW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobmFtZV9jbG9uZSAmJiBpc0VtcHR5T2JqZWN0KG5hbWVfY2xvbmUpKSB7IHJldHVybjsgfVxuXHRcdFx0aWYgKG1pbikgeyAvL2lmIG1pbiB3YXMgc2V0XG5cdFx0XHRcdGlmIChtaW4gPT09IDApIHtcblx0XHRcdFx0XHRtaW4gPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1pbiA9IG5ldyBEYXRlKG1pbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9IG1pbjtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgPSBtaW47XG5cdFx0XHR9IGVsc2UgaWYgKG1heCkgeyAvL2lmIG1heCB3YXMgc2V0XG5cdFx0XHRcdGlmIChtYXggPT09IDApIHtcblx0XHRcdFx0XHRtYXggPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1heCA9IG5ldyBEYXRlKG1heCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZSA9IG1heDtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUgPSBtYXg7XG5cdFx0XHR9IGVsc2UgaWYgKG9uc2VsZWN0KSB7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm9uU2VsZWN0ID0gb25zZWxlY3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERhdGVwaWNrZXIgd2lsbCBvdmVycmlkZSBvdXIgZGF0ZSB3aGVuIHdlIGNhbGwgX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlciB3aGVuXG5cdFx0XHQvLyBjYWxsaW5nIG1pbkRhdGUvbWF4RGF0ZSwgc28gd2Ugd2lsbCBmaXJzdCBncmFiIHRoZSB2YWx1ZSwgY2FsbFxuXHRcdFx0Ly8gX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlciwgdGhlbiBzZXQgb3VyIHZhbHVlIGJhY2suXG5cdFx0XHRpZihtaW4gfHwgbWF4KXtcblx0XHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KTtcblx0XHRcdFx0b2xkVmFsID0gJHRhcmdldC5kYXRldGltZXBpY2tlcignZ2V0RGF0ZScpO1xuXHRcdFx0XHRyZXQgPSB0aGlzLl9iYXNlX29wdGlvbkRhdGVwaWNrZXIuY2FsbCgkLmRhdGVwaWNrZXIsIHRhcmdldCwgbmFtZV9jbG9uZSB8fCBuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdCR0YXJnZXQuZGF0ZXRpbWVwaWNrZXIoJ3NldERhdGUnLCBvbGRWYWwpO1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlci5jYWxsKCQuZGF0ZXBpY2tlciwgdGFyZ2V0LCBuYW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlci5jYWxsKCQuZGF0ZXBpY2tlciwgdGFyZ2V0LCBuYW1lX2Nsb25lIHx8IG5hbWUsIHZhbHVlKTtcblx0fTtcblxuXHQvKlxuXHQqIGpRdWVyeSBpc0VtcHR5T2JqZWN0IGRvZXMgbm90IGNoZWNrIGhhc093blByb3BlcnR5IC0gaWYgc29tZW9uZSBoYXMgYWRkZWQgdG8gdGhlIG9iamVjdCBwcm90b3R5cGUsXG5cdCogaXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIGFsbCBvYmplY3RzXG5cdCovXG5cdHZhciBpc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdHZhciBwcm9wO1xuXHRcdGZvciAocHJvcCBpbiBvYmopIHtcblx0XHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKlxuXHQqIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhXG5cdCovXG5cdHZhciBleHRlbmRSZW1vdmUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wcykge1xuXHRcdCQuZXh0ZW5kKHRhcmdldCwgcHJvcHMpO1xuXHRcdGZvciAodmFyIG5hbWUgaW4gcHJvcHMpIHtcblx0XHRcdGlmIChwcm9wc1tuYW1lXSA9PT0gbnVsbCB8fCBwcm9wc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRhcmdldFtuYW1lXSA9IHByb3BzW25hbWVdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qXG5cdCogRGV0ZXJtaW5lIGJ5IHRoZSB0aW1lIGZvcm1hdCB3aGljaCB1bml0cyBhcmUgc3VwcG9ydGVkXG5cdCogUmV0dXJucyBhbiBvYmplY3Qgb2YgYm9vbGVhbnMgZm9yIGVhY2ggdW5pdFxuXHQqL1xuXHR2YXIgZGV0ZWN0U3VwcG9ydCA9IGZ1bmN0aW9uICh0aW1lRm9ybWF0KSB7XG5cdFx0dmFyIHRmID0gdGltZUZvcm1hdC5yZXBsYWNlKC8nLio/Jy9nLCAnJykudG9Mb3dlckNhc2UoKSwgLy8gcmVtb3ZlcyBsaXRlcmFsc1xuXHRcdFx0aXNJbiA9IGZ1bmN0aW9uIChmLCB0KSB7IC8vIGRvZXMgdGhlIGZvcm1hdCBjb250YWluIHRoZSB0b2tlbj9cblx0XHRcdFx0XHRyZXR1cm4gZi5pbmRleE9mKHQpICE9PSAtMSA/IHRydWUgOiBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0XHRob3VyOiBpc0luKHRmLCAnaCcpLFxuXHRcdFx0XHRtaW51dGU6IGlzSW4odGYsICdtJyksXG5cdFx0XHRcdHNlY29uZDogaXNJbih0ZiwgJ3MnKSxcblx0XHRcdFx0bWlsbGlzZWM6IGlzSW4odGYsICdsJyksXG5cdFx0XHRcdG1pY3Jvc2VjOiBpc0luKHRmLCAnYycpLFxuXHRcdFx0XHR0aW1lem9uZTogaXNJbih0ZiwgJ3onKSxcblx0XHRcdFx0YW1wbTogaXNJbih0ZiwgJ3QnKSAmJiBpc0luKHRpbWVGb3JtYXQsICdoJyksXG5cdFx0XHRcdGlzbzg2MDE6IGlzSW4odGltZUZvcm1hdCwgJ1onKVxuXHRcdFx0fTtcblx0fTtcblxuXHQvKlxuXHQqIENvbnZlcnRzIDI0IGhvdXIgZm9ybWF0IGludG8gMTIgaG91clxuXHQqIFJldHVybnMgMTIgaG91ciB3aXRob3V0IGxlYWRpbmcgMFxuXHQqL1xuXHR2YXIgY29udmVydDI0dG8xMiA9IGZ1bmN0aW9uIChob3VyKSB7XG5cdFx0aG91ciAlPSAxMjtcblxuXHRcdGlmIChob3VyID09PSAwKSB7XG5cdFx0XHRob3VyID0gMTI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFN0cmluZyhob3VyKTtcblx0fTtcblxuXHR2YXIgY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIHByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzICYmIHNldHRpbmdzW3Byb3BlcnR5XSA/IHNldHRpbmdzW3Byb3BlcnR5XSA6ICQudGltZXBpY2tlci5fZGVmYXVsdHNbcHJvcGVydHldO1xuXHR9O1xuXG5cdC8qXG5cdCogU3BsaXRzIGRhdGV0aW1lIHN0cmluZyBpbnRvIGRhdGUgYW5kIHRpbWUgc3Vic3RyaW5ncy5cblx0KiBUaHJvd3MgZXhjZXB0aW9uIHdoZW4gZGF0ZSBjYW4ndCBiZSBwYXJzZWRcblx0KiBSZXR1cm5zIHtkYXRlU3RyaW5nOiBkYXRlU3RyaW5nLCB0aW1lU3RyaW5nOiB0aW1lU3RyaW5nfVxuXHQqL1xuXHR2YXIgc3BsaXREYXRlVGltZSA9IGZ1bmN0aW9uIChkYXRlVGltZVN0cmluZywgdGltZVNldHRpbmdzKSB7XG5cdFx0Ly8gVGhlIGlkZWEgaXMgdG8gZ2V0IHRoZSBudW1iZXIgc2VwYXJhdG9yIG9jY3VycmVuY2VzIGluIGRhdGV0aW1lIGFuZCB0aGUgdGltZSBmb3JtYXQgcmVxdWVzdGVkIChzaW5jZSB0aW1lIGhhc1xuXHRcdC8vIGZld2VyIHVua25vd25zLCBtb3N0bHkgbnVtYmVycyBhbmQgYW0vcG0pLiBXZSB3aWxsIHVzZSB0aGUgdGltZSBwYXR0ZXJuIHRvIHNwbGl0LlxuXHRcdHZhciBzZXBhcmF0b3IgPSBjb21wdXRlRWZmZWN0aXZlU2V0dGluZyh0aW1lU2V0dGluZ3MsICdzZXBhcmF0b3InKSxcblx0XHRcdGZvcm1hdCA9IGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nKHRpbWVTZXR0aW5ncywgJ3RpbWVGb3JtYXQnKSxcblx0XHRcdHRpbWVQYXJ0cyA9IGZvcm1hdC5zcGxpdChzZXBhcmF0b3IpLCAvLyBob3cgbWFueSBvY2N1cnJlbmNlcyBvZiBzZXBhcmF0b3IgbWF5IGJlIGluIG91ciBmb3JtYXQ/XG5cdFx0XHR0aW1lUGFydHNMZW4gPSB0aW1lUGFydHMubGVuZ3RoLFxuXHRcdFx0YWxsUGFydHMgPSBkYXRlVGltZVN0cmluZy5zcGxpdChzZXBhcmF0b3IpLFxuXHRcdFx0YWxsUGFydHNMZW4gPSBhbGxQYXJ0cy5sZW5ndGg7XG5cblx0XHRpZiAoYWxsUGFydHNMZW4gPiAxKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRlU3RyaW5nOiBhbGxQYXJ0cy5zcGxpY2UoMCwgYWxsUGFydHNMZW4gLSB0aW1lUGFydHNMZW4pLmpvaW4oc2VwYXJhdG9yKSxcblx0XHRcdFx0dGltZVN0cmluZzogYWxsUGFydHMuc3BsaWNlKDAsIHRpbWVQYXJ0c0xlbikuam9pbihzZXBhcmF0b3IpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRlU3RyaW5nOiBkYXRlVGltZVN0cmluZyxcblx0XHRcdHRpbWVTdHJpbmc6ICcnXG5cdFx0fTtcblx0fTtcblxuXHQvKlxuXHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIHBhcnNlIGRhdGV0aW1lIGludGVydmFsXG5cdCogUmV0dXJuczoge2RhdGU6IERhdGUsIHRpbWVPYmo6IE9iamVjdH0sIHdoZXJlXG5cdCogICBkYXRlIC0gcGFyc2VkIGRhdGUgd2l0aG91dCB0aW1lICh0eXBlIERhdGUpXG5cdCogICB0aW1lT2JqID0ge2hvdXI6ICwgbWludXRlOiAsIHNlY29uZDogLCBtaWxsaXNlYzogLCBtaWNyb3NlYzogfSAtIHBhcnNlZCB0aW1lLiBPcHRpb25hbFxuXHQqL1xuXHR2YXIgcGFyc2VEYXRlVGltZUludGVybmFsID0gZnVuY3Rpb24gKGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIGRhdGVUaW1lU3RyaW5nLCBkYXRlU2V0dGluZ3MsIHRpbWVTZXR0aW5ncykge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0cGFydHMsXG5cdFx0XHRwYXJzZWRUaW1lO1xuXG5cdFx0cGFydHMgPSBzcGxpdERhdGVUaW1lKGRhdGVUaW1lU3RyaW5nLCB0aW1lU2V0dGluZ3MpO1xuXHRcdGRhdGUgPSAkLmRhdGVwaWNrZXIuX2Jhc2VfcGFyc2VEYXRlKGRhdGVGb3JtYXQsIHBhcnRzLmRhdGVTdHJpbmcsIGRhdGVTZXR0aW5ncyk7XG5cblx0XHRpZiAocGFydHMudGltZVN0cmluZyA9PT0gJycpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGU6IGRhdGVcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cGFyc2VkVGltZSA9ICQuZGF0ZXBpY2tlci5wYXJzZVRpbWUodGltZUZvcm1hdCwgcGFydHMudGltZVN0cmluZywgdGltZVNldHRpbmdzKTtcblxuXHRcdGlmICghcGFyc2VkVGltZSkge1xuXHRcdFx0dGhyb3cgJ1dyb25nIHRpbWUgZm9ybWF0Jztcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0ZTogZGF0ZSxcblx0XHRcdHRpbWVPYmo6IHBhcnNlZFRpbWVcblx0XHR9O1xuXHR9O1xuXG5cdC8qXG5cdCogSW50ZXJuYWwgZnVuY3Rpb24gdG8gc2V0IHRpbWV6b25lX3NlbGVjdCB0byB0aGUgbG9jYWwgdGltZXpvbmVcblx0Ki9cblx0dmFyIHNlbGVjdExvY2FsVGltZXpvbmUgPSBmdW5jdGlvbiAodHBfaW5zdCwgZGF0ZSkge1xuXHRcdGlmICh0cF9pbnN0ICYmIHRwX2luc3QudGltZXpvbmVfc2VsZWN0KSB7XG5cdFx0XHR2YXIgbm93ID0gZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuXHRcdFx0dHBfaW5zdC50aW1lem9uZV9zZWxlY3QudmFsKC1ub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCogQ3JlYXRlIGEgU2luZ2xldG9uIEluc3RhbmNlXG5cdCovXG5cdCQudGltZXBpY2tlciA9IG5ldyBUaW1lcGlja2VyKCk7XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdGltZXpvbmUgb2Zmc2V0IGFzIHN0cmluZyBmcm9tIGEgZGF0ZSBvYmplY3QgKGVnICcrMDUzMCcgZm9yIFVUQys1LjUpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0ek1pbnV0ZXMgaWYgbm90IGEgbnVtYmVyLCBsZXNzIHRoYW4gLTcyMCAoLTEyMDApLCBvciBncmVhdGVyIHRoYW4gODQwICgrMTQwMCkgdGhpcyB2YWx1ZSBpcyByZXR1cm5lZFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzbzg2MDEgaWYgdHJ1ZSBmb3JtYXRzIGluIGFjY29yZGFuY2UgdG8gaXNvODYwMSBcIisxMjo0NVwiXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdCQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZyA9IGZ1bmN0aW9uICh0ek1pbnV0ZXMsIGlzbzg2MDEpIHtcblx0XHRpZiAoaXNOYU4odHpNaW51dGVzKSB8fCB0ek1pbnV0ZXMgPiA4NDAgfHwgdHpNaW51dGVzIDwgLTcyMCkge1xuXHRcdFx0cmV0dXJuIHR6TWludXRlcztcblx0XHR9XG5cblx0XHR2YXIgb2ZmID0gdHpNaW51dGVzLFxuXHRcdFx0bWludXRlcyA9IG9mZiAlIDYwLFxuXHRcdFx0aG91cnMgPSAob2ZmIC0gbWludXRlcykgLyA2MCxcblx0XHRcdGlzbyA9IGlzbzg2MDEgPyAnOicgOiAnJyxcblx0XHRcdHR6ID0gKG9mZiA+PSAwID8gJysnIDogJy0nKSArICgnMCcgKyBNYXRoLmFicyhob3VycykpLnNsaWNlKC0yKSArIGlzbyArICgnMCcgKyBNYXRoLmFicyhtaW51dGVzKSkuc2xpY2UoLTIpO1xuXG5cdFx0aWYgKHR6ID09PSAnKzAwOjAwJykge1xuXHRcdFx0cmV0dXJuICdaJztcblx0XHR9XG5cdFx0cmV0dXJuIHR6O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG51bWJlciBpbiBtaW51dGVzIHRoYXQgcmVwcmVzZW50cyBhIHRpbWV6b25lIHN0cmluZ1xuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHR6U3RyaW5nIGZvcm1hdHRlZCBsaWtlIFwiKzA1MDBcIiwgXCItMTI0NVwiLCBcIlpcIlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBvZmZzZXQgbWludXRlcyBvciB0aGUgb3JpZ2luYWwgc3RyaW5nIGlmIGl0IGRvZXNuJ3QgbWF0Y2ggZXhwZWN0YXRpb25zXG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXROdW1iZXIgPSBmdW5jdGlvbiAodHpTdHJpbmcpIHtcblx0XHR2YXIgbm9ybWFsaXplZCA9IHR6U3RyaW5nLnRvU3RyaW5nKCkucmVwbGFjZSgnOicsICcnKTsgLy8gZXhjdXNlIGFueSBpc284NjAxLCBlbmQgdXAgd2l0aCBcIisxMjQ1XCJcblxuXHRcdGlmIChub3JtYWxpemVkLnRvVXBwZXJDYXNlKCkgPT09ICdaJykgeyAvLyBpZiBpc284NjAxIHdpdGggWiwgaXRzIDAgbWludXRlIG9mZnNldFxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0aWYgKCEvXihcXC18XFwrKVxcZHs0fSQvLnRlc3Qobm9ybWFsaXplZCkpIHsgLy8gcG9zc2libHkgYSB1c2VyIGRlZmluZWQgdHosIHNvIGp1c3QgZ2l2ZSBpdCBiYWNrXG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodHpTdHJpbmcsIDEwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKChub3JtYWxpemVkLnN1YnN0cigwLCAxKSA9PT0gJy0nID8gLTEgOiAxKSAqIC8vIHBsdXMgb3IgbWludXNcblx0XHRcdFx0XHQoKHBhcnNlSW50KG5vcm1hbGl6ZWQuc3Vic3RyKDEsIDIpLCAxMCkgKiA2MCkgKyAvLyBob3VycyAoY29udmVydGVkIHRvIG1pbnV0ZXMpXG5cdFx0XHRcdFx0cGFyc2VJbnQobm9ybWFsaXplZC5zdWJzdHIoMywgMiksIDEwKSkpOyAvLyBtaW51dGVzXG5cdH07XG5cblx0LyoqXG5cdCAqIE5vIHdheSB0byBzZXQgdGltZXpvbmUgaW4ganMgRGF0ZSwgc28gd2UgbXVzdCBhZGp1c3QgdGhlIG1pbnV0ZXMgdG8gY29tcGVuc2F0ZS4gKHRoaW5rIHNldERhdGUsIGdldERhdGUpXG5cdCAqIEBwYXJhbSAge0RhdGV9IGRhdGVcblx0ICogQHBhcmFtICB7c3RyaW5nfSBmcm9tVGltZXpvbmUgZm9ybWF0dGVkIGxpa2UgXCIrMDUwMFwiLCBcIi0xMjQ1XCJcblx0ICogQHBhcmFtICB7c3RyaW5nfSB0b1RpbWV6b25lIGZvcm1hdHRlZCBsaWtlIFwiKzA1MDBcIiwgXCItMTI0NVwiXG5cdCAqIEByZXR1cm4ge0RhdGV9XG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QgPSBmdW5jdGlvbiAoZGF0ZSwgZnJvbVRpbWV6b25lLCB0b1RpbWV6b25lKSB7XG5cdFx0dmFyIGZyb21UeiA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcihmcm9tVGltZXpvbmUpO1xuXHRcdHZhciB0b1R6ID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKHRvVGltZXpvbmUpO1xuXHRcdGlmICghaXNOYU4odG9UeikpIHtcblx0XHRcdGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArICgtZnJvbVR6KSAtICgtdG9UeikpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0ZTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbHMgYHRpbWVwaWNrZXIoKWAgb24gdGhlIGBzdGFydFRpbWVgIGFuZCBgZW5kVGltZWAgZWxlbWVudHMsIGFuZCBjb25maWd1cmVzIHRoZW0gdG9cblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cblx0ICogbi5iLiBUaGUgaW5wdXQgdmFsdWUgbXVzdCBiZSBjb3JyZWN0bHkgZm9ybWF0dGVkIChyZWZvcm1hdHRpbmcgaXMgbm90IHN1cHBvcnRlZClcblx0ICogQHBhcmFtICB7RWxlbWVudH0gc3RhcnRUaW1lXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IGVuZFRpbWVcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0aW1lcGlja2VyKCkgY2FsbFxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIudGltZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xuXHRcdHJldHVybiAkLnRpbWVwaWNrZXIuaGFuZGxlUmFuZ2UoJ3RpbWVwaWNrZXInLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxscyBgZGF0ZXRpbWVwaWNrZXJgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IHN0YXJ0VGltZVxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYHRpbWVwaWNrZXIoKWAgY2FsbC4gQWxzbyBzdXBwb3J0cyBgcmVmb3JtYXRgLFxuXHQgKiAgIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZm9ybWF0IHRoZSBpbnB1dCB2YWx1ZXMgdG8gdGhlIGBkYXRlRm9ybWF0YC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBtZXRob2QgQ2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgdHlwZSBvZiBwaWNrZXIgdG8gYmUgYWRkZWRcblx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHQgKi9cblx0JC50aW1lcGlja2VyLmRhdGV0aW1lUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XG5cdFx0JC50aW1lcGlja2VyLmhhbmRsZVJhbmdlKCdkYXRldGltZXBpY2tlcicsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxzIGBkYXRlcGlja2VyYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xuXHQgKiBlbmZvcmNlIGRhdGUgcmFuZ2UgbGltaXRzLlxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcblx0ICogQHBhcmFtICB7RWxlbWVudH0gZW5kVGltZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGB0aW1lcGlja2VyKClgIGNhbGwuIEFsc28gc3VwcG9ydHMgYHJlZm9ybWF0YCxcblx0ICogICBhIGJvb2xlYW4gdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWVzIHRvIHRoZSBgZGF0ZUZvcm1hdGAuXG5cdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0ICovXG5cdCQudGltZXBpY2tlci5kYXRlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XG5cdFx0JC50aW1lcGlja2VyLmhhbmRsZVJhbmdlKCdkYXRlcGlja2VyJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbHMgYG1ldGhvZGAgb24gdGhlIGBzdGFydFRpbWVgIGFuZCBgZW5kVGltZWAgZWxlbWVudHMsIGFuZCBjb25maWd1cmVzIHRoZW0gdG9cblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBtZXRob2QgQ2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgdHlwZSBvZiBwaWNrZXIgdG8gYmUgYWRkZWRcblx0ICogQHBhcmFtICB7RWxlbWVudH0gc3RhcnRUaW1lXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IGVuZFRpbWVcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBgdGltZXBpY2tlcigpYCBjYWxsLiBBbHNvIHN1cHBvcnRzIGByZWZvcm1hdGAsXG5cdCAqICAgYSBib29sZWFuIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmb3JtYXQgdGhlIGlucHV0IHZhbHVlcyB0byB0aGUgYGRhdGVGb3JtYXRgLlxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIuaGFuZGxlUmFuZ2UgPSBmdW5jdGlvbiAobWV0aG9kLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gJC5leHRlbmQoe30sIHtcblx0XHRcdG1pbkludGVydmFsOiAwLCAvLyBtaW4gYWxsb3dlZCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcblx0XHRcdG1heEludGVydmFsOiAwLCAvLyBtYXggYWxsb3dlZCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcblx0XHRcdHN0YXJ0OiB7fSwgICAgICAvLyBvcHRpb25zIGZvciBzdGFydCBwaWNrZXJcblx0XHRcdGVuZDoge30gICAgICAgICAvLyBvcHRpb25zIGZvciBlbmQgcGlja2VyXG5cdFx0fSwgb3B0aW9ucyk7XG5cblx0XHQvLyBmb3IgdGhlIG1lYW4gdGltZSB0aGlzIGZpeGVzIGFuIGlzc3VlIHdpdGggY2FsbGluZyBnZXREYXRlIHdpdGggdGltZXBpY2tlcigpXG5cdFx0dmFyIHRpbWVPbmx5ID0gZmFsc2U7XG5cdFx0aWYobWV0aG9kID09PSAndGltZXBpY2tlcicpe1xuXHRcdFx0dGltZU9ubHkgPSB0cnVlO1xuXHRcdFx0bWV0aG9kID0gJ2RhdGV0aW1lcGlja2VyJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja0RhdGVzKGNoYW5nZWQsIG90aGVyKSB7XG5cdFx0XHR2YXIgc3RhcnRkdCA9IHN0YXJ0VGltZVttZXRob2RdKCdnZXREYXRlJyksXG5cdFx0XHRcdGVuZGR0ID0gZW5kVGltZVttZXRob2RdKCdnZXREYXRlJyksXG5cdFx0XHRcdGNoYW5nZWRkdCA9IGNoYW5nZWRbbWV0aG9kXSgnZ2V0RGF0ZScpO1xuXG5cdFx0XHRpZiAoc3RhcnRkdCAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgbWluRGF0ZSA9IG5ldyBEYXRlKHN0YXJ0ZHQuZ2V0VGltZSgpKSxcblx0XHRcdFx0XHRtYXhEYXRlID0gbmV3IERhdGUoc3RhcnRkdC5nZXRUaW1lKCkpO1xuXG5cdFx0XHRcdG1pbkRhdGUuc2V0TWlsbGlzZWNvbmRzKG1pbkRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKyBvcHRpb25zLm1pbkludGVydmFsKTtcblx0XHRcdFx0bWF4RGF0ZS5zZXRNaWxsaXNlY29uZHMobWF4RGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG9wdGlvbnMubWF4SW50ZXJ2YWwpO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLm1pbkludGVydmFsID4gMCAmJiBtaW5EYXRlID4gZW5kZHQpIHsgLy8gbWluSW50ZXJ2YWwgY2hlY2tcblx0XHRcdFx0XHRlbmRUaW1lW21ldGhvZF0oJ3NldERhdGUnLCBtaW5EYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChvcHRpb25zLm1heEludGVydmFsID4gMCAmJiBtYXhEYXRlIDwgZW5kZHQpIHsgLy8gbWF4IGludGVydmFsIGNoZWNrXG5cdFx0XHRcdFx0ZW5kVGltZVttZXRob2RdKCdzZXREYXRlJywgbWF4RGF0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoc3RhcnRkdCA+IGVuZGR0KSB7XG5cdFx0XHRcdFx0b3RoZXJbbWV0aG9kXSgnc2V0RGF0ZScsIGNoYW5nZWRkdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZWxlY3RlZChjaGFuZ2VkLCBvdGhlciwgb3B0aW9uKSB7XG5cdFx0XHRpZiAoIWNoYW5nZWQudmFsKCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGRhdGUgPSBjaGFuZ2VkW21ldGhvZF0uY2FsbChjaGFuZ2VkLCAnZ2V0RGF0ZScpO1xuXHRcdFx0aWYgKGRhdGUgIT09IG51bGwgJiYgb3B0aW9ucy5taW5JbnRlcnZhbCA+IDApIHtcblx0XHRcdFx0aWYgKG9wdGlvbiA9PT0gJ21pbkRhdGUnKSB7XG5cdFx0XHRcdFx0ZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG9wdGlvbnMubWluSW50ZXJ2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcHRpb24gPT09ICdtYXhEYXRlJykge1xuXHRcdFx0XHRcdGRhdGUuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSBvcHRpb25zLm1pbkludGVydmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0ZS5nZXRUaW1lKSB7XG5cdFx0XHRcdG90aGVyW21ldGhvZF0uY2FsbChvdGhlciwgJ29wdGlvbicsIG9wdGlvbiwgZGF0ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0JC5mblttZXRob2RdLmNhbGwoc3RhcnRUaW1lLCAkLmV4dGVuZCh7XG5cdFx0XHR0aW1lT25seTogdGltZU9ubHksXG5cdFx0XHRvbkNsb3NlOiBmdW5jdGlvbiAoZGF0ZVRleHQsIGluc3QpIHtcblx0XHRcdFx0Y2hlY2tEYXRlcygkKHRoaXMpLCBlbmRUaW1lKTtcblx0XHRcdH0sXG5cdFx0XHRvblNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZVRpbWUpIHtcblx0XHRcdFx0c2VsZWN0ZWQoJCh0aGlzKSwgZW5kVGltZSwgJ21pbkRhdGUnKTtcblx0XHRcdH1cblx0XHR9LCBvcHRpb25zLCBvcHRpb25zLnN0YXJ0KSk7XG5cdFx0JC5mblttZXRob2RdLmNhbGwoZW5kVGltZSwgJC5leHRlbmQoe1xuXHRcdFx0dGltZU9ubHk6IHRpbWVPbmx5LFxuXHRcdFx0b25DbG9zZTogZnVuY3Rpb24gKGRhdGVUZXh0LCBpbnN0KSB7XG5cdFx0XHRcdGNoZWNrRGF0ZXMoJCh0aGlzKSwgc3RhcnRUaW1lKTtcblx0XHRcdH0sXG5cdFx0XHRvblNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZVRpbWUpIHtcblx0XHRcdFx0c2VsZWN0ZWQoJCh0aGlzKSwgc3RhcnRUaW1lLCAnbWF4RGF0ZScpO1xuXHRcdFx0fVxuXHRcdH0sIG9wdGlvbnMsIG9wdGlvbnMuZW5kKSk7XG5cblx0XHRjaGVja0RhdGVzKHN0YXJ0VGltZSwgZW5kVGltZSk7XG5cblx0XHRzZWxlY3RlZChzdGFydFRpbWUsIGVuZFRpbWUsICdtaW5EYXRlJyk7XG5cdFx0c2VsZWN0ZWQoZW5kVGltZSwgc3RhcnRUaW1lLCAnbWF4RGF0ZScpO1xuXG5cdFx0cmV0dXJuICQoW3N0YXJ0VGltZS5nZXQoMCksIGVuZFRpbWUuZ2V0KDApXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvZyBlcnJvciBvciBkYXRhIHRvIHRoZSBjb25zb2xlIGR1cmluZyBlcnJvciBvciBkZWJ1Z2dpbmdcblx0ICogQHBhcmFtICB7T2JqZWN0fSBlcnIgcGFzcyBhbnkgdHlwZSBvYmplY3QgdG8gbG9nIHRvIHRoZSBjb25zb2xlIGR1cmluZyBlcnJvciBvciBkZWJ1Z2dpbmdcblx0ICogQHJldHVybiB7dm9pZH1cblx0ICovXG5cdCQudGltZXBpY2tlci5sb2cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gT2xkZXIgSUUgKDksIG1heWJlIDEwKSB0aHJvdyBlcnJvciBvbiBhY2Nlc3NpbmcgYHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseWAsIHNvIGNoZWNrIGZpcnN0LlxuXHRcdGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cgJiYgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5KSB7XG5cdFx0XHR3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkod2luZG93LmNvbnNvbGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHQgKiBBZGQgdXRpbCBvYmplY3QgdG8gYWxsb3cgYWNjZXNzIHRvIHByaXZhdGUgbWV0aG9kcyBmb3IgdGVzdGFiaWxpdHkuXG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIuX3V0aWwgPSB7XG5cdFx0X2V4dGVuZFJlbW92ZTogZXh0ZW5kUmVtb3ZlLFxuXHRcdF9pc0VtcHR5T2JqZWN0OiBpc0VtcHR5T2JqZWN0LFxuXHRcdF9jb252ZXJ0MjR0bzEyOiBjb252ZXJ0MjR0bzEyLFxuXHRcdF9kZXRlY3RTdXBwb3J0OiBkZXRlY3RTdXBwb3J0LFxuXHRcdF9zZWxlY3RMb2NhbFRpbWV6b25lOiBzZWxlY3RMb2NhbFRpbWV6b25lLFxuXHRcdF9jb21wdXRlRWZmZWN0aXZlU2V0dGluZzogY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcsXG5cdFx0X3NwbGl0RGF0ZVRpbWU6IHNwbGl0RGF0ZVRpbWUsXG5cdFx0X3BhcnNlRGF0ZVRpbWVJbnRlcm5hbDogcGFyc2VEYXRlVGltZUludGVybmFsXG5cdH07XG5cblx0Lypcblx0KiBNaWNyb3NlY29uZCBzdXBwb3J0XG5cdCovXG5cdGlmICghRGF0ZS5wcm90b3R5cGUuZ2V0TWljcm9zZWNvbmRzKSB7XG5cdFx0RGF0ZS5wcm90b3R5cGUubWljcm9zZWNvbmRzID0gMDtcblx0XHREYXRlLnByb3RvdHlwZS5nZXRNaWNyb3NlY29uZHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1pY3Jvc2Vjb25kczsgfTtcblx0XHREYXRlLnByb3RvdHlwZS5zZXRNaWNyb3NlY29uZHMgPSBmdW5jdGlvbiAobSkge1xuXHRcdFx0dGhpcy5zZXRNaWxsaXNlY29uZHModGhpcy5nZXRNaWxsaXNlY29uZHMoKSArIE1hdGguZmxvb3IobSAvIDEwMDApKTtcblx0XHRcdHRoaXMubWljcm9zZWNvbmRzID0gbSAlIDEwMDA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9XG5cblx0Lypcblx0KiBLZWVwIHVwIHdpdGggdGhlIHZlcnNpb25cblx0Ki9cblx0JC50aW1lcGlja2VyLnZlcnNpb24gPSBcIjEuNi4zXCI7XG5cbn0pKHdpbmRvdy5qUXVlcnkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvanF1ZXJ5LXVpLXRpbWVwaWNrZXItYWRkb24uanMiLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjExLjBcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuUG9wcGVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmF0aXZlSGludHMgPSBbJ25hdGl2ZSBjb2RlJywgJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSddO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkIG5hdGl2ZWx5IChhcyBvcHBvc2VkIHRvIGEgcG9seWZpbGwpLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtGdW5jdGlvbiB8IHVuZGVmaW5lZH0gZm4gdGhlIGZ1bmN0aW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzTmF0aXZlID0gKGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gbmF0aXZlSGludHMuc29tZShmdW5jdGlvbiAoaGludCkge1xuICAgIHJldHVybiAoZm4gfHwgJycpLnRvU3RyaW5nKCkuaW5kZXhPZihoaW50KSA+IC0xO1xuICB9KTtcbn0pO1xuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xudmFyIHRpbWVvdXREdXJhdGlvbiA9IDA7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICB0aW1lb3V0RHVyYXRpb24gPSAxO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAvLyBNdXRhdGlvbk9ic2VydmVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIGZvciBzY2hlZHVsaW5nIG1pY3JvdGFza3MsIHdoaWNoXG4gIC8vIGFyZSBzY2hlZHVsZWQgKmJlZm9yZSogdGhlIG5leHQgdGFzay4gVGhpcyBnaXZlcyB1cyBhIHdheSB0byBkZWJvdW5jZVxuICAvLyBhIGZ1bmN0aW9uIGJ1dCBlbnN1cmUgaXQncyBjYWxsZWQgKmJlZm9yZSogdGhlIG5leHQgcGFpbnQuXG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICBmbigpO1xuICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICB9KTtcblxuICBvYnNlcnZlci5vYnNlcnZlKGVsZW0sIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3gtaW5kZXgnLCBpKTtcbiAgICAgIGkgPSBpICsgMTsgLy8gZG9uJ3QgdXNlIGNvbXB1bmQgKCs9KSBiZWNhdXNlIGl0IGRvZXNuJ3QgZ2V0IG9wdGltaXplZCBpbiBWOFxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBJdCdzIGNvbW1vbiBmb3IgTXV0YXRpb25PYnNlcnZlciBwb2x5ZmlsbHMgdG8gYmUgc2VlbiBpbiB0aGUgd2lsZCwgaG93ZXZlclxuLy8gdGhlc2UgcmVseSBvbiBNdXRhdGlvbiBFdmVudHMgd2hpY2ggb25seSBvY2N1ciB3aGVuIGFuIGVsZW1lbnQgaXMgY29ubmVjdGVkXG4vLyB0byB0aGUgRE9NLiBUaGUgYWxnb3JpdGhtIHVzZWQgaW4gdGhpcyBtb2R1bGUgZG9lcyBub3QgdXNlIGEgY29ubmVjdGVkIGVsZW1lbnQsXG4vLyBhbmQgc28gd2UgbXVzdCBlbnN1cmUgdGhhdCBhICpuYXRpdmUqIE11dGF0aW9uT2JzZXJ2ZXIgaXMgYXZhaWxhYmxlLlxudmFyIHN1cHBvcnRzTmF0aXZlTXV0YXRpb25PYnNlcnZlciA9IGlzQnJvd3NlciAmJiBpc05hdGl2ZSh3aW5kb3cuTXV0YXRpb25PYnNlcnZlcik7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c05hdGl2ZU11dGF0aW9uT2JzZXJ2ZXIgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQgfHwgWydIVE1MJywgJ0JPRFknLCAnI2RvY3VtZW50J10uaW5kZXhPZihlbGVtZW50Lm5vZGVOYW1lKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbCkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQgJiYgZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiArc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXS5zcGxpdCgncHgnKVswXSArICtzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddLnNwbGl0KCdweCcpWzBdO1xufVxuXG4vKipcbiAqIFRlbGxzIGlmIHlvdSBhcmUgcnVubmluZyBJbnRlcm5ldCBFeHBsb3JlciAxMFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUUxMFxuICovXG52YXIgaXNJRTEwID0gdW5kZWZpbmVkO1xuXG52YXIgaXNJRTEwJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChpc0lFMTAgPT09IHVuZGVmaW5lZCkge1xuICAgIGlzSUUxMCA9IG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ01TSUUgMTAnKSAhPT0gLTE7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMDtcbn07XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaXNJRTEwJDEoKSA/IGh0bWxbJ29mZnNldCcgKyBheGlzXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldICsgY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKCkge1xuICB2YXIgYm9keSA9IHdpbmRvdy5kb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRTEwJDEoKSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICBpZiAoaXNJRTEwJDEoKSkge1xuICAgIHRyeSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfSBlbHNlIHtcbiAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcygpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LnJpZ2h0IC0gcmVzdWx0LmxlZnQ7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmJvdHRvbSAtIHJlc3VsdC50b3A7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBpc0lFMTAgPSBpc0lFMTAkMSgpO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9ICtzdHlsZXMuYm9yZGVyVG9wV2lkdGguc3BsaXQoJ3B4JylbMF07XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSArc3R5bGVzLmJvcmRlckxlZnRXaWR0aC5zcGxpdCgncHgnKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9ICtzdHlsZXMubWFyZ2luVG9wLnNwbGl0KCdweCcpWzBdO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gK3N0eWxlcy5tYXJnaW5MZWZ0LnNwbGl0KCdweCcpWzBdO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgaHRtbCA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoaHRtbCk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0Jyk7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShwb3BwZXIpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQpO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBib3VuZGFyaWVzLmxlZnQgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy5yaWdodCAtPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllci5mdW5jdGlvbikge1xuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllci5mdW5jdGlvbiB8fCBtb2RpZmllci5mbjtcbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHdpbmRvdyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIG9uVXBkYXRlIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgdGhlIGFycm93IHN0eWxlIGhhcyBiZWVuIGNvbXB1dGVkLCBhcHBseSB0aGUgYXJyb3cgc3R5bGVcbiAgaWYgKGRhdGEub2Zmc2V0cy5hcnJvdykge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5vZmZzZXRzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICAvLyBmbG9vciBzaWRlcyB0byBhdm9pZCBibHVycnkgdGV4dFxuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICBsZWZ0OiBNYXRoLmZsb29yKHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IE1hdGguZmxvb3IocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiBNYXRoLmZsb29yKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBNYXRoLmZsb29yKHBvcHBlci5yaWdodClcbiAgfTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBhdHRyaWJ1dGVzIGFuZCBzdHlsZXMgb2YgYGRhdGFgXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1Y3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKVtzaWRlXTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0ge307XG4gIGRhdGEub2Zmc2V0cy5hcnJvd1tzaWRlXSA9IE1hdGgucm91bmQoc2lkZVZhbHVlKTtcbiAgZGF0YS5vZmZzZXRzLmFycm93W2FsdFNpZGVdID0gJyc7IC8vIG1ha2Ugc3VyZSB0byB1bnNldCBhbnkgZXZlbnR1YWwgYWx0U2lkZSB2YWx1ZSBmcm9tIHRoZSBET00gbm9kZVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1yaWdodGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgIHZhcmlhdGlvbiA9IGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgZGF0YSA9IHJ1bk1vZGlmaWVycyhkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZGF0YSwgJ2ZsaXAnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gIH1cbiAgaWYgKHBvcHBlcltvcFNpZGVdID4gZmxvb3IocmVmZXJlbmNlW3NpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMsIGJhc2VQbGFjZW1lbnQpIHtcbiAgdmFyIG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgLy8gU3BsaXQgdGhlIG9mZnNldCBzdHJpbmcgdG8gb2J0YWluIGEgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzXG4gIC8vIFRoZSByZWdleCBhZGRyZXNzZXMgdmFsdWVzIHdpdGggdGhlIHBsdXMgb3IgbWludXMgc2lnbiBpbiBmcm9udCAoKzEwLCAtMjAsIGV0YylcbiAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcudHJpbSgpO1xuICB9KTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgdmFyIGRpdmlkZXIgPSBmcmFnbWVudHMuaW5kZXhPZihmaW5kKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW3BsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0bGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgaGVpZ2h0LlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEFuIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIgdGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgaGFzIGFsd2F5cyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLCBjYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNob3RoZXJzXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXhwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gYXNzdXJlIGl0IHRvIHBvaW50IHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcywgeW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVjdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpLlxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLFxuICAgICAqIHRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBrZWVwVG9nZXRoZXIgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM2QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdSBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9ucyB1c2VkIGJ5IFBvcHBlci5qc1xuICogdGhpcyBvYmplY3QgZ2V0IHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXIuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciwgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFzIDNyZCBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoaXMgb2JqZWN0LCBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudFxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWRcbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZCwgdGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGFuIHVwZGF0ZSwgaXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZVxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTBcbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxucmV0dXJuIFBvcHBlcjtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9wb3BwZXIuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gNyIsIi8qIVxuICogQm9vdHN0cmFwIHY0LjAuMC1iZXRhIChodHRwczovL2dldGJvb3RzdHJhcC5jb20pXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE3IFRoZSBCb290c3RyYXAgQXV0aG9ycyAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2dyYXBocy9jb250cmlidXRvcnMpXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5cbmlmICh0eXBlb2YgalF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkuIGpRdWVyeSBtdXN0IGJlIGluY2x1ZGVkIGJlZm9yZSBCb290c3RyYXBcXCdzIEphdmFTY3JpcHQuJylcbn1cblxuKGZ1bmN0aW9uICgkKSB7XG4gIHZhciB2ZXJzaW9uID0gJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpXG4gIGlmICgodmVyc2lvblswXSA8IDIgJiYgdmVyc2lvblsxXSA8IDkpIHx8ICh2ZXJzaW9uWzBdID09IDEgJiYgdmVyc2lvblsxXSA9PSA5ICYmIHZlcnNpb25bMl0gPCAxKSB8fCAodmVyc2lvblswXSA+PSA0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGF0IGxlYXN0IGpRdWVyeSB2MS45LjEgYnV0IGxlc3MgdGhhbiB2NC4wLjAnKVxuICB9XG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24gKCkge1xudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWJldGEpOiB1dGlsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgVXRpbCA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBQcml2YXRlIFRyYW5zaXRpb25FbmQgSGVscGVyc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIHRyYW5zaXRpb24gPSBmYWxzZTtcblxuICB2YXIgTUFYX1VJRCA9IDEwMDAwMDA7XG5cbiAgdmFyIFRyYW5zaXRpb25FbmRFdmVudCA9IHtcbiAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgTW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnLFxuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xuXG4gICAgLy8gc2hvdXRvdXQgQW5ndXNDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxuICB9O2Z1bmN0aW9uIHRvVHlwZShvYmopIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJpbmRUeXBlOiB0cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogdHJhbnNpdGlvbi5lbmQsXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgICAgICBpZiAoJChldmVudC50YXJnZXQpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZFRlc3QoKSB7XG4gICAgaWYgKHdpbmRvdy5RVW5pdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBUcmFuc2l0aW9uRW5kRXZlbnQpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZW5kOiBUcmFuc2l0aW9uRW5kRXZlbnRbbmFtZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kRW11bGF0b3IoZHVyYXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgJCh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZChfdGhpcyk7XG4gICAgICB9XG4gICAgfSwgZHVyYXRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpIHtcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZFRlc3QoKTtcblxuICAgICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kRW11bGF0b3I7XG5cbiAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgJC5ldmVudC5zcGVjaWFsW1V0aWwuVFJBTlNJVElPTl9FTkRdID0gZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBQdWJsaWMgVXRpbCBBcGlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIFV0aWwgPSB7XG5cbiAgICBUUkFOU0lUSU9OX0VORDogJ2JzVHJhbnNpdGlvbkVuZCcsXG5cbiAgICBnZXRVSUQ6IGZ1bmN0aW9uIGdldFVJRChwcmVmaXgpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTsgLy8gXCJ+flwiIGFjdHMgbGlrZSBhIGZhc3RlciBNYXRoLmZsb29yKCkgaGVyZVxuICAgICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XG4gICAgICByZXR1cm4gcHJlZml4O1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudDogZnVuY3Rpb24gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKTtcbiAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgICAgICBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciAkc2VsZWN0b3IgPSAkKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuICRzZWxlY3Rvci5sZW5ndGggPiAwID8gc2VsZWN0b3IgOiBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfSxcbiAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCkge1xuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKHRyYW5zaXRpb24uZW5kKTtcbiAgICB9LFxuICAgIHN1cHBvcnRzVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odHJhbnNpdGlvbik7XG4gICAgfSxcbiAgICB0eXBlQ2hlY2tDb25maWc6IGZ1bmN0aW9uIHR5cGVDaGVja0NvbmZpZyhjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBjb25maWdUeXBlcykge1xuICAgICAgICBpZiAoY29uZmlnVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV07XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29uZmlnW3Byb3BlcnR5XTtcbiAgICAgICAgICB2YXIgdmFsdWVUeXBlID0gdmFsdWUgJiYgaXNFbGVtZW50KHZhbHVlKSA/ICdlbGVtZW50JyA6IHRvVHlwZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpICsgJzogJyArICgnT3B0aW9uIFwiJyArIHByb3BlcnR5ICsgJ1wiIHByb3ZpZGVkIHR5cGUgXCInICsgdmFsdWVUeXBlICsgJ1wiICcpICsgKCdidXQgZXhwZWN0ZWQgdHlwZSBcIicgKyBleHBlY3RlZFR5cGVzICsgJ1wiLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKTtcblxuICByZXR1cm4gVXRpbDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IGFsZXJ0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgQWxlcnQgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdhbGVydCc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuYWxlcnQnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwO1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBESVNNSVNTOiAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBDTE9TRTogJ2Nsb3NlJyArIEVWRU5UX0tFWSxcbiAgICBDTE9TRUQ6ICdjbG9zZWQnICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gIH07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBBTEVSVDogJ2FsZXJ0JyxcbiAgICBGQURFOiAnZmFkZScsXG4gICAgU0hPVzogJ3Nob3cnXG5cbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgfTtcbiAgdmFyIEFsZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsZXJ0KGVsZW1lbnQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbGVydCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgQWxlcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudDtcblxuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB2YXIgY3VzdG9tRXZlbnQgPSB0aGlzLl90cmlnZ2VyQ2xvc2VFdmVudChyb290RWxlbWVudCk7XG5cbiAgICAgIGlmIChjdXN0b21FdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIEFsZXJ0LnByb3RvdHlwZS5fZ2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdmFyIHBhcmVudCA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcGFyZW50ID0gJChzZWxlY3RvcilbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9ICQoZWxlbWVudCkuY2xvc2VzdCgnLicgKyBDbGFzc05hbWUuQUxFUlQpWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuX3RyaWdnZXJDbG9zZUV2ZW50ID0gZnVuY3Rpb24gX3RyaWdnZXJDbG9zZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBjbG9zZUV2ZW50ID0gJC5FdmVudChFdmVudC5DTE9TRSk7XG5cbiAgICAgICQoZWxlbWVudCkudHJpZ2dlcihjbG9zZUV2ZW50KTtcbiAgICAgIHJldHVybiBjbG9zZUV2ZW50O1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuX3JlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIGlmICghVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSB8fCAhJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgJChlbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQsIGV2ZW50KTtcbiAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pO1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuX2Rlc3Ryb3lFbGVtZW50ID0gZnVuY3Rpb24gX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICQoZWxlbWVudCkuZGV0YWNoKCkudHJpZ2dlcihFdmVudC5DTE9TRUQpLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBBbGVydCh0aGlzKTtcbiAgICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBBbGVydC5faGFuZGxlRGlzbWlzcyA9IGZ1bmN0aW9uIF9oYW5kbGVEaXNtaXNzKGFsZXJ0SW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFsZXJ0SW5zdGFuY2UuY2xvc2UodGhpcyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWxlcnQsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWxlcnQ7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuRElTTUlTUywgQWxlcnQuX2hhbmRsZURpc21pc3MobmV3IEFsZXJ0KCkpKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBBbGVydDtcbiAgJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgcmV0dXJuIEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIEFsZXJ0O1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogYnV0dG9uLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgQnV0dG9uID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAnYnV0dG9uJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYmV0YSc7XG4gIHZhciBEQVRBX0tFWSA9ICdicy5idXR0b24nO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBBQ1RJVkU6ICdhY3RpdmUnLFxuICAgIEJVVFRPTjogJ2J0bicsXG4gICAgRk9DVVM6ICdmb2N1cydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgREFUQV9UT0dHTEVfQ0FSUk9UOiAnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsXG4gICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyxcbiAgICBJTlBVVDogJ2lucHV0JyxcbiAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcbiAgICBCVVRUT046ICcuYnRuJ1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBDTElDS19EQVRBX0FQSTogJ2NsaWNrJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICBGT0NVU19CTFVSX0RBVEFfQVBJOiAnZm9jdXMnICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZICsgJyAnICsgKCdibHVyJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSlcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvbihlbGVtZW50KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcblxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gZ2V0dGVyc1xuXG4gICAgLy8gcHVibGljXG5cbiAgICBCdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIHZhciB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlO1xuICAgICAgdmFyIGFkZEFyaWFQcmVzc2VkID0gdHJ1ZTtcbiAgICAgIHZhciByb290RWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5EQVRBX1RPR0dMRSlbMF07XG5cbiAgICAgIGlmIChyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgaW5wdXQgPSAkKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuSU5QVVQpWzBdO1xuXG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAmJiAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5BQ1RJVkUpKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2VFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSAkKHJvb3RFbGVtZW50KS5maW5kKFNlbGVjdG9yLkFDVElWRSlbMF07XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAkKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpIHx8IHJvb3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dC5jaGVja2VkID0gISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICAgICAkKGlucHV0KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgIGFkZEFyaWFQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFkZEFyaWFQcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCAhJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQnV0dG9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBCdXR0b24uX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKEJ1dHRvbiwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCdXR0b247XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICghJChidXR0b24pLmhhc0NsYXNzKENsYXNzTmFtZS5CVVRUT04pKSB7XG4gICAgICBidXR0b24gPSAkKGJ1dHRvbikuY2xvc2VzdChTZWxlY3Rvci5CVVRUT04pO1xuICAgIH1cblxuICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChidXR0b24pLCAndG9nZ2xlJyk7XG4gIH0pLm9uKEV2ZW50LkZPQ1VTX0JMVVJfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFX0NBUlJPVCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yLkJVVFRPTilbMF07XG4gICAgJChidXR0b24pLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5GT0NVUywgL15mb2N1cyhpbik/JC8udGVzdChldmVudC50eXBlKSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBCdXR0b247XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gQnV0dG9uO1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogY2Fyb3VzZWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ2Nhcm91c2VsJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYmV0YSc7XG4gIHZhciBEQVRBX0tFWSA9ICdicy5jYXJvdXNlbCc7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbiAgdmFyIFRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDA7XG4gIHZhciBBUlJPV19MRUZUX0tFWUNPREUgPSAzNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgbGVmdCBhcnJvdyBrZXlcbiAgdmFyIEFSUk9XX1JJR0hUX0tFWUNPREUgPSAzOTsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgcmlnaHQgYXJyb3cga2V5XG4gIHZhciBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcblxuICB2YXIgRGVmYXVsdCA9IHtcbiAgICBpbnRlcnZhbDogNTAwMCxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzbGlkZTogZmFsc2UsXG4gICAgcGF1c2U6ICdob3ZlcicsXG4gICAgd3JhcDogdHJ1ZVxuICB9O1xuXG4gIHZhciBEZWZhdWx0VHlwZSA9IHtcbiAgICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gICAgc2xpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHdyYXA6ICdib29sZWFuJ1xuICB9O1xuXG4gIHZhciBEaXJlY3Rpb24gPSB7XG4gICAgTkVYVDogJ25leHQnLFxuICAgIFBSRVY6ICdwcmV2JyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgUklHSFQ6ICdyaWdodCdcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgU0xJREU6ICdzbGlkZScgKyBFVkVOVF9LRVksXG4gICAgU0xJRDogJ3NsaWQnICsgRVZFTlRfS0VZLFxuICAgIEtFWURPV046ICdrZXlkb3duJyArIEVWRU5UX0tFWSxcbiAgICBNT1VTRUVOVEVSOiAnbW91c2VlbnRlcicgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VMRUFWRTogJ21vdXNlbGVhdmUnICsgRVZFTlRfS0VZLFxuICAgIFRPVUNIRU5EOiAndG91Y2hlbmQnICsgRVZFTlRfS0VZLFxuICAgIExPQURfREFUQV9BUEk6ICdsb2FkJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICBDTElDS19EQVRBX0FQSTogJ2NsaWNrJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICB9O1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgQ0FST1VTRUw6ICdjYXJvdXNlbCcsXG4gICAgQUNUSVZFOiAnYWN0aXZlJyxcbiAgICBTTElERTogJ3NsaWRlJyxcbiAgICBSSUdIVDogJ2Nhcm91c2VsLWl0ZW0tcmlnaHQnLFxuICAgIExFRlQ6ICdjYXJvdXNlbC1pdGVtLWxlZnQnLFxuICAgIE5FWFQ6ICdjYXJvdXNlbC1pdGVtLW5leHQnLFxuICAgIFBSRVY6ICdjYXJvdXNlbC1pdGVtLXByZXYnLFxuICAgIElURU06ICdjYXJvdXNlbC1pdGVtJ1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcbiAgICBBQ1RJVkVfSVRFTTogJy5hY3RpdmUuY2Fyb3VzZWwtaXRlbScsXG4gICAgSVRFTTogJy5jYXJvdXNlbC1pdGVtJyxcbiAgICBORVhUX1BSRVY6ICcuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2JyxcbiAgICBJTkRJQ0FUT1JTOiAnLmNhcm91c2VsLWluZGljYXRvcnMnLFxuICAgIERBVEFfU0xJREU6ICdbZGF0YS1zbGlkZV0sIFtkYXRhLXNsaWRlLXRvXScsXG4gICAgREFUQV9SSURFOiAnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJ1xuXG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gIH07XG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXJvdXNlbChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbCk7XG5cbiAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gJChlbGVtZW50KVswXTtcbiAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLklORElDQVRPUlMpWzBdO1xuXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgdGhpcy5fc2xpZGUoRGlyZWN0aW9uLk5FWFQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUubmV4dFdoZW5WaXNpYmxlID0gZnVuY3Rpb24gbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gcHJldigpIHtcbiAgICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlKERpcmVjdGlvbi5QUkVWKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoZXZlbnQpIHtcbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLk5FWFRfUFJFVilbMF0gJiYgVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgICBVdGlsLnRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLmN5Y2xlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmN5Y2xlID0gZnVuY3Rpb24gY3ljbGUoZXZlbnQpIHtcbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuaW50ZXJ2YWwgJiYgIXRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKHRoaXMpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byhpbmRleCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSAkKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFX0lURU0pWzBdO1xuXG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7XG5cbiAgICAgIGlmIChpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShFdmVudC5TTElELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy50byhpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBEaXJlY3Rpb24uTkVYVCA6IERpcmVjdGlvbi5QUkVWO1xuXG4gICAgICB0aGlzLl9zbGlkZShkaXJlY3Rpb24sIHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSk7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IG51bGw7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5LRVlET1dOLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0Ll9rZXlkb3duKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5NT1VTRUVOVEVSLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnBhdXNlKGV2ZW50KTtcbiAgICAgICAgfSkub24oRXZlbnQuTU9VU0VMRUFWRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5jeWNsZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgLy8gaWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcbiAgICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LlRPVUNIRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQucGF1c2UoKTtcbiAgICAgICAgICAgIGlmIChfdGhpczQudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpczQudG91Y2hUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNC50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0LmN5Y2xlKGV2ZW50KTtcbiAgICAgICAgICAgIH0sIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyBfdGhpczQuX2NvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9rZXlkb3duID0gZnVuY3Rpb24gX2tleWRvd24oZXZlbnQpIHtcbiAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcbiAgICAgICAgY2FzZSBBUlJPV19MRUZUX0tFWUNPREU6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnByZXYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBUlJPV19SSUdIVF9LRVlDT0RFOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldEl0ZW1JbmRleCA9IGZ1bmN0aW9uIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgICAgdGhpcy5faXRlbXMgPSAkLm1ha2VBcnJheSgkKGVsZW1lbnQpLnBhcmVudCgpLmZpbmQoU2VsZWN0b3IuSVRFTSkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoZWxlbWVudCk7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0SXRlbUJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBpc05leHREaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5ORVhUO1xuICAgICAgdmFyIGlzUHJldkRpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlBSRVY7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XG4gICAgICB2YXIgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaXNHb2luZ1RvV3JhcCA9IGlzUHJldkRpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gMCB8fCBpc05leHREaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IGxhc3RJdGVtSW5kZXg7XG5cbiAgICAgIGlmIChpc0dvaW5nVG9XcmFwICYmICF0aGlzLl9jb25maWcud3JhcCkge1xuICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUFJFViA/IC0xIDogMTtcbiAgICAgIHZhciBpdGVtSW5kZXggPSAoYWN0aXZlSW5kZXggKyBkZWx0YSkgJSB0aGlzLl9pdGVtcy5sZW5ndGg7XG5cbiAgICAgIHJldHVybiBpdGVtSW5kZXggPT09IC0xID8gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV0gOiB0aGlzLl9pdGVtc1tpdGVtSW5kZXhdO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3RyaWdnZXJTbGlkZUV2ZW50ID0gZnVuY3Rpb24gX3RyaWdnZXJTbGlkZUV2ZW50KHJlbGF0ZWRUYXJnZXQsIGV2ZW50RGlyZWN0aW9uTmFtZSkge1xuICAgICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCgkKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFX0lURU0pWzBdKTtcbiAgICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5TTElERSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgICBkaXJlY3Rpb246IGV2ZW50RGlyZWN0aW9uTmFtZSxcbiAgICAgICAgZnJvbTogZnJvbUluZGV4LFxuICAgICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICAgIH0pO1xuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZGVFdmVudCk7XG5cbiAgICAgIHJldHVybiBzbGlkZUV2ZW50O1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQgPSBmdW5jdGlvbiBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgICAgJCh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkuZmluZChTZWxlY3Rvci5BQ1RJVkUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuXG4gICAgICAgIHZhciBuZXh0SW5kaWNhdG9yID0gdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQuY2hpbGRyZW5bdGhpcy5fZ2V0SXRlbUluZGV4KGVsZW1lbnQpXTtcblxuICAgICAgICBpZiAobmV4dEluZGljYXRvcikge1xuICAgICAgICAgICQobmV4dEluZGljYXRvcikuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zbGlkZSA9IGZ1bmN0aW9uIF9zbGlkZShkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgYWN0aXZlRWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuZmluZChTZWxlY3Rvci5BQ1RJVkVfSVRFTSlbMF07XG4gICAgICB2YXIgYWN0aXZlRWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBhY3RpdmVFbGVtZW50ICYmIHRoaXMuX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpO1xuICAgICAgdmFyIGlzQ3ljbGluZyA9IEJvb2xlYW4odGhpcy5faW50ZXJ2YWwpO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgb3JkZXJDbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgZXZlbnREaXJlY3Rpb25OYW1lID0gdm9pZCAwO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTkVYVCkge1xuICAgICAgICBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IENsYXNzTmFtZS5MRUZUO1xuICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5ORVhUO1xuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uTEVGVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLlJJR0hUO1xuICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5QUkVWO1xuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uUklHSFQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0RWxlbWVudCAmJiAkKG5leHRFbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSkge1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpO1xuICAgICAgaWYgKHNsaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XG4gICAgICAgIC8vIHNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KTtcblxuICAgICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0xJRCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICAgIGZyb206IGFjdGl2ZUVsZW1lbnRJbmRleCxcbiAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TTElERSkpIHtcblxuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhvcmRlckNsYXNzTmFtZSk7XG5cbiAgICAgICAgVXRpbC5yZWZsb3cobmV4dEVsZW1lbnQpO1xuXG4gICAgICAgICQoYWN0aXZlRWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG5cbiAgICAgICAgJChhY3RpdmVFbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQobmV4dEVsZW1lbnQpLnJlbW92ZUNsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lICsgJyAnICsgb3JkZXJDbGFzc05hbWUpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFICsgJyAnICsgb3JkZXJDbGFzc05hbWUgKyAnICcgKyBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG5cbiAgICAgICAgICBfdGhpczUuX2lzU2xpZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJChfdGhpczUuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZEV2ZW50KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcblxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgdmFyIF9jb25maWcgPSAkLmV4dGVuZCh7fSwgRGVmYXVsdCwgJCh0aGlzKS5kYXRhKCkpO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGNvbmZpZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZmlnKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgJC5leHRlbmQoX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGU7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbYWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBhY3Rpb24gKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVthY3Rpb25dKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnRlcnZhbCkge1xuICAgICAgICAgIGRhdGEucGF1c2UoKTtcbiAgICAgICAgICBkYXRhLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5fZGF0YUFwaUNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XG5cbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gJChzZWxlY3RvcilbMF07XG5cbiAgICAgIGlmICghdGFyZ2V0IHx8ICEkKHRhcmdldCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkNBUk9VU0VMKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25maWcgPSAkLmV4dGVuZCh7fSwgJCh0YXJnZXQpLmRhdGEoKSwgJCh0aGlzKS5kYXRhKCkpO1xuICAgICAgdmFyIHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGlkZS10bycpO1xuXG4gICAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnKTtcblxuICAgICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICAgJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpLnRvKHNsaWRlSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWwsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2Fyb3VzZWw7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9TTElERSwgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIpO1xuXG4gICQod2luZG93KS5vbihFdmVudC5MT0FEX0RBVEFfQVBJLCBmdW5jdGlvbiAoKSB7XG4gICAgJChTZWxlY3Rvci5EQVRBX1JJREUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRjYXJvdXNlbCA9ICQodGhpcyk7XG4gICAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQ2Fyb3VzZWw7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBDYXJvdXNlbDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdjb2xsYXBzZSc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuY29sbGFwc2UnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gNjAwO1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICBwYXJlbnQ6ICcnXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nLFxuICAgIHBhcmVudDogJ3N0cmluZydcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgU0hPVzogJ3Nob3cnICsgRVZFTlRfS0VZLFxuICAgIFNIT1dOOiAnc2hvd24nICsgRVZFTlRfS0VZLFxuICAgIEhJREU6ICdoaWRlJyArIEVWRU5UX0tFWSxcbiAgICBISURERU46ICdoaWRkZW4nICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gIH07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBTSE9XOiAnc2hvdycsXG4gICAgQ09MTEFQU0U6ICdjb2xsYXBzZScsXG4gICAgQ09MTEFQU0lORzogJ2NvbGxhcHNpbmcnLFxuICAgIENPTExBUFNFRDogJ2NvbGxhcHNlZCdcbiAgfTtcblxuICB2YXIgRGltZW5zaW9uID0ge1xuICAgIFdJRFRIOiAnd2lkdGgnLFxuICAgIEhFSUdIVDogJ2hlaWdodCdcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgQUNUSVZFUzogJy5zaG93LCAuY29sbGFwc2luZycsXG4gICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXSdcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sbGFwc2UoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGFwc2UpO1xuXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSAkLm1ha2VBcnJheSgkKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXSwnICsgKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMnICsgZWxlbWVudC5pZCArICdcIl0nKSkpO1xuICAgICAgdmFyIHRhYlRvZ2dsZXMgPSAkKFNlbGVjdG9yLkRBVEFfVE9HR0xFKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFiVG9nZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbSA9IHRhYlRvZ2dsZXNbaV07XG4gICAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKTtcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmICQoc2VsZWN0b3IpLmZpbHRlcihlbGVtZW50KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbDtcblxuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhY3RpdmVzID0gdm9pZCAwO1xuICAgICAgdmFyIGFjdGl2ZXNEYXRhID0gdm9pZCAwO1xuXG4gICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgIGFjdGl2ZXMgPSAkLm1ha2VBcnJheSgkKHRoaXMuX3BhcmVudCkuY2hpbGRyZW4oKS5jaGlsZHJlbihTZWxlY3Rvci5BQ1RJVkVTKSk7XG4gICAgICAgIGlmICghYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY3RpdmVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlcykge1xuICAgICAgICBhY3RpdmVzRGF0YSA9ICQoYWN0aXZlcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudC5TSE9XKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQoYWN0aXZlcyksICdoaWRlJyk7XG4gICAgICAgIGlmICghYWN0aXZlc0RhdGEpIHtcbiAgICAgICAgICAkKGFjdGl2ZXMpLmRhdGEoREFUQV9LRVksIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcblxuICAgICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgJCh0aGlzLl90cmlnZ2VyQXJyYXkpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTRUQpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgJChfdGhpczYuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKS5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgICBfdGhpczYuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuXG4gICAgICAgIF90aGlzNi5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcblxuICAgICAgICAkKF90aGlzNi5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5TSE9XTik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIVV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcbiAgICAgIHZhciBzY3JvbGxTaXplID0gJ3Njcm9sbCcgKyBjYXBpdGFsaXplZERpbWVuc2lvbjtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSB0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdICsgJ3B4JztcbiAgICB9O1xuXG4gICAgQ29sbGFwc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUpO1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHN0YXJ0RXZlbnQpO1xuICAgICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXSArICdweCc7XG5cbiAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJBcnJheVtpXTtcbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodHJpZ2dlcik7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmICghJGVsZW0uaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgICAgICAgICQodHJpZ2dlcikuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgX3RoaXM3LnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xuICAgICAgICAkKF90aGlzNy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNJTkcpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSkudHJpZ2dlcihFdmVudC5ISURERU4pO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG5cbiAgICAgIGlmICghVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICB9O1xuXG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnNldFRyYW5zaXRpb25pbmcgPSBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gaXNUcmFuc2l0aW9uaW5nO1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIGNvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gX2dldERpbWVuc2lvbigpIHtcbiAgICAgIHZhciBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRGltZW5zaW9uLldJRFRIKTtcbiAgICAgIHJldHVybiBoYXNXaWR0aCA/IERpbWVuc2lvbi5XSURUSCA6IERpbWVuc2lvbi5IRUlHSFQ7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0UGFyZW50ID0gZnVuY3Rpb24gX2dldFBhcmVudCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyZW50ID0gJCh0aGlzLl9jb25maWcucGFyZW50KVswXTtcbiAgICAgIHZhciBzZWxlY3RvciA9ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLl9jb25maWcucGFyZW50ICsgJ1wiXSc7XG5cbiAgICAgICQocGFyZW50KS5maW5kKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIF90aGlzOC5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSwgW2VsZW1lbnRdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZWxlbWVudCwgdHJpZ2dlckFycmF5KSB7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgaXNPcGVuID0gJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICAgaWYgKHRyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAkKHRyaWdnZXJBcnJheSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCwgIWlzT3BlbikuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3Blbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBDb2xsYXBzZS5fZ2V0VGFyZ2V0RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gJChzZWxlY3RvcilbMF0gOiBudWxsO1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCAkdGhpcy5kYXRhKCksICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSA9PT0gJ29iamVjdCcgJiYgY29uZmlnKTtcblxuICAgICAgICBpZiAoIWRhdGEgJiYgX2NvbmZpZy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJHRoaXMuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyArIGNvbmZpZyArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhDb2xsYXBzZSwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb2xsYXBzZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQoZG9jdW1lbnQpLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgJHRyaWdnZXIgPSAkKHRoaXMpO1xuICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcbiAgICAkKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKTtcbiAgICAgIHZhciBkYXRhID0gJHRhcmdldC5kYXRhKERBVEFfS0VZKTtcbiAgICAgIHZhciBjb25maWcgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKCk7XG4gICAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHRhcmdldCwgY29uZmlnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQ29sbGFwc2U7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBDb2xsYXBzZTtcbn0oalF1ZXJ5KTtcblxuLyogZ2xvYmFsIFBvcHBlciAqL1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogZHJvcGRvd24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBEcm9wZG93biA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBQb3BwZXIgZGVwZW5kZW5jeVxuICAgKiBQb3BwZXIgLSBodHRwczovL3BvcHBlci5qcy5vcmdcbiAgICovXG4gIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwIGRyb3Bkb3duIHJlcXVpcmUgUG9wcGVyLmpzIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAnZHJvcGRvd24nO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1iZXRhJztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLmRyb3Bkb3duJztcbiAgdmFyIEVWRU5UX0tFWSA9ICcuJyArIERBVEFfS0VZO1xuICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuICB2YXIgRVNDQVBFX0tFWUNPREUgPSAyNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuICB2YXIgU1BBQ0VfS0VZQ09ERSA9IDMyOyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBzcGFjZSBrZXlcbiAgdmFyIFRBQl9LRVlDT0RFID0gOTsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdGFiIGtleVxuICB2YXIgQVJST1dfVVBfS0VZQ09ERSA9IDM4OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB1cCBhcnJvdyBrZXlcbiAgdmFyIEFSUk9XX0RPV05fS0VZQ09ERSA9IDQwOyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBkb3duIGFycm93IGtleVxuICB2YXIgUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIID0gMzsgLy8gTW91c2VFdmVudC53aGljaCB2YWx1ZSBmb3IgdGhlIHJpZ2h0IGJ1dHRvbiAoYXNzdW1pbmcgYSByaWdodC1oYW5kZWQgbW91c2UpXG4gIHZhciBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoQVJST1dfVVBfS0VZQ09ERSArICd8JyArIEFSUk9XX0RPV05fS0VZQ09ERSArICd8JyArIEVTQ0FQRV9LRVlDT0RFKTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgSElERTogJ2hpZGUnICsgRVZFTlRfS0VZLFxuICAgIEhJRERFTjogJ2hpZGRlbicgKyBFVkVOVF9LRVksXG4gICAgU0hPVzogJ3Nob3cnICsgRVZFTlRfS0VZLFxuICAgIFNIT1dOOiAnc2hvd24nICsgRVZFTlRfS0VZLFxuICAgIENMSUNLOiAnY2xpY2snICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZLFxuICAgIEtFWURPV05fREFUQV9BUEk6ICdrZXlkb3duJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICBLRVlVUF9EQVRBX0FQSTogJ2tleXVwJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICB9O1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0hPVzogJ3Nob3cnLFxuICAgIERST1BVUDogJ2Ryb3B1cCcsXG4gICAgTUVOVVJJR0hUOiAnZHJvcGRvd24tbWVudS1yaWdodCcsXG4gICAgTUVOVUxFRlQ6ICdkcm9wZG93bi1tZW51LWxlZnQnXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLFxuICAgIEZPUk1fQ0hJTEQ6ICcuZHJvcGRvd24gZm9ybScsXG4gICAgTUVOVTogJy5kcm9wZG93bi1tZW51JyxcbiAgICBOQVZCQVJfTkFWOiAnLm5hdmJhci1uYXYnLFxuICAgIFZJU0lCTEVfSVRFTVM6ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKSdcbiAgfTtcblxuICB2YXIgQXR0YWNobWVudE1hcCA9IHtcbiAgICBUT1A6ICd0b3Atc3RhcnQnLFxuICAgIFRPUEVORDogJ3RvcC1lbmQnLFxuICAgIEJPVFRPTTogJ2JvdHRvbS1zdGFydCcsXG4gICAgQk9UVE9NRU5EOiAnYm90dG9tLWVuZCdcbiAgfTtcblxuICB2YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6IEF0dGFjaG1lbnRNYXAuQk9UVE9NLFxuICAgIG9mZnNldDogMCxcbiAgICBmbGlwOiB0cnVlXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIHBsYWNlbWVudDogJ3N0cmluZycsXG4gICAgb2Zmc2V0OiAnKG51bWJlcnxzdHJpbmcpJyxcbiAgICBmbGlwOiAnYm9vbGVhbidcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcGRvd24oZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpO1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcblxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgdmFyIGlzQWN0aXZlID0gJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIERyb3Bkb3duLl9jbGVhck1lbnVzKCk7XG5cbiAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICQocGFyZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XG5cbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAvLyBmb3IgZHJvcHVwIHdpdGggYWxpZ25tZW50IHdlIHVzZSB0aGUgcGFyZW50IGFzIHBvcHBlciBjb250YWluZXJcbiAgICAgIGlmICgkKHBhcmVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BVUCkpIHtcbiAgICAgICAgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLk1FTlVMRUZUKSB8fCAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICAgICAgZWxlbWVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcihlbGVtZW50LCB0aGlzLl9tZW51LCB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSk7XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkKHBhcmVudCkuY2xvc2VzdChTZWxlY3Rvci5OQVZCQVJfTkFWKS5sZW5ndGgpIHtcbiAgICAgICAgJCgnYm9keScpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG5cbiAgICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuICAgICAgJChwYXJlbnQpLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5TSE9XKS50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuU0hPV04sIHJlbGF0ZWRUYXJnZXQpKTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX21lbnUgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0ssIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgX3RoaXM5LnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIHZhciBlbGVtZW50RGF0YSA9ICQodGhpcy5fZWxlbWVudCkuZGF0YSgpO1xuICAgICAgaWYgKGVsZW1lbnREYXRhLnBsYWNlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnREYXRhLnBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXBbZWxlbWVudERhdGEucGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xuICAgICAgfVxuXG4gICAgICBjb25maWcgPSAkLmV4dGVuZCh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCAkKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSwgY29uZmlnKTtcblxuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9nZXRNZW51RWxlbWVudCA9IGZ1bmN0aW9uIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5fbWVudSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9tZW51ID0gJChwYXJlbnQpLmZpbmQoU2VsZWN0b3IuTUVOVSlbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbWVudTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9nZXRQbGFjZW1lbnQgPSBmdW5jdGlvbiBfZ2V0UGxhY2VtZW50KCkge1xuICAgICAgdmFyICRwYXJlbnREcm9wZG93biA9ICQodGhpcy5fZWxlbWVudCkucGFyZW50KCk7XG4gICAgICB2YXIgcGxhY2VtZW50ID0gdGhpcy5fY29uZmlnLnBsYWNlbWVudDtcblxuICAgICAgLy8gSGFuZGxlIGRyb3B1cFxuICAgICAgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUFVQKSB8fCB0aGlzLl9jb25maWcucGxhY2VtZW50ID09PSBBdHRhY2htZW50TWFwLlRPUCkge1xuICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUDtcbiAgICAgICAgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLk1FTlVSSUdIVCkpIHtcbiAgICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUEVORDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuQk9UVE9NRU5EO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9kZXRlY3ROYXZiYXIgPSBmdW5jdGlvbiBfZGV0ZWN0TmF2YmFyKCkge1xuICAgICAgcmV0dXJuICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdCgnLm5hdmJhcicpLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fZ2V0UG9wcGVyQ29uZmlnID0gZnVuY3Rpb24gX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICAgIHZhciBwb3BwZXJDb25maWcgPSB7XG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9jb25maWcub2Zmc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0aGlzLl9jb25maWcuZmxpcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGUgUG9wcGVyLmpzIGZvciBEcm9wZG93biBpbiBOYXZiYXJcbiAgICAgIH07aWYgKHRoaXMuX2luTmF2YmFyKSB7XG4gICAgICAgIHBvcHBlckNvbmZpZy5tb2RpZmllcnMuYXBwbHlTdHlsZSA9IHtcbiAgICAgICAgICBlbmFibGVkOiAhdGhpcy5faW5OYXZiYXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3BwZXJDb25maWc7XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24uX2NsZWFyTWVudXMgPSBmdW5jdGlvbiBfY2xlYXJNZW51cyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50ICYmIChldmVudC53aGljaCA9PT0gUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQud2hpY2ggIT09IFRBQl9LRVlDT0RFKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2dnbGVzID0gJC5tYWtlQXJyYXkoJChTZWxlY3Rvci5EQVRBX1RPR0dMRSkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2dnbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodG9nZ2xlc1tpXSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gJCh0b2dnbGVzW2ldKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogdG9nZ2xlc1tpXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyb3Bkb3duTWVudSA9IGNvbnRleHQuX21lbnU7XG4gICAgICAgIGlmICghJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQud2hpY2ggPT09IFRBQl9LRVlDT0RFKSAmJiAkLmNvbnRhaW5zKHBhcmVudCwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQuSElERSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgICQocGFyZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XG4gICAgICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAkKCdib2R5JykuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICQoZHJvcGRvd25NZW51KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG4gICAgICAgICQocGFyZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVykudHJpZ2dlcigkLkV2ZW50KEV2ZW50LkhJRERFTiwgcmVsYXRlZFRhcmdldCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHBhcmVudCA9ICQoc2VsZWN0b3IpWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50IHx8IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGlmICghUkVHRVhQX0tFWURPV04udGVzdChldmVudC53aGljaCkgfHwgL2J1dHRvbi9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpICYmIGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFIHx8IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAkKHRoaXMpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpO1xuICAgICAgdmFyIGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgaWYgKCFpc0FjdGl2ZSAmJiAoZXZlbnQud2hpY2ggIT09IEVTQ0FQRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoICE9PSBTUEFDRV9LRVlDT0RFKSB8fCBpc0FjdGl2ZSAmJiAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFKSkge1xuXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgICB2YXIgdG9nZ2xlID0gJChwYXJlbnQpLmZpbmQoU2VsZWN0b3IuREFUQV9UT0dHTEUpWzBdO1xuICAgICAgICAgICQodG9nZ2xlKS50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtcyA9ICQocGFyZW50KS5maW5kKFNlbGVjdG9yLlZJU0lCTEVfSVRFTVMpLmdldCgpO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KTtcblxuICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19VUF9LRVlDT0RFICYmIGluZGV4ID4gMCkge1xuICAgICAgICAvLyB1cFxuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEFSUk9XX0RPV05fS0VZQ09ERSAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gZG93blxuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaXRlbXNbaW5kZXhdLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhEcm9wZG93biwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHRUeXBlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERyb3Bkb3duO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJChkb2N1bWVudCkub24oRXZlbnQuS0VZRE9XTl9EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKEV2ZW50LktFWURPV05fREFUQV9BUEksIFNlbGVjdG9yLk1FTlUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJICsgJyAnICsgRXZlbnQuS0VZVVBfREFUQV9BUEksIERyb3Bkb3duLl9jbGVhck1lbnVzKS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICd0b2dnbGUnKTtcbiAgfSkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkZPUk1fQ0hJTEQsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gRHJvcGRvd247XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBEcm9wZG93bjtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IG1vZGFsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgTW9kYWwgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdtb2RhbCc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMubW9kYWwnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwO1xuICB2YXIgQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MDtcbiAgdmFyIEVTQ0FQRV9LRVlDT0RFID0gMjc7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcblxuICB2YXIgRGVmYXVsdCA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgICBmb2N1czogJ2Jvb2xlYW4nLFxuICAgIHNob3c6ICdib29sZWFuJ1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNJTjogJ2ZvY3VzaW4nICsgRVZFTlRfS0VZLFxuICAgIFJFU0laRTogJ3Jlc2l6ZScgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0tfRElTTUlTUzogJ2NsaWNrLmRpc21pc3MnICsgRVZFTlRfS0VZLFxuICAgIEtFWURPV05fRElTTUlTUzogJ2tleWRvd24uZGlzbWlzcycgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VVUF9ESVNNSVNTOiAnbW91c2V1cC5kaXNtaXNzJyArIEVWRU5UX0tFWSxcbiAgICBNT1VTRURPV05fRElTTUlTUzogJ21vdXNlZG93bi5kaXNtaXNzJyArIEVWRU5UX0tFWSxcbiAgICBDTElDS19EQVRBX0FQSTogJ2NsaWNrJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICB9O1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgU0NST0xMQkFSX01FQVNVUkVSOiAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnLFxuICAgIEJBQ0tEUk9QOiAnbW9kYWwtYmFja2Ryb3AnLFxuICAgIE9QRU46ICdtb2RhbC1vcGVuJyxcbiAgICBGQURFOiAnZmFkZScsXG4gICAgU0hPVzogJ3Nob3cnXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIERJQUxPRzogJy5tb2RhbC1kaWFsb2cnLFxuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLFxuICAgIERBVEFfRElTTUlTUzogJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsXG4gICAgRklYRURfQ09OVEVOVDogJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnLFxuICAgIE5BVkJBUl9UT0dHTEVSOiAnLm5hdmJhci10b2dnbGVyJ1xuXG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gIH07XG4gIHZhciBNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RhbChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbCk7XG5cbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9kaWFsb2cgPSAkKGVsZW1lbnQpLmZpbmQoU2VsZWN0b3IuRElBTE9HKVswXTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gMDtcbiAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gMDtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5faXNTaG93biB8fCBzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fY2hlY2tTY3JvbGxiYXIoKTtcbiAgICAgIHRoaXMuX3NldFNjcm9sbGJhcigpO1xuXG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKENsYXNzTmFtZS5PUEVOKTtcblxuICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcbiAgICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0tfRElTTUlTUywgU2VsZWN0b3IuREFUQV9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAuaGlkZShldmVudCk7XG4gICAgICB9KTtcblxuICAgICAgJCh0aGlzLl9kaWFsb2cpLm9uKEV2ZW50Lk1PVVNFRE9XTl9ESVNNSVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoX3RoaXMxMC5fZWxlbWVudCkub25lKEV2ZW50Lk1PVVNFVVBfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyhfdGhpczEwLl9lbGVtZW50KSkge1xuICAgICAgICAgICAgX3RoaXMxMC5faWdub3JlQmFja2Ryb3BDbGljayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb24gPSBVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFKTtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XG5cbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KCk7XG4gICAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpO1xuXG4gICAgICAkKGRvY3VtZW50KS5vZmYoRXZlbnQuRk9DVVNJTik7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudC5DTElDS19ESVNNSVNTKTtcbiAgICAgICQodGhpcy5fZGlhbG9nKS5vZmYoRXZlbnQuTU9VU0VET1dOX0RJU01JU1MpO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczExLl9oaWRlTW9kYWwoZXZlbnQpO1xuICAgICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpZGVNb2RhbCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICAkKHdpbmRvdywgZG9jdW1lbnQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2JhY2tkcm9wKS5vZmYoRVZFTlRfS0VZKTtcblxuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fZGlhbG9nID0gbnVsbDtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBudWxsO1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBudWxsO1xuICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IG51bGw7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiBoYW5kbGVVcGRhdGUoKSB7XG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgTW9kYWwucHJvdG90eXBlLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gJC5leHRlbmQoe30sIERlZmF1bHQsIGNvbmZpZyk7XG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2hvd0VsZW1lbnQgPSBmdW5jdGlvbiBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSk7XG5cbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPV04sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uQ29tcGxldGUgPSBmdW5jdGlvbiB0cmFuc2l0aW9uQ29tcGxldGUoKSB7XG4gICAgICAgIGlmIChfdGhpczEyLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgICBfdGhpczEyLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMxMi5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgICQoX3RoaXMxMi5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICQodGhpcy5fZGlhbG9nKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgdHJhbnNpdGlvbkNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2VuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICAgICQoZG9jdW1lbnQpLm9mZihFdmVudC5GT0NVU0lOKSAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbihFdmVudC5GT0NVU0lOLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiYgX3RoaXMxMy5fZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICEkKF90aGlzMTMuX2VsZW1lbnQpLmhhcyhldmVudC50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzMTMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0RXNjYXBlRXZlbnQgPSBmdW5jdGlvbiBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LktFWURPV05fRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzMTQuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LktFWURPV05fRElTTUlTUyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0UmVzaXplRXZlbnQgPSBmdW5jdGlvbiBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgICQod2luZG93KS5vbihFdmVudC5SRVNJWkUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczE1LmhhbmRsZVVwZGF0ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZihFdmVudC5SRVNJWkUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2hpZGVNb2RhbCA9IGZ1bmN0aW9uIF9oaWRlTW9kYWwoKSB7XG4gICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5PUEVOKTtcbiAgICAgICAgX3RoaXMxNi5fcmVzZXRBZGp1c3RtZW50cygpO1xuICAgICAgICBfdGhpczE2Ll9yZXNldFNjcm9sbGJhcigpO1xuICAgICAgICAkKF90aGlzMTYuX2VsZW1lbnQpLnRyaWdnZXIoRXZlbnQuSElEREVOKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX3JlbW92ZUJhY2tkcm9wID0gZnVuY3Rpb24gX3JlbW92ZUJhY2tkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wKSB7XG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2hvd0JhY2tkcm9wID0gZnVuY3Rpb24gX3Nob3dCYWNrZHJvcChjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMTcgPSB0aGlzO1xuXG4gICAgICB2YXIgYW5pbWF0ZSA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpID8gQ2xhc3NOYW1lLkZBREUgOiAnJztcblxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgIHZhciBkb0FuaW1hdGUgPSBVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmIGFuaW1hdGU7XG5cbiAgICAgICAgdGhpcy5fYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NOYW1lID0gQ2xhc3NOYW1lLkJBQ0tEUk9QO1xuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoYW5pbWF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcblxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LkNMSUNLX0RJU01JU1MsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczE3Ll9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgICBfdGhpczE3Ll9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzMTcuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIF90aGlzMTcuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMxNy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZG9BbmltYXRlKSB7XG4gICAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fYmFja2Ryb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRvQW5pbWF0ZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNhbGxiYWNrKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChCQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uIGNhbGxiYWNrUmVtb3ZlKCkge1xuICAgICAgICAgIF90aGlzMTcuX3JlbW92ZUJhY2tkcm9wKCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgICAgICQodGhpcy5fYmFja2Ryb3ApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFja1JlbW92ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2tSZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgICAvLyB0b2RvIChmYXQpOiB0aGVzZSBzaG91bGQgcHJvYmFibHkgYmUgcmVmYWN0b3JlZCBvdXQgb2YgbW9kYWwuanNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2FkanVzdERpYWxvZyA9IGZ1bmN0aW9uIF9hZGp1c3REaWFsb2coKSB7XG4gICAgICB2YXIgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBpZiAoIXRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuX3Njcm9sbGJhcldpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLl9yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2NoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gX2NoZWNrU2Nyb2xsYmFyKCkge1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IHRoaXMuX2dldFNjcm9sbGJhcldpZHRoKCk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gX3NldFNjcm9sbGJhcigpIHtcbiAgICAgIHZhciBfdGhpczE4ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICAgIC8vIE5vdGU6IERPTU5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0IHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSBvciAnJyBpZiBub3Qgc2V0XG4gICAgICAgIC8vICAgd2hpbGUgJChET01Ob2RlKS5jc3MoJ3BhZGRpbmctcmlnaHQnKSByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHZhbHVlIG9yIDAgaWYgbm90IHNldFxuXG4gICAgICAgIC8vIEFkanVzdCBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICAgICAgJChTZWxlY3Rvci5GSVhFRF9DT05URU5UKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgIHZhciBhY3R1YWxQYWRkaW5nID0gJChlbGVtZW50KVswXS5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYWRkaW5nID0gJChlbGVtZW50KS5jc3MoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgICAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBwYXJzZUZsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIF90aGlzMTguX3Njcm9sbGJhcldpZHRoICsgJ3B4Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkanVzdCBuYXZiYXItdG9nZ2xlciBtYXJnaW5cbiAgICAgICAgJChTZWxlY3Rvci5OQVZCQVJfVE9HR0xFUikuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYWN0dWFsTWFyZ2luID0gJChlbGVtZW50KVswXS5zdHlsZS5tYXJnaW5SaWdodDtcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZE1hcmdpbiA9ICQoZWxlbWVudCkuY3NzKCdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgICAkKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcsIGFjdHVhbE1hcmdpbikuY3NzKCdtYXJnaW4tcmlnaHQnLCBwYXJzZUZsb2F0KGNhbGN1bGF0ZWRNYXJnaW4pICsgX3RoaXMxOC5fc2Nyb2xsYmFyV2lkdGggKyAncHgnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRqdXN0IGJvZHkgcGFkZGluZ1xuICAgICAgICB2YXIgYWN0dWFsUGFkZGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICB2YXIgY2FsY3VsYXRlZFBhZGRpbmcgPSAkKCdib2R5JykuY3NzKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgICQoJ2JvZHknKS5kYXRhKCdwYWRkaW5nLXJpZ2h0JywgYWN0dWFsUGFkZGluZykuY3NzKCdwYWRkaW5nLXJpZ2h0JywgcGFyc2VGbG9hdChjYWxjdWxhdGVkUGFkZGluZykgKyB0aGlzLl9zY3JvbGxiYXJXaWR0aCArICdweCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX3Jlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gX3Jlc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgLy8gUmVzdG9yZSBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICAgICQoU2VsZWN0b3IuRklYRURfQ09OVEVOVCkuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWRkaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICQoZWxlbWVudCkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgcGFkZGluZykucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzdG9yZSBuYXZiYXItdG9nZ2xlciBtYXJnaW5cbiAgICAgICQoU2VsZWN0b3IuTkFWQkFSX1RPR0dMRVIpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBtYXJnaW4gPSAkKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcmdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0JywgbWFyZ2luKS5yZW1vdmVEYXRhKCdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYm9keSBwYWRkaW5nXG4gICAgICB2YXIgcGFkZGluZyA9ICQoJ2JvZHknKS5kYXRhKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICBpZiAodHlwZW9mIHBhZGRpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICQoJ2JvZHknKS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBwYWRkaW5nKS5yZW1vdmVEYXRhKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fZ2V0U2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAvLyB0aHggZC53YWxzaFxuICAgICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IENsYXNzTmFtZS5TQ1JPTExCQVJfTUVBU1VSRVI7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgTW9kYWwuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5EZWZhdWx0LCAkKHRoaXMpLmRhdGEoKSwgKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyAmJiBjb25maWcpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgTW9kYWwodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uZmlnLnNob3cpIHtcbiAgICAgICAgICBkYXRhLnNob3cocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoTW9kYWwsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTW9kYWw7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpczE5ID0gdGhpcztcblxuICAgIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB0YXJnZXQgPSAkKHNlbGVjdG9yKVswXTtcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0gJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7fSwgJCh0YXJnZXQpLmRhdGEoKSwgJCh0aGlzKS5kYXRhKCkpO1xuXG4gICAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ0EnIHx8IHRoaXMudGFnTmFtZSA9PT0gJ0FSRUEnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciAkdGFyZ2V0ID0gJCh0YXJnZXQpLm9uZShFdmVudC5TSE9XLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAkdGFyZ2V0Lm9uZShFdmVudC5ISURERU4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCQoX3RoaXMxOSkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICBfdGhpczE5LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTW9kYWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnLCB0aGlzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gTW9kYWw7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBNb2RhbDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IHNjcm9sbHNweS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIFNjcm9sbFNweSA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ3Njcm9sbHNweSc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuc2Nyb2xsc3B5JztcbiAgdmFyIEVWRU5UX0tFWSA9ICcuJyArIERBVEFfS0VZO1xuICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIG9mZnNldDogMTAsXG4gICAgbWV0aG9kOiAnYXV0bycsXG4gICAgdGFyZ2V0OiAnJ1xuICB9O1xuXG4gIHZhciBEZWZhdWx0VHlwZSA9IHtcbiAgICBvZmZzZXQ6ICdudW1iZXInLFxuICAgIG1ldGhvZDogJ3N0cmluZycsXG4gICAgdGFyZ2V0OiAnKHN0cmluZ3xlbGVtZW50KSdcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgQUNUSVZBVEU6ICdhY3RpdmF0ZScgKyBFVkVOVF9LRVksXG4gICAgU0NST0xMOiAnc2Nyb2xsJyArIEVWRU5UX0tFWSxcbiAgICBMT0FEX0RBVEFfQVBJOiAnbG9hZCcgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIERST1BET1dOX0lURU06ICdkcm9wZG93bi1pdGVtJyxcbiAgICBEUk9QRE9XTl9NRU5VOiAnZHJvcGRvd24tbWVudScsXG4gICAgQUNUSVZFOiAnYWN0aXZlJ1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBEQVRBX1NQWTogJ1tkYXRhLXNweT1cInNjcm9sbFwiXScsXG4gICAgQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgTkFWX0xJU1RfR1JPVVA6ICcubmF2LCAubGlzdC1ncm91cCcsXG4gICAgTkFWX0xJTktTOiAnLm5hdi1saW5rJyxcbiAgICBMSVNUX0lURU1TOiAnLmxpc3QtZ3JvdXAtaXRlbScsXG4gICAgRFJPUERPV046ICcuZHJvcGRvd24nLFxuICAgIERST1BET1dOX0lURU1TOiAnLmRyb3Bkb3duLWl0ZW0nLFxuICAgIERST1BET1dOX1RPR0dMRTogJy5kcm9wZG93bi10b2dnbGUnXG4gIH07XG5cbiAgdmFyIE9mZnNldE1ldGhvZCA9IHtcbiAgICBPRkZTRVQ6ICdvZmZzZXQnLFxuICAgIFBPU0lUSU9OOiAncG9zaXRpb24nXG5cbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgfTtcbiAgdmFyIFNjcm9sbFNweSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMyMCA9IHRoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGxTcHkpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBlbGVtZW50LnRhZ05hbWUgPT09ICdCT0RZJyA/IHdpbmRvdyA6IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX3NlbGVjdG9yID0gdGhpcy5fY29uZmlnLnRhcmdldCArICcgJyArIFNlbGVjdG9yLk5BVl9MSU5LUyArICcsJyArICh0aGlzLl9jb25maWcudGFyZ2V0ICsgJyAnICsgU2VsZWN0b3IuTElTVF9JVEVNUyArICcsJykgKyAodGhpcy5fY29uZmlnLnRhcmdldCArICcgJyArIFNlbGVjdG9yLkRST1BET1dOX0lURU1TKTtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xuXG4gICAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKEV2ZW50LlNDUk9MTCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIwLl9wcm9jZXNzKGV2ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMyMSA9IHRoaXM7XG5cbiAgICAgIHZhciBhdXRvTWV0aG9kID0gdGhpcy5fc2Nyb2xsRWxlbWVudCAhPT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBPZmZzZXRNZXRob2QuUE9TSVRJT04gOiBPZmZzZXRNZXRob2QuT0ZGU0VUO1xuXG4gICAgICB2YXIgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2Q7XG5cbiAgICAgIHZhciBvZmZzZXRCYXNlID0gb2Zmc2V0TWV0aG9kID09PSBPZmZzZXRNZXRob2QuUE9TSVRJT04gPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG5cbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcblxuICAgICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG5cbiAgICAgIHZhciB0YXJnZXRzID0gJC5tYWtlQXJyYXkoJCh0aGlzLl9zZWxlY3RvcikpO1xuXG4gICAgICB0YXJnZXRzLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICB2YXIgdGFyZ2V0U2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFNlbGVjdG9yKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gJCh0YXJnZXRTZWxlY3RvcilbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIHRhcmdldEJDUiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAodGFyZ2V0QkNSLndpZHRoIHx8IHRhcmdldEJDUi5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gKGZhdCk6IHJlbW92ZSBza2V0Y2ggcmVsaWFuY2Ugb24galF1ZXJ5IHBvc2l0aW9uL29mZnNldFxuICAgICAgICAgICAgcmV0dXJuIFskKHRhcmdldClbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsIHRhcmdldFNlbGVjdG9yXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgX3RoaXMyMS5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xuICAgICAgICBfdGhpczIxLl90YXJnZXRzLnB1c2goaXRlbVsxXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG4gICAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9mZihFVkVOVF9LRVkpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX3NlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBudWxsO1xuICAgICAgdGhpcy5fdGFyZ2V0cyA9IG51bGw7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpZCA9ICQoY29uZmlnLnRhcmdldCkuYXR0cignaWQnKTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgIGlkID0gVXRpbC5nZXRVSUQoTkFNRSk7XG4gICAgICAgICAgJChjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcudGFyZ2V0ID0gJyMnICsgaWQ7XG4gICAgICB9XG5cbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpO1xuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICBTY3JvbGxTcHkucHJvdG90eXBlLl9nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcbiAgICB9O1xuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCk7XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX2dldE9mZnNldEhlaWdodCA9IGZ1bmN0aW9uIF9nZXRPZmZzZXRIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiBfcHJvY2VzcygpIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQ7XG4gICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG4gICAgICB2YXIgbWF4U2Nyb2xsID0gdGhpcy5fY29uZmlnLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuX2dldE9mZnNldEhlaWdodCgpO1xuXG4gICAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1swXSAmJiB0aGlzLl9vZmZzZXRzWzBdID4gMCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiYgc2Nyb2xsVG9wID49IHRoaXMuX29mZnNldHNbaV0gJiYgKHRoaXMuX29mZnNldHNbaSArIDFdID09PSB1bmRlZmluZWQgfHwgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1tpICsgMV0pO1xuXG4gICAgICAgIGlmIChpc0FjdGl2ZVRhcmdldCkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX2FjdGl2YXRlID0gZnVuY3Rpb24gX2FjdGl2YXRlKHRhcmdldCkge1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgICB2YXIgcXVlcmllcyA9IHRoaXMuX3NlbGVjdG9yLnNwbGl0KCcsJyk7XG4gICAgICBxdWVyaWVzID0gcXVlcmllcy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvciArICdbZGF0YS10YXJnZXQ9XCInICsgdGFyZ2V0ICsgJ1wiXSwnICsgKHNlbGVjdG9yICsgJ1tocmVmPVwiJyArIHRhcmdldCArICdcIl0nKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgJGxpbmsgPSAkKHF1ZXJpZXMuam9pbignLCcpKTtcblxuICAgICAgaWYgKCRsaW5rLmhhc0NsYXNzKENsYXNzTmFtZS5EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgICAkbGluay5jbG9zZXN0KFNlbGVjdG9yLkRST1BET1dOKS5maW5kKFNlbGVjdG9yLkRST1BET1dOX1RPR0dMRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICRsaW5rLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxuICAgICAgICAkbGluay5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxuICAgICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgICAgJGxpbmsucGFyZW50cyhTZWxlY3Rvci5OQVZfTElTVF9HUk9VUCkucHJldihTZWxlY3Rvci5OQVZfTElOS1MgKyAnLCAnICsgU2VsZWN0b3IuTElTVF9JVEVNUykuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fc2Nyb2xsRWxlbWVudCkudHJpZ2dlcihFdmVudC5BQ1RJVkFURSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTY3JvbGxTcHkucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uIF9jbGVhcigpIHtcbiAgICAgICQodGhpcy5fc2VsZWN0b3IpLmZpbHRlcihTZWxlY3Rvci5BQ1RJVkUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyAmJiBjb25maWc7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFNjcm9sbFNweSwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTY3JvbGxTcHk7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKHdpbmRvdykub24oRXZlbnQuTE9BRF9EQVRBX0FQSSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY3JvbGxTcHlzID0gJC5tYWtlQXJyYXkoJChTZWxlY3Rvci5EQVRBX1NQWSkpO1xuXG4gICAgZm9yICh2YXIgaSA9IHNjcm9sbFNweXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgJHNweSA9ICQoc2Nyb2xsU3B5c1tpXSk7XG4gICAgICBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRzcHksICRzcHkuZGF0YSgpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBTY3JvbGxTcHk7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsU3B5O1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgVGFiID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAndGFiJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYmV0YSc7XG4gIHZhciBEQVRBX0tFWSA9ICdicy50YWInO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwO1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0tfREFUQV9BUEk6ICdjbGljaycgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIERST1BET1dOX01FTlU6ICdkcm9wZG93bi1tZW51JyxcbiAgICBBQ1RJVkU6ICdhY3RpdmUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEZBREU6ICdmYWRlJyxcbiAgICBTSE9XOiAnc2hvdydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgRFJPUERPV046ICcuZHJvcGRvd24nLFxuICAgIE5BVl9MSVNUX0dST1VQOiAnLm5hdiwgLmxpc3QtZ3JvdXAnLFxuICAgIEFDVElWRTogJy5hY3RpdmUnLFxuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS10b2dnbGU9XCJsaXN0XCJdJyxcbiAgICBEUk9QRE9XTl9UT0dHTEU6ICcuZHJvcGRvd24tdG9nZ2xlJyxcbiAgICBEUk9QRE9XTl9BQ1RJVkVfQ0hJTEQ6ICc+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnXG5cbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgfTtcbiAgdmFyIFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWIoZWxlbWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYik7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgVGFiLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpczIyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91cyA9IHZvaWQgMDtcbiAgICAgIHZhciBsaXN0RWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5OQVZfTElTVF9HUk9VUClbMF07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIGlmIChsaXN0RWxlbWVudCkge1xuICAgICAgICBwcmV2aW91cyA9ICQubWFrZUFycmF5KCQobGlzdEVsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFKSk7XG4gICAgICAgIHByZXZpb3VzID0gcHJldmlvdXNbcHJldmlvdXMubGVuZ3RoIC0gMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgJChwcmV2aW91cykudHJpZ2dlcihoaWRlRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcblxuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdGFyZ2V0ID0gJChzZWxlY3RvcilbMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX2VsZW1lbnQsIGxpc3RFbGVtZW50KTtcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIHZhciBoaWRkZW5FdmVudCA9ICQuRXZlbnQoRXZlbnQuSElEREVOLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogX3RoaXMyMi5fZWxlbWVudFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPV04sIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgICB9KTtcblxuICAgICAgICAkKHByZXZpb3VzKS50cmlnZ2VyKGhpZGRlbkV2ZW50KTtcbiAgICAgICAgJChfdGhpczIyLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlLCBjb21wbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUYWIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBUYWIucHJvdG90eXBlLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uIF9hY3RpdmF0ZShlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyMyA9IHRoaXM7XG5cbiAgICAgIHZhciBhY3RpdmUgPSAkKGNvbnRhaW5lcikuZmluZChTZWxlY3Rvci5BQ1RJVkUpWzBdO1xuICAgICAgdmFyIGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgYWN0aXZlICYmICQoYWN0aXZlKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSk7XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyMy5fdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgaXNUcmFuc2l0aW9uaW5nLCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAkKGFjdGl2ZSkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgJChhY3RpdmUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFiLnByb3RvdHlwZS5fdHJhbnNpdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGlzVHJhbnNpdGlvbmluZywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgJChhY3RpdmUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuXG4gICAgICAgIHZhciBkcm9wZG93bkNoaWxkID0gJChhY3RpdmUucGFyZW50Tm9kZSkuZmluZChTZWxlY3Rvci5EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQpWzBdO1xuXG4gICAgICAgIGlmIChkcm9wZG93bkNoaWxkKSB7XG4gICAgICAgICAgJChkcm9wZG93bkNoaWxkKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGl2ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICBpZiAoaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIFV0aWwucmVmbG93KGVsZW1lbnQpO1xuICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkZBREUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmICQoZWxlbWVudC5wYXJlbnROb2RlKS5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUERPV05fTUVOVSkpIHtcblxuICAgICAgICB2YXIgZHJvcGRvd25FbGVtZW50ID0gJChlbGVtZW50KS5jbG9zZXN0KFNlbGVjdG9yLkRST1BET1dOKVswXTtcbiAgICAgICAgaWYgKGRyb3Bkb3duRWxlbWVudCkge1xuICAgICAgICAgICQoZHJvcGRvd25FbGVtZW50KS5maW5kKFNlbGVjdG9yLkRST1BET1dOX1RPR0dMRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkdGhpcy5kYXRhKERBVEFfS0VZKTtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IFRhYih0aGlzKTtcbiAgICAgICAgICAkdGhpcy5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFRhYiwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUYWI7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgVGFiLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRoaXMpLCAnc2hvdycpO1xuICB9KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IFRhYi5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVGFiO1xuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICByZXR1cm4gVGFiLl9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIFRhYjtcbn0oalF1ZXJ5KTtcblxuLyogZ2xvYmFsIFBvcHBlciAqL1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogdG9vbHRpcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgUG9wcGVyIGRlcGVuZGVuY3lcbiAgICogUG9wcGVyIC0gaHR0cHM6Ly9wb3BwZXIuanMub3JnXG4gICAqL1xuICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcCB0b29sdGlwcyByZXF1aXJlIFBvcHBlci5qcyAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ3Rvb2x0aXAnO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1iZXRhJztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLnRvb2x0aXAnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuICB2YXIgVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MDtcbiAgdmFyIENMQVNTX1BSRUZJWCA9ICdicy10b29sdGlwJztcbiAgdmFyIEJTQ0xTX1BSRUZJWF9SRUdFWCA9IG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBDTEFTU19QUkVGSVggKyAnXFxcXFMrJywgJ2cnKTtcblxuICB2YXIgRGVmYXVsdFR5cGUgPSB7XG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gICAgdGVtcGxhdGU6ICdzdHJpbmcnLFxuICAgIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gICAgdHJpZ2dlcjogJ3N0cmluZycsXG4gICAgZGVsYXk6ICcobnVtYmVyfG9iamVjdCknLFxuICAgIGh0bWw6ICdib29sZWFuJyxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBvZmZzZXQ6ICcobnVtYmVyfHN0cmluZyknLFxuICAgIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gICAgZmFsbGJhY2tQbGFjZW1lbnQ6ICcoc3RyaW5nfGFycmF5KSdcbiAgfTtcblxuICB2YXIgQXR0YWNobWVudE1hcCA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgVE9QOiAndG9wJyxcbiAgICBSSUdIVDogJ3JpZ2h0JyxcbiAgICBCT1RUT006ICdib3R0b20nLFxuICAgIExFRlQ6ICdsZWZ0J1xuICB9O1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIG9mZnNldDogMCxcbiAgICBjb250YWluZXI6IGZhbHNlLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50OiAnZmxpcCdcbiAgfTtcblxuICB2YXIgSG92ZXJTdGF0ZSA9IHtcbiAgICBTSE9XOiAnc2hvdycsXG4gICAgT1VUOiAnb3V0J1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgSU5TRVJURUQ6ICdpbnNlcnRlZCcgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0s6ICdjbGljaycgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNJTjogJ2ZvY3VzaW4nICsgRVZFTlRfS0VZLFxuICAgIEZPQ1VTT1VUOiAnZm9jdXNvdXQnICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFRU5URVI6ICdtb3VzZWVudGVyJyArIEVWRU5UX0tFWSxcbiAgICBNT1VTRUxFQVZFOiAnbW91c2VsZWF2ZScgKyBFVkVOVF9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIEZBREU6ICdmYWRlJyxcbiAgICBTSE9XOiAnc2hvdydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgVE9PTFRJUDogJy50b29sdGlwJyxcbiAgICBUT09MVElQX0lOTkVSOiAnLnRvb2x0aXAtaW5uZXInLFxuICAgIEFSUk9XOiAnLmFycm93J1xuICB9O1xuXG4gIHZhciBUcmlnZ2VyID0ge1xuICAgIEhPVkVSOiAnaG92ZXInLFxuICAgIEZPQ1VTOiAnZm9jdXMnLFxuICAgIENMSUNLOiAnY2xpY2snLFxuICAgIE1BTlVBTDogJ21hbnVhbCdcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xuXG4gICAgICAvLyBwcml2YXRlXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fdGltZW91dCA9IDA7XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gJyc7XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuXG4gICAgICAvLyBwcm90ZWN0ZWRcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiB0b2dnbGVFbmFibGVkKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuICAgICAgICB2YXIgY29udGV4dCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KTtcblxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuXG4gICAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XG4gICAgICAkKHRoaXMuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub2ZmKCdoaWRlLmJzLm1vZGFsJyk7XG5cbiAgICAgIGlmICh0aGlzLnRpcCkge1xuICAgICAgICAkKHRoaXMudGlwKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNFbmFibGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLnRpcCA9IG51bGw7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzMjQgPSB0aGlzO1xuXG4gICAgICBpZiAoJCh0aGlzLmVsZW1lbnQpLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO1xuICAgICAgaWYgKHRoaXMuaXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICAgIHZhciBpc0luVGhlRG9tID0gJC5jb250YWlucyh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaXNJblRoZURvbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICAgICAgdmFyIHRpcElkID0gVXRpbC5nZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcblxuICAgICAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcElkKTtcblxuICAgICAgICB0aGlzLnNldENvbnRlbnQoKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5GQURFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5jb25maWcucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID8gdGhpcy5jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLmVsZW1lbnQpIDogdGhpcy5jb25maWcucGxhY2VtZW50O1xuXG4gICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5fZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpO1xuICAgICAgICB0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KTtcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiAkKHRoaXMuY29uZmlnLmNvbnRhaW5lcik7XG5cbiAgICAgICAgJCh0aXApLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy50aXApKSB7XG4gICAgICAgICAgJCh0aXApLmFwcGVuZFRvKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKTtcblxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBuZXcgUG9wcGVyKHRoaXMuZWxlbWVudCwgdGlwLCB7XG4gICAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgIG9mZnNldDogdGhpcy5jb25maWcub2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxpcDoge1xuICAgICAgICAgICAgICBiZWhhdmlvcjogdGhpcy5jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcnJvdzoge1xuICAgICAgICAgICAgICBlbGVtZW50OiBTZWxlY3Rvci5BUlJPV1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLm9yaWdpbmFsUGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgICBfdGhpczI0Ll9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMyNC5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgJCgnYm9keScpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyNC5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBfdGhpczI0Ll9maXhUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IF90aGlzMjQuX2hvdmVyU3RhdGU7XG4gICAgICAgICAgX3RoaXMyNC5faG92ZXJTdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAkKF90aGlzMjQuZWxlbWVudCkudHJpZ2dlcihfdGhpczI0LmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKTtcblxuICAgICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICAgIF90aGlzMjQuX2xlYXZlKG51bGwsIF90aGlzMjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMudGlwKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgICAkKHRoaXMudGlwKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuX1RSQU5TSVRJT05fRFVSQVRJT04pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczI1ID0gdGhpcztcblxuICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKTtcbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBpZiAoX3RoaXMyNS5faG92ZXJTdGF0ZSAhPT0gSG92ZXJTdGF0ZS5TSE9XICYmIHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMjUuX2NsZWFuVGlwQ2xhc3MoKTtcbiAgICAgICAgX3RoaXMyNS5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuICAgICAgICAkKF90aGlzMjUuZWxlbWVudCkudHJpZ2dlcihfdGhpczI1LmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XG4gICAgICAgIGlmIChfdGhpczI1Ll9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczI1Ll9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAkKCdib2R5JykuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5DTElDS10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5GT0NVU10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5IT1ZFUl0gPSBmYWxzZTtcblxuICAgICAgaWYgKFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG5cbiAgICAgICAgJCh0aXApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gJyc7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByb3RlY3RlZFxuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaXNXaXRoQ29udGVudCA9IGZ1bmN0aW9uIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldFRpdGxlKCkpO1xuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5hZGRBdHRhY2htZW50Q2xhc3MgPSBmdW5jdGlvbiBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgICAgJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoQ0xBU1NfUFJFRklYICsgJy0nICsgYXR0YWNobWVudCk7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmdldFRpcEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRUaXBFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlwID0gdGhpcy50aXAgfHwgJCh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF07XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50KCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNlbGVjdG9yLlRPT0xUSVBfSU5ORVIpLCB0aGlzLmdldFRpdGxlKCkpO1xuICAgICAgJHRpcC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSArICcgJyArIENsYXNzTmFtZS5TSE9XKTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuc2V0RWxlbWVudENvbnRlbnQgPSBmdW5jdGlvbiBzZXRFbGVtZW50Q29udGVudCgkZWxlbWVudCwgY29udGVudCkge1xuICAgICAgdmFyIGh0bWwgPSB0aGlzLmNvbmZpZy5odG1sO1xuICAgICAgaWYgKCh0eXBlb2YgY29udGVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29udGVudCkpID09PSAnb2JqZWN0JyAmJiAoY29udGVudC5ub2RlVHlwZSB8fCBjb250ZW50LmpxdWVyeSkpIHtcbiAgICAgICAgLy8gY29udGVudCBpcyBhIERPTSBub2RlIG9yIGEgalF1ZXJ5XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaWYgKCEkKGNvbnRlbnQpLnBhcmVudCgpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICAgJGVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRlbGVtZW50LnRleHQoJChjb250ZW50KS50ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWxlbWVudFtodG1sID8gJ2h0bWwnIDogJ3RleHQnXShjb250ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHZhciB0aXRsZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKTtcblxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICB0aXRsZSA9IHR5cGVvZiB0aGlzLmNvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLnRpdGxlLmNhbGwodGhpcy5lbGVtZW50KSA6IHRoaXMuY29uZmlnLnRpdGxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGl0bGU7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9nZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9zZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfc2V0TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMjYgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLmNvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XG5cbiAgICAgIHRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAkKF90aGlzMjYuZWxlbWVudCkub24oX3RoaXMyNi5jb25zdHJ1Y3Rvci5FdmVudC5DTElDSywgX3RoaXMyNi5jb25maWcuc2VsZWN0b3IsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMjYudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUcmlnZ2VyLk1BTlVBTCkge1xuICAgICAgICAgIHZhciBldmVudEluID0gdHJpZ2dlciA9PT0gVHJpZ2dlci5IT1ZFUiA/IF90aGlzMjYuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IF90aGlzMjYuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTjtcbiAgICAgICAgICB2YXIgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUcmlnZ2VyLkhPVkVSID8gX3RoaXMyNi5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogX3RoaXMyNi5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcblxuICAgICAgICAgICQoX3RoaXMyNi5lbGVtZW50KS5vbihldmVudEluLCBfdGhpczI2LmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5fZW50ZXIoZXZlbnQpO1xuICAgICAgICAgIH0pLm9uKGV2ZW50T3V0LCBfdGhpczI2LmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5fbGVhdmUoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgJChfdGhpczI2LmVsZW1lbnQpLmNsb3Nlc3QoJy5tb2RhbCcpLm9uKCdoaWRlLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczI2LmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gJC5leHRlbmQoe30sIHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgICAgc2VsZWN0b3I6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZml4VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2ZpeFRpdGxlID0gZnVuY3Rpb24gX2ZpeFRpdGxlKCkge1xuICAgICAgdmFyIHRpdGxlVHlwZSA9IF90eXBlb2YodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpKTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgJycpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsICcnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2VudGVyID0gZnVuY3Rpb24gX2VudGVyKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgICB2YXIgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XG5cbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KTtcblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUcmlnZ2VyLkZPQ1VTIDogVHJpZ2dlci5IT1ZFUl0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJChjb250ZXh0LmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpIHx8IGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuU0hPVykge1xuICAgICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5TSE9XO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KTtcblxuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhvdmVyU3RhdGUuU0hPVztcblxuICAgICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLlNIT1cpIHtcbiAgICAgICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuc2hvdyk7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9sZWF2ZSA9IGZ1bmN0aW9uIF9sZWF2ZShldmVudCwgY29udGV4dCkge1xuICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRyaWdnZXIuRk9DVVMgOiBUcmlnZ2VyLkhPVkVSXSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuXG4gICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5PVVQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpIHtcbiAgICAgICAgY29udGV4dC5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICBjb250ZXh0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSk7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyID0gZnVuY3Rpb24gX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgICBmb3IgKHZhciB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gJC5leHRlbmQoe30sIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCwgJCh0aGlzLmVsZW1lbnQpLmRhdGEoKSwgY29uZmlnKTtcblxuICAgICAgaWYgKGNvbmZpZy5kZWxheSAmJiB0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxuICAgICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLnRpdGxlICYmIHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmNvbnRlbnQgJiYgdHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9nZXREZWxlZ2F0ZUNvbmZpZyA9IGZ1bmN0aW9uIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdGhpcy5jb25maWdba2V5XSkge1xuICAgICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLmNvbmZpZ1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5fY2xlYW5UaXBDbGFzcyA9IGZ1bmN0aW9uIF9jbGVhblRpcENsYXNzKCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgIHZhciB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpO1xuICAgICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UgPSBmdW5jdGlvbiBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpIHtcbiAgICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKTtcbiAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQoZGF0YS5wbGFjZW1lbnQpKTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2ZpeFRyYW5zaXRpb24gPSBmdW5jdGlvbiBfZml4VHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICAgIHZhciBpbml0Q29uZmlnQW5pbWF0aW9uID0gdGhpcy5jb25maWcuYW5pbWF0aW9uO1xuICAgICAgaWYgKHRpcC5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgJCh0aXApLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5GQURFKTtcbiAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGluaXRDb25maWdBbmltYXRpb247XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyAmJiBjb25maWc7XG5cbiAgICAgICAgaWYgKCFkYXRhICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBjb25maWcgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ05BTUUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBOQU1FO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RBVEFfS0VZJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gREFUQV9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRXZlbnQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFdmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdFVkVOVF9LRVknLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFVkVOVF9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRGVmYXVsdFR5cGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVG9vbHRpcDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVG9vbHRpcDtcbiAgJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgcmV0dXJuIFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IHBvcG92ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBQb3BvdmVyID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAncG9wb3Zlcic7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMucG9wb3Zlcic7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBDTEFTU19QUkVGSVggPSAnYnMtcG9wb3Zlcic7XG4gIHZhciBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgQ0xBU1NfUFJFRklYICsgJ1xcXFxTKycsICdnJyk7XG5cbiAgdmFyIERlZmF1bHQgPSAkLmV4dGVuZCh7fSwgVG9vbHRpcC5EZWZhdWx0LCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj48L2Rpdj4nXG4gIH0pO1xuXG4gIHZhciBEZWZhdWx0VHlwZSA9ICQuZXh0ZW5kKHt9LCBUb29sdGlwLkRlZmF1bHRUeXBlLCB7XG4gICAgY29udGVudDogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG4gIH0pO1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgRkFERTogJ2ZhZGUnLFxuICAgIFNIT1c6ICdzaG93J1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBUSVRMRTogJy5wb3BvdmVyLWhlYWRlcicsXG4gICAgQ09OVEVOVDogJy5wb3BvdmVyLWJvZHknXG4gIH07XG5cbiAgdmFyIEV2ZW50ID0ge1xuICAgIEhJREU6ICdoaWRlJyArIEVWRU5UX0tFWSxcbiAgICBISURERU46ICdoaWRkZW4nICsgRVZFTlRfS0VZLFxuICAgIFNIT1c6ICdzaG93JyArIEVWRU5UX0tFWSxcbiAgICBTSE9XTjogJ3Nob3duJyArIEVWRU5UX0tFWSxcbiAgICBJTlNFUlRFRDogJ2luc2VydGVkJyArIEVWRU5UX0tFWSxcbiAgICBDTElDSzogJ2NsaWNrJyArIEVWRU5UX0tFWSxcbiAgICBGT0NVU0lOOiAnZm9jdXNpbicgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNPVVQ6ICdmb2N1c291dCcgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VFTlRFUjogJ21vdXNlZW50ZXInICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFTEVBVkU6ICdtb3VzZWxlYXZlJyArIEVWRU5UX0tFWVxuXG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gIH07XG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKF9Ub29sdGlwKSB7XG4gICAgX2luaGVyaXRzKFBvcG92ZXIsIF9Ub29sdGlwKTtcblxuICAgIGZ1bmN0aW9uIFBvcG92ZXIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wb3Zlcik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVG9vbHRpcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZXNcblxuICAgIFBvcG92ZXIucHJvdG90eXBlLmlzV2l0aENvbnRlbnQgPSBmdW5jdGlvbiBpc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gICAgfTtcblxuICAgIFBvcG92ZXIucHJvdG90eXBlLmFkZEF0dGFjaG1lbnRDbGFzcyA9IGZ1bmN0aW9uIGFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XG4gICAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhDTEFTU19QUkVGSVggKyAnLScgKyBhdHRhY2htZW50KTtcbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQoKSB7XG4gICAgICB2YXIgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpO1xuXG4gICAgICAvLyB3ZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5USVRMRSksIHRoaXMuZ2V0VGl0bGUoKSk7XG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5DT05URU5UKSwgdGhpcy5fZ2V0Q29udGVudCgpKTtcblxuICAgICAgJHRpcC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSArICcgJyArIENsYXNzTmFtZS5TSE9XKTtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2dldENvbnRlbnQgPSBmdW5jdGlvbiBfZ2V0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRlbnQnKSB8fCAodHlwZW9mIHRoaXMuY29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy5jb250ZW50LmNhbGwodGhpcy5lbGVtZW50KSA6IHRoaXMuY29uZmlnLmNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fY2xlYW5UaXBDbGFzcyA9IGZ1bmN0aW9uIF9jbGVhblRpcENsYXNzKCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgIHZhciB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpO1xuICAgICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFkYXRhICYmIC9kZXN0cm95fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgUG9wb3Zlcih0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBjb25maWcgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoUG9wb3ZlciwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuXG5cbiAgICAgIC8vIGdldHRlcnNcblxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ05BTUUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBOQU1FO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RBVEFfS0VZJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gREFUQV9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRXZlbnQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFdmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdFVkVOVF9LRVknLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFVkVOVF9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRGVmYXVsdFR5cGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUG9wb3ZlcjtcbiAgfShUb29sdGlwKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZTtcbiAgJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFBvcG92ZXI7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIFBvcG92ZXI7XG59KGpRdWVyeSk7XG5cblxufSkoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9ib290c3RyYXAuanMiLCIhIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImpxdWVyeVwiXSwgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gdChlKVxuICAgIH0pIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSB0KHJlcXVpcmUoXCJqcXVlcnlcIikpIDogdChlLmpRdWVyeSlcbn0odGhpcywgZnVuY3Rpb24oZSkge1xuICAgICEgZnVuY3Rpb24oZSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICBmdW5jdGlvbiB0KHQpIHtcbiAgICAgICAgICAgIHZhciBpID0gW3tcbiAgICAgICAgICAgICAgICByZTogL1tcXHhDMC1cXHhDNl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJBXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhFMC1cXHhFNl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJhXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhDOC1cXHhDQl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJFXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhFOC1cXHhFQl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJlXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhDQy1cXHhDRl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJJXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhFQy1cXHhFRl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJpXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhEMi1cXHhENl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJPXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhGMi1cXHhGNl0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJvXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhEOS1cXHhEQ10vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJVXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhGOS1cXHhGQ10vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJ1XCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhDNy1cXHhFN10vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJjXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhEMV0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJOXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL1tcXHhGMV0vZyxcbiAgICAgICAgICAgICAgICBjaDogXCJuXCJcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcmV0dXJuIGUuZWFjaChpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0ID0gdCA/IHQucmVwbGFjZSh0aGlzLnJlLCB0aGlzLmNoKSA6IFwiXCJcbiAgICAgICAgICAgIH0pLCB0XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIG4gPSB0O1xuICAgICAgICAgICAgW10uc2hpZnQuYXBwbHkoaSk7XG4gICAgICAgICAgICB2YXIgcywgbyA9IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHQuaXMoXCJzZWxlY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0LmRhdGEoXCJzZWxlY3RwaWNrZXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gXCJvYmplY3RcIiA9PSB0eXBlb2YgbiAmJiBuO1xuICAgICAgICAgICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCBpbiBhKSBhLmhhc093blByb3BlcnR5KGwpICYmIChvLm9wdGlvbnNbbF0gPSBhW2xdKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLmV4dGVuZCh7fSwgaC5ERUZBVUxUUywgZS5mbi5zZWxlY3RwaWNrZXIuZGVmYXVsdHMgfHwge30sIHQuZGF0YSgpLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIudGVtcGxhdGUgPSBlLmV4dGVuZCh7fSwgaC5ERUZBVUxUUy50ZW1wbGF0ZSwgZS5mbi5zZWxlY3RwaWNrZXIuZGVmYXVsdHMgPyBlLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cy50ZW1wbGF0ZSA6IHt9LCB0LmRhdGEoKS50ZW1wbGF0ZSwgYS50ZW1wbGF0ZSksIHQuZGF0YShcInNlbGVjdHBpY2tlclwiLCBvID0gbmV3IGgodGhpcywgcikpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiAmJiAocyA9IG9bbl0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IG9bbl0uYXBwbHkobywgaSkgOiBvLm9wdGlvbnNbbl0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgcyA/IHMgOiBvXG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyB8fCAhIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB7fS50b1N0cmluZyxcbiAgICAgICAgICAgICAgICB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHQoZSwgZSwgZSkgJiYgdFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChuKSB7fVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgICAgIH0oKSxcbiAgICAgICAgICAgICAgICBpID0gXCJcIi5pbmRleE9mLFxuICAgICAgICAgICAgICAgIG4gPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IHRoaXMpIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBcIltvYmplY3QgUmVnRXhwXVwiID09IGUuY2FsbCh0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBTdHJpbmcodCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gby5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gbCA/IE51bWJlcihsKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHIgIT0gciAmJiAociA9IDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IE1hdGgubWluKE1hdGgubWF4KHIsIDApLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBkID4gcyA/ICExIDogLTEgIT0gaS5jYWxsKG4sIG8sIHIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHQgPyB0KFN0cmluZy5wcm90b3R5cGUsIFwiaW5jbHVkZXNcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgICB9KSA6IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMgPSBuXG4gICAgICAgIH0oKSwgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoIHx8ICEgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0KGUsIGUsIGUpICYmIHRcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAobikge31cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICB9KCksXG4gICAgICAgICAgICAgICAgdCA9IHt9LnRvU3RyaW5nLFxuICAgICAgICAgICAgICAgIGkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IHRoaXMpIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBcIltvYmplY3QgUmVnRXhwXVwiID09IHQuY2FsbChlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBTdHJpbmcoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gYSA/IE51bWJlcihhKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGwgIT0gbCAmJiAobCA9IDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGgubWluKE1hdGgubWF4KGwsIDApLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gKyByID4gbikgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gLTE7ICsrZCA8IG87KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuY2hhckNvZGVBdChyICsgZCkgIT0gcy5jaGFyQ29kZUF0KGQpKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlID8gZShTdHJpbmcucHJvdG90eXBlLCBcInN0YXJ0c1dpdGhcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgICB9KSA6IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGlcbiAgICAgICAgfSgpLCBPYmplY3Qua2V5cyB8fCAoT2JqZWN0LmtleXMgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICBpID0gW107XG4gICAgICAgICAgICBmb3IgKHQgaW4gZSkgaS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpICYmIGkucHVzaCh0KTtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgIHVzZURlZmF1bHQ6ICExLFxuICAgICAgICAgICAgX3NldDogZS52YWxIb29rcy5zZWxlY3Quc2V0XG4gICAgICAgIH07XG4gICAgICAgIGUudmFsSG9va3Muc2VsZWN0LnNldCA9IGZ1bmN0aW9uKHQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpICYmICFuLnVzZURlZmF1bHQgJiYgZSh0KS5kYXRhKFwic2VsZWN0ZWRcIiwgITApLCBuLl9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcyA9IG51bGw7XG4gICAgICAgIGUuZm4udHJpZ2dlck5hdGl2ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXNbMF07XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoZSlcbiAgICAgICAgfSwgZS5leHByLnBzZXVkb3MuaWNvbnRhaW5zID0gZnVuY3Rpb24odCwgaSwgbikge1xuICAgICAgICAgICAgdmFyIHMgPSBlKHQpLmZpbmQoXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIiksXG4gICAgICAgICAgICAgICAgbyA9IChzLmRhdGEoXCJ0b2tlbnNcIikgfHwgcy50ZXh0KCkpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBvLmluY2x1ZGVzKG5bM10udG9VcHBlckNhc2UoKSlcbiAgICAgICAgfSwgZS5leHByLnBzZXVkb3MuaWJlZ2lucyA9IGZ1bmN0aW9uKHQsIGksIG4pIHtcbiAgICAgICAgICAgIHZhciBzID0gZSh0KS5maW5kKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLFxuICAgICAgICAgICAgICAgIG8gPSAocy5kYXRhKFwidG9rZW5zXCIpIHx8IHMudGV4dCgpKS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gby5zdGFydHNXaXRoKG5bM10udG9VcHBlckNhc2UoKSlcbiAgICAgICAgfSwgZS5leHByLnBzZXVkb3MuYWljb250YWlucyA9IGZ1bmN0aW9uKHQsIGksIG4pIHtcbiAgICAgICAgICAgIHZhciBzID0gZSh0KS5maW5kKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLFxuICAgICAgICAgICAgICAgIG8gPSAocy5kYXRhKFwidG9rZW5zXCIpIHx8IHMuZGF0YShcIm5vcm1hbGl6ZWRUZXh0XCIpIHx8IHMudGV4dCgpKS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gby5pbmNsdWRlcyhuWzNdLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgIH0sIGUuZXhwci5wc2V1ZG9zLmFpYmVnaW5zID0gZnVuY3Rpb24odCwgaSwgbikge1xuICAgICAgICAgICAgdmFyIHMgPSBlKHQpLmZpbmQoXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIiksXG4gICAgICAgICAgICAgICAgbyA9IChzLmRhdGEoXCJ0b2tlbnNcIikgfHwgcy5kYXRhKFwibm9ybWFsaXplZFRleHRcIikgfHwgcy50ZXh0KCkpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBvLnN0YXJ0c1dpdGgoblszXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgICAgICAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgICAgICAgICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICAgICAgICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgICAgICAgICAgICBcIidcIjogXCImI3gyNztcIixcbiAgICAgICAgICAgICAgICBcImBcIjogXCImI3g2MDtcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGEgPSB7XG4gICAgICAgICAgICAgICAgXCImYW1wO1wiOiBcIiZcIixcbiAgICAgICAgICAgICAgICBcIiZsdDtcIjogXCI8XCIsXG4gICAgICAgICAgICAgICAgXCImZ3Q7XCI6IFwiPlwiLFxuICAgICAgICAgICAgICAgIFwiJnF1b3Q7XCI6ICdcIicsXG4gICAgICAgICAgICAgICAgXCImI3gyNztcIjogXCInXCIsXG4gICAgICAgICAgICAgICAgXCImI3g2MDtcIjogXCJgXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVbdF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IFwiKD86XCIgKyBPYmplY3Qua2V5cyhlKS5qb2luKFwifFwiKSArIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICBuID0gUmVnRXhwKGkpLFxuICAgICAgICAgICAgICAgICAgICBzID0gUmVnRXhwKGksIFwiZ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9IG51bGwgPT0gZSA/IFwiXCIgOiBcIlwiICsgZSwgbi50ZXN0KGUpID8gZS5yZXBsYWNlKHMsIHQpIDogZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByID0gbChvKSxcbiAgICAgICAgICAgIGQgPSBsKGEpLFxuICAgICAgICAgICAgaCA9IGZ1bmN0aW9uKHQsIGkpIHtcbiAgICAgICAgICAgICAgICBuLnVzZURlZmF1bHQgfHwgKGUudmFsSG9va3Muc2VsZWN0LnNldCA9IG4uX3NldCwgbi51c2VEZWZhdWx0ID0gITApLCB0aGlzLiRlbGVtZW50ID0gZSh0KSwgdGhpcy4kbmV3RWxlbWVudCA9IG51bGwsIHRoaXMuJGJ1dHRvbiA9IG51bGwsIHRoaXMuJG1lbnUgPSBudWxsLCB0aGlzLiRsaXMgPSBudWxsLCB0aGlzLm9wdGlvbnMgPSBpLCBudWxsID09PSB0aGlzLm9wdGlvbnMudGl0bGUgJiYgKHRoaXMub3B0aW9ucy50aXRsZSA9IHRoaXMuJGVsZW1lbnQuYXR0cihcInRpdGxlXCIpKTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMub3B0aW9ucy53aW5kb3dQYWRkaW5nO1xuICAgICAgICAgICAgICAgIFwibnVtYmVyXCIgPT0gdHlwZW9mIHMgJiYgKHRoaXMub3B0aW9ucy53aW5kb3dQYWRkaW5nID0gW3MsIHMsIHMsIHNdKSwgdGhpcy52YWwgPSBoLnByb3RvdHlwZS52YWwsIHRoaXMucmVuZGVyID0gaC5wcm90b3R5cGUucmVuZGVyLCB0aGlzLnJlZnJlc2ggPSBoLnByb3RvdHlwZS5yZWZyZXNoLCB0aGlzLnNldFN0eWxlID0gaC5wcm90b3R5cGUuc2V0U3R5bGUsIHRoaXMuc2VsZWN0QWxsID0gaC5wcm90b3R5cGUuc2VsZWN0QWxsLCB0aGlzLmRlc2VsZWN0QWxsID0gaC5wcm90b3R5cGUuZGVzZWxlY3RBbGwsIHRoaXMuZGVzdHJveSA9IGgucHJvdG90eXBlLmRlc3Ryb3ksIHRoaXMucmVtb3ZlID0gaC5wcm90b3R5cGUucmVtb3ZlLCB0aGlzLnNob3cgPSBoLnByb3RvdHlwZS5zaG93LCB0aGlzLmhpZGUgPSBoLnByb3RvdHlwZS5oaWRlLCB0aGlzLmluaXQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgaC5WRVJTSU9OID0gXCIxLjEyLjJcIiwgaC5ERUZBVUxUUyA9IHtcbiAgICAgICAgICAgIG5vbmVTZWxlY3RlZFRleHQ6IFwiTm90aGluZyBzZWxlY3RlZFwiLFxuICAgICAgICAgICAgbm9uZVJlc3VsdHNUZXh0OiBcIk5vIHJlc3VsdHMgbWF0Y2hlZCB7MH1cIixcbiAgICAgICAgICAgIGNvdW50U2VsZWN0ZWRUZXh0OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgPT0gZSA/IFwiezB9IGl0ZW0gc2VsZWN0ZWRcIiA6IFwiezB9IGl0ZW1zIHNlbGVjdGVkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhPcHRpb25zVGV4dDogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMSA9PSBlID8gXCJMaW1pdCByZWFjaGVkICh7bn0gaXRlbSBtYXgpXCIgOiBcIkxpbWl0IHJlYWNoZWQgKHtufSBpdGVtcyBtYXgpXCIsIDEgPT0gdCA/IFwiR3JvdXAgbGltaXQgcmVhY2hlZCAoe259IGl0ZW0gbWF4KVwiIDogXCJHcm91cCBsaW1pdCByZWFjaGVkICh7bn0gaXRlbXMgbWF4KVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdEFsbFRleHQ6IFwiU2VsZWN0IEFsbFwiLFxuICAgICAgICAgICAgZGVzZWxlY3RBbGxUZXh0OiBcIkRlc2VsZWN0IEFsbFwiLFxuICAgICAgICAgICAgZG9uZUJ1dHRvbjogITEsXG4gICAgICAgICAgICBkb25lQnV0dG9uVGV4dDogXCJDbG9zZVwiLFxuICAgICAgICAgICAgbXVsdGlwbGVTZXBhcmF0b3I6IFwiLCBcIixcbiAgICAgICAgICAgIHN0eWxlQmFzZTogXCJidG5cIixcbiAgICAgICAgICAgIHN0eWxlOiBcImJ0bi1kZWZhdWx0IGJ0bi1saWdodFwiLFxuICAgICAgICAgICAgc2l6ZTogXCJhdXRvXCIsXG4gICAgICAgICAgICB0aXRsZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGVkVGV4dEZvcm1hdDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgIHdpZHRoOiAhMSxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogITEsXG4gICAgICAgICAgICBoaWRlRGlzYWJsZWQ6ICExLFxuICAgICAgICAgICAgc2hvd1N1YnRleHQ6ICExLFxuICAgICAgICAgICAgc2hvd0ljb246ICEwLFxuICAgICAgICAgICAgc2hvd0NvbnRlbnQ6ICEwLFxuICAgICAgICAgICAgZHJvcHVwQXV0bzogITAsXG4gICAgICAgICAgICBoZWFkZXI6ICExLFxuICAgICAgICAgICAgbGl2ZVNlYXJjaDogITEsXG4gICAgICAgICAgICBsaXZlU2VhcmNoUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgICAgICAgICBsaXZlU2VhcmNoTm9ybWFsaXplOiAhMSxcbiAgICAgICAgICAgIGxpdmVTZWFyY2hTdHlsZTogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgYWN0aW9uc0JveDogITEsXG4gICAgICAgICAgICBpY29uQmFzZTogXCJmYVwiLFxuICAgICAgICAgICAgdGlja0ljb246IFwiZmEtY2hlY2tcIixcbiAgICAgICAgICAgIHNob3dUaWNrOiAhMSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgICAgICAgICAgY2FyZXQ6ICc8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhPcHRpb25zOiAhMSxcbiAgICAgICAgICAgIG1vYmlsZTogITEsXG4gICAgICAgICAgICBzZWxlY3RPblRhYjogITEsXG4gICAgICAgICAgICBkcm9wZG93bkFsaWduUmlnaHQ6ICExLFxuICAgICAgICAgICAgd2luZG93UGFkZGluZzogMFxuICAgICAgICB9LCBoLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBoLFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy4kZWxlbWVudC5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcImJzLXNlbGVjdC1oaWRkZW5cIiksIHRoaXMubGlPYmogPSB7fSwgdGhpcy5tdWx0aXBsZSA9IHRoaXMuJGVsZW1lbnQucHJvcChcIm11bHRpcGxlXCIpLCB0aGlzLmF1dG9mb2N1cyA9IHRoaXMuJGVsZW1lbnQucHJvcChcImF1dG9mb2N1c1wiKSwgdGhpcy4kbmV3RWxlbWVudCA9IHRoaXMuY3JlYXRlVmlldygpLCB0aGlzLiRlbGVtZW50LmFmdGVyKHRoaXMuJG5ld0VsZW1lbnQpLmFwcGVuZFRvKHRoaXMuJG5ld0VsZW1lbnQpLCB0aGlzLiRidXR0b24gPSB0aGlzLiRuZXdFbGVtZW50LmNoaWxkcmVuKFwiYnV0dG9uXCIpLCB0aGlzLiRtZW51ID0gdGhpcy4kbmV3RWxlbWVudC5jaGlsZHJlbihcIi5kcm9wZG93bi1tZW51XCIpLCB0aGlzLiRtZW51SW5uZXIgPSB0aGlzLiRtZW51LmNoaWxkcmVuKFwiLmlubmVyXCIpLCB0aGlzLiRzZWFyY2hib3ggPSB0aGlzLiRtZW51LmZpbmQoXCJpbnB1dFwiKSwgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImJzLXNlbGVjdC1oaWRkZW5cIiksIHRoaXMub3B0aW9ucy5kcm9wZG93bkFsaWduUmlnaHQgPT09ICEwICYmIHRoaXMuJG1lbnUuYWRkQ2xhc3MoXCJkcm9wZG93bi1tZW51LXJpZ2h0XCIpLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBpICYmICh0aGlzLiRidXR0b24uYXR0cihcImRhdGEtaWRcIiwgaSksIGUoJ2xhYmVsW2Zvcj1cIicgKyBpICsgJ1wiXScpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0LiRidXR0b24uZm9jdXMoKVxuICAgICAgICAgICAgICAgIH0pKSwgdGhpcy5jaGVja0Rpc2FibGVkKCksIHRoaXMuY2xpY2tMaXN0ZW5lcigpLCB0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCAmJiB0aGlzLmxpdmVTZWFyY2hMaXN0ZW5lcigpLCB0aGlzLnJlbmRlcigpLCB0aGlzLnNldFN0eWxlKCksIHRoaXMuc2V0V2lkdGgoKSwgdGhpcy5vcHRpb25zLmNvbnRhaW5lciAmJiB0aGlzLnNlbGVjdFBvc2l0aW9uKCksIHRoaXMuJG1lbnUuZGF0YShcInRoaXNcIiwgdGhpcyksIHRoaXMuJG5ld0VsZW1lbnQuZGF0YShcInRoaXNcIiwgdGhpcyksIHRoaXMub3B0aW9ucy5tb2JpbGUgJiYgdGhpcy5tb2JpbGUoKSwgdGhpcy4kbmV3RWxlbWVudC5vbih7XG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZS5icy5kcm9wZG93blwiOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LiRtZW51SW5uZXIuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgITEpLCB0LiRlbGVtZW50LnRyaWdnZXIoXCJoaWRlLmJzLnNlbGVjdFwiLCBlKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImhpZGRlbi5icy5kcm9wZG93blwiOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LiRlbGVtZW50LnRyaWdnZXIoXCJoaWRkZW4uYnMuc2VsZWN0XCIsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic2hvdy5icy5kcm9wZG93blwiOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LiRtZW51SW5uZXIuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgITApLCB0LiRlbGVtZW50LnRyaWdnZXIoXCJzaG93LmJzLnNlbGVjdFwiLCBlKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcInNob3duLmJzLmRyb3Bkb3duXCI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuJGVsZW1lbnQudHJpZ2dlcihcInNob3duLmJzLnNlbGVjdFwiLCBlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIHQuJGVsZW1lbnRbMF0uaGFzQXR0cmlidXRlKFwicmVxdWlyZWRcIikgJiYgdGhpcy4kZWxlbWVudC5vbihcImludmFsaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHQuJGJ1dHRvbi5hZGRDbGFzcyhcImJzLWludmFsaWRcIikuZm9jdXMoKSwgdC4kZWxlbWVudC5vbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZvY3VzLmJzLnNlbGVjdFwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LiRidXR0b24uZm9jdXMoKSwgdC4kZWxlbWVudC5vZmYoXCJmb2N1cy5icy5zZWxlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNob3duLmJzLnNlbGVjdFwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LiRlbGVtZW50LnZhbCh0LiRlbGVtZW50LnZhbCgpKS5vZmYoXCJzaG93bi5icy5zZWxlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlbmRlcmVkLmJzLnNlbGVjdFwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkaXR5LnZhbGlkICYmIHQuJGJ1dHRvbi5yZW1vdmVDbGFzcyhcImJzLWludmFsaWRcIiksIHQuJGVsZW1lbnQub2ZmKFwicmVuZGVyZWQuYnMuc2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHQuJGVsZW1lbnQudHJpZ2dlcihcImxvYWRlZC5icy5zZWxlY3RcIilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyZWF0ZURyb3Bkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMubXVsdGlwbGUgfHwgdGhpcy5vcHRpb25zLnNob3dUaWNrID8gXCIgc2hvdy10aWNrXCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcyhcImlucHV0LWdyb3VwXCIpID8gXCIgaW5wdXQtZ3JvdXAtYnRuXCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5hdXRvZm9jdXMgPyBcIiBhdXRvZm9jdXNcIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLm9wdGlvbnMuaGVhZGVyID8gJzxkaXYgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCI+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L2J1dHRvbj4nICsgdGhpcy5vcHRpb25zLmhlYWRlciArIFwiPC9kaXY+XCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBvID0gdGhpcy5vcHRpb25zLmxpdmVTZWFyY2ggPyAnPGRpdiBjbGFzcz1cImJzLXNlYXJjaGJveFwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCInICsgKG51bGwgPT09IHRoaXMub3B0aW9ucy5saXZlU2VhcmNoUGxhY2Vob2xkZXIgPyBcIlwiIDogJyBwbGFjZWhvbGRlcj1cIicgKyByKHRoaXMub3B0aW9ucy5saXZlU2VhcmNoUGxhY2Vob2xkZXIpICsgJ1wiJykgKyAnIHJvbGU9XCJ0ZXh0Ym94XCIgYXJpYS1sYWJlbD1cIlNlYXJjaFwiPjwvZGl2PicgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5tdWx0aXBsZSAmJiB0aGlzLm9wdGlvbnMuYWN0aW9uc0JveCA/ICc8ZGl2IGNsYXNzPVwiYnMtYWN0aW9uc2JveFwiPjxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWdyb3VwLXNtIGJ0bi1ibG9ja1wiPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYWN0aW9ucy1idG4gYnMtc2VsZWN0LWFsbCBidG4gYnRuLWRlZmF1bHQgYnRuLWxpZ2h0XCI+JyArIHRoaXMub3B0aW9ucy5zZWxlY3RBbGxUZXh0ICsgJzwvYnV0dG9uPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYWN0aW9ucy1idG4gYnMtZGVzZWxlY3QtYWxsIGJ0biBidG4tZGVmYXVsdCBidG4tbGlnaHRcIj4nICsgdGhpcy5vcHRpb25zLmRlc2VsZWN0QWxsVGV4dCArIFwiPC9idXR0b24+PC9kaXY+PC9kaXY+XCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy5tdWx0aXBsZSAmJiB0aGlzLm9wdGlvbnMuZG9uZUJ1dHRvbiA/ICc8ZGl2IGNsYXNzPVwiYnMtZG9uZWJ1dHRvblwiPjxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWJsb2NrXCI+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0IGJ0bi1saWdodFwiPicgKyB0aGlzLm9wdGlvbnMuZG9uZUJ1dHRvblRleHQgKyBcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlwiIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZCA9ICc8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGJvb3RzdHJhcC1zZWxlY3QnICsgdCArIGkgKyAnXCI+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLnN0eWxlQmFzZSArICcgZHJvcGRvd24tdG9nZ2xlXCIgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiJyArIG4gKyAnIHJvbGU9XCJidXR0b25cIj48c3BhbiBjbGFzcz1cImZpbHRlci1vcHRpb24gcHVsbC1sZWZ0XCI+PC9zcGFuPiZuYnNwOzxzcGFuIGNsYXNzPVwiYnMtY2FyZXRcIj4nICsgdGhpcy5vcHRpb25zLnRlbXBsYXRlLmNhcmV0ICsgJzwvc3Bhbj48L2J1dHRvbj48ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBvcGVuXCIgcm9sZT1cImNvbWJvYm94XCI+JyArIHMgKyBvICsgYSArICc8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBpbm5lclwiIHJvbGU9XCJsaXN0Ym94XCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+PC9kaXY+JyArIGwgKyBcIjwvZGl2PjwvZGl2PlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBlKGQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNyZWF0ZURyb3Bkb3duKCksXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0aGlzLmNyZWF0ZUxpKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZmluZChcImRpdi5pbm5lclwiKVswXS5pbm5lckhUTUwgPSB0LCBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsb2FkTGk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5jcmVhdGVMaSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJG1lbnVJbm5lclswXS5pbm5lckhUTUwgPSBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTGk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbiA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBzID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiksXG4gICAgICAgICAgICAgICAgICAgIGEgPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IGZ1bmN0aW9uKGUsIHQsIGksIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpID0gXCJkcm9wZG93bi1pdGVtIFwiICsgKGkgfHwgXCJcIiksIFwiPGFcIiArIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBpICYmIFwiXCIgIT09IGkgPyAnIGNsYXNzPVwiJyArIGkgKyAnXCInIDogXCJcIikgKyAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0ID8gJyBkYXRhLW9yaWdpbmFsLWluZGV4PVwiJyArIHQgKyAnXCInIDogXCJcIikgKyAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbiAmJiBudWxsICE9PSBuID8gJ2RhdGEtb3B0Z3JvdXA9XCInICsgbiArICdcIicgOiBcIlwiKSArIFwiPlwiICsgZSArIFwiPC9hPlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGQgPSBmdW5jdGlvbihuLCBzLCBvLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcyA9IFwiZHJvcGRvd24taXRlbS1pbm5lciBcIiArIChzIHx8IFwiXCIpLCAnPHNwYW4gdGFiaW5kZXg9XCIwXCInICsgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHMgPyAnIGNsYXNzPVwiJyArIHMgKyAnXCInIDogXCJcIikgKyAobyA/ICcgc3R5bGU9XCInICsgbyArICdcIicgOiBcIlwiKSArIChpLm9wdGlvbnMubGl2ZVNlYXJjaE5vcm1hbGl6ZSA/ICcgZGF0YS1ub3JtYWxpemVkLXRleHQ9XCInICsgdChyKGUobikuaHRtbCgpKSkgKyAnXCInIDogXCJcIikgKyAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYSB8fCBudWxsICE9PSBhID8gJyBkYXRhLXRva2Vucz1cIicgKyBhICsgJ1wiJyA6IFwiXCIpICsgJyByb2xlPVwib3B0aW9uXCI+JyArIG4gKyAnPHNwYW4gY2xhc3M9XCInICsgaS5vcHRpb25zLmljb25CYXNlICsgXCIgXCIgKyBpLm9wdGlvbnMudGlja0ljb24gKyAnIGNoZWNrLW1hcmtcIj48L3NwYW4+PC9zcGFuPidcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRpdGxlICYmICF0aGlzLm11bHRpcGxlICYmIChhLS0sICF0aGlzLiRlbGVtZW50LmZpbmQoXCIuYnMtdGl0bGUtb3B0aW9uXCIpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSB0aGlzLiRlbGVtZW50WzBdO1xuICAgICAgICAgICAgICAgICAgICBvLmNsYXNzTmFtZSA9IFwiYnMtdGl0bGUtb3B0aW9uXCIsIG8uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnRpdGxlLCBvLnZhbHVlID0gXCJcIiwgaC5pbnNlcnRCZWZvcmUobywgaC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlKGgub3B0aW9uc1toLnNlbGVjdGVkSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBjLmF0dHIoXCJzZWxlY3RlZFwiKSAmJiB2b2lkIDAgPT09IHRoaXMuJGVsZW1lbnQuZGF0YShcInNlbGVjdGVkXCIpICYmIChvLnNlbGVjdGVkID0gITApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy4kZWxlbWVudC5maW5kKFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhKyssICFvLmhhc0NsYXNzKFwiYnMtdGl0bGUtb3B0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCwgYyA9IHRoaXMuY2xhc3NOYW1lIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHIodGhpcy5zdHlsZS5jc3NUZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gby5kYXRhKFwiY29udGVudFwiKSA/IG8uZGF0YShcImNvbnRlbnRcIikgOiBvLmh0bWwoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gby5kYXRhKFwidG9rZW5zXCIpID8gby5kYXRhKFwidG9rZW5zXCIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygby5kYXRhKFwic3VidGV4dFwiKSA/ICc8c21hbGwgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+JyArIG8uZGF0YShcInN1YnRleHRcIikgKyBcIjwvc21hbGw+XCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBvLmRhdGEoXCJpY29uXCIpID8gJzxzcGFuIGNsYXNzPVwiJyArIGkub3B0aW9ucy5pY29uQmFzZSArIFwiIFwiICsgby5kYXRhKFwiaWNvblwiKSArICdcIj48L3NwYW4+ICcgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBvLnBhcmVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQgPSBcIk9QVEdST1VQXCIgPT09IHZbMF0udGFnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gJCAmJiB2WzBdLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcgPSB0aGlzLmRpc2FibGVkIHx8IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gYiAmJiB3ICYmIChiID0gXCI8c3Bhbj5cIiArIGIgKyBcIjwvc3Bhbj5cIiksIGkub3B0aW9ucy5oaWRlRGlzYWJsZWQgJiYgKHcgJiYgISQgfHwgeCkpIHJldHVybiBoID0gby5kYXRhKFwicHJldkhpZGRlbkluZGV4XCIpLCBvLm5leHQoKS5kYXRhKFwicHJldkhpZGRlbkluZGV4XCIsIHZvaWQgMCAhPT0gaCA/IGggOiB0KSwgdm9pZCBhLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5kYXRhKFwiY29udGVudFwiKSB8fCAoZiA9IGIgKyAnPHNwYW4gY2xhc3M9XCJ0ZXh0XCI+JyArIGYgKyBnICsgXCI8L3NwYW4+XCIpLCAkICYmIG8uZGF0YShcImRpdmlkZXJcIikgIT09ICEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkub3B0aW9ucy5oaWRlRGlzYWJsZWQgJiYgdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSB2LmRhdGEoXCJhbGxPcHRpb25zRGlzYWJsZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdi5jaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5kYXRhKFwiYWxsT3B0aW9uc0Rpc2FibGVkXCIsIHkuZmlsdGVyKFwiOmRpc2FibGVkXCIpLmxlbmd0aCA9PT0geS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuZGF0YShcImFsbE9wdGlvbnNEaXNhYmxlZFwiKSkgcmV0dXJuIHZvaWQgYS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDID0gXCIgXCIgKyB2WzBdLmNsYXNzTmFtZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvLmluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUyA9IHZbMF0ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygdi5kYXRhKFwic3VidGV4dFwiKSA/ICc8c21hbGwgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+JyArIHYuZGF0YShcInN1YnRleHRcIikgKyBcIjwvc21hbGw+XCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSSA9IHYuZGF0YShcImljb25cIikgPyAnPHNwYW4gY2xhc3M9XCInICsgaS5vcHRpb25zLmljb25CYXNlICsgXCIgXCIgKyB2LmRhdGEoXCJpY29uXCIpICsgJ1wiPjwvc3Bhbj4gJyA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMgPSBJICsgJzxzcGFuIGNsYXNzPVwidGV4dFwiPicgKyByKFMpICsgayArIFwiPC9zcGFuPlwiLCAwICE9PSB0ICYmIG4ubGVuZ3RoID4gMCAmJiAoYSsrLCBuLnB1c2gobChcIlwiLCBudWxsLCBcImRpdmlkZXJcIiwgcyArIFwiZGl2XCIpKSksIGErKywgbi5wdXNoKGwoUywgbnVsbCwgXCJkcm9wZG93bi1oZWFkZXJcIiArIEMsIHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5vcHRpb25zLmhpZGVEaXNhYmxlZCAmJiB3KSByZXR1cm4gdm9pZCBhLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5wdXNoKGwoZChmLCBcIm9wdCBcIiArIGMgKyBDLCB1LCBtKSwgdCwgXCJcIiwgcykpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG8uZGF0YShcImRpdmlkZXJcIikgPT09ICEwKSBuLnB1c2gobChcIlwiLCB0LCBcImRpdmlkZXJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoby5kYXRhKFwiaGlkZGVuXCIpID09PSAhMCkgaCA9IG8uZGF0YShcInByZXZIaWRkZW5JbmRleFwiKSwgby5uZXh0KCkuZGF0YShcInByZXZIaWRkZW5JbmRleFwiLCB2b2lkIDAgIT09IGggPyBoIDogdCksIG4ucHVzaChsKGQoZiwgYywgdSwgbSksIHQsIFwiaGlkZGVuIGlzLWhpZGRlblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVCA9IHRoaXMucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBcIk9QVEdST1VQXCIgPT09IHRoaXMucHJldmlvdXNFbGVtZW50U2libGluZy50YWdOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVCAmJiBpLm9wdGlvbnMuaGlkZURpc2FibGVkICYmIChoID0gby5kYXRhKFwicHJldkhpZGRlbkluZGV4XCIpLCB2b2lkIDAgIT09IGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBFID0gcC5lcShoKVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFICYmIFwiT1BUR1JPVVBcIiA9PT0gRS50YWdOYW1lICYmICFFLmRpc2FibGVkICYmIChUID0gITApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQgJiYgKGErKywgbi5wdXNoKGwoXCJcIiwgbnVsbCwgXCJkaXZpZGVyXCIsIHMgKyBcImRpdlwiKSkpLCBuLnB1c2gobChkKGYsIGMsIHUsIG0pLCB0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkubGlPYmpbdF0gPSBhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgdGhpcy5tdWx0aXBsZSB8fCAwICE9PSB0aGlzLiRlbGVtZW50LmZpbmQoXCJvcHRpb246c2VsZWN0ZWRcIikubGVuZ3RoIHx8IHRoaXMub3B0aW9ucy50aXRsZSB8fCB0aGlzLiRlbGVtZW50LmZpbmQoXCJvcHRpb25cIikuZXEoMCkucHJvcChcInNlbGVjdGVkXCIsICEwKS5hdHRyKFwic2VsZWN0ZWRcIiwgXCJzZWxlY3RlZFwiKSwgbi5qb2luKFwiXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluZExpczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gdGhpcy4kbGlzICYmICh0aGlzLiRsaXMgPSB0aGlzLiRtZW51LmZpbmQoXCJhXCIpKSwgdGhpcy4kbGlzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIG4gPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzID0gdGhpcy4kZWxlbWVudC5maW5kKFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHQgIT09ICExICYmIHMuZWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbi5maW5kTGlzKCkuZXEobi5saU9ialtlXSk7XG4gICAgICAgICAgICAgICAgICAgIG4uc2V0RGlzYWJsZWQoZSwgdGhpcy5kaXNhYmxlZCB8fCBcIk9QVEdST1VQXCIgPT09IHRoaXMucGFyZW50Tm9kZS50YWdOYW1lICYmIHRoaXMucGFyZW50Tm9kZS5kaXNhYmxlZCwgdCksIG4uc2V0U2VsZWN0ZWQoZSwgdGhpcy5zZWxlY3RlZCwgdClcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy50b2dnbGVQbGFjZWhvbGRlcigpLCB0aGlzLnRhYkluZGV4KCk7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBzLm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4ub3B0aW9ucy5oaWRlRGlzYWJsZWQgJiYgKHRoaXMuZGlzYWJsZWQgfHwgXCJPUFRHUk9VUFwiID09PSB0aGlzLnBhcmVudE5vZGUudGFnTmFtZSAmJiB0aGlzLnBhcmVudE5vZGUuZGlzYWJsZWQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQsIGkgPSBlKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gaS5kYXRhKFwiaWNvblwiKSAmJiBuLm9wdGlvbnMuc2hvd0ljb24gPyAnPGkgY2xhc3M9XCInICsgbi5vcHRpb25zLmljb25CYXNlICsgXCIgXCIgKyBpLmRhdGEoXCJpY29uXCIpICsgJ1wiPjwvaT4gJyA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPSBuLm9wdGlvbnMuc2hvd1N1YnRleHQgJiYgaS5kYXRhKFwic3VidGV4dFwiKSAmJiAhbi5tdWx0aXBsZSA/ICcgPHNtYWxsIGNsYXNzPVwidGV4dC1tdXRlZFwiPicgKyBpLmRhdGEoXCJzdWJ0ZXh0XCIpICsgXCI8L3NtYWxsPlwiIDogXCJcIiwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgaS5hdHRyKFwidGl0bGVcIikgPyBpLmF0dHIoXCJ0aXRsZVwiKSA6IGkuZGF0YShcImNvbnRlbnRcIikgJiYgbi5vcHRpb25zLnNob3dDb250ZW50ID8gaS5kYXRhKFwiY29udGVudFwiKS50b1N0cmluZygpIDogcyArIGkuaHRtbCgpICsgdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLm11bHRpcGxlID8gby5qb2luKHRoaXMub3B0aW9ucy5tdWx0aXBsZVNlcGFyYXRvcikgOiBvWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQuaW5kZXhPZihcImNvdW50XCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRUZXh0Rm9ybWF0LnNwbGl0KFwiPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwubGVuZ3RoID4gMSAmJiBvLmxlbmd0aCA+IGxbMV0gfHwgMSA9PSBsLmxlbmd0aCAmJiBvLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCA/IFwiLCBbZGlzYWJsZWRdXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBzLm5vdCgnW2RhdGEtZGl2aWRlcj1cInRydWVcIl0sIFtkYXRhLWhpZGRlbj1cInRydWVcIl0nICsgaSkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMub3B0aW9ucy5jb3VudFNlbGVjdGVkVGV4dCA/IHRoaXMub3B0aW9ucy5jb3VudFNlbGVjdGVkVGV4dChvLmxlbmd0aCwgcikgOiB0aGlzLm9wdGlvbnMuY291bnRTZWxlY3RlZFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gaC5yZXBsYWNlKFwiezB9XCIsIG8ubGVuZ3RoLnRvU3RyaW5nKCkpLnJlcGxhY2UoXCJ7MX1cIiwgci50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PSB0aGlzLm9wdGlvbnMudGl0bGUgJiYgKHRoaXMub3B0aW9ucy50aXRsZSA9IHRoaXMuJGVsZW1lbnQuYXR0cihcInRpdGxlXCIpKSwgXCJzdGF0aWNcIiA9PSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRUZXh0Rm9ybWF0ICYmIChhID0gdGhpcy5vcHRpb25zLnRpdGxlKSwgYSB8fCAoYSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHRoaXMub3B0aW9ucy50aXRsZSA/IHRoaXMub3B0aW9ucy50aXRsZSA6IHRoaXMub3B0aW9ucy5ub25lU2VsZWN0ZWRUZXh0KSwgdGhpcy4kYnV0dG9uLmF0dHIoXCJ0aXRsZVwiLCBkKGUudHJpbShhLnJlcGxhY2UoLzxbXj5dKj4/L2csIFwiXCIpKSkpLCB0aGlzLiRidXR0b24uY2hpbGRyZW4oXCIuZmlsdGVyLW9wdGlvblwiKS5odG1sKGEpLCB0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJyZW5kZXJlZC5icy5zZWxlY3RcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTdHlsZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cihcImNsYXNzXCIpICYmIHRoaXMuJG5ld0VsZW1lbnQuYWRkQ2xhc3ModGhpcy4kZWxlbWVudC5hdHRyKFwiY2xhc3NcIikucmVwbGFjZSgvc2VsZWN0cGlja2VyfG1vYmlsZS1kZXZpY2V8YnMtc2VsZWN0LWhpZGRlbnx2YWxpZGF0ZVxcWy4qXFxdL2dpLCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlID8gZSA6IHRoaXMub3B0aW9ucy5zdHlsZTtcbiAgICAgICAgICAgICAgICBcImFkZFwiID09IHQgPyB0aGlzLiRidXR0b24uYWRkQ2xhc3MoaSkgOiBcInJlbW92ZVwiID09IHQgPyB0aGlzLiRidXR0b24ucmVtb3ZlQ2xhc3MoaSkgOiAodGhpcy4kYnV0dG9uLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zdHlsZSksIHRoaXMuJGJ1dHRvbi5hZGRDbGFzcyhpKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaUhlaWdodDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIGlmICh0IHx8IHRoaXMub3B0aW9ucy5zaXplICE9PSAhMSAmJiAhdGhpcy5zaXplSW5mbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gdGhpcy5vcHRpb25zLmhlYWRlciAmJiB0aGlzLiRtZW51LmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKS5sZW5ndGggPiAwID8gdGhpcy4kbWVudS5maW5kKFwiLnBvcG92ZXItdGl0bGVcIilbMF0uY2xvbmVOb2RlKCEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gdGhpcy5vcHRpb25zLmxpdmVTZWFyY2ggPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnMuYWN0aW9uc0JveCAmJiB0aGlzLm11bHRpcGxlICYmIHRoaXMuJG1lbnUuZmluZChcIi5icy1hY3Rpb25zYm94XCIpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoXCIuYnMtYWN0aW9uc2JveFwiKVswXS5jbG9uZU5vZGUoITApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLm9wdGlvbnMuZG9uZUJ1dHRvbiAmJiB0aGlzLm11bHRpcGxlICYmIHRoaXMuJG1lbnUuZmluZChcIi5icy1kb25lYnV0dG9uXCIpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoXCIuYnMtZG9uZWJ1dHRvblwiKVswXS5jbG9uZU5vZGUoITApIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuY2xhc3NOYW1lID0gXCJ0ZXh0XCIsIGkuY2xhc3NOYW1lID0gdGhpcy4kbWVudVswXS5wYXJlbnROb2RlLmNsYXNzTmFtZSArIFwiIHNob3cgb3BlblwiLCBuLmNsYXNzTmFtZSA9IFwiZHJvcGRvd24tbWVudSBvcGVuIHNob3dcIiwgcy5jbGFzc05hbWUgPSBcImRyb3Bkb3duLW1lbnUgaW5uZXJcIiwgby5jbGFzc05hbWUgPSBcImRpdmlkZXJcIiwgbC5jbGFzc05hbWUgPSBcImRyb3Bkb3duLWl0ZW0taW5uZXJcIiwgci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIklubmVyIHRleHRcIikpLCBsLmFwcGVuZENoaWxkKHIpLCBhLmFwcGVuZENoaWxkKGwpLCBzLmFwcGVuZENoaWxkKGEpLCBzLmFwcGVuZENoaWxkKG8pLCBkICYmIG4uYXBwZW5kQ2hpbGQoZCksIGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaC5jbGFzc05hbWUgPSBcImJzLXNlYXJjaGJveFwiLCB1LmNsYXNzTmFtZSA9IFwiZm9ybS1jb250cm9sXCIsIGguYXBwZW5kQ2hpbGQodSksIG4uYXBwZW5kQ2hpbGQoaClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjICYmIG4uYXBwZW5kQ2hpbGQoYyksIG4uYXBwZW5kQ2hpbGQocyksIHAgJiYgbi5hcHBlbmRDaGlsZChwKSwgaS5hcHBlbmRDaGlsZChuKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBsLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBkID8gZC5vZmZzZXRIZWlnaHQgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGggPyBoLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYyA/IGMub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwID8gcC5vZmZzZXRIZWlnaHQgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJCA9IGUobykub3V0ZXJIZWlnaHQoITApLFxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUobikgOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSB4ID8gbnVsbCA6IGUobiksXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnQ6IHBhcnNlSW50KHggPyB4LnBhZGRpbmdUb3AgOiB3LmNzcyhcInBhZGRpbmdUb3BcIikpICsgcGFyc2VJbnQoeCA/IHgucGFkZGluZ0JvdHRvbSA6IHcuY3NzKFwicGFkZGluZ0JvdHRvbVwiKSkgKyBwYXJzZUludCh4ID8geC5ib3JkZXJUb3BXaWR0aCA6IHcuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIikpICsgcGFyc2VJbnQoeCA/IHguYm9yZGVyQm90dG9tV2lkdGggOiB3LmNzcyhcImJvcmRlckJvdHRvbVdpZHRoXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3JpejogcGFyc2VJbnQoeCA/IHgucGFkZGluZ0xlZnQgOiB3LmNzcyhcInBhZGRpbmdMZWZ0XCIpKSArIHBhcnNlSW50KHggPyB4LnBhZGRpbmdSaWdodCA6IHcuY3NzKFwicGFkZGluZ1JpZ2h0XCIpKSArIHBhcnNlSW50KHggPyB4LmJvcmRlckxlZnRXaWR0aCA6IHcuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpKSArIHBhcnNlSW50KHggPyB4LmJvcmRlclJpZ2h0V2lkdGggOiB3LmNzcyhcImJvcmRlclJpZ2h0V2lkdGhcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgQyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0OiB5LnZlcnQgKyBwYXJzZUludCh4ID8geC5tYXJnaW5Ub3AgOiB3LmNzcyhcIm1hcmdpblRvcFwiKSkgKyBwYXJzZUludCh4ID8geC5tYXJnaW5Cb3R0b20gOiB3LmNzcyhcIm1hcmdpbkJvdHRvbVwiKSkgKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6OiB5Lmhvcml6ICsgcGFyc2VJbnQoeCA/IHgubWFyZ2luTGVmdCA6IHcuY3NzKFwibWFyZ2luTGVmdFwiKSkgKyBwYXJzZUludCh4ID8geC5tYXJnaW5SaWdodCA6IHcuY3NzKFwibWFyZ2luUmlnaHRcIikpICsgMlxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpKSwgdGhpcy5zaXplSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpSGVpZ2h0OiBmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoSGVpZ2h0OiBnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0hlaWdodDogYixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVCdXR0b25IZWlnaHQ6IHYsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZpZGVySGVpZ2h0OiAkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVudVBhZGRpbmc6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51RXh0cmFzOiBDXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZExpcygpLCB0aGlzLmxpSGVpZ2h0KCksIHRoaXMub3B0aW9ucy5oZWFkZXIgJiYgdGhpcy4kbWVudS5jc3MoXCJwYWRkaW5nLXRvcFwiLCAwKSwgdGhpcy5vcHRpb25zLnNpemUgIT09ICExKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0LCBpLCBuLCBzLCBvLCBhLCBsLCByLCBkID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSB0aGlzLiRtZW51LFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuJG1lbnVJbm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBlKHdpbmRvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gdGhpcy4kbmV3RWxlbWVudFswXS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gdGhpcy4kbmV3RWxlbWVudFswXS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB0aGlzLnNpemVJbmZvLmxpSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuc2l6ZUluZm8uaGVhZGVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuc2l6ZUluZm8uc2VhcmNoSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuc2l6ZUluZm8uYWN0aW9uc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICQgPSB0aGlzLnNpemVJbmZvLmRvbmVCdXR0b25IZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcy5zaXplSW5mby5kaXZpZGVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHRoaXMuc2l6ZUluZm8ubWVudVBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gdGhpcy5zaXplSW5mby5tZW51RXh0cmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgQyA9IHRoaXMub3B0aW9ucy5oaWRlRGlzYWJsZWQgPyBcIi5kaXNhYmxlZFwiIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCwgaSA9IGQuJG5ld0VsZW1lbnQub2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBlKGQub3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQub3B0aW9ucy5jb250YWluZXIgJiYgIW4uaXMoXCJib2R5XCIpID8gKHQgPSBuLm9mZnNldCgpLCB0LnRvcCArPSBwYXJzZUludChuLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpKSwgdC5sZWZ0ICs9IHBhcnNlSW50KG4uY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpKSkgOiB0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gZC5vcHRpb25zLndpbmRvd1BhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGkudG9wIC0gdC50b3AgLSBwLnNjcm9sbFRvcCgpLCBhID0gcC5oZWlnaHQoKSAtIG8gLSB1IC0gdC50b3AgLSBzWzJdLCBsID0gaS5sZWZ0IC0gdC5sZWZ0IC0gcC5zY3JvbGxMZWZ0KCksIHIgPSBwLndpZHRoKCkgLSBsIC0gZiAtIHQubGVmdCAtIHNbMV0sIG8gLT0gc1swXSwgbCAtPSBzWzNdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoUygpLCBcImF1dG9cIiA9PT0gdGhpcy5vcHRpb25zLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAsIHUgPSBmdW5jdGlvbih0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpID8gbi5jbGFzc0xpc3QgPyBuLmNsYXNzTGlzdC5jb250YWlucyh0KSA6IGUobikuaGFzQ2xhc3ModCkgOiAhKG4uY2xhc3NMaXN0ID8gbi5jbGFzc0xpc3QuY29udGFpbnModCkgOiBlKG4pLmhhc0NsYXNzKHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZC4kbWVudUlubmVyWzBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPyBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoeCwgdShcImhpZGRlblwiLCAhMSkpIDogZC4kbGlzLm5vdChcIi5oaWRkZW5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyID8gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKEMsIHUoXCJkcm9wZG93bi1oZWFkZXJcIiwgITApKSA6IEMuZmlsdGVyKFwiLmRyb3Bkb3duLWhlYWRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTKCksIHQgPSBhIC0geS52ZXJ0LCBpID0gciAtIHkuaG9yaXosIGQub3B0aW9ucy5jb250YWluZXIgPyAoaC5kYXRhKFwiaGVpZ2h0XCIpIHx8IGguZGF0YShcImhlaWdodFwiLCBoLmhlaWdodCgpKSwgbiA9IGguZGF0YShcImhlaWdodFwiKSwgaC5kYXRhKFwid2lkdGhcIikgfHwgaC5kYXRhKFwid2lkdGhcIiwgaC53aWR0aCgpKSwgcyA9IGguZGF0YShcIndpZHRoXCIpKSA6IChuID0gaC5oZWlnaHQoKSwgcyA9IGgud2lkdGgoKSksIGQub3B0aW9ucy5kcm9wdXBBdXRvICYmIGQuJG5ld0VsZW1lbnQudG9nZ2xlQ2xhc3MoXCJkcm9wdXBcIiwgbyA+IGEgJiYgdCAtIHkudmVydCA8IG4pLCBkLiRuZXdFbGVtZW50Lmhhc0NsYXNzKFwiZHJvcHVwXCIpICYmICh0ID0gbyAtIHkudmVydCksIFwiYXV0b1wiID09PSBkLm9wdGlvbnMuZHJvcGRvd25BbGlnblJpZ2h0ICYmIGgudG9nZ2xlQ2xhc3MoXCJkcm9wZG93bi1tZW51LXJpZ2h0XCIsIGwgPiByICYmIGkgLSB5Lmhvcml6IDwgcyAtIGYpLCBwID0gQy5sZW5ndGggKyBrLmxlbmd0aCA+IDMgPyAzICogbSArIHkudmVydCAtIDIgOiAwLCBoLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF4LWhlaWdodFwiOiB0ICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW4taGVpZ2h0XCI6IHAgKyBnICsgYiArIHYgKyAkICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGMuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtaGVpZ2h0XCI6IHQgLSBnIC0gYiAtIHYgLSAkIC0gdy52ZXJ0ICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJmbG93LXlcIjogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWluLWhlaWdodFwiOiBNYXRoLm1heChwIC0gdy52ZXJ0LCAwKSArIFwicHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaygpLCB0aGlzLiRzZWFyY2hib3gub2ZmKFwiaW5wdXQuZ2V0U2l6ZSBwcm9wZXJ0eWNoYW5nZS5nZXRTaXplXCIpLm9uKFwiaW5wdXQuZ2V0U2l6ZSBwcm9wZXJ0eWNoYW5nZS5nZXRTaXplXCIsIGspLCBwLm9mZihcInJlc2l6ZS5nZXRTaXplIHNjcm9sbC5nZXRTaXplXCIpLm9uKFwicmVzaXplLmdldFNpemUgc2Nyb2xsLmdldFNpemVcIiwgaylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSAmJiBcImF1dG9cIiAhPSB0aGlzLm9wdGlvbnMuc2l6ZSAmJiB0aGlzLiRsaXMubm90KEMpLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgSSA9IHRoaXMuJGxpcy5ub3QoXCIuZGl2aWRlclwiKS5ub3QoQykuY2hpbGRyZW4oKS5zbGljZSgwLCB0aGlzLm9wdGlvbnMuc2l6ZSkubGFzdCgpLnBhcmVudCgpLmluZGV4KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVCA9IHRoaXMuJGxpcy5zbGljZSgwLCBJICsgMSkuZmlsdGVyKFwiLmRpdmlkZXJcIikubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG0gKiB0aGlzLm9wdGlvbnMuc2l6ZSArIFQgKiB4ICsgdy52ZXJ0LCBkLm9wdGlvbnMuY29udGFpbmVyID8gKGguZGF0YShcImhlaWdodFwiKSB8fCBoLmRhdGEoXCJoZWlnaHRcIiwgaC5oZWlnaHQoKSksIG4gPSBoLmRhdGEoXCJoZWlnaHRcIikpIDogbiA9IGguaGVpZ2h0KCksIGQub3B0aW9ucy5kcm9wdXBBdXRvICYmIHRoaXMuJG5ld0VsZW1lbnQudG9nZ2xlQ2xhc3MoXCJkcm9wdXBcIiwgbyA+IGEgJiYgdCAtIHkudmVydCA8IG4pLCBoLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtaGVpZ2h0XCI6IHQgKyBnICsgYiArIHYgKyAkICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWluLWhlaWdodFwiOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgYy5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF4LWhlaWdodFwiOiB0IC0gdy52ZXJ0ICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3ZlcmZsb3cteVwiOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbi1oZWlnaHRcIjogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiYXV0b1wiID09PSB0aGlzLm9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWVudS5jc3MoXCJtaW4td2lkdGhcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuJG1lbnUucGFyZW50KCkuY2xvbmUoKS5hcHBlbmRUbyhcImJvZHlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lciA/IHRoaXMuJG5ld0VsZW1lbnQuY2xvbmUoKS5hcHBlbmRUbyhcImJvZHlcIikgOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGUuY2hpbGRyZW4oXCIuZHJvcGRvd24tbWVudVwiKS5vdXRlcldpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gdC5jc3MoXCJ3aWR0aFwiLCBcImF1dG9cIikuY2hpbGRyZW4oXCJidXR0b25cIikub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZSgpLCB0LnJlbW92ZSgpLCB0aGlzLiRuZXdFbGVtZW50LmNzcyhcIndpZHRoXCIsIE1hdGgubWF4KGksIG4pICsgXCJweFwiKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBcImZpdFwiID09PSB0aGlzLm9wdGlvbnMud2lkdGggPyAodGhpcy4kbWVudS5jc3MoXCJtaW4td2lkdGhcIiwgXCJcIiksIHRoaXMuJG5ld0VsZW1lbnQuY3NzKFwid2lkdGhcIiwgXCJcIikuYWRkQ2xhc3MoXCJmaXQtd2lkdGhcIikpIDogdGhpcy5vcHRpb25zLndpZHRoID8gKHRoaXMuJG1lbnUuY3NzKFwibWluLXdpZHRoXCIsIFwiXCIpLCB0aGlzLiRuZXdFbGVtZW50LmNzcyhcIndpZHRoXCIsIHRoaXMub3B0aW9ucy53aWR0aCkpIDogKHRoaXMuJG1lbnUuY3NzKFwibWluLXdpZHRoXCIsIFwiXCIpLCB0aGlzLiRuZXdFbGVtZW50LmNzcyhcIndpZHRoXCIsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXdFbGVtZW50Lmhhc0NsYXNzKFwiZml0LXdpZHRoXCIpICYmIFwiZml0XCIgIT09IHRoaXMub3B0aW9ucy53aWR0aCAmJiB0aGlzLiRuZXdFbGVtZW50LnJlbW92ZUNsYXNzKFwiZml0LXdpZHRoXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGJzQ29udGFpbmVyID0gZSgnPGRpdiBjbGFzcz1cImJzLWNvbnRhaW5lclwiIC8+Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHQsIGksIG4sIHMgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBvID0gZSh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICAgICAgYSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuJGJzQ29udGFpbmVyLmFkZENsYXNzKGUuYXR0cihcImNsYXNzXCIpLnJlcGxhY2UoL2Zvcm0tY29udHJvbHxmaXQtd2lkdGgvZ2ksIFwiXCIpKS50b2dnbGVDbGFzcyhcImRyb3B1cFwiLCBlLmhhc0NsYXNzKFwiZHJvcHVwXCIpKSwgdCA9IGUub2Zmc2V0KCksIG8uaXMoXCJib2R5XCIpID8gaSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IChpID0gby5vZmZzZXQoKSwgaS50b3AgKz0gcGFyc2VJbnQoby5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSkgLSBvLnNjcm9sbFRvcCgpLCBpLmxlZnQgKz0gcGFyc2VJbnQoby5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIikpIC0gby5zY3JvbGxMZWZ0KCkpLCBuID0gZS5oYXNDbGFzcyhcImRyb3B1cFwiKSA/IDAgOiBlWzBdLm9mZnNldEhlaWdodCwgcy4kYnNDb250YWluZXIuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHQudG9wIC0gaS50b3AgKyBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHQubGVmdCAtIGkubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZVswXS5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLiRidXR0b24ub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBzLmlzRGlzYWJsZWQoKSB8fCAoYShzLiRuZXdFbGVtZW50KSwgcy4kYnNDb250YWluZXIuYXBwZW5kVG8ocy5vcHRpb25zLmNvbnRhaW5lcikudG9nZ2xlQ2xhc3MoXCJvcGVuXCIsICF0Lmhhc0NsYXNzKFwib3BlblwiKSkuYXBwZW5kKHMuJG1lbnUpKVxuICAgICAgICAgICAgICAgIH0pLCBlKHdpbmRvdykub24oXCJyZXNpemUgc2Nyb2xsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhKHMuJG5ld0VsZW1lbnQpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuJGVsZW1lbnQub24oXCJoaWRlLmJzLnNlbGVjdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcy4kbWVudS5kYXRhKFwiaGVpZ2h0XCIsIHMuJG1lbnUuaGVpZ2h0KCkpLCBzLiRic0NvbnRhaW5lci5kZXRhY2goKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICBpIHx8ICh0aGlzLnRvZ2dsZVBsYWNlaG9sZGVyKCksIGkgPSB0aGlzLmZpbmRMaXMoKS5lcSh0aGlzLmxpT2JqW2VdKSksIGkudG9nZ2xlQ2xhc3MoXCJzZWxlY3RlZFwiLCB0KS5maW5kKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLmF0dHIoXCJhcmlhLXNlbGVjdGVkXCIsIHQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RGlzYWJsZWQ6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICBpIHx8IChpID0gdGhpcy5maW5kTGlzKCkuZXEodGhpcy5saU9ialtlXSkpLCB0ID8gaS5hZGRDbGFzcyhcImRpc2FibGVkXCIpLmNoaWxkcmVuKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLmF0dHIoXCJocmVmXCIsIFwiI1wiKS5hdHRyKFwidGFiaW5kZXhcIiwgLTEpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsICEwKSA6IGkucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKS5jaGlsZHJlbihcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKS5yZW1vdmVBdHRyKFwiaHJlZlwiKS5hdHRyKFwidGFiaW5kZXhcIiwgMCkuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnRbMF0uZGlzYWJsZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGVja0Rpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rpc2FibGVkKCkgPyAodGhpcy4kbmV3RWxlbWVudC5hZGRDbGFzcyhcImRpc2FibGVkXCIpLCB0aGlzLiRidXR0b24uYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKS5hdHRyKFwidGFiaW5kZXhcIiwgLTEpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsICEwKSkgOiAodGhpcy4kYnV0dG9uLmhhc0NsYXNzKFwiZGlzYWJsZWRcIikgJiYgKHRoaXMuJG5ld0VsZW1lbnQucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKSwgdGhpcy4kYnV0dG9uLnJlbW92ZUNsYXNzKFwiZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITEpKSwgLTEgIT0gdGhpcy4kYnV0dG9uLmF0dHIoXCJ0YWJpbmRleFwiKSB8fCB0aGlzLiRlbGVtZW50LmRhdGEoXCJ0YWJpbmRleFwiKSB8fCB0aGlzLiRidXR0b24ucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpKSwgdGhpcy4kYnV0dG9uLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWUuaXNEaXNhYmxlZCgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVQbGFjZWhvbGRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLiRlbGVtZW50LnZhbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGJ1dHRvbi50b2dnbGVDbGFzcyhcImJzLXBsYWNlaG9sZGVyXCIsIG51bGwgPT09IGUgfHwgXCJcIiA9PT0gZSB8fCBlLmNvbnN0cnVjdG9yID09PSBBcnJheSAmJiAwID09PSBlLmxlbmd0aClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YWJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKFwidGFiaW5kZXhcIikgIT09IHRoaXMuJGVsZW1lbnQuYXR0cihcInRhYmluZGV4XCIpICYmIC05OCAhPT0gdGhpcy4kZWxlbWVudC5hdHRyKFwidGFiaW5kZXhcIikgJiYgXCItOThcIiAhPT0gdGhpcy4kZWxlbWVudC5hdHRyKFwidGFiaW5kZXhcIikgJiYgKHRoaXMuJGVsZW1lbnQuZGF0YShcInRhYmluZGV4XCIsIHRoaXMuJGVsZW1lbnQuYXR0cihcInRhYmluZGV4XCIpKSwgdGhpcy4kYnV0dG9uLmF0dHIoXCJ0YWJpbmRleFwiLCB0aGlzLiRlbGVtZW50LmRhdGEoXCJ0YWJpbmRleFwiKSkpLCB0aGlzLiRlbGVtZW50LmF0dHIoXCJ0YWJpbmRleFwiLCAtOTgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpY2tMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpID0gZShkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgaS5kYXRhKFwic3BhY2VTZWxlY3RcIiwgITEpLCB0aGlzLiRidXR0b24ub24oXCJrZXl1cFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8oMzIpLy50ZXN0KGUua2V5Q29kZS50b1N0cmluZygxMCkpICYmIGkuZGF0YShcInNwYWNlU2VsZWN0XCIpICYmIChlLnByZXZlbnREZWZhdWx0KCksIGkuZGF0YShcInNwYWNlU2VsZWN0XCIsICExKSlcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kYnV0dG9uLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHQuc2V0U2l6ZSgpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuJGVsZW1lbnQub24oXCJzaG93bi5icy5zZWxlY3RcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0Lm9wdGlvbnMubGl2ZVNlYXJjaCB8fCB0Lm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHQubGlPYmpbdC4kZWxlbWVudFswXS5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgZSB8fCB0Lm9wdGlvbnMuc2l6ZSA9PT0gITEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQuJGxpcy5lcShlKVswXS5vZmZzZXRUb3AgLSB0LiRtZW51SW5uZXJbMF0ub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpIC0gdC4kbWVudUlubmVyWzBdLm9mZnNldEhlaWdodCAvIDIgKyB0LnNpemVJbmZvLmxpSGVpZ2h0IC8gMiwgdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IGlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHQuJG1lbnVJbm5lci5maW5kKFwiLnNlbGVjdGVkIGFcIikuZm9jdXMoKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRtZW51SW5uZXIub24oXCJjbGlja1wiLCBcImEgc3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIsIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IG4ucGFyZW50KCkuZGF0YShcIm9yaWdpbmFsSW5kZXhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gdC4kZWxlbWVudC52YWwoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB0LiRlbGVtZW50LnByb3AoXCJzZWxlY3RlZEluZGV4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5tdWx0aXBsZSAmJiAxICE9PSB0Lm9wdGlvbnMubWF4T3B0aW9ucyAmJiBpLnN0b3BQcm9wYWdhdGlvbigpLCBpLnByZXZlbnREZWZhdWx0KCksICF0LmlzRGlzYWJsZWQoKSAmJiAhbi5wYXJlbnQoKS5oYXNDbGFzcyhcImRpc2FibGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHQuJGVsZW1lbnQuZmluZChcIm9wdGlvblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gZC5lcShvKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gaC5wcm9wKFwic2VsZWN0ZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGgucGFyZW50KFwib3B0Z3JvdXBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHQub3B0aW9ucy5tYXhPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBwLmRhdGEoXCJtYXhPcHRpb25zXCIpIHx8ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaC5wcm9wKFwic2VsZWN0ZWRcIiwgIWMpLCB0LnNldFNlbGVjdGVkKG8sICFjKSwgbi5ibHVyKCksIHUgIT09ICExIHx8IGYgIT09ICExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gdSA8IGQuZmlsdGVyKFwiOnNlbGVjdGVkXCIpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBmIDwgcC5maW5kKFwib3B0aW9uOnNlbGVjdGVkXCIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHUgJiYgbSB8fCBmICYmIGcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodSAmJiAxID09IHUpIGQucHJvcChcInNlbGVjdGVkXCIsICExKSwgaC5wcm9wKFwic2VsZWN0ZWRcIiwgITApLCB0LiRtZW51SW5uZXIuZmluZChcIi5zZWxlY3RlZFwiKS5yZW1vdmVDbGFzcyhcInNlbGVjdGVkXCIpLCB0LnNldFNlbGVjdGVkKG8sICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGYgJiYgMSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpbmQoXCJvcHRpb246c2VsZWN0ZWRcIikucHJvcChcInNlbGVjdGVkXCIsICExKSwgaC5wcm9wKFwic2VsZWN0ZWRcIiwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBuLnBhcmVudCgpLmRhdGEoXCJvcHRncm91cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuJG1lbnVJbm5lci5maW5kKCdbZGF0YS1vcHRncm91cD1cIicgKyBiICsgJ1wiXScpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWRcIiksIHQuc2V0U2VsZWN0ZWQobywgITApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQub3B0aW9ucy5tYXhPcHRpb25zVGV4dCA/IFt0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHQsIHQub3B0aW9ucy5tYXhPcHRpb25zVGV4dF0gOiB0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdiA/IHYodSwgZikgOiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSAkWzBdLnJlcGxhY2UoXCJ7bn1cIiwgdSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9ICRbMV0ucmVwbGFjZShcIntufVwiLCBmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gZSgnPGRpdiBjbGFzcz1cIm5vdGlmeVwiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJFsyXSAmJiAoeCA9IHgucmVwbGFjZShcInt2YXJ9XCIsICRbMl1bdSA+IDEgPyAwIDogMV0pLCB3ID0gdy5yZXBsYWNlKFwie3Zhcn1cIiwgJFsyXVtmID4gMSA/IDAgOiAxXSkpLCBoLnByb3AoXCJzZWxlY3RlZFwiLCAhMSksIHQuJG1lbnUuYXBwZW5kKHkpLCB1ICYmIG0gJiYgKHkuYXBwZW5kKGUoXCI8ZGl2PlwiICsgeCArIFwiPC9kaXY+XCIpKSwgciA9ICExLCB0LiRlbGVtZW50LnRyaWdnZXIoXCJtYXhSZWFjaGVkLmJzLnNlbGVjdFwiKSksIGYgJiYgZyAmJiAoeS5hcHBlbmQoZShcIjxkaXY+XCIgKyB3ICsgXCI8L2Rpdj5cIikpLCByID0gITEsIHQuJGVsZW1lbnQudHJpZ2dlcihcIm1heFJlYWNoZWRHcnAuYnMuc2VsZWN0XCIpKSwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNldFNlbGVjdGVkKG8sICExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApLCB5LmRlbGF5KDc1MCkuZmFkZU91dCgzMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUodGhpcykucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZC5wcm9wKFwic2VsZWN0ZWRcIiwgITEpLCBoLnByb3AoXCJzZWxlY3RlZFwiLCAhMCksIHQuJG1lbnVJbm5lci5maW5kKFwiLnNlbGVjdGVkXCIpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWRcIikuZmluZChcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKS5hdHRyKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSksIHQuc2V0U2VsZWN0ZWQobywgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgIXQubXVsdGlwbGUgfHwgdC5tdWx0aXBsZSAmJiAxID09PSB0Lm9wdGlvbnMubWF4T3B0aW9ucyA/IHQuJGJ1dHRvbi5mb2N1cygpIDogdC5vcHRpb25zLmxpdmVTZWFyY2ggJiYgdC4kc2VhcmNoYm94LmZvY3VzKCksIHIgJiYgKGEgIT0gdC4kZWxlbWVudC52YWwoKSAmJiB0Lm11bHRpcGxlIHx8IGwgIT0gdC4kZWxlbWVudC5wcm9wKFwic2VsZWN0ZWRJbmRleFwiKSAmJiAhdC5tdWx0aXBsZSkgJiYgKHMgPSBbbywgaC5wcm9wKFwic2VsZWN0ZWRcIiksIGNdLCB0LiRlbGVtZW50LnRyaWdnZXJOYXRpdmUoXCJjaGFuZ2VcIikpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kbWVudS5vbihcImNsaWNrXCIsIFwiYS5kaXNhYmxlZCBzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXIgLCAucG9wb3Zlci10aXRsZSwgLnBvcG92ZXItdGl0bGUgOm5vdCguY2xvc2UpXCIsIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaS5jdXJyZW50VGFyZ2V0ID09IHRoaXMgJiYgKGkucHJldmVudERlZmF1bHQoKSwgaS5zdG9wUHJvcGFnYXRpb24oKSwgdC5vcHRpb25zLmxpdmVTZWFyY2ggJiYgIWUoaS50YXJnZXQpLmhhc0NsYXNzKFwiY2xvc2VcIikgPyB0LiRzZWFyY2hib3guZm9jdXMoKSA6IHQuJGJ1dHRvbi5mb2N1cygpKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRtZW51SW5uZXIub24oXCJjbGlja1wiLCBcIi5kaXZpZGVyLCAuZHJvcGRvd24taGVhZGVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCB0Lm9wdGlvbnMubGl2ZVNlYXJjaCA/IHQuJHNlYXJjaGJveC5mb2N1cygpIDogdC4kYnV0dG9uLmZvY3VzKClcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kbWVudS5vbihcImNsaWNrXCIsIFwiLnBvcG92ZXItdGl0bGUgLmNsb3NlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0LiRidXR0b24uY2xpY2soKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRzZWFyY2hib3gub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kbWVudS5vbihcImNsaWNrXCIsIFwiLmFjdGlvbnMtYnRuXCIsIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5vcHRpb25zLmxpdmVTZWFyY2ggPyB0LiRzZWFyY2hib3guZm9jdXMoKSA6IHQuJGJ1dHRvbi5mb2N1cygpLCBpLnByZXZlbnREZWZhdWx0KCksIGkuc3RvcFByb3BhZ2F0aW9uKCksIGUodGhpcykuaGFzQ2xhc3MoXCJicy1zZWxlY3QtYWxsXCIpID8gdC5zZWxlY3RBbGwoKSA6IHQuZGVzZWxlY3RBbGwoKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRlbGVtZW50LmNoYW5nZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5yZW5kZXIoITEpLCB0LiRlbGVtZW50LnRyaWdnZXIoXCJjaGFuZ2VkLmJzLnNlbGVjdFwiLCBzKSwgcyA9IG51bGxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpdmVTZWFyY2hMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBuID0gZSgnPGxpIGNsYXNzPVwibm8tcmVzdWx0c1wiPjwvbGk+Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kYnV0dG9uLm9uKFwiY2xpY2suZHJvcGRvd24uZGF0YS1hcGlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGkuJG1lbnVJbm5lci5maW5kKFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKSwgaS4kc2VhcmNoYm94LnZhbCgpICYmIChpLiRzZWFyY2hib3gudmFsKFwiXCIpLCBpLiRsaXMubm90KFwiLmlzLWhpZGRlblwiKS5yZW1vdmVDbGFzcyhcImhpZGRlblwiKSwgbi5wYXJlbnQoKS5sZW5ndGggJiYgbi5yZW1vdmUoKSksIGkubXVsdGlwbGUgfHwgaS4kbWVudUlubmVyLmZpbmQoXCIuc2VsZWN0ZWRcIikuYWRkQ2xhc3MoXCJhY3RpdmVcIiksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLiRzZWFyY2hib3guZm9jdXMoKVxuICAgICAgICAgICAgICAgICAgICB9LCAxMClcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kc2VhcmNoYm94Lm9uKFwiY2xpY2suZHJvcGRvd24uZGF0YS1hcGkgZm9jdXMuZHJvcGRvd24uZGF0YS1hcGkgdG91Y2hlbmQuZHJvcGRvd24uZGF0YS1hcGlcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuJHNlYXJjaGJveC5vbihcImlucHV0IHByb3BlcnR5Y2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaS4kbGlzLm5vdChcIi5pcy1oaWRkZW5cIikucmVtb3ZlQ2xhc3MoXCJoaWRkZW5cIiksIGkuJGxpcy5maWx0ZXIoXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLCBuLnJlbW92ZSgpLCBpLiRzZWFyY2hib3gudmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzLCBvID0gaS4kbGlzLm5vdChcIi5pcy1oaWRkZW4sIC5kaXZpZGVyLCAuZHJvcGRvd24taGVhZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPSBpLm9wdGlvbnMubGl2ZVNlYXJjaE5vcm1hbGl6ZSA/IG8ubm90KFwiOmFcIiArIGkuX3NlYXJjaFN0eWxlKCkgKyAnKFwiJyArIHQoaS4kc2VhcmNoYm94LnZhbCgpKSArICdcIiknKSA6IG8ubm90KFwiOlwiICsgaS5fc2VhcmNoU3R5bGUoKSArICcoXCInICsgaS4kc2VhcmNoYm94LnZhbCgpICsgJ1wiKScpLCBzLmxlbmd0aCA9PT0gby5sZW5ndGgpIG4uaHRtbChpLm9wdGlvbnMubm9uZVJlc3VsdHNUZXh0LnJlcGxhY2UoXCJ7MH1cIiwgJ1wiJyArIHIoaS4kc2VhcmNoYm94LnZhbCgpKSArICdcIicpKSwgaS4kbWVudUlubmVyLmFwcGVuZChuKSwgaS4kbGlzLmFkZENsYXNzKFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5hZGRDbGFzcyhcImhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgbCA9IGkuJGxpcy5ub3QoXCIuaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwuZWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5oYXNDbGFzcyhcImRpdmlkZXJcIikgPyB2b2lkIDAgPT09IGEgPyBpLmFkZENsYXNzKFwiaGlkZGVuXCIpIDogKGEgJiYgYS5hZGRDbGFzcyhcImhpZGRlblwiKSwgYSA9IGkpIDogaS5oYXNDbGFzcyhcImRyb3Bkb3duLWhlYWRlclwiKSAmJiBsLmVxKHQgKyAxKS5kYXRhKFwib3B0Z3JvdXBcIikgIT09IGkuZGF0YShcIm9wdGdyb3VwXCIpID8gaS5hZGRDbGFzcyhcImhpZGRlblwiKSA6IGEgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGEgJiYgYS5hZGRDbGFzcyhcImhpZGRlblwiKSwgby5ub3QoXCIuaGlkZGVuXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXCJhY3RpdmVcIiksIGkuJG1lbnVJbm5lci5zY3JvbGxUb3AoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NlYXJjaFN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5zOiBcImliZWdpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRzV2l0aDogXCJpYmVnaW5zXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBlW3RoaXMub3B0aW9ucy5saXZlU2VhcmNoU3R5bGVdIHx8IFwiaWNvbnRhaW5zXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZSA/ICh0aGlzLiRlbGVtZW50LnZhbChlKSwgdGhpcy5yZW5kZXIoKSwgdGhpcy4kZWxlbWVudCkgOiB0aGlzLiRlbGVtZW50LnZhbCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhbmdlQWxsOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgdCAmJiAodCA9ICEwKSwgdGhpcy5maW5kTGlzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy4kZWxlbWVudC5maW5kKFwib3B0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMuJGxpcy5ub3QoXCIuZGl2aWRlciwgLmRyb3Bkb3duLWhlYWRlciwgLmRpc2FibGVkLCAuaGlkZGVuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IG4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4uZmlsdGVyKFwiLnNlbGVjdGVkXCIpLmxlbmd0aCA9PT0gbi5sZW5ndGgpIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDAgPT09IG4uZmlsdGVyKFwiLnNlbGVjdGVkXCIpLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBuLnRvZ2dsZUNsYXNzKFwic2VsZWN0ZWRcIiwgdCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBzID4gYTsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IG5bYV0uZ2V0QXR0cmlidXRlKFwiZGF0YS1vcmlnaW5hbC1pbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9bby5sZW5ndGhdID0gaS5lcShsKVswXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUobykucHJvcChcInNlbGVjdGVkXCIsIHQpLCB0aGlzLnJlbmRlcighMSksIHRoaXMudG9nZ2xlUGxhY2Vob2xkZXIoKSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyTmF0aXZlKFwiY2hhbmdlXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQWxsKCEwKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VBbGwoITEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50LCBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCksIHRoaXMuJGJ1dHRvbi50cmlnZ2VyKFwiY2xpY2tcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlkb3duOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIG4sIHMsIG8sIGEgPSBlKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBsID0gYS5pcyhcImlucHV0XCIpID8gYS5wYXJlbnQoKS5wYXJlbnQoKSA6IGEucGFyZW50KCksXG4gICAgICAgICAgICAgICAgICAgIHIgPSBsLmRhdGEoXCJ0aGlzXCIpLFxuICAgICAgICAgICAgICAgICAgICBkID0gXCI6bm90KC5kaXNhYmxlZCwgLmhpZGRlbiwgLmRyb3Bkb3duLWhlYWRlciwgLmRpdmlkZXIpXCIsXG4gICAgICAgICAgICAgICAgICAgIGggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAzMjogXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA0ODogXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA0OTogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1MDogXCIyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1MTogXCIzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1MjogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1MzogXCI1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1NDogXCI2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1NTogXCI3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1NjogXCI4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1NzogXCI5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA1OTogXCI7XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA2NTogXCJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA2NjogXCJiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA2NzogXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA2ODogXCJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA2OTogXCJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3MDogXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3MTogXCJnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3MjogXCJoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3MzogXCJpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3NDogXCJqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3NTogXCJrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3NjogXCJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3NzogXCJtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3ODogXCJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA3OTogXCJvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4MDogXCJwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4MTogXCJxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4MjogXCJyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4MzogXCJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4NDogXCJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4NTogXCJ1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4NjogXCJ2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4NzogXCJ3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4ODogXCJ4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA4OTogXCJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA5MDogXCJ6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA5NjogXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA5NzogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA5ODogXCIyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICA5OTogXCIzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDA6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAxOiBcIjVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMjogXCI2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDM6IFwiN1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTA0OiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwNTogXCI5XCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobyA9IHIuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoXCJvcGVuXCIpLCAhbyAmJiAodC5rZXlDb2RlID49IDQ4ICYmIHQua2V5Q29kZSA8PSA1NyB8fCB0LmtleUNvZGUgPj0gOTYgJiYgdC5rZXlDb2RlIDw9IDEwNSB8fCB0LmtleUNvZGUgPj0gNjUgJiYgdC5rZXlDb2RlIDw9IDkwKSkgcmV0dXJuIHIub3B0aW9ucy5jb250YWluZXIgPyByLiRidXR0b24udHJpZ2dlcihcImNsaWNrXCIpIDogKHIuc2V0U2l6ZSgpLCByLiRtZW51LnBhcmVudCgpLmFkZENsYXNzKFwib3BlblwiKSwgbyA9ICEwKSwgdm9pZCByLiRzZWFyY2hib3guZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoci5vcHRpb25zLmxpdmVTZWFyY2ggJiYgLyheOSR8MjcpLy50ZXN0KHQua2V5Q29kZS50b1N0cmluZygxMCkpICYmIG8gJiYgKHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSwgci4kbWVudUlubmVyLmNsaWNrKCksIHIuJGJ1dHRvbi5mb2N1cygpKSwgLygzOHw0MCkvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPSByLiRsaXMuZmlsdGVyKGQpLCAhaS5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHIub3B0aW9ucy5saXZlU2VhcmNoID8gaS5pbmRleChpLmZpbHRlcihcIi5hY3RpdmVcIikpIDogaS5pbmRleChpLmZpbmQoXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIikuZmlsdGVyKFwiOmZvY3VzXCIpLnBhcmVudCgpKSwgcyA9IHIuJG1lbnVJbm5lci5kYXRhKFwicHJldkluZGV4XCIpLCAzOCA9PSB0LmtleUNvZGUgPyAoIXIub3B0aW9ucy5saXZlU2VhcmNoICYmIG4gIT0gcyB8fCAtMSA9PSBuIHx8IG4tLSwgMCA+IG4gJiYgKG4gKz0gaS5sZW5ndGgpKSA6IDQwID09IHQua2V5Q29kZSAmJiAoKHIub3B0aW9ucy5saXZlU2VhcmNoIHx8IG4gPT0gcykgJiYgbisrLCBuICU9IGkubGVuZ3RoKSwgci4kbWVudUlubmVyLmRhdGEoXCJwcmV2SW5kZXhcIiwgbiksIHIub3B0aW9ucy5saXZlU2VhcmNoID8gKHQucHJldmVudERlZmF1bHQoKSwgYS5oYXNDbGFzcyhcImRyb3Bkb3duLXRvZ2dsZVwiKSB8fCAoaS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKS5lcShuKS5hZGRDbGFzcyhcImFjdGl2ZVwiKS5jaGlsZHJlbihcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKS5mb2N1cygpLCBhLmZvY3VzKCkpKSA6IGkuZXEobikuY2hpbGRyZW4oXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIikuZm9jdXMoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWEuaXMoXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYywgcCwgdSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpID0gci4kbGlzLmZpbHRlcihkKSwgaS5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudHJpbShlKHRoaXMpLmNoaWxkcmVuKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLnRleHQoKS50b0xvd2VyQ2FzZSgpKS5zdWJzdHJpbmcoMCwgMSkgPT0gaFt0LmtleUNvZGVdICYmIHUucHVzaChpKVxuICAgICAgICAgICAgICAgICAgICB9KSwgYyA9IGUoZG9jdW1lbnQpLmRhdGEoXCJrZXljb3VudFwiKSwgYysrLCBlKGRvY3VtZW50KS5kYXRhKFwia2V5Y291bnRcIiwgYyksIHAgPSBlLnRyaW0oZShcIjpmb2N1c1wiKS50ZXh0KCkudG9Mb3dlckNhc2UoKSkuc3Vic3RyaW5nKDAsIDEpLCBwICE9IGhbdC5rZXlDb2RlXSA/IChjID0gMSwgZShkb2N1bWVudCkuZGF0YShcImtleWNvdW50XCIsIGMpKSA6IGMgPj0gdS5sZW5ndGggJiYgKGUoZG9jdW1lbnQpLmRhdGEoXCJrZXljb3VudFwiLCAwKSwgYyA+IHUubGVuZ3RoICYmIChjID0gMSkpLCBpLmVxKHVbYyAtIDFdKS5jaGlsZHJlbihcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKS5mb2N1cygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoLygxM3wzMikvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgfHwgLyheOSQpLy50ZXN0KHQua2V5Q29kZS50b1N0cmluZygxMCkpICYmIHIub3B0aW9ucy5zZWxlY3RPblRhYikgJiYgbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLygzMikvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgfHwgdC5wcmV2ZW50RGVmYXVsdCgpLCByLm9wdGlvbnMubGl2ZVNlYXJjaCkgLygzMikvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgfHwgKHIuJG1lbnVJbm5lci5maW5kKFwiLmFjdGl2ZSBhXCIpLmNsaWNrKCksIGEuZm9jdXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBlKFwiOmZvY3VzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5jbGljaygpLCBmLmZvY3VzKCksIHQucHJldmVudERlZmF1bHQoKSwgZShkb2N1bWVudCkuZGF0YShcInNwYWNlU2VsZWN0XCIsICEwKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUoZG9jdW1lbnQpLmRhdGEoXCJrZXljb3VudFwiLCAwKVxuICAgICAgICAgICAgICAgIH0oLyheOSR8MjcpLy50ZXN0KHQua2V5Q29kZS50b1N0cmluZygxMCkpICYmIG8gJiYgKHIubXVsdGlwbGUgfHwgci5vcHRpb25zLmxpdmVTZWFyY2gpIHx8IC8oMjcpLy50ZXN0KHQua2V5Q29kZS50b1N0cmluZygxMCkpICYmICFvKSAmJiAoci4kbWVudS5wYXJlbnQoKS5yZW1vdmVDbGFzcyhcIm9wZW5cIiksIHIub3B0aW9ucy5jb250YWluZXIgJiYgci4kbmV3RWxlbWVudC5yZW1vdmVDbGFzcyhcIm9wZW5cIiksIHIuJGJ1dHRvbi5mb2N1cygpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vYmlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcIm1vYmlsZS1kZXZpY2VcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRsaXMgPSBudWxsLCB0aGlzLmxpT2JqID0ge30sIHRoaXMucmVsb2FkTGkoKSwgdGhpcy5yZW5kZXIoKSwgdGhpcy5jaGVja0Rpc2FibGVkKCksIHRoaXMubGlIZWlnaHQoITApLCB0aGlzLnNldFN0eWxlKCksIHRoaXMuc2V0V2lkdGgoKSwgdGhpcy4kbGlzICYmIHRoaXMuJHNlYXJjaGJveC50cmlnZ2VyKFwicHJvcGVydHljaGFuZ2VcIiksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInJlZnJlc2hlZC5icy5zZWxlY3RcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmhpZGUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5ld0VsZW1lbnQuc2hvdygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXdFbGVtZW50LnJlbW92ZSgpLCB0aGlzLiRlbGVtZW50LnJlbW92ZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5iZWZvcmUodGhpcy4kZWxlbWVudCkucmVtb3ZlKCksIHRoaXMuJGJzQ29udGFpbmVyID8gdGhpcy4kYnNDb250YWluZXIucmVtb3ZlKCkgOiB0aGlzLiRtZW51LnJlbW92ZSgpLCB0aGlzLiRlbGVtZW50Lm9mZihcIi5icy5zZWxlY3RcIikucmVtb3ZlRGF0YShcInNlbGVjdHBpY2tlclwiKS5yZW1vdmVDbGFzcyhcImJzLXNlbGVjdC1oaWRkZW4gc2VsZWN0cGlja2VyXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjID0gZS5mbi5zZWxlY3RwaWNrZXI7XG4gICAgICAgIGUuZm4uc2VsZWN0cGlja2VyID0gaSwgZS5mbi5zZWxlY3RwaWNrZXIuQ29uc3RydWN0b3IgPSBoLCBlLmZuLnNlbGVjdHBpY2tlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5mbi5zZWxlY3RwaWNrZXIgPSBjLCB0aGlzXG4gICAgICAgIH0sIGUoZG9jdW1lbnQpLmRhdGEoXCJrZXljb3VudFwiLCAwKS5vbihcImtleWRvd24uYnMuc2VsZWN0XCIsICcuYm9vdHN0cmFwLXNlbGVjdCBbZGF0YS10b2dnbGU9ZHJvcGRvd25dLCAuYm9vdHN0cmFwLXNlbGVjdCBbcm9sZT1cImxpc3Rib3hcIl0sIC5icy1zZWFyY2hib3ggaW5wdXQnLCBoLnByb3RvdHlwZS5rZXlkb3duKS5vbihcImZvY3VzaW4ubW9kYWxcIiwgJy5ib290c3RyYXAtc2VsZWN0IFtkYXRhLXRvZ2dsZT1kcm9wZG93bl0sIC5ib290c3RyYXAtc2VsZWN0IFtyb2xlPVwibGlzdGJveFwiXSwgLmJzLXNlYXJjaGJveCBpbnB1dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgfSksIGUod2luZG93KS5vbihcImxvYWQuYnMuc2VsZWN0LmRhdGEtYXBpXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZShcIi5zZWxlY3RwaWNrZXJcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaS5jYWxsKHQsIHQuZGF0YSgpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KGUpXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2Jvb3RzdHJhcC1zZWxlY3QuanMiLCIvKiFcbiAqIENoYXJ0LmpzXG4gKiBodHRwOi8vY2hhcnRqcy5vcmcvXG4gKiBWZXJzaW9uOiAyLjcuMFxuICpcbiAqIENvcHlyaWdodCAyMDE3IE5pY2sgRG93bmllXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuQ2hhcnQgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb2xvck5hbWVzID0gcmVxdWlyZSg2KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59XG5cbmZ1bmN0aW9uIGdldFJnYmEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezN9KSQvaSxcbiAgICAgICBoZXggPSAgL14jKFthLWZBLUYwLTldezZ9KSQvaSxcbiAgICAgICByZ2JhID0gL15yZ2JhP1xcKFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBrZXl3b3JkID0gLyhcXHcrKS87XG5cbiAgIHZhciByZ2IgPSBbMCwgMCwgMF0sXG4gICAgICAgYSA9IDEsXG4gICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJicik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZXNbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGwgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICB3ID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgYiA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCB3LCBiLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmdiKHN0cmluZykge1xuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICByZXR1cm4gcmdiYSAmJiByZ2JhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRIc2woc3RyaW5nKSB7XG4gIHZhciBoc2xhID0gZ2V0SHNsYShzdHJpbmcpO1xuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcbiAgIHZhciB2YWxzID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgaWYgKHZhbHMpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEhzbGEoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHdiKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxufVxuXG4vLyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBoZXhTdHJpbmcocmdiKSB7XG4gICByZXR1cm4gXCIjXCIgKyBoZXhEb3VibGUocmdiWzBdKSArIGhleERvdWJsZShyZ2JbMV0pXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYlsyXSk7XG59XG5cbmZ1bmN0aW9uIHJnYlN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYihcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAocmdiYVszXSAhPT0gdW5kZWZpbmVkID8gcmdiYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxuICAgICAgICAgICArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcbiAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSwgXCIgKyAoYWxwaGEgfHwgcmdiYVszXSB8fCAxKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKGhzbGFbM10gJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHNsYVszXSAhPT0gdW5kZWZpbmVkID8gaHNsYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXG4gICAgICAgICAgICsgYWxwaGEgKyBcIilcIjtcbn1cblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHdiWzNdICE9PSB1bmRlZmluZWQgPyBod2JbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImh3YihcIiArIGh3YlswXSArIFwiLCBcIiArIGh3YlsxXSArIFwiJSwgXCIgKyBod2JbMl0gKyBcIiVcIlxuICAgICAgICAgICArIChhbHBoYSAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSAxID8gXCIsIFwiICsgYWxwaGEgOiBcIlwiKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHNjYWxlKG51bSwgbWluLCBtYXgpIHtcbiAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyBcIjBcIiArIHN0ciA6IHN0cjtcbn1cblxuXG4vL2NyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWVzKSB7XG4gICByZXZlcnNlTmFtZXNbY29sb3JOYW1lc1tuYW1lXV0gPSBuYW1lO1xufVxuXG59LHtcIjZcIjo2fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBNSVQgbGljZW5zZSAqL1xudmFyIGNvbnZlcnQgPSByZXF1aXJlKDUpO1xudmFyIHN0cmluZyA9IHJlcXVpcmUoMik7XG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmopO1xuXHR9XG5cblx0dGhpcy52YWxpZCA9IGZhbHNlO1xuXHR0aGlzLnZhbHVlcyA9IHtcblx0XHRyZ2I6IFswLCAwLCAwXSxcblx0XHRoc2w6IFswLCAwLCAwXSxcblx0XHRoc3Y6IFswLCAwLCAwXSxcblx0XHRod2I6IFswLCAwLCAwXSxcblx0XHRjbXlrOiBbMCwgMCwgMCwgMF0sXG5cdFx0YWxwaGE6IDFcblx0fTtcblxuXHQvLyBwYXJzZSBDb2xvcigpIGFyZ3VtZW50XG5cdHZhciB2YWxzO1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YWxzID0gc3RyaW5nLmdldFJnYmEob2JqKTtcblx0XHRpZiAodmFscykge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscyA9IHN0cmluZy5nZXRIc2xhKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBzdHJpbmcuZ2V0SHdiKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcblx0XHR2YWxzID0gb2JqO1xuXHRcdGlmICh2YWxzLnIgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmwgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLnYgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc3YnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMud2hpdGVuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMuYyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMuY3lhbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnY215aycsIHZhbHMpO1xuXHRcdH1cblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdH0sXG5cdHJnYjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdyZ2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc2w6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHNsJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHN2OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzdicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGh3YjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdod2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjbXlrOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2NteWsnLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHJnYkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLnJnYjtcblx0fSxcblx0aHNsQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHNsO1xuXHR9LFxuXHRoc3ZBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc3Y7XG5cdH0sXG5cdGh3YkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHRcdHJldHVybiB2YWx1ZXMuaHdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXMuaHdiO1xuXHR9LFxuXHRjbXlrQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuY215aztcblx0fSxcblx0cmdiYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMucmdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGhzbGFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLmhzbC5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCB2YWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDAsIHZhbCk7XG5cdH0sXG5cdGdyZWVuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMSwgdmFsKTtcblx0fSxcblx0Ymx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDIsIHZhbCk7XG5cdH0sXG5cdGh1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHZhbCAlPSAzNjA7XG5cdFx0XHR2YWwgPSB2YWwgPCAwID8gMzYwICsgdmFsIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAwLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9uOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMSwgdmFsKTtcblx0fSxcblx0bGlnaHRuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMiwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbnY6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAxLCB2YWwpO1xuXHR9LFxuXHR3aGl0ZW5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibGFja25lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAyLCB2YWwpO1xuXHR9LFxuXHR2YWx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDIsIHZhbCk7XG5cdH0sXG5cdGN5YW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMCwgdmFsKTtcblx0fSxcblx0bWFnZW50YTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAxLCB2YWwpO1xuXHR9LFxuXHR5ZWxsb3c6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMiwgdmFsKTtcblx0fSxcblx0YmxhY2s6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMywgdmFsKTtcblx0fSxcblxuXHRoZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLmhleFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IpO1xuXHR9LFxuXHRyZ2JTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cmdiYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcucGVyY2VudFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHNsU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbGFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGh3YlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcuaHdiU3RyaW5nKHRoaXMudmFsdWVzLmh3YiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRrZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXG5cdHJnYk51bWJlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0cmV0dXJuIChyZ2JbMF0gPDwgMTYpIHwgKHJnYlsxXSA8PCA4KSB8IHJnYlsyXTtcblx0fSxcblxuXHRsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIGx1bSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhbiA9IHJnYltpXSAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDM5MjgpID8gY2hhbiAvIDEyLjkyIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdHZhciBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0dmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuXHRcdGlmIChsdW0xID4gbHVtMikge1xuXHRcdFx0cmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuXHRcdH1cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWw6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHR2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3LjEpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRkYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIHlpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMDtcblx0XHRyZXR1cm4geWlxIDwgMTI4O1xuXHR9LFxuXG5cdGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRhcmsoKTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IDI1NSAtIHRoaXMudmFsdWVzLnJnYltpXTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHJnYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0bGlnaHRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gKz0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGFya2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSAtPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gKz0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGVzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gLT0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d2hpdGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsxXSArPSBod2JbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRibGFja2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsyXSArPSBod2JbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRncmV5c2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0dmFyIHZhbCA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCBbdmFsLCB2YWwsIHZhbF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhIC0gKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvcGFxdWVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSArIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0dmFyIGh1ZSA9IChoc2xbMF0gKyBkZWdyZWVzKSAlIDM2MDtcblx0XHRoc2xbMF0gPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdCAqL1xuXHRtaXg6IGZ1bmN0aW9uIChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHR2YXIgY29sb3IxID0gdGhpcztcblx0XHR2YXIgY29sb3IyID0gbWl4aW5Db2xvcjtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5yZ2IoXG5cdFx0XHRcdHcxICogY29sb3IxLnJlZCgpICsgdzIgKiBjb2xvcjIucmVkKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ibHVlKCkgKyB3MiAqIGNvbG9yMi5ibHVlKClcblx0XHRcdClcblx0XHRcdC5hbHBoYShjb2xvcjEuYWxwaGEoKSAqIHAgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gcCkpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJnYigpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gTk9URShTQik6IHVzaW5nIG5vZGUtY2xvbmUgY3JlYXRlcyBhIGRlcGVuZGVuY3kgdG8gQnVmZmVyIHdoZW4gdXNpbmcgYnJvd3NlcmlmeSxcblx0XHQvLyBtYWtpbmcgdGhlIGZpbmFsIGJ1aWxkIHdheSB0byBiaWcgdG8gZW1iZWQgaW4gQ2hhcnQuanMuIFNvIGxldCdzIGRvIGl0IG1hbnVhbGx5LFxuXHRcdC8vIGFzc3VtaW5nIHRoYXQgdmFsdWVzIHRvIGNsb25lIGFyZSAxIGRpbWVuc2lvbiBhcnJheXMgY29udGFpbmluZyBvbmx5IG51bWJlcnMsXG5cdFx0Ly8gZXhjZXB0ICdhbHBoYScgd2hpY2ggaXMgYSBudW1iZXIuXG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb2xvcigpO1xuXHRcdHZhciBzb3VyY2UgPSB0aGlzLnZhbHVlcztcblx0XHR2YXIgdGFyZ2V0ID0gcmVzdWx0LnZhbHVlcztcblx0XHR2YXIgdmFsdWUsIHR5cGU7XG5cblx0XHRmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcblx0XHRcdFx0dHlwZSA9ICh7fSkudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWUuc2xpY2UoMCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCd1bmV4cGVjdGVkIGNvbG9yIHZhbHVlOicsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zcGFjZXMgPSB7XG5cdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdGhzdjogWydodWUnLCAnc2F0dXJhdGlvbicsICd2YWx1ZSddLFxuXHRod2I6IFsnaHVlJywgJ3doaXRlbmVzcycsICdibGFja25lc3MnXSxcblx0Y215azogWydjeWFuJywgJ21hZ2VudGEnLCAneWVsbG93JywgJ2JsYWNrJ11cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5tYXhlcyA9IHtcblx0cmdiOiBbMjU1LCAyNTUsIDI1NV0sXG5cdGhzbDogWzM2MCwgMTAwLCAxMDBdLFxuXHRoc3Y6IFszNjAsIDEwMCwgMTAwXSxcblx0aHdiOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGNteWs6IFsxMDAsIDEwMCwgMTAwLCAxMDBdXG59O1xuXG5Db2xvci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHZhbHMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFsc1tzcGFjZS5jaGFyQXQoaSldID0gdmFsdWVzW3NwYWNlXVtpXTtcblx0fVxuXG5cdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHR2YWxzLmEgPSB2YWx1ZXMuYWxwaGE7XG5cdH1cblxuXHQvLyB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMC40fVxuXHRyZXR1cm4gdmFscztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UsIHZhbHMpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXM7XG5cdHZhciBtYXhlcyA9IHRoaXMubWF4ZXM7XG5cdHZhciBhbHBoYSA9IDE7XG5cdHZhciBpO1xuXG5cdHRoaXMudmFsaWQgPSB0cnVlO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdGFscGhhID0gdmFscztcblx0fSBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuXHRcdC8vIFsxMCwgMTAsIDEwXVxuXHRcdHZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG5cdFx0YWxwaGEgPSB2YWxzW3NwYWNlLmxlbmd0aF07XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZS5jaGFyQXQoMCldICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cjogMTAsIGc6IDEwLCBiOiAxMH1cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlLmNoYXJBdChpKV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmE7XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3JlZDogMTAsIGdyZWVuOiAxMCwgYmx1ZTogMTB9XG5cdFx0dmFyIGNoYW5zID0gc3BhY2VzW3NwYWNlXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hbHBoYTtcblx0fVxuXG5cdHZhbHVlcy5hbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChhbHBoYSA9PT0gdW5kZWZpbmVkID8gdmFsdWVzLmFscGhhIDogYWxwaGEpKSk7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNhcHBlZDtcblxuXHQvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcblx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2FwcGVkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4ZXNbc3BhY2VdW2ldLCB2YWx1ZXNbc3BhY2VdW2ldKSk7XG5cdFx0dmFsdWVzW3NwYWNlXVtpXSA9IE1hdGgucm91bmQoY2FwcGVkKTtcblx0fVxuXG5cdC8vIGNvbnZlcnQgdG8gYWxsIHRoZSBvdGhlciBjb2xvciBzcGFjZXNcblx0Zm9yICh2YXIgc25hbWUgaW4gc3BhY2VzKSB7XG5cdFx0aWYgKHNuYW1lICE9PSBzcGFjZSkge1xuXHRcdFx0dmFsdWVzW3NuYW1lXSA9IGNvbnZlcnRbc3BhY2VdW3NuYW1lXSh2YWx1ZXNbc3BhY2VdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSwgYXJncykge1xuXHR2YXIgdmFscyA9IGFyZ3NbMF07XG5cblx0aWYgKHZhbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJnYigpXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcblx0fVxuXG5cdC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuXHRpZiAodHlwZW9mIHZhbHMgPT09ICdudW1iZXInKSB7XG5cdFx0dmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHR9XG5cblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24gKHNwYWNlLCBpbmRleCwgdmFsKSB7XG5cdHZhciBzdmFsdWVzID0gdGhpcy52YWx1ZXNbc3BhY2VdO1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZWQoKVxuXHRcdHJldHVybiBzdmFsdWVzW2luZGV4XTtcblx0fSBlbHNlIGlmICh2YWwgPT09IHN2YWx1ZXNbaW5kZXhdKSB7XG5cdFx0Ly8gY29sb3IucmVkKGNvbG9yLnJlZCgpKVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gY29sb3IucmVkKDEwMClcblx0c3ZhbHVlc1tpbmRleF0gPSB2YWw7XG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCBzdmFsdWVzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuQ29sb3IgPSBDb2xvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxufSx7XCIyXCI6MixcIjVcIjo1fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBNSVQgbGljZW5zZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmdiMmhzbDogcmdiMmhzbCxcbiAgcmdiMmhzdjogcmdiMmhzdixcbiAgcmdiMmh3YjogcmdiMmh3YixcbiAgcmdiMmNteWs6IHJnYjJjbXlrLFxuICByZ2Iya2V5d29yZDogcmdiMmtleXdvcmQsXG4gIHJnYjJ4eXo6IHJnYjJ4eXosXG4gIHJnYjJsYWI6IHJnYjJsYWIsXG4gIHJnYjJsY2g6IHJnYjJsY2gsXG5cbiAgaHNsMnJnYjogaHNsMnJnYixcbiAgaHNsMmhzdjogaHNsMmhzdixcbiAgaHNsMmh3YjogaHNsMmh3YixcbiAgaHNsMmNteWs6IGhzbDJjbXlrLFxuICBoc2wya2V5d29yZDogaHNsMmtleXdvcmQsXG5cbiAgaHN2MnJnYjogaHN2MnJnYixcbiAgaHN2MmhzbDogaHN2MmhzbCxcbiAgaHN2Mmh3YjogaHN2Mmh3YixcbiAgaHN2MmNteWs6IGhzdjJjbXlrLFxuICBoc3Yya2V5d29yZDogaHN2MmtleXdvcmQsXG5cbiAgaHdiMnJnYjogaHdiMnJnYixcbiAgaHdiMmhzbDogaHdiMmhzbCxcbiAgaHdiMmhzdjogaHdiMmhzdixcbiAgaHdiMmNteWs6IGh3YjJjbXlrLFxuICBod2Iya2V5d29yZDogaHdiMmtleXdvcmQsXG5cbiAgY215azJyZ2I6IGNteWsycmdiLFxuICBjbXlrMmhzbDogY215azJoc2wsXG4gIGNteWsyaHN2OiBjbXlrMmhzdixcbiAgY215azJod2I6IGNteWsyaHdiLFxuICBjbXlrMmtleXdvcmQ6IGNteWsya2V5d29yZCxcblxuICBrZXl3b3JkMnJnYjoga2V5d29yZDJyZ2IsXG4gIGtleXdvcmQyaHNsOiBrZXl3b3JkMmhzbCxcbiAga2V5d29yZDJoc3Y6IGtleXdvcmQyaHN2LFxuICBrZXl3b3JkMmh3Yjoga2V5d29yZDJod2IsXG4gIGtleXdvcmQyY215azoga2V5d29yZDJjbXlrLFxuICBrZXl3b3JkMmxhYjoga2V5d29yZDJsYWIsXG4gIGtleXdvcmQyeHl6OiBrZXl3b3JkMnh5eixcblxuICB4eXoycmdiOiB4eXoycmdiLFxuICB4eXoybGFiOiB4eXoybGFiLFxuICB4eXoybGNoOiB4eXoybGNoLFxuXG4gIGxhYjJ4eXo6IGxhYjJ4eXosXG4gIGxhYjJyZ2I6IGxhYjJyZ2IsXG4gIGxhYjJsY2g6IGxhYjJsY2gsXG5cbiAgbGNoMmxhYjogbGNoMmxhYixcbiAgbGNoMnh5ejogbGNoMnh5eixcbiAgbGNoMnJnYjogbGNoMnJnYlxufVxuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZSg0KTtcblxudmFyIGNvbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgQ29udmVydGVyKCk7XG59XG5cbmZvciAodmFyIGZ1bmMgaW4gY29udmVyc2lvbnMpIHtcbiAgLy8gZXhwb3J0IFJhdyB2ZXJzaW9uc1xuICBjb252ZXJ0W2Z1bmMgKyBcIlJhd1wiXSA9ICAoZnVuY3Rpb24oZnVuYykge1xuICAgIC8vIGFjY2VwdCBhcnJheSBvciBwbGFpbiBhcmdzXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgIH1cbiAgfSkoZnVuYyk7XG5cbiAgdmFyIHBhaXIgPSAvKFxcdyspMihcXHcrKS8uZXhlYyhmdW5jKSxcbiAgICAgIGZyb20gPSBwYWlyWzFdLFxuICAgICAgdG8gPSBwYWlyWzJdO1xuXG4gIC8vIGV4cG9ydCByZ2IyaHNsIGFuZCBbXCJyZ2JcIl1bXCJoc2xcIl1cbiAgY29udmVydFtmcm9tXSA9IGNvbnZlcnRbZnJvbV0gfHwge307XG5cbiAgY29udmVydFtmcm9tXVt0b10gPSBjb252ZXJ0W2Z1bmNdID0gKGZ1bmN0aW9uKGZ1bmMpIHsgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIFxuICAgICAgdmFyIHZhbCA9IGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiIHx8IHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdmFsOyAvLyBrZXl3b3JkXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKVxuICAgICAgICB2YWxbaV0gPSBNYXRoLnJvdW5kKHZhbFtpXSk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSkoZnVuYyk7XG59XG5cblxuLyogQ29udmVydGVyIGRvZXMgbGF6eSBjb252ZXJzaW9uIGFuZCBjYWNoaW5nICovXG52YXIgQ29udmVydGVyID0gZnVuY3Rpb24oKSB7XG4gICB0aGlzLmNvbnZzID0ge307XG59O1xuXG4vKiBFaXRoZXIgZ2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2Ugb3JcbiAgc2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGRlcGVuZGluZyBvbiBhcmdzICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnJvdXRlU3BhY2UgPSBmdW5jdGlvbihzcGFjZSwgYXJncykge1xuICAgdmFyIHZhbHVlcyA9IGFyZ3NbMF07XG4gICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHVlcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTsgICAgICAgIFxuICAgfVxuXG4gICByZXR1cm4gdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHVlcyk7XG59O1xuICBcbi8qIFNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBpbnZhbGlkYXRpbmcgY2FjaGUgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UsIHZhbHVlcykge1xuICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgdGhpcy5jb252cyA9IHt9O1xuICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWx1ZXM7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qIEdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLiBJZiB0aGVyZSdzIGFscmVhZHlcbiAgYSBjb252ZXJzaW9uIGZvciB0aGUgc3BhY2UsIGZldGNoIGl0LCBvdGhlcndpc2VcbiAgY29tcHV0ZSBpdCAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSkge1xuICAgdmFyIHZhbHMgPSB0aGlzLmNvbnZzW3NwYWNlXTtcbiAgIGlmICghdmFscykge1xuICAgICAgdmFyIGZzcGFjZSA9IHRoaXMuc3BhY2UsXG4gICAgICAgICAgZnJvbSA9IHRoaXMuY29udnNbZnNwYWNlXTtcbiAgICAgIHZhbHMgPSBjb252ZXJ0W2ZzcGFjZV1bc3BhY2VdKGZyb20pO1xuXG4gICAgICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHM7XG4gICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuW1wicmdiXCIsIFwiaHNsXCIsIFwiaHN2XCIsIFwiY215a1wiLCBcImtleXdvcmRcIl0uZm9yRWFjaChmdW5jdGlvbihzcGFjZSkge1xuICAgQ29udmVydGVyLnByb3RvdHlwZVtzcGFjZV0gPSBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3V0ZVNwYWNlKHNwYWNlLCBhcmd1bWVudHMpO1xuICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcbn0se1wiNFwiOjR9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXG5cdFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcblx0XCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXG5cdFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcblx0XCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxuXHRcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXG5cdFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXG5cdFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXG5cdFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxuXHRcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXG5cdFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcblx0XCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXG5cdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxuXHRcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXG5cdFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcblx0XCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcblx0XCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxuXHRcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXG5cdFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXG5cdFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxuXHRcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxuXHRcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXG5cdFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxuXHRcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxuXHRcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcblx0XCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxuXHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcblx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXG5cdFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcblx0XCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcblx0XCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcblx0XCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxuXHRcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxuXHRcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcblx0XCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXG5cdFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXG5cdFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxuXHRcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxuXHRcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcblx0XCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcblx0XCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxuXHRcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXG5cdFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcblx0XCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxuXHRcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXG5cdFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXG5cdFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXG5cdFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXG5cdFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcblx0XCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxufTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnRcbiAqL1xudmFyIENoYXJ0ID0gcmVxdWlyZSgyOSkoKTtcblxuQ2hhcnQuaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG4vLyBAdG9kbyBkaXNwYXRjaCB0aGVzZSBoZWxwZXJzIGludG8gYXBwcm9wcmlhdGVkIGhlbHBlcnMvaGVscGVycy4qIGZpbGUgYW5kIHdyaXRlIHVuaXQgdGVzdHMhXG5yZXF1aXJlKDI3KShDaGFydCk7XG5cbkNoYXJ0LmRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG5DaGFydC5FbGVtZW50ID0gcmVxdWlyZSgyNik7XG5DaGFydC5lbGVtZW50cyA9IHJlcXVpcmUoNDApO1xuQ2hhcnQuSW50ZXJhY3Rpb24gPSByZXF1aXJlKDI4KTtcbkNoYXJ0LnBsYXRmb3JtID0gcmVxdWlyZSg0OCk7XG5cbnJlcXVpcmUoMzEpKENoYXJ0KTtcbnJlcXVpcmUoMjIpKENoYXJ0KTtcbnJlcXVpcmUoMjMpKENoYXJ0KTtcbnJlcXVpcmUoMjQpKENoYXJ0KTtcbnJlcXVpcmUoMzApKENoYXJ0KTtcbnJlcXVpcmUoMzMpKENoYXJ0KTtcbnJlcXVpcmUoMzIpKENoYXJ0KTtcbnJlcXVpcmUoMzUpKENoYXJ0KTtcblxucmVxdWlyZSg1NCkoQ2hhcnQpO1xucmVxdWlyZSg1MikoQ2hhcnQpO1xucmVxdWlyZSg1MykoQ2hhcnQpO1xucmVxdWlyZSg1NSkoQ2hhcnQpO1xucmVxdWlyZSg1NikoQ2hhcnQpO1xucmVxdWlyZSg1NykoQ2hhcnQpO1xuXG4vLyBDb250cm9sbGVycyBtdXN0IGJlIGxvYWRlZCBhZnRlciBlbGVtZW50c1xuLy8gU2VlIENoYXJ0LmNvcmUuZGF0YXNldENvbnRyb2xsZXIuZGF0YUVsZW1lbnRUeXBlXG5yZXF1aXJlKDE1KShDaGFydCk7XG5yZXF1aXJlKDE2KShDaGFydCk7XG5yZXF1aXJlKDE3KShDaGFydCk7XG5yZXF1aXJlKDE4KShDaGFydCk7XG5yZXF1aXJlKDE5KShDaGFydCk7XG5yZXF1aXJlKDIwKShDaGFydCk7XG5yZXF1aXJlKDIxKShDaGFydCk7XG5cbnJlcXVpcmUoOCkoQ2hhcnQpO1xucmVxdWlyZSg5KShDaGFydCk7XG5yZXF1aXJlKDEwKShDaGFydCk7XG5yZXF1aXJlKDExKShDaGFydCk7XG5yZXF1aXJlKDEyKShDaGFydCk7XG5yZXF1aXJlKDEzKShDaGFydCk7XG5yZXF1aXJlKDE0KShDaGFydCk7XG5cbi8vIExvYWRpbmcgYnVpbHQtaXQgcGx1Z2luc1xudmFyIHBsdWdpbnMgPSBbXTtcblxucGx1Z2lucy5wdXNoKFxuXHRyZXF1aXJlKDQ5KShDaGFydCksXG5cdHJlcXVpcmUoNTApKENoYXJ0KSxcblx0cmVxdWlyZSg1MSkoQ2hhcnQpXG4pO1xuXG5DaGFydC5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbnMpO1xuXG5DaGFydC5wbGF0Zm9ybS5pbml0aWFsaXplKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnQ7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LkNoYXJ0ID0gQ2hhcnQ7XG59XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuY2FudmFzSGVscGVyc1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQuY2FudmFzSGVscGVycyA9IENoYXJ0LmhlbHBlcnMuY2FudmFzO1xuXG59LHtcIjEwXCI6MTAsXCIxMVwiOjExLFwiMTJcIjoxMixcIjEzXCI6MTMsXCIxNFwiOjE0LFwiMTVcIjoxNSxcIjE2XCI6MTYsXCIxN1wiOjE3LFwiMThcIjoxOCxcIjE5XCI6MTksXCIyMFwiOjIwLFwiMjFcIjoyMSxcIjIyXCI6MjIsXCIyM1wiOjIzLFwiMjRcIjoyNCxcIjI1XCI6MjUsXCIyNlwiOjI2LFwiMjdcIjoyNyxcIjI4XCI6MjgsXCIyOVwiOjI5LFwiMzBcIjozMCxcIjMxXCI6MzEsXCIzMlwiOjMyLFwiMzNcIjozMyxcIjM1XCI6MzUsXCI0MFwiOjQwLFwiNDVcIjo0NSxcIjQ4XCI6NDgsXCI0OVwiOjQ5LFwiNTBcIjo1MCxcIjUxXCI6NTEsXCI1MlwiOjUyLFwiNTNcIjo1MyxcIjU0XCI6NTQsXCI1NVwiOjU1LFwiNTZcIjo1NixcIjU3XCI6NTcsXCI4XCI6OCxcIjlcIjo5fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5CYXIgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdiYXInO1xuXG5cdFx0cmV0dXJuIG5ldyBDaGFydChjb250ZXh0LCBjb25maWcpO1xuXHR9O1xuXG59O1xuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LkJ1YmJsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbmZpZykge1xuXHRcdGNvbmZpZy50eXBlID0gJ2J1YmJsZSc7XG5cdFx0cmV0dXJuIG5ldyBDaGFydChjb250ZXh0LCBjb25maWcpO1xuXHR9O1xuXG59O1xuXG59LHt9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5Eb3VnaG51dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbmZpZykge1xuXHRcdGNvbmZpZy50eXBlID0gJ2RvdWdobnV0JztcblxuXHRcdHJldHVybiBuZXcgQ2hhcnQoY29udGV4dCwgY29uZmlnKTtcblx0fTtcblxufTtcblxufSx7fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuTGluZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbmZpZykge1xuXHRcdGNvbmZpZy50eXBlID0gJ2xpbmUnO1xuXG5cdFx0cmV0dXJuIG5ldyBDaGFydChjb250ZXh0LCBjb25maWcpO1xuXHR9O1xuXG59O1xuXG59LHt9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5Qb2xhckFyZWEgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdwb2xhckFyZWEnO1xuXG5cdFx0cmV0dXJuIG5ldyBDaGFydChjb250ZXh0LCBjb25maWcpO1xuXHR9O1xuXG59O1xuXG59LHt9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5SYWRhciA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbmZpZykge1xuXHRcdGNvbmZpZy50eXBlID0gJ3JhZGFyJztcblxuXHRcdHJldHVybiBuZXcgQ2hhcnQoY29udGV4dCwgY29uZmlnKTtcblx0fTtcblxufTtcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cdENoYXJ0LlNjYXR0ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdzY2F0dGVyJztcblx0XHRyZXR1cm4gbmV3IENoYXJ0KGNvbnRleHQsIGNvbmZpZyk7XG5cdH07XG59O1xuXG59LHt9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGVsZW1lbnRzID0gcmVxdWlyZSg0MCk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdiYXInLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ2xhYmVsJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5JyxcblxuXHRcdFx0Ly8gU3BlY2lmaWMgdG8gQmFyIENvbnRyb2xsZXJcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuXHRcdFx0YmFyUGVyY2VudGFnZTogMC45LFxuXG5cdFx0XHQvLyBvZmZzZXQgc2V0dGluZ3Ncblx0XHRcdG9mZnNldDogdHJ1ZSxcblxuXHRcdFx0Ly8gZ3JpZCBsaW5lIHNldHRpbmdzXG5cdFx0XHRncmlkTGluZXM6IHtcblx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHR9XG5cdFx0fV0sXG5cblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInXG5cdFx0fV1cblx0fVxufSk7XG5cbmRlZmF1bHRzLl9zZXQoJ2hvcml6b250YWxCYXInLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ2luZGV4Jyxcblx0XHRheGlzOiAneSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cblx0XHR5QXhlczogW3tcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXG5cdFx0XHQvLyBTcGVjaWZpYyB0byBIb3Jpem9udGFsIEJhciBDb250cm9sbGVyXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblxuXHRcdFx0Ly8gb2Zmc2V0IHNldHRpbmdzXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cblx0XHRcdC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuXHRcdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRcdG9mZnNldEdyaWRMaW5lczogdHJ1ZVxuXHRcdFx0fVxuXHRcdH1dXG5cdH0sXG5cblx0ZWxlbWVudHM6IHtcblx0XHRyZWN0YW5nbGU6IHtcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdsZWZ0J1xuXHRcdH1cblx0fSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKGl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0Ly8gUGljayBmaXJzdCB4TGFiZWwgZm9yIG5vd1xuXHRcdFx0XHR2YXIgdGl0bGUgPSAnJztcblxuXHRcdFx0XHRpZiAoaXRlbS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0aWYgKGl0ZW1bMF0ueUxhYmVsKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW1bMF0ueUxhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoID4gMCAmJiBpdGVtWzBdLmluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGRhdGEubGFiZWxzW2l0ZW1bMF0uaW5kZXhdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aXRsZTtcblx0XHRcdH0sXG5cblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblx0XHRcdFx0cmV0dXJuIGRhdGFzZXRMYWJlbCArICc6ICcgKyBpdGVtLnhMYWJlbDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG1vZGU6ICdpbmRleCcsXG5cdFx0YXhpczogJ3knXG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuY29udHJvbGxlcnMuYmFyID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRcdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUmVjdGFuZ2xlLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGE7XG5cblx0XHRcdENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0bWV0YS5zdGFjayA9IG1lLmdldERhdGFzZXQoKS5zdGFjaztcblx0XHRcdG1ldGEuYmFyID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdFx0dmFyIGksIGlsZW47XG5cblx0XHRcdG1lLl9ydWxlciA9IG1lLmdldFJ1bGVyKCk7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChyZWN0c1tpXSwgaSwgcmVzZXQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBjdXN0b20gPSByZWN0YW5nbGUuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIHJlY3RhbmdsZU9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnJlY3RhbmdsZTtcblxuXHRcdFx0cmVjdGFuZ2xlLl94U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0XHRyZWN0YW5nbGUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRcdHJlY3RhbmdsZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0XHRyZWN0YW5nbGUuX2luZGV4ID0gaW5kZXg7XG5cblx0XHRcdHJlY3RhbmdsZS5fbW9kZWwgPSB7XG5cdFx0XHRcdGRhdGFzZXRMYWJlbDogZGF0YXNldC5sYWJlbCxcblx0XHRcdFx0bGFiZWw6IGNoYXJ0LmRhdGEubGFiZWxzW2luZGV4XSxcblx0XHRcdFx0Ym9yZGVyU2tpcHBlZDogY3VzdG9tLmJvcmRlclNraXBwZWQgPyBjdXN0b20uYm9yZGVyU2tpcHBlZCA6IHJlY3RhbmdsZU9wdGlvbnMuYm9yZGVyU2tpcHBlZCxcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYmFja2dyb3VuZENvbG9yLCBpbmRleCwgcmVjdGFuZ2xlT3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJDb2xvciwgaW5kZXgsIHJlY3RhbmdsZU9wdGlvbnMuYm9yZGVyQ29sb3IpLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJXaWR0aCwgaW5kZXgsIHJlY3RhbmdsZU9wdGlvbnMuYm9yZGVyV2lkdGgpXG5cdFx0XHR9O1xuXG5cdFx0XHRtZS51cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpO1xuXG5cdFx0XHRyZWN0YW5nbGUucGl2b3QoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR1cGRhdGVFbGVtZW50R2VvbWV0cnk6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1vZGVsID0gcmVjdGFuZ2xlLl9tb2RlbDtcblx0XHRcdHZhciB2c2NhbGUgPSBtZS5nZXRWYWx1ZVNjYWxlKCk7XG5cdFx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHRcdHZhciBob3Jpem9udGFsID0gdnNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0dmFyIHJ1bGVyID0gbWUuX3J1bGVyIHx8IG1lLmdldFJ1bGVyKCk7XG5cdFx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCk7XG5cdFx0XHR2YXIgaXBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgcnVsZXIpO1xuXG5cdFx0XHRtb2RlbC5ob3Jpem9udGFsID0gaG9yaXpvbnRhbDtcblx0XHRcdG1vZGVsLmJhc2UgPSByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmJhc2U7XG5cdFx0XHRtb2RlbC54ID0gaG9yaXpvbnRhbCA/IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyO1xuXHRcdFx0bW9kZWwueSA9IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuaGVhZDtcblx0XHRcdG1vZGVsLmhlaWdodCA9IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiB1bmRlZmluZWQ7XG5cdFx0XHRtb2RlbC53aWR0aCA9IGhvcml6b250YWwgPyB1bmRlZmluZWQgOiBpcGl4ZWxzLnNpemU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS55QXhpc0lEO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRnZXRWYWx1ZVNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFNjYWxlRm9ySWQodGhpcy5nZXRWYWx1ZVNjYWxlSWQoKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0SW5kZXhTY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuZ2V0SW5kZXhTY2FsZUlkKCkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgbnVtYmVyIG9mIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0U3RhY2tDb3VudDogZnVuY3Rpb24obGFzdCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIHNjYWxlID0gbWUuZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0XHR2YXIgaWxlbiA9IGxhc3QgPT09IHVuZGVmaW5lZCA/IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoIDogbGFzdCArIDE7XG5cdFx0XHR2YXIgc3RhY2tzID0gW107XG5cdFx0XHR2YXIgaSwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdGlmIChtZXRhLmJhciAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmXG5cdFx0XHRcdFx0KHN0YWNrZWQgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0KHN0YWNrZWQgPT09IHRydWUgJiYgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSB8fFxuXHRcdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgKG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEpKSkpIHtcblx0XHRcdFx0XHRzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3RhY2tzLmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgc3RhY2sgaW5kZXggZm9yIHRoZSBnaXZlbiBkYXRhc2V0IGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRnZXRTdGFja0luZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFN0YWNrQ291bnQoZGF0YXNldEluZGV4KSAtIDE7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0UnVsZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBzY2FsZSA9IG1lLmdldEluZGV4U2NhbGUoKTtcblx0XHRcdHZhciBzdGFja0NvdW50ID0gbWUuZ2V0U3RhY2tDb3VudCgpO1xuXHRcdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0dmFyIHBpeGVscyA9IFtdO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0dmFyIHN0YXJ0ID0gaXNIb3Jpem9udGFsID8gc2NhbGUubGVmdCA6IHNjYWxlLnRvcDtcblx0XHRcdHZhciBlbmQgPSBzdGFydCArIChpc0hvcml6b250YWwgPyBzY2FsZS53aWR0aCA6IHNjYWxlLmhlaWdodCk7XG5cdFx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmdldE1ldGEoKS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRwaXhlbHMucHVzaChzY2FsZS5nZXRQaXhlbEZvclZhbHVlKG51bGwsIGksIGRhdGFzZXRJbmRleCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwaXhlbHM6IHBpeGVscyxcblx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRlbmQ6IGVuZCxcblx0XHRcdFx0c3RhY2tDb3VudDogc3RhY2tDb3VudCxcblx0XHRcdFx0c2NhbGU6IHNjYWxlXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y2FsY3VsYXRlQmFyVmFsdWVQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHNjYWxlID0gbWUuZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHRcdHZhciB2YWx1ZSA9IHNjYWxlLmdldFJpZ2h0VmFsdWUoZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0XHR2YXIgc3RhY2tlZCA9IHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcblx0XHRcdHZhciBzdGFjayA9IG1ldGEuc3RhY2s7XG5cdFx0XHR2YXIgc3RhcnQgPSAwO1xuXHRcdFx0dmFyIGksIGltZXRhLCBpdmFsdWUsIGJhc2UsIGhlYWQsIHNpemU7XG5cblx0XHRcdGlmIChzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgc3RhY2sgIT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRcdFx0aW1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblxuXHRcdFx0XHRcdGlmIChpbWV0YS5iYXIgJiZcblx0XHRcdFx0XHRcdGltZXRhLnN0YWNrID09PSBzdGFjayAmJlxuXHRcdFx0XHRcdFx0aW1ldGEuY29udHJvbGxlci5nZXRWYWx1ZVNjYWxlSWQoKSA9PT0gc2NhbGUuaWQgJiZcblx0XHRcdFx0XHRcdGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblxuXHRcdFx0XHRcdFx0aXZhbHVlID0gc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0c1tpXS5kYXRhW2luZGV4XSk7XG5cdFx0XHRcdFx0XHRpZiAoKHZhbHVlIDwgMCAmJiBpdmFsdWUgPCAwKSB8fCAodmFsdWUgPj0gMCAmJiBpdmFsdWUgPiAwKSkge1xuXHRcdFx0XHRcdFx0XHRzdGFydCArPSBpdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGJhc2UgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0KTtcblx0XHRcdGhlYWQgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgdmFsdWUpO1xuXHRcdFx0c2l6ZSA9IChoZWFkIC0gYmFzZSkgLyAyO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRiYXNlOiBiYXNlLFxuXHRcdFx0XHRoZWFkOiBoZWFkLFxuXHRcdFx0XHRjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRjYWxjdWxhdGVCYXJJbmRleFBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCwgcnVsZXIpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHJ1bGVyLnNjYWxlLm9wdGlvbnM7XG5cdFx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdHZhciBwaXhlbHMgPSBydWxlci5waXhlbHM7XG5cdFx0XHR2YXIgYmFzZSA9IHBpeGVsc1tpbmRleF07XG5cdFx0XHR2YXIgbGVuZ3RoID0gcGl4ZWxzLmxlbmd0aDtcblx0XHRcdHZhciBzdGFydCA9IHJ1bGVyLnN0YXJ0O1xuXHRcdFx0dmFyIGVuZCA9IHJ1bGVyLmVuZDtcblx0XHRcdHZhciBsZWZ0U2FtcGxlU2l6ZSwgcmlnaHRTYW1wbGVTaXplLCBsZWZ0Q2F0ZWdvcnlTaXplLCByaWdodENhdGVnb3J5U2l6ZSwgZnVsbEJhclNpemUsIHNpemU7XG5cblx0XHRcdGlmIChsZW5ndGggPT09IDEpIHtcblx0XHRcdFx0bGVmdFNhbXBsZVNpemUgPSBiYXNlID4gc3RhcnQgPyBiYXNlIC0gc3RhcnQgOiBlbmQgLSBiYXNlO1xuXHRcdFx0XHRyaWdodFNhbXBsZVNpemUgPSBiYXNlIDwgZW5kID8gZW5kIC0gYmFzZSA6IGJhc2UgLSBzdGFydDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0XHRsZWZ0U2FtcGxlU2l6ZSA9IChiYXNlIC0gcGl4ZWxzW2luZGV4IC0gMV0pIC8gMjtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdHJpZ2h0U2FtcGxlU2l6ZSA9IGxlZnRTYW1wbGVTaXplO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0cmlnaHRTYW1wbGVTaXplID0gKHBpeGVsc1tpbmRleCArIDFdIC0gYmFzZSkgLyAyO1xuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0bGVmdFNhbXBsZVNpemUgPSByaWdodFNhbXBsZVNpemU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxlZnRDYXRlZ29yeVNpemUgPSBsZWZ0U2FtcGxlU2l6ZSAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHRcdFx0cmlnaHRDYXRlZ29yeVNpemUgPSByaWdodFNhbXBsZVNpemUgKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblx0XHRcdGZ1bGxCYXJTaXplID0gKGxlZnRDYXRlZ29yeVNpemUgKyByaWdodENhdGVnb3J5U2l6ZSkgLyBydWxlci5zdGFja0NvdW50O1xuXHRcdFx0c2l6ZSA9IGZ1bGxCYXJTaXplICogb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuXG5cdFx0XHRzaXplID0gTWF0aC5taW4oXG5cdFx0XHRcdGhlbHBlcnMudmFsdWVPckRlZmF1bHQob3B0aW9ucy5iYXJUaGlja25lc3MsIHNpemUpLFxuXHRcdFx0XHRoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSkpO1xuXG5cdFx0XHRiYXNlIC09IGxlZnRDYXRlZ29yeVNpemU7XG5cdFx0XHRiYXNlICs9IGZ1bGxCYXJTaXplICogc3RhY2tJbmRleDtcblx0XHRcdGJhc2UgKz0gKGZ1bGxCYXJTaXplIC0gc2l6ZSkgLyAyO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRiYXNlOiBiYXNlLFxuXHRcdFx0XHRoZWFkOiBiYXNlICsgc2l6ZSxcblx0XHRcdFx0Y2VudGVyOiBiYXNlICsgc2l6ZSAvIDJcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIHNjYWxlID0gbWUuZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdFx0dmFyIHJlY3RzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBpbGVuID0gcmVjdHMubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHRoZWxwZXJzLmNhbnZhcy5jbGlwQXJlYShjaGFydC5jdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cblx0XHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmICghaXNOYU4oc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0LmRhdGFbaV0pKSkge1xuXHRcdFx0XHRcdHJlY3RzW2ldLmRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdFx0fSxcblxuXHRcdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbcmVjdGFuZ2xlLl9kYXRhc2V0SW5kZXhdO1xuXHRcdFx0dmFyIGluZGV4ID0gcmVjdGFuZ2xlLl9pbmRleDtcblx0XHRcdHZhciBjdXN0b20gPSByZWN0YW5nbGUuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIG1vZGVsID0gcmVjdGFuZ2xlLl9tb2RlbDtcblxuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5ob3ZlckJhY2tncm91bmRDb2xvciwgaW5kZXgsIGhlbHBlcnMuZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IgPyBjdXN0b20uaG92ZXJCb3JkZXJDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCb3JkZXJDb2xvciwgaW5kZXgsIGhlbHBlcnMuZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA/IGN1c3RvbS5ob3ZlckJvcmRlcldpZHRoIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5ob3ZlckJvcmRlcldpZHRoLCBpbmRleCwgbW9kZWwuYm9yZGVyV2lkdGgpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihyZWN0YW5nbGUpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3JlY3RhbmdsZS5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBpbmRleCA9IHJlY3RhbmdsZS5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gcmVjdGFuZ2xlLmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBtb2RlbCA9IHJlY3RhbmdsZS5fbW9kZWw7XG5cdFx0XHR2YXIgcmVjdGFuZ2xlRWxlbWVudE9wdGlvbnMgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucmVjdGFuZ2xlO1xuXG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYmFja2dyb3VuZENvbG9yLCBpbmRleCwgcmVjdGFuZ2xlRWxlbWVudE9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJDb2xvciwgaW5kZXgsIHJlY3RhbmdsZUVsZW1lbnRPcHRpb25zLmJvcmRlckNvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJXaWR0aCwgaW5kZXgsIHJlY3RhbmdsZUVsZW1lbnRPcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHR9XG5cdH0pO1xuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLmhvcml6b250YWxCYXIgPSBDaGFydC5jb250cm9sbGVycy5iYXIuZXh0ZW5kKHtcblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRnZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjQwXCI6NDAsXCI0NVwiOjQ1fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBlbGVtZW50cyA9IHJlcXVpcmUoNDApO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnYnViYmxlJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdzaW5nbGUnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJywgLy8gYnViYmxlIHNob3VsZCBwcm9iYWJseSB1c2UgYSBsaW5lYXIgc2NhbGUgYnkgZGVmYXVsdFxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCcgLy8gbmVlZCBhbiBJRCBzbyBkYXRhc2V0cyBjYW4gcmVmZXJlbmNlIHRoZSBzY2FsZVxuXHRcdH1dLFxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9LFxuXG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRpdGxlIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3Igc2NhdHRlciBzaW5jZSB3ZSBmb3JtYXQgdGhlIGRhdGEgYXMgYSBwb2ludFxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0dmFyIGRhdGFzZXRMYWJlbCA9IGRhdGEuZGF0YXNldHNbaXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xuXHRcdFx0XHR2YXIgZGF0YVBvaW50ID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0uZGF0YVtpdGVtLmluZGV4XTtcblx0XHRcdFx0cmV0dXJuIGRhdGFzZXRMYWJlbCArICc6ICgnICsgaXRlbS54TGFiZWwgKyAnLCAnICsgaXRlbS55TGFiZWwgKyAnLCAnICsgZGF0YVBvaW50LnIgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuY29udHJvbGxlcnMuYnViYmxlID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhO1xuXG5cdFx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0XHRoZWxwZXJzLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludCwgaW5kZXgsIHJlc2V0KTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHBvaW50LCBpbmRleCk7XG5cdFx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcblx0XHRcdHZhciBkc0luZGV4ID0gbWUuaW5kZXg7XG5cblx0XHRcdHZhciB4ID0gcmVzZXQgPyB4U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhIDogTmFOLCBpbmRleCwgZHNJbmRleCk7XG5cdFx0XHR2YXIgeSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogeVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZGF0YSwgaW5kZXgsIGRzSW5kZXgpO1xuXG5cdFx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xuXHRcdFx0cG9pbnQuX3lTY2FsZSA9IHlTY2FsZTtcblx0XHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkc0luZGV4O1xuXHRcdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cdFx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1cyxcblx0XHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuXHRcdFx0XHRyYWRpdXM6IHJlc2V0ID8gMCA6IG9wdGlvbnMucmFkaXVzLFxuXHRcdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogeSxcblx0XHRcdH07XG5cblx0XHRcdHBvaW50LnBpdm90KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblxuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBoZWxwZXJzLmdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGhlbHBlcnMuZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRcdG1vZGVsLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5ob3ZlclJhZGl1cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdG1vZGVsLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZXNvbHZlRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHRcdHZhciByZXNvbHZlID0gaGVscGVycy5vcHRpb25zLnJlc29sdmU7XG5cdFx0XHR2YXIgZGF0YSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHRcdH07XG5cblx0XHRcdHZhciBrZXlzID0gW1xuXHRcdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHRcdCdob3ZlclJhZGl1cycsXG5cdFx0XHRcdCdoaXRSYWRpdXMnLFxuXHRcdFx0XHQncG9pbnRTdHlsZSdcblx0XHRcdF07XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUoW1xuXHRcdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cblx0XHRcdHZhbHVlcy5yYWRpdXMgPSByZXNvbHZlKFtcblx0XHRcdFx0Y3VzdG9tLnJhZGl1cyxcblx0XHRcdFx0ZGF0YSA/IGRhdGEuciA6IHVuZGVmaW5lZCxcblx0XHRcdFx0ZGF0YXNldC5yYWRpdXMsXG5cdFx0XHRcdG9wdGlvbnMucmFkaXVzXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjQwXCI6NDAsXCI0NVwiOjQ1fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBlbGVtZW50cyA9IHJlcXVpcmUoNDApO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnZG91Z2hudXQnLCB7XG5cdGFuaW1hdGlvbjoge1xuXHRcdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBEb3VnaG51dFxuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcblx0XHRhbmltYXRlU2NhbGU6IGZhbHNlXG5cdH0sXG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRleHQgPSBbXTtcblx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV0gKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XG5cdFx0XHRcdFx0dGV4dC5wdXNoKGxhYmVsc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fSxcblx0bGVnZW5kOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcblx0XHRcdFx0XHRcdHZhciBkcyA9IGRhdGEuZGF0YXNldHNbMF07XG5cdFx0XHRcdFx0XHR2YXIgYXJjID0gbWV0YS5kYXRhW2ldO1xuXHRcdFx0XHRcdFx0dmFyIGN1c3RvbSA9IGFyYyAmJiBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXHRcdFx0XHRcdFx0dmFyIGFyY09wdHMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHRcdFx0XHRcdHZhciBmaWxsID0gY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYmFja2dyb3VuZENvbG9yLCBpLCBhcmNPcHRzLmJhY2tncm91bmRDb2xvcik7XG5cdFx0XHRcdFx0XHR2YXIgc3Ryb2tlID0gY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogdmFsdWVBdEluZGV4T3JEZWZhdWx0KGRzLmJvcmRlckNvbG9yLCBpLCBhcmNPcHRzLmJvcmRlckNvbG9yKTtcblx0XHRcdFx0XHRcdHZhciBidyA9IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IHZhbHVlQXRJbmRleE9yRGVmYXVsdChkcy5ib3JkZXJXaWR0aCwgaSwgYXJjT3B0cy5ib3JkZXJXaWR0aCk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IGxhYmVsLFxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IGZpbGwsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHJva2UsXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogYncsXG5cdFx0XHRcdFx0XHRcdGhpZGRlbjogaXNOYU4oZHMuZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcblxuXHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblx0XHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdC8vIHRvZ2dsZSB2aXNpYmlsaXR5IG9mIGluZGV4IGlmIGV4aXN0c1xuXHRcdFx0XHRpZiAobWV0YS5kYXRhW2luZGV4XSkge1xuXHRcdFx0XHRcdG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuID0gIW1ldGEuZGF0YVtpbmRleF0uaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG5cdGN1dG91dFBlcmNlbnRhZ2U6IDUwLFxuXG5cdC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG5cdHJvdGF0aW9uOiBNYXRoLlBJICogLTAuNSxcblxuXHQvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG5cdGNpcmN1bWZlcmVuY2U6IE1hdGguUEkgKiAyLjAsXG5cblx0Ly8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0dmFyIGRhdGFMYWJlbCA9IGRhdGEubGFiZWxzW3Rvb2x0aXBJdGVtLmluZGV4XTtcblx0XHRcdFx0dmFyIHZhbHVlID0gJzogJyArIGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblxuXHRcdFx0XHRpZiAoaGVscGVycy5pc0FycmF5KGRhdGFMYWJlbCkpIHtcblx0XHRcdFx0XHQvLyBzaG93IHZhbHVlIG9uIGZpcnN0IGxpbmUgb2YgbXVsdGlsaW5lIGxhYmVsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjbG9uZSBiZWNhdXNlIHdlIGFyZSBjaGFuZ2luZyB0aGUgdmFsdWVcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcblx0XHRcdFx0XHRkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsICs9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGFMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5kZWZhdWx0cy5fc2V0KCdwaWUnLCBoZWxwZXJzLmNsb25lKGRlZmF1bHRzLmRvdWdobnV0KSk7XG5kZWZhdWx0cy5fc2V0KCdwaWUnLCB7XG5cdGN1dG91dFBlcmNlbnRhZ2U6IDBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuY29udHJvbGxlcnMuZG91Z2hudXQgPSBDaGFydC5jb250cm9sbGVycy5waWUgPSBDaGFydC5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdFx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0XHRsaW5rU2NhbGVzOiBoZWxwZXJzLm5vb3AsXG5cblx0XHQvLyBHZXQgaW5kZXggb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHRcdGdldFJpbmdJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgcmluZ0luZGV4ID0gMDtcblxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhc2V0SW5kZXg7ICsraikge1xuXHRcdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGopKSB7XG5cdFx0XHRcdFx0KytyaW5nSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJpbmdJbmRleDtcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHRcdHZhciBhcmNPcHRzID0gb3B0cy5lbGVtZW50cy5hcmM7XG5cdFx0XHR2YXIgYXZhaWxhYmxlV2lkdGggPSBjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCAtIGFyY09wdHMuYm9yZGVyV2lkdGg7XG5cdFx0XHR2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3AgLSBhcmNPcHRzLmJvcmRlcldpZHRoO1xuXHRcdFx0dmFyIG1pblNpemUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KTtcblx0XHRcdHZhciBvZmZzZXQgPSB7eDogMCwgeTogMH07XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBjdXRvdXRQZXJjZW50YWdlID0gb3B0cy5jdXRvdXRQZXJjZW50YWdlO1xuXHRcdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBvcHRzLmNpcmN1bWZlcmVuY2U7XG5cblx0XHRcdC8vIElmIHRoZSBjaGFydCdzIGNpcmN1bWZlcmVuY2UgaXNuJ3QgYSBmdWxsIGNpcmNsZSwgY2FsY3VsYXRlIG1pblNpemUgYXMgYSByYXRpbyBvZiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhcmNcblx0XHRcdGlmIChjaXJjdW1mZXJlbmNlIDwgTWF0aC5QSSAqIDIuMCkge1xuXHRcdFx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb24gJSAoTWF0aC5QSSAqIDIuMCk7XG5cdFx0XHRcdHN0YXJ0QW5nbGUgKz0gTWF0aC5QSSAqIDIuMCAqIChzdGFydEFuZ2xlID49IE1hdGguUEkgPyAtMSA6IHN0YXJ0QW5nbGUgPCAtTWF0aC5QSSA/IDEgOiAwKTtcblx0XHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG5cdFx0XHRcdHZhciBzdGFydCA9IHt4OiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogTWF0aC5zaW4oc3RhcnRBbmdsZSl9O1xuXHRcdFx0XHR2YXIgZW5kID0ge3g6IE1hdGguY29zKGVuZEFuZ2xlKSwgeTogTWF0aC5zaW4oZW5kQW5nbGUpfTtcblx0XHRcdFx0dmFyIGNvbnRhaW5zMCA9IChzdGFydEFuZ2xlIDw9IDAgJiYgZW5kQW5nbGUgPj0gMCkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDIuMCAmJiBNYXRoLlBJICogMi4wIDw9IGVuZEFuZ2xlKTtcblx0XHRcdFx0dmFyIGNvbnRhaW5zOTAgPSAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMC41ICYmIE1hdGguUEkgKiAwLjUgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAyLjUgJiYgTWF0aC5QSSAqIDIuNSA8PSBlbmRBbmdsZSk7XG5cdFx0XHRcdHZhciBjb250YWluczE4MCA9IChzdGFydEFuZ2xlIDw9IC1NYXRoLlBJICYmIC1NYXRoLlBJIDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICYmIE1hdGguUEkgPD0gZW5kQW5nbGUpO1xuXHRcdFx0XHR2YXIgY29udGFpbnMyNzAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAqIDAuNSAmJiAtTWF0aC5QSSAqIDAuNSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDEuNSAmJiBNYXRoLlBJICogMS41IDw9IGVuZEFuZ2xlKTtcblx0XHRcdFx0dmFyIGN1dG91dCA9IGN1dG91dFBlcmNlbnRhZ2UgLyAxMDAuMDtcblx0XHRcdFx0dmFyIG1pbiA9IHt4OiBjb250YWluczE4MCA/IC0xIDogTWF0aC5taW4oc3RhcnQueCAqIChzdGFydC54IDwgMCA/IDEgOiBjdXRvdXQpLCBlbmQueCAqIChlbmQueCA8IDAgPyAxIDogY3V0b3V0KSksIHk6IGNvbnRhaW5zMjcwID8gLTEgOiBNYXRoLm1pbihzdGFydC55ICogKHN0YXJ0LnkgPCAwID8gMSA6IGN1dG91dCksIGVuZC55ICogKGVuZC55IDwgMCA/IDEgOiBjdXRvdXQpKX07XG5cdFx0XHRcdHZhciBtYXggPSB7eDogY29udGFpbnMwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnggKiAoc3RhcnQueCA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPiAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczkwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnkgKiAoc3RhcnQueSA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPiAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdFx0dmFyIHNpemUgPSB7d2lkdGg6IChtYXgueCAtIG1pbi54KSAqIDAuNSwgaGVpZ2h0OiAobWF4LnkgLSBtaW4ueSkgKiAwLjV9O1xuXHRcdFx0XHRtaW5TaXplID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGggLyBzaXplLndpZHRoLCBhdmFpbGFibGVIZWlnaHQgLyBzaXplLmhlaWdodCk7XG5cdFx0XHRcdG9mZnNldCA9IHt4OiAobWF4LnggKyBtaW4ueCkgKiAtMC41LCB5OiAobWF4LnkgKyBtaW4ueSkgKiAtMC41fTtcblx0XHRcdH1cblxuXHRcdFx0Y2hhcnQuYm9yZGVyV2lkdGggPSBtZS5nZXRNYXhCb3JkZXJXaWR0aChtZXRhLmRhdGEpO1xuXHRcdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgobWluU2l6ZSAtIGNoYXJ0LmJvcmRlcldpZHRoKSAvIDIsIDApO1xuXHRcdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChjdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChjdXRvdXRQZXJjZW50YWdlKSA6IDAsIDApO1xuXHRcdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXHRcdFx0Y2hhcnQub2Zmc2V0WCA9IG9mZnNldC54ICogY2hhcnQub3V0ZXJSYWRpdXM7XG5cdFx0XHRjaGFydC5vZmZzZXRZID0gb2Zmc2V0LnkgKiBjaGFydC5vdXRlclJhZGl1cztcblxuXHRcdFx0bWV0YS50b3RhbCA9IG1lLmNhbGN1bGF0ZVRvdGFsKCk7XG5cblx0XHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuZ2V0UmluZ0luZGV4KG1lLmluZGV4KSk7XG5cdFx0XHRtZS5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoLCAwKTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oYXJjLCBpbmRleCkge1xuXHRcdFx0XHRtZS51cGRhdGVFbGVtZW50KGFyYywgaW5kZXgsIHJlc2V0KTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHRcdHZhciBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG5cdFx0XHR2YXIgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuXHRcdFx0dmFyIGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdFx0dmFyIGVuZEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IDAgOiBhcmMuaGlkZGVuID8gMCA6IG1lLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UoZGF0YXNldC5kYXRhW2luZGV4XSkgKiAob3B0cy5jaXJjdW1mZXJlbmNlIC8gKDIuMCAqIE1hdGguUEkpKTtcblx0XHRcdHZhciBpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xuXHRcdFx0dmFyIG91dGVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUub3V0ZXJSYWRpdXM7XG5cdFx0XHR2YXIgdmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cblx0XHRcdGhlbHBlcnMuZXh0ZW5kKGFyYywge1xuXHRcdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0XHRfaW5kZXg6IGluZGV4LFxuXG5cdFx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRcdHg6IGNlbnRlclggKyBjaGFydC5vZmZzZXRYLFxuXHRcdFx0XHRcdHk6IGNlbnRlclkgKyBjaGFydC5vZmZzZXRZLFxuXHRcdFx0XHRcdHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdFx0ZW5kQW5nbGU6IGVuZEFuZ2xlLFxuXHRcdFx0XHRcdGNpcmN1bWZlcmVuY2U6IGNpcmN1bWZlcmVuY2UsXG5cdFx0XHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRcdFx0XHRsYWJlbDogdmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQubGFiZWwsIGluZGV4LCBjaGFydC5kYXRhLmxhYmVsc1tpbmRleF0pXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXHRcdFx0Ly8gUmVzZXRzIHRoZSB2aXN1YWwgc3R5bGVzXG5cdFx0XHR0aGlzLnJlbW92ZUhvdmVyU3R5bGUoYXJjKTtcblxuXHRcdFx0Ly8gU2V0IGNvcnJlY3QgYW5nbGVzIGlmIG5vdCByZXNldHRpbmdcblx0XHRcdGlmICghcmVzZXQgfHwgIWFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuXHRcdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gbWUuZ2V0TWV0YSgpLmRhdGFbaW5kZXggLSAxXS5fbW9kZWwuZW5kQW5nbGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtb2RlbC5lbmRBbmdsZSA9IG1vZGVsLnN0YXJ0QW5nbGUgKyBtb2RlbC5jaXJjdW1mZXJlbmNlO1xuXHRcdFx0fVxuXG5cdFx0XHRhcmMucGl2b3QoKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0XHRDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlSG92ZXJTdHlsZS5jYWxsKHRoaXMsIGFyYywgdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYyk7XG5cdFx0fSxcblxuXHRcdGNhbGN1bGF0ZVRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHRvdGFsID0gMDtcblx0XHRcdHZhciB2YWx1ZTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdFx0dmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSAmJiAhZWxlbWVudC5oaWRkZW4pIHtcblx0XHRcdFx0XHR0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvKiBpZiAodG90YWwgPT09IDApIHtcblx0XHRcdFx0dG90YWwgPSBOYU47XG5cdFx0XHR9Ki9cblxuXHRcdFx0cmV0dXJuIHRvdGFsO1xuXHRcdH0sXG5cblx0XHRjYWxjdWxhdGVDaXJjdW1mZXJlbmNlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIHRvdGFsID0gdGhpcy5nZXRNZXRhKCkudG90YWw7XG5cdFx0XHRpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIChNYXRoLlBJICogMi4wKSAqICh2YWx1ZSAvIHRvdGFsKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH0sXG5cblx0XHQvLyBnZXRzIHRoZSBtYXggYm9yZGVyIG9yIGhvdmVyIHdpZHRoIHRvIHByb3Blcmx5IHNjYWxlIHBpZSBjaGFydHNcblx0XHRnZXRNYXhCb3JkZXJXaWR0aDogZnVuY3Rpb24oYXJjcykge1xuXHRcdFx0dmFyIG1heCA9IDA7XG5cdFx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdFx0dmFyIGxlbmd0aCA9IGFyY3MubGVuZ3RoO1xuXHRcdFx0dmFyIGJvcmRlcldpZHRoO1xuXHRcdFx0dmFyIGhvdmVyV2lkdGg7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBhcmNzW2ldLl9tb2RlbCA/IGFyY3NbaV0uX21vZGVsLmJvcmRlcldpZHRoIDogMDtcblx0XHRcdFx0aG92ZXJXaWR0aCA9IGFyY3NbaV0uX2NoYXJ0ID8gYXJjc1tpXS5fY2hhcnQuY29uZmlnLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhvdmVyQm9yZGVyV2lkdGggOiAwO1xuXG5cdFx0XHRcdG1heCA9IGJvcmRlcldpZHRoID4gbWF4ID8gYm9yZGVyV2lkdGggOiBtYXg7XG5cdFx0XHRcdG1heCA9IGhvdmVyV2lkdGggPiBtYXggPyBob3ZlcldpZHRoIDogbWF4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heDtcblx0XHR9XG5cdH0pO1xufTtcblxufSx7XCIyNVwiOjI1LFwiNDBcIjo0MCxcIjQ1XCI6NDV9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGVsZW1lbnRzID0gcmVxdWlyZSg0MCk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdsaW5lJywge1xuXHRzaG93TGluZXM6IHRydWUsXG5cdHNwYW5HYXBzOiBmYWxzZSxcblxuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdsYWJlbCdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cdFx0XHRpZDogJ3gtYXhpcy0wJ1xuXHRcdH1dLFxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xuXHRcdH1dXG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0ZnVuY3Rpb24gbGluZUVuYWJsZWQoZGF0YXNldCwgb3B0aW9ucykge1xuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuc2hvd0xpbmUsIG9wdGlvbnMuc2hvd0xpbmVzKTtcblx0fVxuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLmxpbmUgPSBDaGFydC5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdFx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdFx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHRcdHZhciBvcHRpb25zID0gbWUuY2hhcnQub3B0aW9ucztcblx0XHRcdHZhciBsaW5lRWxlbWVudE9wdGlvbnMgPSBvcHRpb25zLmVsZW1lbnRzLmxpbmU7XG5cdFx0XHR2YXIgc2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0XHR2YXIgaSwgaWxlbiwgY3VzdG9tO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgc2hvd0xpbmUgPSBsaW5lRW5hYmxlZChkYXRhc2V0LCBvcHRpb25zKTtcblxuXHRcdFx0Ly8gVXBkYXRlIExpbmVcblx0XHRcdGlmIChzaG93TGluZSkge1xuXHRcdFx0XHRjdXN0b20gPSBsaW5lLmN1c3RvbSB8fCB7fTtcblxuXHRcdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRcdGlmICgoZGF0YXNldC50ZW5zaW9uICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LmxpbmVUZW5zaW9uID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcblx0XHRcdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0XHRcdC8vIERhdGFcblx0XHRcdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XG5cdFx0XHRcdC8vIE1vZGVsXG5cdFx0XHRcdGxpbmUuX21vZGVsID0ge1xuXHRcdFx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBiZWhhdmlvciBvZiBsaW5lcyBpcyB0byBicmVhayBhdCBudWxsIHZhbHVlcywgYWNjb3JkaW5nXG5cdFx0XHRcdFx0Ly8gdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0MzUjaXNzdWVjb21tZW50LTIxNjcxODE1OFxuXHRcdFx0XHRcdC8vIFRoaXMgb3B0aW9uIGdpdmVzIGxpbmVzIHRoZSBhYmlsaXR5IHRvIHNwYW4gZ2Fwc1xuXHRcdFx0XHRcdHNwYW5HYXBzOiBkYXRhc2V0LnNwYW5HYXBzID8gZGF0YXNldC5zcGFuR2FwcyA6IG9wdGlvbnMuc3BhbkdhcHMsXG5cdFx0XHRcdFx0dGVuc2lvbjogY3VzdG9tLnRlbnNpb24gPyBjdXN0b20udGVuc2lvbiA6IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoZGF0YXNldC5saW5lVGVuc2lvbiwgbGluZUVsZW1lbnRPcHRpb25zLnRlbnNpb24pLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiAoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJhY2tncm91bmRDb2xvciksXG5cdFx0XHRcdFx0Ym9yZGVyV2lkdGg6IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IChkYXRhc2V0LmJvcmRlcldpZHRoIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJXaWR0aCksXG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IChkYXRhc2V0LmJvcmRlckNvbG9yIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJDb2xvciksXG5cdFx0XHRcdFx0Ym9yZGVyQ2FwU3R5bGU6IGN1c3RvbS5ib3JkZXJDYXBTdHlsZSA/IGN1c3RvbS5ib3JkZXJDYXBTdHlsZSA6IChkYXRhc2V0LmJvcmRlckNhcFN0eWxlIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJDYXBTdHlsZSksXG5cdFx0XHRcdFx0Ym9yZGVyRGFzaDogY3VzdG9tLmJvcmRlckRhc2ggPyBjdXN0b20uYm9yZGVyRGFzaCA6IChkYXRhc2V0LmJvcmRlckRhc2ggfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckRhc2gpLFxuXHRcdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IGN1c3RvbS5ib3JkZXJEYXNoT2Zmc2V0ID8gY3VzdG9tLmJvcmRlckRhc2hPZmZzZXQgOiAoZGF0YXNldC5ib3JkZXJEYXNoT2Zmc2V0IHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KSxcblx0XHRcdFx0XHRib3JkZXJKb2luU3R5bGU6IGN1c3RvbS5ib3JkZXJKb2luU3R5bGUgPyBjdXN0b20uYm9yZGVySm9pblN0eWxlIDogKGRhdGFzZXQuYm9yZGVySm9pblN0eWxlIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpLFxuXHRcdFx0XHRcdGZpbGw6IGN1c3RvbS5maWxsID8gY3VzdG9tLmZpbGwgOiAoZGF0YXNldC5maWxsICE9PSB1bmRlZmluZWQgPyBkYXRhc2V0LmZpbGwgOiBsaW5lRWxlbWVudE9wdGlvbnMuZmlsbCksXG5cdFx0XHRcdFx0c3RlcHBlZExpbmU6IGN1c3RvbS5zdGVwcGVkTGluZSA/IGN1c3RvbS5zdGVwcGVkTGluZSA6IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoZGF0YXNldC5zdGVwcGVkTGluZSwgbGluZUVsZW1lbnRPcHRpb25zLnN0ZXBwZWQpLFxuXHRcdFx0XHRcdGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IGN1c3RvbS5jdWJpY0ludGVycG9sYXRpb25Nb2RlID8gY3VzdG9tLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgOiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSwgbGluZUVsZW1lbnRPcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUpLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGxpbmUucGl2b3QoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludHNbaV0sIGksIHJlc2V0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNob3dMaW5lICYmIGxpbmUuX21vZGVsLnRlbnNpb24gIT09IDApIHtcblx0XHRcdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRQb2ludEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHR2YXIgYmFja2dyb3VuZENvbG9yID0gdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LmJhY2tncm91bmRDb2xvcjtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXG5cdFx0XHRpZiAoY3VzdG9tLmJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRhc2V0LnBvaW50QmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvciA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBiYWNrZ3JvdW5kQ29sb3IpO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRhc2V0LmJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmJhY2tncm91bmRDb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJhY2tncm91bmRDb2xvcjtcblx0XHR9LFxuXG5cdFx0Z2V0UG9pbnRCb3JkZXJDb2xvcjogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHR2YXIgYm9yZGVyQ29sb3IgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQuYm9yZGVyQ29sb3I7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblxuXHRcdFx0aWYgKGN1c3RvbS5ib3JkZXJDb2xvcikge1xuXHRcdFx0XHRib3JkZXJDb2xvciA9IGN1c3RvbS5ib3JkZXJDb2xvcjtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YXNldC5wb2ludEJvcmRlckNvbG9yKSB7XG5cdFx0XHRcdGJvcmRlckNvbG9yID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJvcmRlckNvbG9yLCBpbmRleCwgYm9yZGVyQ29sb3IpO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRhc2V0LmJvcmRlckNvbG9yKSB7XG5cdFx0XHRcdGJvcmRlckNvbG9yID0gZGF0YXNldC5ib3JkZXJDb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJvcmRlckNvbG9yO1xuXHRcdH0sXG5cblx0XHRnZXRQb2ludEJvcmRlcldpZHRoOiBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdHZhciBib3JkZXJXaWR0aCA9IHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5ib3JkZXJXaWR0aDtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXG5cdFx0XHRpZiAoIWlzTmFOKGN1c3RvbS5ib3JkZXJXaWR0aCkpIHtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBjdXN0b20uYm9yZGVyV2lkdGg7XG5cdFx0XHR9IGVsc2UgaWYgKCFpc05hTihkYXRhc2V0LnBvaW50Qm9yZGVyV2lkdGgpIHx8IGhlbHBlcnMuaXNBcnJheShkYXRhc2V0LnBvaW50Qm9yZGVyV2lkdGgpKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJvcmRlcldpZHRoLCBpbmRleCwgYm9yZGVyV2lkdGgpO1xuXHRcdFx0fSBlbHNlIGlmICghaXNOYU4oZGF0YXNldC5ib3JkZXJXaWR0aCkpIHtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBkYXRhc2V0LmJvcmRlcldpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYm9yZGVyV2lkdGg7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRcdHZhciB2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHRcdHZhciBwb2ludE9wdGlvbnMgPSBtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdFx0dmFyIHgsIHk7XG5cblx0XHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcblx0XHRcdGlmICgoZGF0YXNldC5yYWRpdXMgIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQucG9pbnRSYWRpdXMgPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5wb2ludFJhZGl1cyA9IGRhdGFzZXQucmFkaXVzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChkYXRhc2V0LmhpdFJhZGl1cyAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5wb2ludEhpdFJhZGl1cyA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRkYXRhc2V0LnBvaW50SGl0UmFkaXVzID0gZGF0YXNldC5oaXRSYWRpdXM7XG5cdFx0XHR9XG5cblx0XHRcdHggPSB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiBOYU4sIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xuXHRcdFx0eSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogbWUuY2FsY3VsYXRlUG9pbnRZKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KTtcblxuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XG5cdFx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHksXG5cdFx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRcdHJhZGl1czogY3VzdG9tLnJhZGl1cyB8fCBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50UmFkaXVzLCBpbmRleCwgcG9pbnRPcHRpb25zLnJhZGl1cyksXG5cdFx0XHRcdHBvaW50U3R5bGU6IGN1c3RvbS5wb2ludFN0eWxlIHx8IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRTdHlsZSwgaW5kZXgsIHBvaW50T3B0aW9ucy5wb2ludFN0eWxlKSxcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBtZS5nZXRQb2ludEJhY2tncm91bmRDb2xvcihwb2ludCwgaW5kZXgpLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogbWUuZ2V0UG9pbnRCb3JkZXJDb2xvcihwb2ludCwgaW5kZXgpLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogbWUuZ2V0UG9pbnRCb3JkZXJXaWR0aChwb2ludCwgaW5kZXgpLFxuXHRcdFx0XHR0ZW5zaW9uOiBtZXRhLmRhdGFzZXQuX21vZGVsID8gbWV0YS5kYXRhc2V0Ll9tb2RlbC50ZW5zaW9uIDogMCxcblx0XHRcdFx0c3RlcHBlZExpbmU6IG1ldGEuZGF0YXNldC5fbW9kZWwgPyBtZXRhLmRhdGFzZXQuX21vZGVsLnN0ZXBwZWRMaW5lIDogZmFsc2UsXG5cdFx0XHRcdC8vIFRvb2x0aXBcblx0XHRcdFx0aGl0UmFkaXVzOiBjdXN0b20uaGl0UmFkaXVzIHx8IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIaXRSYWRpdXMsIGluZGV4LCBwb2ludE9wdGlvbnMuaGl0UmFkaXVzKVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Y2FsY3VsYXRlUG9pbnRZOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdFx0dmFyIHN1bVBvcyA9IDA7XG5cdFx0XHR2YXIgc3VtTmVnID0gMDtcblx0XHRcdHZhciBpLCBkcywgZHNNZXRhO1xuXG5cdFx0XHRpZiAoeVNjYWxlLm9wdGlvbnMuc3RhY2tlZCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyBpKyspIHtcblx0XHRcdFx0XHRkcyA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV07XG5cdFx0XHRcdFx0ZHNNZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdFx0aWYgKGRzTWV0YS50eXBlID09PSAnbGluZScgJiYgZHNNZXRhLnlBeGlzSUQgPT09IHlTY2FsZS5pZCAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0XHR2YXIgc3RhY2tlZFJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUoZHMuZGF0YVtpbmRleF0pKTtcblx0XHRcdFx0XHRcdGlmIChzdGFja2VkUmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0c3VtTmVnICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdW1Qb3MgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmlnaHRWYWx1ZSA9IE51bWJlcih5U2NhbGUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSkpO1xuXHRcdFx0XHRpZiAocmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtTmVnICsgcmlnaHRWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bVBvcyArIHJpZ2h0VmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBhcmVhID0gbWUuY2hhcnQuY2hhcnRBcmVhO1xuXHRcdFx0dmFyIHBvaW50cyA9IChtZXRhLmRhdGEgfHwgW10pO1xuXHRcdFx0dmFyIGksIGlsZW4sIHBvaW50LCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdFx0Ly8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcblx0XHRcdGlmIChtZXRhLmRhdGFzZXQuX21vZGVsLnNwYW5HYXBzKSB7XG5cdFx0XHRcdHBvaW50cyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtZXRhLmRhdGFzZXQuX21vZGVsLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcblx0XHRcdFx0aGVscGVycy5zcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRcdHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRcdG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdFx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRcdFx0aGVscGVycy5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0XHRtb2RlbCxcblx0XHRcdFx0XHRcdGhlbHBlcnMubmV4dEl0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0XHRtZXRhLmRhdGFzZXQuX21vZGVsLnRlbnNpb25cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjb250cm9sUG9pbnRzLm5leHQueDtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUuY2FwQmV6aWVyUG9pbnRzKSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1gsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHRcdHZhciBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdFx0dmFyIGlsZW4gPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHRoZWxwZXJzLmNhbnZhcy5jbGlwQXJlYShjaGFydC5jdHgsIGFyZWEpO1xuXG5cdFx0XHRpZiAobGluZUVuYWJsZWQobWUuZ2V0RGF0YXNldCgpLCBjaGFydC5vcHRpb25zKSkge1xuXHRcdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cblx0XHRcdC8vIERyYXcgdGhlIHBvaW50c1xuXHRcdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0cG9pbnRzW2ldLmRyYXcoYXJlYSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHQvLyBQb2ludFxuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbcG9pbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgaW5kZXggPSBwb2ludC5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBjdXN0b20uaG92ZXJSYWRpdXMgfHwgaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhvdmVyUmFkaXVzLCBpbmRleCwgdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LmhvdmVyUmFkaXVzKTtcblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciB8fCBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yIHx8IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIb3ZlckJvcmRlckNvbG9yLCBpbmRleCwgaGVscGVycy5nZXRIb3ZlckNvbG9yKG1vZGVsLmJvcmRlckNvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IGN1c3RvbS5ob3ZlckJvcmRlcldpZHRoIHx8IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIb3ZlckJvcmRlcldpZHRoLCBpbmRleCwgbW9kZWwuYm9yZGVyV2lkdGgpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBpbmRleCA9IHBvaW50Ll9pbmRleDtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cblx0XHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcblx0XHRcdGlmICgoZGF0YXNldC5yYWRpdXMgIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQucG9pbnRSYWRpdXMgPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5wb2ludFJhZGl1cyA9IGRhdGFzZXQucmFkaXVzO1xuXHRcdFx0fVxuXG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBjdXN0b20ucmFkaXVzIHx8IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRSYWRpdXMsIGluZGV4LCBtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LnJhZGl1cyk7XG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBtZS5nZXRQb2ludEJhY2tncm91bmRDb2xvcihwb2ludCwgaW5kZXgpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBtZS5nZXRQb2ludEJvcmRlckNvbG9yKHBvaW50LCBpbmRleCk7XG5cdFx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IG1lLmdldFBvaW50Qm9yZGVyV2lkdGgocG9pbnQsIGluZGV4KTtcblx0XHR9XG5cdH0pO1xufTtcblxufSx7XCIyNVwiOjI1LFwiNDBcIjo0MCxcIjQ1XCI6NDV9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGVsZW1lbnRzID0gcmVxdWlyZSg0MCk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdwb2xhckFyZWEnLCB7XG5cdHNjYWxlOiB7XG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0YW5nbGVMaW5lczoge1xuXHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHR9LFxuXHRcdGdyaWRMaW5lczoge1xuXHRcdFx0Y2lyY3VsYXI6IHRydWVcblx0XHR9LFxuXHRcdHBvaW50TGFiZWxzOiB7XG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdH0sXG5cdFx0dGlja3M6IHtcblx0XHRcdGJlZ2luQXRaZXJvOiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydFxuXHRhbmltYXRpb246IHtcblx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxuXHRcdGFuaW1hdGVTY2FsZTogdHJ1ZVxuXHR9LFxuXG5cdHN0YXJ0QW5nbGU6IC0wLjUgKiBNYXRoLlBJLFxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblxuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcblx0XHRcdFx0XHR0ZXh0LnB1c2gobGFiZWxzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9LFxuXHRsZWdlbmQ6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuXHRcdFx0XHRcdFx0dmFyIGRzID0gZGF0YS5kYXRhc2V0c1swXTtcblx0XHRcdFx0XHRcdHZhciBhcmMgPSBtZXRhLmRhdGFbaV07XG5cdFx0XHRcdFx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblx0XHRcdFx0XHRcdHZhciBhcmNPcHRzID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0XHRcdFx0XHR2YXIgZmlsbCA9IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uYmFja2dyb3VuZENvbG9yIDogdmFsdWVBdEluZGV4T3JEZWZhdWx0KGRzLmJhY2tncm91bmRDb2xvciwgaSwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3IpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IHZhbHVlQXRJbmRleE9yRGVmYXVsdChkcy5ib3JkZXJDb2xvciwgaSwgYXJjT3B0cy5ib3JkZXJDb2xvcik7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyV2lkdGgsIGksIGFyY09wdHMuYm9yZGVyV2lkdGgpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Y2hhcnQudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzW2l0ZW0uaW5kZXhdICsgJzogJyArIGl0ZW0ueUxhYmVsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5jb250cm9sbGVycy5wb2xhckFyZWEgPSBDaGFydC5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdFx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0XHRsaW5rU2NhbGVzOiBoZWxwZXJzLm5vb3AsXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0XHR2YXIgYXJjT3B0cyA9IG9wdHMuZWxlbWVudHMuYXJjO1xuXHRcdFx0dmFyIG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXHRcdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgobWluU2l6ZSAtIGFyY09wdHMuYm9yZGVyV2lkdGggLyAyKSAvIDIsIDApO1xuXHRcdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAoY2hhcnQub3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcblx0XHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuXHRcdFx0bWUub3V0ZXJSYWRpdXMgPSBjaGFydC5vdXRlclJhZGl1cyAtIChjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5pbmRleCk7XG5cdFx0XHRtZS5pbm5lclJhZGl1cyA9IG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoO1xuXG5cdFx0XHRtZXRhLmNvdW50ID0gbWUuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oYXJjLCBpbmRleCkge1xuXHRcdFx0XHRtZS51cGRhdGVFbGVtZW50KGFyYywgaW5kZXgsIHJlc2V0KTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdFx0dmFyIHNjYWxlID0gY2hhcnQuc2NhbGU7XG5cdFx0XHR2YXIgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHM7XG5cblx0XHRcdHZhciBjaXJjdW1mZXJlbmNlID0gbWUuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHRcdHZhciBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcblx0XHRcdHZhciBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgTmFOIGRhdGEgYmVmb3JlIHVzLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgc3RhcnRpbmcgYW5nbGUgY29ycmVjdGx5LlxuXHRcdFx0Ly8gV2UgY291bGQgYmUgd2F5IG1vcmUgZWZmaWNpZW50IGhlcmUsIGJ1dCBpdHMgdW5saWtlbHkgdGhhdCB0aGUgcG9sYXIgYXJlYSBjaGFydCB3aWxsIGhhdmUgYSBsb3Qgb2YgZGF0YVxuXHRcdFx0dmFyIHZpc2libGVDb3VudCA9IDA7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7ICsraSkge1xuXHRcdFx0XHRpZiAoIWlzTmFOKGRhdGFzZXQuZGF0YVtpXSkgJiYgIW1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcblx0XHRcdFx0XHQrK3Zpc2libGVDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB2YXIgbmVnSGFsZlBJID0gLTAuNSAqIE1hdGguUEk7XG5cdFx0XHR2YXIgZGF0YXNldFN0YXJ0QW5nbGUgPSBvcHRzLnN0YXJ0QW5nbGU7XG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBhcmMuaGlkZGVuID8gMCA6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICogdmlzaWJsZUNvdW50KTtcblx0XHRcdHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoYXJjLmhpZGRlbiA/IDAgOiBjaXJjdW1mZXJlbmNlKTtcblxuXHRcdFx0dmFyIHJlc2V0UmFkaXVzID0gYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cblx0XHRcdGhlbHBlcnMuZXh0ZW5kKGFyYywge1xuXHRcdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0XHRfaW5kZXg6IGluZGV4LFxuXHRcdFx0XHRfc2NhbGU6IHNjYWxlLFxuXG5cdFx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRcdHg6IGNlbnRlclgsXG5cdFx0XHRcdFx0eTogY2VudGVyWSxcblx0XHRcdFx0XHRpbm5lclJhZGl1czogMCxcblx0XHRcdFx0XHRvdXRlclJhZGl1czogcmVzZXQgPyByZXNldFJhZGl1cyA6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdHN0YXJ0QW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogc3RhcnRBbmdsZSxcblx0XHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcblx0XHRcdFx0XHRsYWJlbDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQobGFiZWxzLCBpbmRleCwgbGFiZWxzW2luZGV4XSlcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGJvcmRlciBhbmQgZmlsbCBzdHlsZVxuXHRcdFx0bWUucmVtb3ZlSG92ZXJTdHlsZShhcmMpO1xuXG5cdFx0XHRhcmMucGl2b3QoKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0XHRDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlSG92ZXJTdHlsZS5jYWxsKHRoaXMsIGFyYywgdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYyk7XG5cdFx0fSxcblxuXHRcdGNvdW50VmlzaWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdFx0aWYgKCFpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSAmJiAhZWxlbWVudC5oaWRkZW4pIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRjYWxjdWxhdGVDaXJjdW1mZXJlbmNlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIGNvdW50ID0gdGhpcy5nZXRNZXRhKCkuY291bnQ7XG5cdFx0XHRpZiAoY291bnQgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuICgyICogTWF0aC5QSSkgLyBjb3VudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fSk7XG59O1xuXG59LHtcIjI1XCI6MjUsXCI0MFwiOjQwLFwiNDVcIjo0NX1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgZWxlbWVudHMgPSByZXF1aXJlKDQwKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmRlZmF1bHRzLl9zZXQoJ3JhZGFyJywge1xuXHRzY2FsZToge1xuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInXG5cdH0sXG5cdGVsZW1lbnRzOiB7XG5cdFx0bGluZToge1xuXHRcdFx0dGVuc2lvbjogMCAvLyBubyBiZXppZXIgaW4gcmFkYXJcblx0XHR9XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuY29udHJvbGxlcnMucmFkYXIgPSBDaGFydC5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdFx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdFx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHRcdGxpbmtTY2FsZXM6IGhlbHBlcnMubm9vcCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YTtcblx0XHRcdHZhciBjdXN0b20gPSBsaW5lLmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGxpbmVFbGVtZW50T3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xuXG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQudGVuc2lvbiAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5saW5lVGVuc2lvbiA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRkYXRhc2V0LmxpbmVUZW5zaW9uID0gZGF0YXNldC50ZW5zaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChtZXRhLmRhdGFzZXQsIHtcblx0XHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdFx0X3NjYWxlOiBzY2FsZSxcblx0XHRcdFx0Ly8gRGF0YVxuXHRcdFx0XHRfY2hpbGRyZW46IHBvaW50cyxcblx0XHRcdFx0X2xvb3A6IHRydWUsXG5cdFx0XHRcdC8vIE1vZGVsXG5cdFx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdFx0XHR0ZW5zaW9uOiBjdXN0b20udGVuc2lvbiA/IGN1c3RvbS50ZW5zaW9uIDogaGVscGVycy52YWx1ZU9yRGVmYXVsdChkYXRhc2V0LmxpbmVUZW5zaW9uLCBsaW5lRWxlbWVudE9wdGlvbnMudGVuc2lvbiksXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IChkYXRhc2V0LmJhY2tncm91bmRDb2xvciB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSxcblx0XHRcdFx0XHRib3JkZXJXaWR0aDogY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogKGRhdGFzZXQuYm9yZGVyV2lkdGggfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlcldpZHRoKSxcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogKGRhdGFzZXQuYm9yZGVyQ29sb3IgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckNvbG9yKSxcblx0XHRcdFx0XHRmaWxsOiBjdXN0b20uZmlsbCA/IGN1c3RvbS5maWxsIDogKGRhdGFzZXQuZmlsbCAhPT0gdW5kZWZpbmVkID8gZGF0YXNldC5maWxsIDogbGluZUVsZW1lbnRPcHRpb25zLmZpbGwpLFxuXHRcdFx0XHRcdGJvcmRlckNhcFN0eWxlOiBjdXN0b20uYm9yZGVyQ2FwU3R5bGUgPyBjdXN0b20uYm9yZGVyQ2FwU3R5bGUgOiAoZGF0YXNldC5ib3JkZXJDYXBTdHlsZSB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpLFxuXHRcdFx0XHRcdGJvcmRlckRhc2g6IGN1c3RvbS5ib3JkZXJEYXNoID8gY3VzdG9tLmJvcmRlckRhc2ggOiAoZGF0YXNldC5ib3JkZXJEYXNoIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJEYXNoKSxcblx0XHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0OiBjdXN0b20uYm9yZGVyRGFzaE9mZnNldCA/IGN1c3RvbS5ib3JkZXJEYXNoT2Zmc2V0IDogKGRhdGFzZXQuYm9yZGVyRGFzaE9mZnNldCB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCksXG5cdFx0XHRcdFx0Ym9yZGVySm9pblN0eWxlOiBjdXN0b20uYm9yZGVySm9pblN0eWxlID8gY3VzdG9tLmJvcmRlckpvaW5TdHlsZSA6IChkYXRhc2V0LmJvcmRlckpvaW5TdHlsZSB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVySm9pblN0eWxlKSxcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1ldGEuZGF0YXNldC5waXZvdCgpO1xuXG5cdFx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0XHRoZWxwZXJzLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludCwgaW5kZXgsIHJlc2V0KTtcblx0XHRcdH0sIG1lKTtcblxuXHRcdFx0Ly8gVXBkYXRlIGJlemllciBjb250cm9sIHBvaW50c1xuXHRcdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xuXHRcdH0sXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xuXHRcdFx0dmFyIHBvaW50RWxlbWVudE9wdGlvbnMgPSBtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdFx0dmFyIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQucmFkaXVzICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LnBvaW50UmFkaXVzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQucG9pbnRSYWRpdXMgPSBkYXRhc2V0LnJhZGl1cztcblx0XHRcdH1cblx0XHRcdGlmICgoZGF0YXNldC5oaXRSYWRpdXMgIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQucG9pbnRIaXRSYWRpdXMgPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5wb2ludEhpdFJhZGl1cyA9IGRhdGFzZXQuaGl0UmFkaXVzO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChwb2ludCwge1xuXHRcdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0XHRfaW5kZXg6IGluZGV4LFxuXHRcdFx0XHRfc2NhbGU6IHNjYWxlLFxuXG5cdFx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRcdHg6IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueCwgLy8gdmFsdWUgbm90IHVzZWQgaW4gZGF0YXNldCBzY2FsZSwgYnV0IHdlIHdhbnQgYSBjb25zaXN0ZW50IEFQSSBiZXR3ZWVuIHNjYWxlc1xuXHRcdFx0XHRcdHk6IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueSxcblxuXHRcdFx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdFx0XHR0ZW5zaW9uOiBjdXN0b20udGVuc2lvbiA/IGN1c3RvbS50ZW5zaW9uIDogaGVscGVycy52YWx1ZU9yRGVmYXVsdChkYXRhc2V0LmxpbmVUZW5zaW9uLCBtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUudGVuc2lvbiksXG5cdFx0XHRcdFx0cmFkaXVzOiBjdXN0b20ucmFkaXVzID8gY3VzdG9tLnJhZGl1cyA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRSYWRpdXMsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLnJhZGl1cyksXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmJhY2tncm91bmRDb2xvciksXG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCb3JkZXJDb2xvciwgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMuYm9yZGVyQ29sb3IpLFxuXHRcdFx0XHRcdGJvcmRlcldpZHRoOiBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50Qm9yZGVyV2lkdGgsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmJvcmRlcldpZHRoKSxcblx0XHRcdFx0XHRwb2ludFN0eWxlOiBjdXN0b20ucG9pbnRTdHlsZSA/IGN1c3RvbS5wb2ludFN0eWxlIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludFN0eWxlLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5wb2ludFN0eWxlKSxcblxuXHRcdFx0XHRcdC8vIFRvb2x0aXBcblx0XHRcdFx0XHRoaXRSYWRpdXM6IGN1c3RvbS5oaXRSYWRpdXMgPyBjdXN0b20uaGl0UmFkaXVzIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhpdFJhZGl1cywgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMuaGl0UmFkaXVzKVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cG9pbnQuX21vZGVsLnNraXAgPSBjdXN0b20uc2tpcCA/IGN1c3RvbS5za2lwIDogKGlzTmFOKHBvaW50Ll9tb2RlbC54KSB8fCBpc05hTihwb2ludC5fbW9kZWwueSkpO1xuXHRcdH0sXG5cdFx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2hhcnRBcmVhID0gdGhpcy5jaGFydC5jaGFydEFyZWE7XG5cdFx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdFx0XHR2YXIgY29udHJvbFBvaW50cyA9IGhlbHBlcnMuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdFx0aGVscGVycy5wcmV2aW91c0l0ZW0obWV0YS5kYXRhLCBpbmRleCwgdHJ1ZSkuX21vZGVsLFxuXHRcdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRcdGhlbHBlcnMubmV4dEl0ZW0obWV0YS5kYXRhLCBpbmRleCwgdHJ1ZSkuX21vZGVsLFxuXHRcdFx0XHRcdG1vZGVsLnRlbnNpb25cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IHRoZSBiZXppZXIgZ29pbmcgb3V0c2lkZSBvZiB0aGUgYm91bmRzIG9mIHRoZSBncmFwaFxuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBNYXRoLm1heChNYXRoLm1pbihjb250cm9sUG9pbnRzLnByZXZpb3VzLngsIGNoYXJ0QXJlYS5yaWdodCksIGNoYXJ0QXJlYS5sZWZ0KTtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gTWF0aC5tYXgoTWF0aC5taW4oY29udHJvbFBvaW50cy5wcmV2aW91cy55LCBjaGFydEFyZWEuYm90dG9tKSwgY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBNYXRoLm1heChNYXRoLm1pbihjb250cm9sUG9pbnRzLm5leHQueCwgY2hhcnRBcmVhLnJpZ2h0KSwgY2hhcnRBcmVhLmxlZnQpO1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IE1hdGgubWF4KE1hdGgubWluKGNvbnRyb2xQb2ludHMubmV4dC55LCBjaGFydEFyZWEuYm90dG9tKSwgY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRcdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0XHRcdHBvaW50LnBpdm90KCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdC8vIFBvaW50XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgaW5kZXggPSBwb2ludC5faW5kZXg7XG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cblx0XHRcdG1vZGVsLnJhZGl1cyA9IGN1c3RvbS5ob3ZlclJhZGl1cyA/IGN1c3RvbS5ob3ZlclJhZGl1cyA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIb3ZlclJhZGl1cywgaW5kZXgsIHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5ob3ZlclJhZGl1cyk7XG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yID8gY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCb3JkZXJDb2xvciwgaW5kZXgsIGhlbHBlcnMuZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA/IGN1c3RvbS5ob3ZlckJvcmRlcldpZHRoIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhvdmVyQm9yZGVyV2lkdGgsIGluZGV4LCBtb2RlbC5ib3JkZXJXaWR0aCk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgaW5kZXggPSBwb2ludC5faW5kZXg7XG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0XHR2YXIgcG9pbnRFbGVtZW50T3B0aW9ucyA9IHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblxuXHRcdFx0bW9kZWwucmFkaXVzID0gY3VzdG9tLnJhZGl1cyA/IGN1c3RvbS5yYWRpdXMgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50UmFkaXVzLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5yYWRpdXMpO1xuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50QmFja2dyb3VuZENvbG9yLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50Qm9yZGVyQ29sb3IsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmJvcmRlckNvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJvcmRlcldpZHRoLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjQwXCI6NDAsXCI0NVwiOjQ1fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcblxuZGVmYXVsdHMuX3NldCgnc2NhdHRlcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAgICAvLyBzY2F0dGVyIHNob3VsZCBub3QgdXNlIGEgY2F0ZWdvcnkgYXhpc1xuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHRpZDogJ3ktYXhpcy0xJyxcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0J1xuXHRcdH1dXG5cdH0sXG5cblx0c2hvd0xpbmVzOiBmYWxzZSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7ICAgICAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2UgZGF0YSBhcmUgZm9ybWF0dGVkIGFzIGEgcG9pbnRcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gJygnICsgaXRlbS54TGFiZWwgKyAnLCAnICsgaXRlbS55TGFiZWwgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdC8vIFNjYXR0ZXIgY2hhcnRzIHVzZSBsaW5lIGNvbnRyb2xsZXJzXG5cdENoYXJ0LmNvbnRyb2xsZXJzLnNjYXR0ZXIgPSBDaGFydC5jb250cm9sbGVycy5saW5lO1xuXG59O1xuXG59LHtcIjI1XCI6MjV9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBnbG9iYWwgd2luZG93OiBmYWxzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgyNik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGFuaW1hdGlvbjoge1xuXHRcdGR1cmF0aW9uOiAxMDAwLFxuXHRcdGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG5cdFx0b25Qcm9ncmVzczogaGVscGVycy5ub29wLFxuXHRcdG9uQ29tcGxldGU6IGhlbHBlcnMubm9vcFxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LkFuaW1hdGlvbiA9IEVsZW1lbnQuZXh0ZW5kKHtcblx0XHRjaGFydDogbnVsbCwgLy8gdGhlIGFuaW1hdGlvbiBhc3NvY2lhdGVkIGNoYXJ0IGluc3RhbmNlXG5cdFx0Y3VycmVudFN0ZXA6IDAsIC8vIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGVwXG5cdFx0bnVtU3RlcHM6IDYwLCAvLyBkZWZhdWx0IG51bWJlciBvZiBzdGVwc1xuXHRcdGVhc2luZzogJycsIC8vIHRoZSBlYXNpbmcgdG8gdXNlIGZvciB0aGlzIGFuaW1hdGlvblxuXHRcdHJlbmRlcjogbnVsbCwgLy8gcmVuZGVyIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGFuaW1hdGlvbiBzZXJ2aWNlXG5cblx0XHRvbkFuaW1hdGlvblByb2dyZXNzOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIG9uIGVhY2ggc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG5cdFx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXNcblx0fSk7XG5cblx0Q2hhcnQuYW5pbWF0aW9uU2VydmljZSA9IHtcblx0XHRmcmFtZUR1cmF0aW9uOiAxNyxcblx0XHRhbmltYXRpb25zOiBbXSxcblx0XHRkcm9wRnJhbWVzOiAwLFxuXHRcdHJlcXVlc3Q6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCB0byBhbmltYXRlLlxuXHRcdCAqIEBwYXJhbSB7Q2hhcnQuQW5pbWF0aW9ufSBhbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRoYXQgd2Ugd2lsbCBhbmltYXRlLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBsYXp5IC0gaWYgdHJ1ZSwgdGhlIGNoYXJ0IGlzIG5vdCBtYXJrZWQgYXMgYW5pbWF0aW5nIHRvIGVuYWJsZSBtb3JlIHJlc3BvbnNpdmUgaW50ZXJhY3Rpb25zXG5cdFx0ICovXG5cdFx0YWRkQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSkge1xuXHRcdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XG5cdFx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdFx0YW5pbWF0aW9uLmNoYXJ0ID0gY2hhcnQ7XG5cblx0XHRcdGlmICghbGF6eSkge1xuXHRcdFx0XHRjaGFydC5hbmltYXRpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYW5pbWF0aW9ucy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGFuaW1hdGlvbnNbaV0uY2hhcnQgPT09IGNoYXJ0KSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uc1tpXSA9IGFuaW1hdGlvbjtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG5cblx0XHRcdC8vIElmIHRoZXJlIGFyZSBubyBhbmltYXRpb25zIHF1ZXVlZCwgbWFudWFsbHkga2lja3N0YXJ0IGEgZGlnZXN0LCBmb3IgbGFjayBvZiBhIGJldHRlciB3b3JkXG5cdFx0XHRpZiAoYW5pbWF0aW9ucy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2FuY2VsQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0dmFyIGluZGV4ID0gaGVscGVycy5maW5kSW5kZXgodGhpcy5hbmltYXRpb25zLCBmdW5jdGlvbihhbmltYXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIGFuaW1hdGlvbi5jaGFydCA9PT0gY2hhcnQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHR0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0aWYgKG1lLnJlcXVlc3QgPT09IG51bGwpIHtcblx0XHRcdFx0Ly8gU2tpcCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdHMgdW50aWwgdGhlIGFjdGl2ZSBvbmUgaXMgZXhlY3V0ZWQuXG5cdFx0XHRcdC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHByb2Nlc3NpbmcgbW91c2UgZXZlbnRzLCBlLmcuICdtb3VzZW1vdmUnXG5cdFx0XHRcdC8vIGFuZCAnbW91c2VvdXQnIGV2ZW50cyB3aWxsIHRyaWdnZXIgbXVsdGlwbGUgcmVuZGVycy5cblx0XHRcdFx0bWUucmVxdWVzdCA9IGhlbHBlcnMucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0bWUucmVxdWVzdCA9IG51bGw7XG5cdFx0XHRcdFx0bWUuc3RhcnREaWdlc3QoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0c3RhcnREaWdlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0dmFyIGZyYW1lc1RvRHJvcCA9IDA7XG5cblx0XHRcdGlmIChtZS5kcm9wRnJhbWVzID4gMSkge1xuXHRcdFx0XHRmcmFtZXNUb0Ryb3AgPSBNYXRoLmZsb29yKG1lLmRyb3BGcmFtZXMpO1xuXHRcdFx0XHRtZS5kcm9wRnJhbWVzID0gbWUuZHJvcEZyYW1lcyAlIDE7XG5cdFx0XHR9XG5cblx0XHRcdG1lLmFkdmFuY2UoMSArIGZyYW1lc1RvRHJvcCk7XG5cblx0XHRcdHZhciBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0bWUuZHJvcEZyYW1lcyArPSAoZW5kVGltZSAtIHN0YXJ0VGltZSkgLyBtZS5mcmFtZUR1cmF0aW9uO1xuXG5cdFx0XHQvLyBEbyB3ZSBoYXZlIG1vcmUgc3R1ZmYgdG8gYW5pbWF0ZT9cblx0XHRcdGlmIChtZS5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0bWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0YWR2YW5jZTogZnVuY3Rpb24oY291bnQpIHtcblx0XHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdFx0dmFyIGFuaW1hdGlvbiwgY2hhcnQ7XG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdHdoaWxlIChpIDwgYW5pbWF0aW9ucy5sZW5ndGgpIHtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uc1tpXTtcblx0XHRcdFx0Y2hhcnQgPSBhbmltYXRpb24uY2hhcnQ7XG5cblx0XHRcdFx0YW5pbWF0aW9uLmN1cnJlbnRTdGVwID0gKGFuaW1hdGlvbi5jdXJyZW50U3RlcCB8fCAwKSArIGNvdW50O1xuXHRcdFx0XHRhbmltYXRpb24uY3VycmVudFN0ZXAgPSBNYXRoLm1pbihhbmltYXRpb24uY3VycmVudFN0ZXAsIGFuaW1hdGlvbi5udW1TdGVwcyk7XG5cblx0XHRcdFx0aGVscGVycy5jYWxsYmFjayhhbmltYXRpb24ucmVuZGVyLCBbY2hhcnQsIGFuaW1hdGlvbl0sIGNoYXJ0KTtcblx0XHRcdFx0aGVscGVycy5jYWxsYmFjayhhbmltYXRpb24ub25BbmltYXRpb25Qcm9ncmVzcywgW2FuaW1hdGlvbl0sIGNoYXJ0KTtcblxuXHRcdFx0XHRpZiAoYW5pbWF0aW9uLmN1cnJlbnRTdGVwID49IGFuaW1hdGlvbi5udW1TdGVwcykge1xuXHRcdFx0XHRcdGhlbHBlcnMuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uQ29tcGxldGUsIFthbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KytpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiBpbnN0ZWFkXG5cdCAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNhbmltYXRpb25PYmplY3Rcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhcnQuQW5pbWF0aW9uLnByb3RvdHlwZSwgJ2FuaW1hdGlvbk9iamVjdCcsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5BbmltYXRpb24jY2hhcnQgaW5zdGVhZFxuXHQgKiBAcHJvcCBDaGFydC5BbmltYXRpb24jY2hhcnRJbnN0YW5jZVxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFydC5BbmltYXRpb24ucHJvdG90eXBlLCAnY2hhcnRJbnN0YW5jZScsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2hhcnQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmNoYXJ0ID0gdmFsdWU7XG5cdFx0fVxuXHR9KTtcblxufTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNixcIjQ1XCI6NDV9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoMjgpO1xudmFyIHBsYXRmb3JtID0gcmVxdWlyZSg0OCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblx0dmFyIHBsdWdpbnMgPSBDaGFydC5wbHVnaW5zO1xuXG5cdC8vIENyZWF0ZSBhIGRpY3Rpb25hcnkgb2YgY2hhcnQgdHlwZXMsIHRvIGFsbG93IGZvciBleHRlbnNpb24gb2YgZXhpc3RpbmcgdHlwZXNcblx0Q2hhcnQudHlwZXMgPSB7fTtcblxuXHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byBlYWNoIGluc3RhbmNlIC0gYWxsb3dpbmcgdXMgdG8gZ2xvYmFsbHkgcmVzaXplIGNoYXJ0IGluc3RhbmNlcyBvbiB3aW5kb3cgcmVzaXplLlxuXHQvLyBEZXN0cm95IG1ldGhvZCBvbiB0aGUgY2hhcnQgd2lsbCByZW1vdmUgdGhlIGluc3RhbmNlIG9mIHRoZSBjaGFydCBmcm9tIHRoaXMgcmVmZXJlbmNlLlxuXHRDaGFydC5pbnN0YW5jZXMgPSB7fTtcblxuXHQvLyBDb250cm9sbGVycyBhdmFpbGFibGUgZm9yIGRhdGFzZXQgdmlzdWFsaXphdGlvbiBlZy4gYmFyLCBsaW5lLCBzbGljZSwgZXRjLlxuXHRDaGFydC5jb250cm9sbGVycyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgZ2l2ZW4gY29uZmlnIHdpdGggZ2xvYmFsIGFuZCBjaGFydCBkZWZhdWx0IHZhbHVlcy5cblx0ICovXG5cdGZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdFx0Ly8gRG8gTk9UIHVzZSBjb25maWdNZXJnZSgpIGZvciB0aGUgZGF0YSBvYmplY3QgYmVjYXVzZSB0aGlzIG1ldGhvZCBtZXJnZXMgYXJyYXlzXG5cdFx0Ly8gYW5kIHNvIHdvdWxkIGNoYW5nZSByZWZlcmVuY2VzIHRvIGxhYmVscyBhbmQgZGF0YXNldHMsIHByZXZlbnRpbmcgZGF0YSB1cGRhdGVzLlxuXHRcdHZhciBkYXRhID0gY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblx0XHRkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcblx0XHRkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuXG5cdFx0Y29uZmlnLm9wdGlvbnMgPSBoZWxwZXJzLmNvbmZpZ01lcmdlKFxuXHRcdFx0ZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdFx0ZGVmYXVsdHNbY29uZmlnLnR5cGVdLFxuXHRcdFx0Y29uZmlnLm9wdGlvbnMgfHwge30pO1xuXG5cdFx0cmV0dXJuIGNvbmZpZztcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjb25maWcgb2YgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSBjaGFydCB7Q2hhcnR9IGNoYXJ0IHRvIHVwZGF0ZSB0aGUgb3B0aW9ucyBmb3Jcblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyhjaGFydCkge1xuXHRcdHZhciBuZXdPcHRpb25zID0gY2hhcnQub3B0aW9ucztcblxuXHRcdC8vIFVwZGF0ZSBTY2FsZShzKSB3aXRoIG9wdGlvbnNcblx0XHRpZiAobmV3T3B0aW9ucy5zY2FsZSkge1xuXHRcdFx0Y2hhcnQuc2NhbGUub3B0aW9ucyA9IG5ld09wdGlvbnMuc2NhbGU7XG5cdFx0fSBlbHNlIGlmIChuZXdPcHRpb25zLnNjYWxlcykge1xuXHRcdFx0bmV3T3B0aW9ucy5zY2FsZXMueEF4ZXMuY29uY2F0KG5ld09wdGlvbnMuc2NhbGVzLnlBeGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHNjYWxlT3B0aW9ucykge1xuXHRcdFx0XHRjaGFydC5zY2FsZXNbc2NhbGVPcHRpb25zLmlkXS5vcHRpb25zID0gc2NhbGVPcHRpb25zO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gVG9vbHRpcFxuXHRcdGNoYXJ0LnRvb2x0aXAuX29wdGlvbnMgPSBuZXdPcHRpb25zLnRvb2x0aXBzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcblx0fVxuXG5cdGhlbHBlcnMuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBDaGFydCAqLyB7XG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Q6IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Y29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuXG5cdFx0XHR2YXIgY29udGV4dCA9IHBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGl0ZW0sIGNvbmZpZyk7XG5cdFx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcblx0XHRcdHZhciBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcblx0XHRcdHZhciB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cblx0XHRcdG1lLmlkID0gaGVscGVycy51aWQoKTtcblx0XHRcdG1lLmN0eCA9IGNvbnRleHQ7XG5cdFx0XHRtZS5jYW52YXMgPSBjYW52YXM7XG5cdFx0XHRtZS5jb25maWcgPSBjb25maWc7XG5cdFx0XHRtZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0bWUuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0bWUuYXNwZWN0UmF0aW8gPSBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG5cdFx0XHRtZS5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG5cdFx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgQ2hhcnQgYW5kIENoYXJ0LkNvbnRyb2xsZXIgaGF2ZSBiZWVuIG1lcmdlZCxcblx0XHRcdCAqIHRoZSBcImluc3RhbmNlXCIgc3RpbGwgbmVlZCB0byBiZSBkZWZpbmVkIHNpbmNlIGl0IG1pZ2h0IGJlIGNhbGxlZCBmcm9tIHBsdWdpbnMuXG5cdFx0XHQgKiBAcHJvcCBDaGFydCNjaGFydFxuXHRcdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHRcdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHRcdFx0bWUuY2hhcnQgPSBtZTtcblx0XHRcdG1lLmNvbnRyb2xsZXIgPSBtZTsgLy8gY2hhcnQuY2hhcnQuY29udHJvbGxlciAjaW5jZXB0aW9uXG5cblx0XHRcdC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2Vcblx0XHRcdENoYXJ0Lmluc3RhbmNlc1ttZS5pZF0gPSBtZTtcblxuXHRcdFx0Ly8gRGVmaW5lIGFsaWFzIHRvIHRoZSBjb25maWcgZGF0YTogYGNoYXJ0LmRhdGEgPT09IGNoYXJ0LmNvbmZpZy5kYXRhYFxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnZGF0YScsIHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWUuY29uZmlnLmRhdGE7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRtZS5jb25maWcuZGF0YSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcblx0XHRcdFx0Ly8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG5cdFx0XHRcdC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XG5cdFx0XHRcdC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG1lLmluaXRpYWxpemUoKTtcblx0XHRcdG1lLnVwZGF0ZSgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Ly8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVJbml0Jyk7XG5cblx0XHRcdGhlbHBlcnMucmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRcdG1lLmJpbmRFdmVudHMoKTtcblxuXHRcdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0XHQvLyBJbml0aWFsIHJlc2l6ZSBiZWZvcmUgY2hhcnQgZHJhd3MgKG11c3QgYmUgc2lsZW50IHRvIHByZXNlcnZlIGluaXRpYWwgYW5pbWF0aW9ucykuXG5cdFx0XHRcdG1lLnJlc2l6ZSh0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHNjYWxlcyBoYXZlIElEcyBhbmQgYXJlIGJ1aWx0IGJlZm9yZSB3ZSBidWlsZCBhbnkgY29udHJvbGxlcnMuXG5cdFx0XHRtZS5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG5cdFx0XHRtZS5idWlsZFNjYWxlcygpO1xuXHRcdFx0bWUuaW5pdFRvb2xUaXAoKTtcblxuXHRcdFx0Ly8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVySW5pdCcpO1xuXG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fSxcblxuXHRcdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FudmFzLmNsZWFyKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gU3RvcHMgYW55IGN1cnJlbnQgYW5pbWF0aW9uIGxvb3Agb2NjdXJyaW5nXG5cdFx0XHRDaGFydC5hbmltYXRpb25TZXJ2aWNlLmNhbmNlbEFuaW1hdGlvbih0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZXNpemU6IGZ1bmN0aW9uKHNpbGVudCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0XHR2YXIgYXNwZWN0UmF0aW8gPSAob3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG1lLmFzcGVjdFJhdGlvKSB8fCBudWxsO1xuXG5cdFx0XHQvLyB0aGUgY2FudmFzIHJlbmRlciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgY2FzdGVkIHRvIGludGVnZXJzIHNvIG1ha2Ugc3VyZSB0aGF0XG5cdFx0XHQvLyB0aGUgY2FudmFzIGRpc3BsYXkgc3R5bGUgdXNlcyB0aGUgc2FtZSBpbnRlZ2VyIHZhbHVlcyB0byBhdm9pZCBibHVycmluZyBlZmZlY3QuXG5cblx0XHRcdC8vIFNldCB0byAwIGluc3RlYWQgb2YgY2FudmFzLnNpemUgYmVjYXVzZSB0aGUgc2l6ZSBkZWZhdWx0cyB0byAzMDB4MTUwIGlmIHRoZSBlbGVtZW50IGlzIGNvbGxhc2VkXG5cdFx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGhlbHBlcnMuZ2V0TWF4aW11bVdpZHRoKGNhbnZhcykpKTtcblx0XHRcdHZhciBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGFzcGVjdFJhdGlvID8gbmV3V2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlbHBlcnMuZ2V0TWF4aW11bUhlaWdodChjYW52YXMpKSk7XG5cblx0XHRcdGlmIChtZS53aWR0aCA9PT0gbmV3V2lkdGggJiYgbWUuaGVpZ2h0ID09PSBuZXdIZWlnaHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYW52YXMud2lkdGggPSBtZS53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IG1lLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuXG5cdFx0XHRoZWxwZXJzLnJldGluYVNjYWxlKG1lLCBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0XHRpZiAoIXNpbGVudCkge1xuXHRcdFx0XHQvLyBOb3RpZnkgYW55IHBsdWdpbnMgYWJvdXQgdGhlIHJlc2l6ZVxuXHRcdFx0XHR2YXIgbmV3U2l6ZSA9IHt3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0fTtcblx0XHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdyZXNpemUnLCBbbmV3U2l6ZV0pO1xuXG5cdFx0XHRcdC8vIE5vdGlmeSBvZiByZXNpemVcblx0XHRcdFx0aWYgKG1lLm9wdGlvbnMub25SZXNpemUpIHtcblx0XHRcdFx0XHRtZS5vcHRpb25zLm9uUmVzaXplKG1lLCBuZXdTaXplKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lLnN0b3AoKTtcblx0XHRcdFx0bWUudXBkYXRlKG1lLm9wdGlvbnMucmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZW5zdXJlU2NhbGVzSGF2ZUlEczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRcdHZhciBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cdFx0XHR2YXIgc2NhbGVPcHRpb25zID0gb3B0aW9ucy5zY2FsZTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHNjYWxlc09wdGlvbnMueEF4ZXMsIGZ1bmN0aW9uKHhBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdFx0eEF4aXNPcHRpb25zLmlkID0geEF4aXNPcHRpb25zLmlkIHx8ICgneC1heGlzLScgKyBpbmRleCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHNjYWxlc09wdGlvbnMueUF4ZXMsIGZ1bmN0aW9uKHlBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdFx0eUF4aXNPcHRpb25zLmlkID0geUF4aXNPcHRpb25zLmlkIHx8ICgneS1heGlzLScgKyBpbmRleCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHNjYWxlT3B0aW9ucykge1xuXHRcdFx0XHRzY2FsZU9wdGlvbnMuaWQgPSBzY2FsZU9wdGlvbnMuaWQgfHwgJ3NjYWxlJztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0XHQgKi9cblx0XHRidWlsZFNjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyA9IHt9O1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cblx0XHRcdGlmIChvcHRpb25zLnNjYWxlcykge1xuXHRcdFx0XHRpdGVtcyA9IGl0ZW1zLmNvbmNhdChcblx0XHRcdFx0XHQob3B0aW9ucy5zY2FsZXMueEF4ZXMgfHwgW10pLm1hcChmdW5jdGlvbih4QXhpc09wdGlvbnMpIHtcblx0XHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeEF4aXNPcHRpb25zLCBkdHlwZTogJ2NhdGVnb3J5JywgZHBvc2l0aW9uOiAnYm90dG9tJ307XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnlBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeUF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHlBeGlzT3B0aW9ucywgZHR5cGU6ICdsaW5lYXInLCBkcG9zaXRpb246ICdsZWZ0J307XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcblx0XHRcdFx0aXRlbXMucHVzaCh7XG5cdFx0XHRcdFx0b3B0aW9uczogb3B0aW9ucy5zY2FsZSxcblx0XHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0XHRcdFx0aXNEZWZhdWx0OiB0cnVlLFxuXHRcdFx0XHRcdGRwb3NpdGlvbjogJ2NoYXJ0QXJlYSdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGhlbHBlcnMuZWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHR2YXIgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuXHRcdFx0XHR2YXIgc2NhbGVUeXBlID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cdFx0XHRcdHZhciBzY2FsZUNsYXNzID0gQ2hhcnQuc2NhbGVTZXJ2aWNlLmdldFNjYWxlQ29uc3RydWN0b3Ioc2NhbGVUeXBlKTtcblx0XHRcdFx0aWYgKCFzY2FsZUNsYXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuXHRcdFx0XHRcdHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuXHRcdFx0XHRcdGlkOiBzY2FsZU9wdGlvbnMuaWQsXG5cdFx0XHRcdFx0b3B0aW9uczogc2NhbGVPcHRpb25zLFxuXHRcdFx0XHRcdGN0eDogbWUuY3R4LFxuXHRcdFx0XHRcdGNoYXJ0OiBtZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG5cdFx0XHRcdHNjYWxlLm1lcmdlVGlja3NPcHRpb25zKCk7XG5cblx0XHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXG5cdFx0XHRcdC8vIGFuZCBjb25zaWRlciBpdCBhcyBhIHJlZ3VsYXIgc2NhbGUgcGFydCBvZiB0aGUgXCJzY2FsZXNcIlwiIG1hcCBvbmx5ISBUaGlzIHdvdWxkXG5cdFx0XHRcdC8vIG1ha2UgdGhlIGxvZ2ljIGVhc2llciBhbmQgcmVtb3ZlIHNvbWUgdXNlbGVzcz8gY3VzdG9tIGNvZGUuXG5cdFx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xuXHRcdFx0XHRcdG1lLnNjYWxlID0gc2NhbGU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRDaGFydC5zY2FsZVNlcnZpY2UuYWRkU2NhbGVzVG9MYXlvdXQodGhpcyk7XG5cdFx0fSxcblxuXHRcdGJ1aWxkT3JVcGRhdGVDb250cm9sbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHR5cGVzID0gW107XG5cdFx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBbXTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciB0eXBlID0gZGF0YXNldC50eXBlIHx8IG1lLmNvbmZpZy50eXBlO1xuXG5cdFx0XHRcdGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG5cdFx0XHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdFx0bWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWV0YS50eXBlID0gdHlwZTtcblxuXHRcdFx0XHR0eXBlcy5wdXNoKG1ldGEudHlwZSk7XG5cblx0XHRcdFx0aWYgKG1ldGEuY29udHJvbGxlcikge1xuXHRcdFx0XHRcdG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBDb250cm9sbGVyQ2xhc3MgPSBDaGFydC5jb250cm9sbGVyc1ttZXRhLnR5cGVdO1xuXHRcdFx0XHRcdGlmIChDb250cm9sbGVyQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdcIicgKyBtZXRhLnR5cGUgKyAnXCIgaXMgbm90IGEgY2hhcnQgdHlwZS4nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKG1lLCBkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgbWUpO1xuXG5cdFx0XHRyZXR1cm4gbmV3Q29udHJvbGxlcnM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGhlbHBlcnMuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0XHR9LCBtZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0J3Mgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuXHRcdCovXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldEVsZW1lbnRzKCk7XG5cdFx0XHR0aGlzLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0aWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBjb25maWcsXG5cdFx0XHRcdFx0bGF6eTogYXJndW1lbnRzWzFdXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZUNvbmZpZyhtZSk7XG5cblx0XHRcdGlmIChwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVVwZGF0ZScpID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluIGNhc2UgdGhlIGVudGlyZSBkYXRhIG9iamVjdCBjaGFuZ2VkXG5cdFx0XHRtZS50b29sdGlwLl9kYXRhID0gbWUuZGF0YTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcblx0XHRcdHZhciBuZXdDb250cm9sbGVycyA9IG1lLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcblx0XHRcdGhlbHBlcnMuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cygpO1xuXHRcdFx0fSwgbWUpO1xuXG5cdFx0XHRtZS51cGRhdGVMYXlvdXQoKTtcblxuXHRcdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0XHRoZWxwZXJzLmVhY2gobmV3Q29udHJvbGxlcnMsIGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0Y29udHJvbGxlci5yZXNldCgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdG1lLnVwZGF0ZURhdGFzZXRzKCk7XG5cblx0XHRcdC8vIERvIHRoaXMgYmVmb3JlIHJlbmRlciBzbyB0aGF0IGFueSBwbHVnaW5zIHRoYXQgbmVlZCBmaW5hbCBzY2FsZSB1cGRhdGVzIGNhbiB1c2UgaXRcblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJVcGRhdGUnKTtcblxuXHRcdFx0aWYgKG1lLl9idWZmZXJlZFJlbmRlcikge1xuXHRcdFx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0ge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBjb25maWcuZHVyYXRpb24sXG5cdFx0XHRcdFx0ZWFzaW5nOiBjb25maWcuZWFzaW5nLFxuXHRcdFx0XHRcdGxhenk6IGNvbmZpZy5sYXp5XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5yZW5kZXIoY29uZmlnKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdFx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHVwZGF0ZUxheW91dDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVMYXlvdXQnKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRDaGFydC5sYXlvdXRTZXJ2aWNlLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBgYWZ0ZXJMYXlvdXRgIGluc3RlYWQuXG5cdFx0XHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJTY2FsZVVwZGF0ZVxuXHRcdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuXHRcdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyTGF5b3V0Jyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0XHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR1cGRhdGVEYXRhc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c1VwZGF0ZScpID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWUudXBkYXRlRGF0YXNldChpKTtcblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzVXBkYXRlJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0XHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHVwZGF0ZURhdGFzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0XHR2YXIgYXJncyA9IHtcblx0XHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlKCk7XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKTtcblx0XHR9LFxuXG5cdFx0cmVuZGVyOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdGNvbmZpZyA9IHtcblx0XHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb247XG5cdFx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVSZW5kZXInKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IG1lLm9wdGlvbnMuYW5pbWF0aW9uO1xuXHRcdFx0dmFyIG9uQ29tcGxldGUgPSBmdW5jdGlvbihhbmltYXRpb24pIHtcblx0XHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclJlbmRlcicpO1xuXHRcdFx0XHRoZWxwZXJzLmNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgbWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGFuaW1hdGlvbk9wdGlvbnMgJiYgKCh0eXBlb2YgZHVyYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGR1cmF0aW9uICE9PSAwKSB8fCAodHlwZW9mIGR1cmF0aW9uID09PSAndW5kZWZpbmVkJyAmJiBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uICE9PSAwKSkpIHtcblx0XHRcdFx0dmFyIGFuaW1hdGlvbiA9IG5ldyBDaGFydC5BbmltYXRpb24oe1xuXHRcdFx0XHRcdG51bVN0ZXBzOiAoZHVyYXRpb24gfHwgYW5pbWF0aW9uT3B0aW9ucy5kdXJhdGlvbikgLyAxNi42NiwgLy8gNjAgZnBzXG5cdFx0XHRcdFx0ZWFzaW5nOiBjb25maWcuZWFzaW5nIHx8IGFuaW1hdGlvbk9wdGlvbnMuZWFzaW5nLFxuXG5cdFx0XHRcdFx0cmVuZGVyOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uT2JqZWN0KSB7XG5cdFx0XHRcdFx0XHR2YXIgZWFzaW5nRnVuY3Rpb24gPSBoZWxwZXJzLmVhc2luZy5lZmZlY3RzW2FuaW1hdGlvbk9iamVjdC5lYXNpbmddO1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRTdGVwID0gYW5pbWF0aW9uT2JqZWN0LmN1cnJlbnRTdGVwO1xuXHRcdFx0XHRcdFx0dmFyIHN0ZXBEZWNpbWFsID0gY3VycmVudFN0ZXAgLyBhbmltYXRpb25PYmplY3QubnVtU3RlcHM7XG5cblx0XHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRvbkFuaW1hdGlvblByb2dyZXNzOiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsXG5cdFx0XHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogb25Db21wbGV0ZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRDaGFydC5hbmltYXRpb25TZXJ2aWNlLmFkZEFuaW1hdGlvbihtZSwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5kcmF3KCk7XG5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNzgxXG5cdFx0XHRcdG9uQ29tcGxldGUobmV3IENoYXJ0LkFuaW1hdGlvbih7bnVtU3RlcHM6IDAsIGNoYXJ0OiBtZX0pKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH0sXG5cblx0XHRkcmF3OiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0bWUuY2xlYXIoKTtcblxuXHRcdFx0aWYgKGhlbHBlcnMuaXNOdWxsT3JVbmRlZihlYXNpbmdWYWx1ZSkpIHtcblx0XHRcdFx0ZWFzaW5nVmFsdWUgPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblxuXHRcdFx0aWYgKHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIERyYXcgYWxsIHRoZSBzY2FsZXNcblx0XHRcdGhlbHBlcnMuZWFjaChtZS5ib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdGJveC5kcmF3KG1lLmNoYXJ0QXJlYSk7XG5cdFx0XHR9LCBtZSk7XG5cblx0XHRcdGlmIChtZS5zY2FsZSkge1xuXHRcdFx0XHRtZS5zY2FsZS5kcmF3KCk7XG5cdFx0XHR9XG5cblx0XHRcdG1lLmRyYXdEYXRhc2V0cyhlYXNpbmdWYWx1ZSk7XG5cblx0XHRcdC8vIEZpbmFsbHkgZHJhdyB0aGUgdG9vbHRpcFxuXHRcdFx0bWUudG9vbHRpcC5kcmF3KCk7XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bWUudG9vbHRpcC50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXG5cdFx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdGlmIChwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIERyYXcgZGF0YXNldHMgcmV2ZXJzZWQgdG8gc3VwcG9ydCBwcm9wZXIgbGluZSBzdGFja2luZ1xuXHRcdFx0Zm9yICh2YXIgaSA9IChtZS5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRcdG1lLmRyYXdEYXRhc2V0KGksIGVhc2luZ1ZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHRcdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGRyYXdEYXRhc2V0OiBmdW5jdGlvbihpbmRleCwgZWFzaW5nVmFsdWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHRcdHZhciBhcmdzID0ge1xuXHRcdFx0XHRtZXRhOiBtZXRhLFxuXHRcdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldERyYXcnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG1ldGEuY29udHJvbGxlci5kcmF3KGVhc2luZ1ZhbHVlKTtcblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXREcmF3JywgW2FyZ3NdKTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRoZSBzaW5nbGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkIG9uXG5cdFx0Ly8gQHJldHVybiA6IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhc2V0IGluZGV4IGFuZCBlbGVtZW50IGluZGV4IG9mIHRoZSBtYXRjaGluZyBlbGVtZW50LiBBbHNvIGNvbnRhaW5zIHRoZSByZWN0YW5nbGUgdGhhdCB3YXMgZHJhd1xuXHRcdGdldEVsZW1lbnRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gSW50ZXJhY3Rpb24ubW9kZXMuc2luZ2xlKHRoaXMsIGUpO1xuXHRcdH0sXG5cblx0XHRnZXRFbGVtZW50c0F0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiBJbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdFx0fSxcblxuXHRcdGdldEVsZW1lbnRzQXRYQXhpczogZnVuY3Rpb24oZSkge1xuXHRcdFx0cmV0dXJuIEludGVyYWN0aW9uLm1vZGVzWyd4LWF4aXMnXSh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdFx0fSxcblxuXHRcdGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGU6IGZ1bmN0aW9uKGUsIG1vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcblx0XHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBbXTtcblx0XHR9LFxuXG5cdFx0Z2V0RGF0YXNldEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiBJbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0KHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0XHR9LFxuXG5cdFx0Z2V0RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuXHRcdFx0aWYgKCFkYXRhc2V0Ll9tZXRhKSB7XG5cdFx0XHRcdGRhdGFzZXQuX21ldGEgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXTtcblx0XHRcdGlmICghbWV0YSkge1xuXHRcdFx0XHRtZXRhID0gZGF0YXNldC5fbWV0YVttZS5pZF0gPSB7XG5cdFx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0XHRkYXRhOiBbXSxcblx0XHRcdFx0XHRkYXRhc2V0OiBudWxsLFxuXHRcdFx0XHRcdGNvbnRyb2xsZXI6IG51bGwsXG5cdFx0XHRcdFx0aGlkZGVuOiBudWxsLFx0XHRcdC8vIFNlZSBpc0RhdGFzZXRWaXNpYmxlKCkgY29tbWVudFxuXHRcdFx0XHRcdHhBeGlzSUQ6IG51bGwsXG5cdFx0XHRcdFx0eUF4aXNJRDogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWV0YTtcblx0XHR9LFxuXG5cdFx0Z2V0VmlzaWJsZURhdGFzZXRDb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY291bnQgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fSxcblxuXHRcdGlzRGF0YXNldFZpc2libGU6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHRcdC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcblx0XHRcdC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cblx0XHRcdHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICF0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5oaWRkZW47XG5cdFx0fSxcblxuXHRcdGdlbmVyYXRlTGVnZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGVnZW5kQ2FsbGJhY2sodGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZGVzdHJveURhdGFzZXRNZXRhOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBpZCA9IHRoaXMuaWQ7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuXHRcdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhICYmIGRhdGFzZXQuX21ldGFbaWRdO1xuXG5cdFx0XHRpZiAobWV0YSkge1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIuZGVzdHJveSgpO1xuXHRcdFx0XHRkZWxldGUgZGF0YXNldC5fbWV0YVtpZF07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdFx0bWUuc3RvcCgpO1xuXG5cdFx0XHQvLyBkYXRhc2V0IGNvbnRyb2xsZXJzIG5lZWQgdG8gY2xlYW51cCBhc3NvY2lhdGVkIGRhdGFcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZS5kZXN0cm95RGF0YXNldE1ldGEoaSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYW52YXMpIHtcblx0XHRcdFx0bWUudW5iaW5kRXZlbnRzKCk7XG5cdFx0XHRcdGhlbHBlcnMuY2FudmFzLmNsZWFyKG1lKTtcblx0XHRcdFx0cGxhdGZvcm0ucmVsZWFzZUNvbnRleHQobWUuY3R4KTtcblx0XHRcdFx0bWUuY2FudmFzID0gbnVsbDtcblx0XHRcdFx0bWUuY3R4ID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdkZXN0cm95Jyk7XG5cblx0XHRcdGRlbGV0ZSBDaGFydC5pbnN0YW5jZXNbbWUuaWRdO1xuXHRcdH0sXG5cblx0XHR0b0Jhc2U2NEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGluaXRUb29sVGlwOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRtZS50b29sdGlwID0gbmV3IENoYXJ0LlRvb2x0aXAoe1xuXHRcdFx0XHRfY2hhcnQ6IG1lLFxuXHRcdFx0XHRfY2hhcnRJbnN0YW5jZTogbWUsIC8vIGRlcHJlY2F0ZWQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0X2RhdGE6IG1lLmRhdGEsXG5cdFx0XHRcdF9vcHRpb25zOiBtZS5vcHRpb25zLnRvb2x0aXBzXG5cdFx0XHR9LCBtZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0YmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9IG1lLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRcdHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtZS5ldmVudEhhbmRsZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobWUub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHRsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBFbGVtZW50cyB1c2VkIHRvIGRldGVjdCBzaXplIGNoYW5nZSBzaG91bGQgbm90IGJlIGluamVjdGVkIGZvciBub24gcmVzcG9uc2l2ZSBjaGFydHMuXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIyMTBcblx0XHRcdGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcblx0XHRcdFx0bGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRtZS5yZXNpemUoKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCAncmVzaXplJywgbGlzdGVuZXIpO1xuXHRcdFx0XHRsaXN0ZW5lcnMucmVzaXplID0gbGlzdGVuZXI7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dW5iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcblx0XHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIG1lLl9saXN0ZW5lcnM7XG5cdFx0XHRoZWxwZXJzLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lciwgdHlwZSkge1xuXHRcdFx0XHRwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudHMsIG1vZGUsIGVuYWJsZWQpIHtcblx0XHRcdHZhciBtZXRob2QgPSBlbmFibGVkID8gJ3NldEhvdmVyU3R5bGUnIDogJ3JlbW92ZUhvdmVyU3R5bGUnO1xuXHRcdFx0dmFyIGVsZW1lbnQsIGksIGlsZW47XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0RGF0YXNldE1ldGEoZWxlbWVudC5fZGF0YXNldEluZGV4KS5jb250cm9sbGVyW21ldGhvZF0oZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XG5cblx0XHRcdGlmIChwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUV2ZW50JywgW2VdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdWZmZXIgYW55IHVwZGF0ZSBjYWxscyBzbyB0aGF0IHJlbmRlcnMgZG8gbm90IG9jY3VyXG5cdFx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xuXHRcdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHRcdHZhciBjaGFuZ2VkID0gbWUuaGFuZGxlRXZlbnQoZSk7XG5cdFx0XHRjaGFuZ2VkIHw9IHRvb2x0aXAgJiYgdG9vbHRpcC5oYW5kbGVFdmVudChlKTtcblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckV2ZW50JywgW2VdKTtcblxuXHRcdFx0dmFyIGJ1ZmZlcmVkUmVxdWVzdCA9IG1lLl9idWZmZXJlZFJlcXVlc3Q7XG5cdFx0XHRpZiAoYnVmZmVyZWRSZXF1ZXN0KSB7XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYW4gdXBkYXRlIHRoYXQgd2FzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBkbyBhIG5vcm1hbCByZW5kZXJcblx0XHRcdFx0bWUucmVuZGVyKGJ1ZmZlcmVkUmVxdWVzdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYW5nZWQgJiYgIW1lLmFuaW1hdGluZykge1xuXHRcdFx0XHQvLyBJZiBlbnRlcmluZywgbGVhdmluZywgb3IgY2hhbmdpbmcgZWxlbWVudHMsIGFuaW1hdGUgdGhlIGNoYW5nZSB2aWEgcGl2b3Rcblx0XHRcdFx0bWUuc3RvcCgpO1xuXG5cdFx0XHRcdC8vIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgYXQgdGhpcyBwb2ludC4gVXBkYXRpbmcgd2lsbCBjYXVzZSBzY2FsZXMgdG8gYmVcblx0XHRcdFx0Ly8gcmVjb21wdXRlZCBnZW5lcmF0aW5nIGZsaWNrZXIgJiB1c2luZyBtb3JlIG1lbW9yeSB0aGFuIG5lY2Vzc2FyeS5cblx0XHRcdFx0bWUucmVuZGVyKG1lLm9wdGlvbnMuaG92ZXIuYW5pbWF0aW9uRHVyYXRpb24sIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcblx0XHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSBhbiBldmVudFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IHRoZSBldmVudCB0byBoYW5kbGVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0XHQgKi9cblx0XHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucyB8fCB7fTtcblx0XHRcdHZhciBob3Zlck9wdGlvbnMgPSBvcHRpb25zLmhvdmVyO1xuXHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmxhc3RBY3RpdmUgfHwgW107XG5cblx0XHRcdC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciBob3ZlciBhbmQgdG9vbHRpcHNcblx0XHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdFx0bWUuYWN0aXZlID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5hY3RpdmUgPSBtZS5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2Ugb25Ib3ZlciBob29rXG5cdFx0XHQvLyBOZWVkIHRvIGNhbGwgd2l0aCBuYXRpdmUgZXZlbnQgaGVyZSB0byBub3QgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XG5cblx0XHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0aWYgKG9wdGlvbnMub25DbGljaykge1xuXHRcdFx0XHRcdC8vIFVzZSBlLm5hdGl2ZSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdG9wdGlvbnMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuYWN0aXZlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgc3R5bGluZyBmb3IgbGFzdCBhY3RpdmUgKGV2ZW4gaWYgaXQgbWF5IHN0aWxsIGJlIGFjdGl2ZSlcblx0XHRcdGlmIChtZS5sYXN0QWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmxhc3RBY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1aWx0IGluIGhvdmVyIHN0eWxpbmdcblx0XHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUuYWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNoYW5nZWQgPSAhaGVscGVycy5hcnJheUVxdWFscyhtZS5hY3RpdmUsIG1lLmxhc3RBY3RpdmUpO1xuXG5cdFx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5hY3RpdmU7XG5cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQgaW5zdGVhZC5cblx0ICogQGNsYXNzIENoYXJ0LkNvbnRyb2xsZXJcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRDaGFydC5Db250cm9sbGVyID0gQ2hhcnQ7XG59O1xuXG59LHtcIjI1XCI6MjUsXCIyOFwiOjI4LFwiNDVcIjo0NSxcIjQ4XCI6NDh9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XG5cblx0LyoqXG5cdCAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG5cdCAqICd1bnNoaWZ0JykgYW5kIG5vdGlmeSB0aGUgbGlzdGVuZXIgQUZURVIgdGhlIGFycmF5IGhhcyBiZWVuIGFsdGVyZWQuIExpc3RlbmVycyBhcmVcblx0ICogY2FsbGVkIG9uIHRoZSAnb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIG9uRGF0YVB1c2gsIGV0Yy4pIHdpdGggc2FtZSBhcmd1bWVudHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcblx0XHRpZiAoYXJyYXkuX2NoYXJ0anMpIHtcblx0XHRcdGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0bGlzdGVuZXJzOiBbbGlzdGVuZXJdXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIG1ldGhvZCA9ICdvbkRhdGEnICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpO1xuXHRcdFx0dmFyIGJhc2UgPSBhcnJheVtrZXldO1xuXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR2YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHRcdHZhciByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG5cdFx0XHRcdFx0aGVscGVycy5lYWNoKGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycywgZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRcdG9iamVjdFttZXRob2RdLmFwcGx5KG9iamVjdCwgYXJncyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG5cdCAqIHRoZSBfY2hhcnRqcyBzdHViIGFuZCBvdmVycmlkZGVuIG1ldGhvZHMpIGlmIGFycmF5IGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBsaXN0ZW5lcnMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHRcdHZhciBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG5cdFx0aWYgKCFzdHViKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHN0dWIubGlzdGVuZXJzO1xuXHRcdHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cblx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVsZXRlIGFycmF5W2tleV07XG5cdFx0fSk7XG5cblx0XHRkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG5cdH1cblxuXHQvLyBCYXNlIGNsYXNzIGZvciBhbGwgZGF0YXNldCBjb250cm9sbGVycyAobGluZSwgYmFyLCBldGMpXG5cdENoYXJ0LkRhdGFzZXRDb250cm9sbGVyID0gZnVuY3Rpb24oY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuXHRcdHRoaXMuaW5pdGlhbGl6ZShjaGFydCwgZGF0YXNldEluZGV4KTtcblx0fTtcblxuXHRoZWxwZXJzLmV4dGVuZChDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblxuXHRcdC8qKlxuXHRcdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZSkuXG5cdFx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cblx0XHQgKi9cblx0XHRkYXRhc2V0RWxlbWVudFR5cGU6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YSAoZS5nLiBDaGFydC5lbGVtZW50LlBvaW50KS5cblx0XHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxuXHRcdCAqL1xuXHRcdGRhdGFFbGVtZW50VHlwZTogbnVsbCxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRtZS5jaGFydCA9IGNoYXJ0O1xuXHRcdFx0bWUuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0XHRtZS5saW5rU2NhbGVzKCk7XG5cdFx0XHRtZS5hZGRFbGVtZW50cygpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0XHR0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdH0sXG5cblx0XHRsaW5rU2NhbGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXG5cdFx0XHRpZiAobWV0YS54QXhpc0lEID09PSBudWxsKSB7XG5cdFx0XHRcdG1ldGEueEF4aXNJRCA9IGRhdGFzZXQueEF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy54QXhlc1swXS5pZDtcblx0XHRcdH1cblx0XHRcdGlmIChtZXRhLnlBeGlzSUQgPT09IG51bGwpIHtcblx0XHRcdFx0bWV0YS55QXhpc0lEID0gZGF0YXNldC55QXhpc0lEIHx8IG1lLmNoYXJ0Lm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLmlkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXREYXRhc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG5cdFx0fSxcblxuXHRcdGdldE1ldGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG5cdFx0fSxcblxuXHRcdGdldFNjYWxlRm9ySWQ6IGZ1bmN0aW9uKHNjYWxlSUQpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcblx0XHR9LFxuXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy51cGRhdGUodHJ1ZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5fZGF0YSkge1xuXHRcdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjcmVhdGVNZXRhRGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHR5cGUgPSBtZS5kYXRhc2V0RWxlbWVudFR5cGU7XG5cdFx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRcdF9jaGFydDogbWUuY2hhcnQsXG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlTWV0YURhdGE6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHR5cGUgPSBtZS5kYXRhRWxlbWVudFR5cGU7XG5cdFx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRcdF9jaGFydDogbWUuY2hhcnQsXG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0XHRfaW5kZXg6IGluZGV4XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0YWRkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YSB8fCBbXTtcblx0XHRcdHZhciBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcblx0XHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YURhdGFbaV0gPSBtZXRhRGF0YVtpXSB8fCBtZS5jcmVhdGVNZXRhRGF0YShpKTtcblx0XHRcdH1cblxuXHRcdFx0bWV0YS5kYXRhc2V0ID0gbWV0YS5kYXRhc2V0IHx8IG1lLmNyZWF0ZU1ldGFEYXRhc2V0KCk7XG5cdFx0fSxcblxuXHRcdGFkZEVsZW1lbnRBbmRSZXNldDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVNZXRhRGF0YShpbmRleCk7XG5cdFx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShpbmRleCwgMCwgZWxlbWVudCk7XG5cdFx0XHR0aGlzLnVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRidWlsZE9yVXBkYXRlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcblxuXHRcdFx0Ly8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW4gdGh1cyBzaW11bGF0ZVxuXHRcdFx0Ly8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG5cdFx0XHQvLyB0aGUgaW50ZXJuYWwgbWV0YSBkYXRhIGFjY29yZGluZ2x5LlxuXHRcdFx0aWYgKG1lLl9kYXRhICE9PSBkYXRhKSB7XG5cdFx0XHRcdGlmIChtZS5fZGF0YSkge1xuXHRcdFx0XHRcdC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgaW5zdGFuY2UuXG5cdFx0XHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyhtZS5fZGF0YSwgbWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgbWUpO1xuXHRcdFx0XHRtZS5fZGF0YSA9IGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG5cdFx0XHQvLyBhbnkgdXBkYXRlcyBhbmQgc28gbWFrZSBzdXJlIHRoYXQgd2UgaGFuZGxlIG51bWJlciBvZiBkYXRhcG9pbnRzIGNoYW5naW5nLlxuXHRcdFx0bWUucmVzeW5jRWxlbWVudHMoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBoZWxwZXJzLm5vb3AsXG5cblx0XHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRlbGVtZW50c1tpXS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1ldGEuZGF0YXNldCkge1xuXHRcdFx0XHRtZXRhLmRhdGFzZXQudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGVsZW1lbnRzW2ldLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCwgZWxlbWVudE9wdHMpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2VsZW1lbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgaW5kZXggPSBlbGVtZW50Ll9pbmRleDtcblx0XHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXHRcdFx0dmFyIG1vZGVsID0gZWxlbWVudC5fbW9kZWw7XG5cblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uYmFja2dyb3VuZENvbG9yIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBlbGVtZW50T3B0cy5iYWNrZ3JvdW5kQ29sb3IpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LmJvcmRlckNvbG9yLCBpbmRleCwgZWxlbWVudE9wdHMuYm9yZGVyQ29sb3IpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LmJvcmRlcldpZHRoLCBpbmRleCwgZWxlbWVudE9wdHMuYm9yZGVyV2lkdGgpO1xuXHRcdH0sXG5cblx0XHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblx0XHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycy5nZXRIb3ZlckNvbG9yO1xuXHRcdFx0dmFyIG1vZGVsID0gZWxlbWVudC5fbW9kZWw7XG5cblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA6IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uaG92ZXJCb3JkZXJDb2xvciA/IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ob3ZlckJvcmRlckNvbG9yLCBpbmRleCwgZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA/IGN1c3RvbS5ob3ZlckJvcmRlcldpZHRoIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ob3ZlckJvcmRlcldpZHRoLCBpbmRleCwgbW9kZWwuYm9yZGVyV2lkdGgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XG5cdFx0XHR2YXIgbnVtTWV0YSA9IG1ldGEuZGF0YS5sZW5ndGg7XG5cdFx0XHR2YXIgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuXG5cdFx0XHRpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcblx0XHRcdFx0bWV0YS5kYXRhLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG5cdFx0XHR9IGVsc2UgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG5cdFx0XHRcdG1lLmluc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRpbnNlcnRFbGVtZW50czogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0XHRcdFx0dGhpcy5hZGRFbGVtZW50QW5kUmVzZXQoc3RhcnQgKyBpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRvbkRhdGFQdXNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuaW5zZXJ0RWxlbWVudHModGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSAxLCBhcmd1bWVudHMubGVuZ3RoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRvbkRhdGFQb3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5wb3AoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRvbkRhdGFTaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNoaWZ0KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG5cdFx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoIC0gMik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0b25EYXRhVW5zaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmluc2VydEVsZW1lbnRzKDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXHRcdH1cblx0fSk7XG5cblx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcbn07XG5cbn0se1wiNDVcIjo0NX1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldDogZnVuY3Rpb24oc2NvcGUsIHZhbHVlcykge1xuXHRcdHJldHVybiBoZWxwZXJzLm1lcmdlKHRoaXNbc2NvcGVdIHx8ICh0aGlzW3Njb3BlXSA9IHt9KSwgdmFsdWVzKTtcblx0fVxufTtcblxufSx7XCI0NVwiOjQ1fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29sb3IgPSByZXF1aXJlKDMpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIHZpZXcsIG1vZGVsLCBlYXNlKSB7XG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMobW9kZWwpO1xuXHR2YXIgaSwgaWxlbiwga2V5LCBhY3R1YWwsIG9yaWdpbiwgdGFyZ2V0LCB0eXBlLCBjMCwgYzE7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0a2V5ID0ga2V5c1tpXTtcblxuXHRcdHRhcmdldCA9IG1vZGVsW2tleV07XG5cblx0XHQvLyBpZiBhIHZhbHVlIGlzIGFkZGVkIHRvIHRoZSBtb2RlbCBhZnRlciBwaXZvdCgpIGhhcyBiZWVuIGNhbGxlZCwgdGhlIHZpZXdcblx0XHQvLyBkb2Vzbid0IGNvbnRhaW4gaXQsIHNvIGxldCdzIGluaXRpYWxpemUgdGhlIHZpZXcgdG8gdGhlIHRhcmdldCB2YWx1ZS5cblx0XHRpZiAoIXZpZXcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0dmlld1trZXldID0gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGFjdHVhbCA9IHZpZXdba2V5XTtcblxuXHRcdGlmIChhY3R1YWwgPT09IHRhcmdldCB8fCBrZXlbMF0gPT09ICdfJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFzdGFydC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRzdGFydFtrZXldID0gYWN0dWFsO1xuXHRcdH1cblxuXHRcdG9yaWdpbiA9IHN0YXJ0W2tleV07XG5cblx0XHR0eXBlID0gdHlwZW9mIHRhcmdldDtcblxuXHRcdGlmICh0eXBlID09PSB0eXBlb2Ygb3JpZ2luKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0YzAgPSBjb2xvcihvcmlnaW4pO1xuXHRcdFx0XHRpZiAoYzAudmFsaWQpIHtcblx0XHRcdFx0XHRjMSA9IGNvbG9yKHRhcmdldCk7XG5cdFx0XHRcdFx0aWYgKGMxLnZhbGlkKSB7XG5cdFx0XHRcdFx0XHR2aWV3W2tleV0gPSBjMS5taXgoYzAsIGVhc2UpLnJnYlN0cmluZygpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKG9yaWdpbikgJiYgaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0XHR2aWV3W2tleV0gPSBvcmlnaW4gKyAodGFyZ2V0IC0gb3JpZ2luKSAqIGVhc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0fVxufVxuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcblx0aGVscGVycy5leHRlbmQodGhpcywgY29uZmlndXJhdGlvbik7XG5cdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuaGVscGVycy5leHRlbmQoRWxlbWVudC5wcm90b3R5cGUsIHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXHR9LFxuXG5cdHBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmICghbWUuX3ZpZXcpIHtcblx0XHRcdG1lLl92aWV3ID0gaGVscGVycy5jbG9uZShtZS5fbW9kZWwpO1xuXHRcdH1cblx0XHRtZS5fc3RhcnQgPSB7fTtcblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdHZhciBzdGFydCA9IG1lLl9zdGFydDtcblx0XHR2YXIgdmlldyA9IG1lLl92aWV3O1xuXG5cdFx0Ly8gTm8gYW5pbWF0aW9uIC0+IE5vIFRyYW5zaXRpb25cblx0XHRpZiAoIW1vZGVsIHx8IGVhc2UgPT09IDEpIHtcblx0XHRcdG1lLl92aWV3ID0gbW9kZWw7XG5cdFx0XHRtZS5fc3RhcnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH1cblxuXHRcdGlmICghdmlldykge1xuXHRcdFx0dmlldyA9IG1lLl92aWV3ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0c3RhcnQgPSBtZS5fc3RhcnQgPSB7fTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHRoaXMuX21vZGVsLngsXG5cdFx0XHR5OiB0aGlzLl9tb2RlbC55XG5cdFx0fTtcblx0fSxcblxuXHRoYXNWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMuaXNOdW1iZXIodGhpcy5fbW9kZWwueCkgJiYgaGVscGVycy5pc051bWJlcih0aGlzLl9tb2RlbC55KTtcblx0fVxufSk7XG5cbkVsZW1lbnQuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50O1xuXG59LHtcIjNcIjozLFwiNDVcIjo0NX1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCB3aW5kb3c6IGZhbHNlICovXG4vKiBnbG9iYWwgZG9jdW1lbnQ6IGZhbHNlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb2xvciA9IHJlcXVpcmUoMyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHQvLyAtLSBCYXNpYyBqcyB1dGlsaXR5IG1ldGhvZHNcblxuXHRoZWxwZXJzLmV4dGVuZCA9IGZ1bmN0aW9uKGJhc2UpIHtcblx0XHR2YXIgc2V0Rm4gPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRiYXNlW2tleV0gPSB2YWx1ZTtcblx0XHR9O1xuXHRcdGZvciAodmFyIGkgPSAxLCBpbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuXHRcdFx0aGVscGVycy5lYWNoKGFyZ3VtZW50c1tpXSwgc2V0Rm4pO1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fTtcblxuXHRoZWxwZXJzLmNvbmZpZ01lcmdlID0gZnVuY3Rpb24oLyogb2JqZWN0cyAuLi4gKi8pIHtcblx0XHRyZXR1cm4gaGVscGVycy5tZXJnZShoZWxwZXJzLmNsb25lKGFyZ3VtZW50c1swXSksIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwge1xuXHRcdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciB0dmFsID0gdGFyZ2V0W2tleV0gfHwge307XG5cdFx0XHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRcdFx0aWYgKGtleSA9PT0gJ3NjYWxlcycpIHtcblx0XHRcdFx0XHQvLyBzY2FsZSBjb25maWcgbWVyZ2luZyBpcyBjb21wbGV4LiBBZGQgb3VyIG93biBmdW5jdGlvbiBoZXJlIGZvciB0aGF0XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLnNjYWxlTWVyZ2UodHZhbCwgc3ZhbCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2NhbGUnKSB7XG5cdFx0XHRcdFx0Ly8gdXNlZCBpbiBwb2xhciBhcmVhICYgcmFkYXIgY2hhcnRzIHNpbmNlIHRoZXJlIGlzIG9ubHkgb25lIHNjYWxlXG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLm1lcmdlKHR2YWwsIFtDaGFydC5zY2FsZVNlcnZpY2UuZ2V0U2NhbGVEZWZhdWx0cyhzdmFsLnR5cGUpLCBzdmFsXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVscGVycy5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0aGVscGVycy5zY2FsZU1lcmdlID0gZnVuY3Rpb24oLyogb2JqZWN0cyAuLi4gKi8pIHtcblx0XHRyZXR1cm4gaGVscGVycy5tZXJnZShoZWxwZXJzLmNsb25lKGFyZ3VtZW50c1swXSksIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwge1xuXHRcdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHRcdGlmIChrZXkgPT09ICd4QXhlcycgfHwga2V5ID09PSAneUF4ZXMnKSB7XG5cdFx0XHRcdFx0dmFyIHNsZW4gPSBzb3VyY2Vba2V5XS5sZW5ndGg7XG5cdFx0XHRcdFx0dmFyIGksIHR5cGUsIHNjYWxlO1xuXG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2xlbjsgKytpKSB7XG5cdFx0XHRcdFx0XHRzY2FsZSA9IHNvdXJjZVtrZXldW2ldO1xuXHRcdFx0XHRcdFx0dHlwZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoc2NhbGUudHlwZSwga2V5ID09PSAneEF4ZXMnID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInKTtcblxuXHRcdFx0XHRcdFx0aWYgKGkgPj0gdGFyZ2V0W2tleV0ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtrZXldLnB1c2goe30pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIXRhcmdldFtrZXldW2ldLnR5cGUgfHwgKHNjYWxlLnR5cGUgJiYgc2NhbGUudHlwZSAhPT0gdGFyZ2V0W2tleV1baV0udHlwZSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbmV3L3VudHlwZWQgc2NhbGUgb3IgdHlwZSBjaGFuZ2VkOiBsZXQncyBhcHBseSB0aGUgbmV3IGRlZmF1bHRzXG5cdFx0XHRcdFx0XHRcdC8vIHRoZW4gbWVyZ2Ugc291cmNlIHNjYWxlIHRvIGNvcnJlY3RseSBvdmVyd3JpdGUgdGhlIGRlZmF1bHRzLlxuXHRcdFx0XHRcdFx0XHRoZWxwZXJzLm1lcmdlKHRhcmdldFtrZXldW2ldLCBbQ2hhcnQuc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHModHlwZSksIHNjYWxlXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBzY2FsZXMgdHlwZSBhcmUgdGhlIHNhbWVcblx0XHRcdFx0XHRcdFx0aGVscGVycy5tZXJnZSh0YXJnZXRba2V5XVtpXSwgc2NhbGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWxwZXJzLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRoZWxwZXJzLndoZXJlID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgZmlsdGVyQ2FsbGJhY2spIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJDYWxsYmFjayk7XG5cdFx0fVxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXG5cdFx0aGVscGVycy5lYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhpdGVtKSkge1xuXHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZpbHRlcmVkO1xuXHR9O1xuXHRoZWxwZXJzLmZpbmRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggP1xuXHRcdGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaywgc2NvcGUpIHtcblx0XHRcdHJldHVybiBhcnJheS5maW5kSW5kZXgoY2FsbGJhY2ssIHNjb3BlKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRzY29wZSA9IHNjb3BlID09PSB1bmRlZmluZWQgPyBhcnJheSA6IHNjb3BlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrLmNhbGwoc2NvcGUsIGFycmF5W2ldLCBpLCBhcnJheSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cdGhlbHBlcnMuZmluZE5leHRXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycy5pc051bGxPclVuZGVmKHN0YXJ0SW5kZXgpKSB7XG5cdFx0XHRzdGFydEluZGV4ID0gLTE7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBzdGFydEluZGV4ICsgMTsgaSA8IGFycmF5VG9TZWFyY2gubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soY3VycmVudEl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50SXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGhlbHBlcnMuZmluZFByZXZpb3VzV2hlcmUgPSBmdW5jdGlvbihhcnJheVRvU2VhcmNoLCBmaWx0ZXJDYWxsYmFjaywgc3RhcnRJbmRleCkge1xuXHRcdC8vIERlZmF1bHQgdG8gZW5kIG9mIHRoZSBhcnJheVxuXHRcdGlmIChoZWxwZXJzLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycy5pbmhlcml0cyA9IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcblx0XHQvLyBCYXNpYyBqYXZhc2NyaXB0IGluaGVyaXRhbmNlIGJhc2VkIG9uIHRoZSBtb2RlbCBjcmVhdGVkIGluIEJhY2tib25lLmpzXG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgQ2hhcnRFbGVtZW50ID0gKGV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkgPyBleHRlbnNpb25zLmNvbnN0cnVjdG9yIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXG5cdFx0dmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5jb25zdHJ1Y3RvciA9IENoYXJ0RWxlbWVudDtcblx0XHR9O1xuXHRcdFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBtZS5wcm90b3R5cGU7XG5cdFx0Q2hhcnRFbGVtZW50LnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGUoKTtcblxuXHRcdENoYXJ0RWxlbWVudC5leHRlbmQgPSBoZWxwZXJzLmluaGVyaXRzO1xuXG5cdFx0aWYgKGV4dGVuc2lvbnMpIHtcblx0XHRcdGhlbHBlcnMuZXh0ZW5kKENoYXJ0RWxlbWVudC5wcm90b3R5cGUsIGV4dGVuc2lvbnMpO1xuXHRcdH1cblxuXHRcdENoYXJ0RWxlbWVudC5fX3N1cGVyX18gPSBtZS5wcm90b3R5cGU7XG5cblx0XHRyZXR1cm4gQ2hhcnRFbGVtZW50O1xuXHR9O1xuXHQvLyAtLSBNYXRoIG1ldGhvZHNcblx0aGVscGVycy5pc051bWJlciA9IGZ1bmN0aW9uKG4pIHtcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuXHR9O1xuXHRoZWxwZXJzLmFsbW9zdEVxdWFscyA9IGZ1bmN0aW9uKHgsIHksIGVwc2lsb24pIHtcblx0XHRyZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcblx0fTtcblx0aGVscGVycy5hbG1vc3RXaG9sZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcblx0XHR2YXIgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG5cdFx0cmV0dXJuICgoKHJvdW5kZWQgLSBlcHNpbG9uKSA8IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID4geCkpO1xuXHR9O1xuXHRoZWxwZXJzLm1heCA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtYXgsIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgobWF4LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF4O1xuXHRcdH0sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMubWluID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1pbiwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1pbihtaW4sIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtaW47XG5cdFx0fSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycy5zaWduID0gTWF0aC5zaWduID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaWduKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XG5cdFx0fTtcblx0aGVscGVycy5sb2cxMCA9IE1hdGgubG9nMTAgP1xuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLmxvZzEwKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcblx0XHR9O1xuXHRoZWxwZXJzLnRvUmFkaWFucyA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcblx0XHRyZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcblx0fTtcblx0aGVscGVycy50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XG5cdFx0cmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdH07XG5cdC8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXG5cdGhlbHBlcnMuZ2V0QW5nbGVGcm9tUG9pbnQgPSBmdW5jdGlvbihjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuXHRcdHZhciBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcblx0XHR2YXIgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG5cdFx0dmFyIHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcblxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cblx0XHRpZiAoYW5nbGUgPCAoLTAuNSAqIE1hdGguUEkpKSB7XG5cdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbmdsZTogYW5nbGUsXG5cdFx0XHRkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG5cdFx0fTtcblx0fTtcblx0aGVscGVycy5kaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbihwdDEsIHB0Mikge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG5cdH07XG5cdGhlbHBlcnMuYWxpYXNQaXhlbCA9IGZ1bmN0aW9uKHBpeGVsV2lkdGgpIHtcblx0XHRyZXR1cm4gKHBpeGVsV2lkdGggJSAyID09PSAwKSA/IDAgOiAwLjU7XG5cdH07XG5cdGhlbHBlcnMuc3BsaW5lQ3VydmUgPSBmdW5jdGlvbihmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuXHRcdC8vIFByb3BzIHRvIFJvYiBTcGVuY2VyIGF0IHNjYWxlZCBpbm5vdmF0aW9uIGZvciBoaXMgcG9zdCBvbiBzcGxpbmluZyBiZXR3ZWVuIHBvaW50c1xuXHRcdC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuXHRcdHZhciBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcblx0XHR2YXIgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuXHRcdHZhciBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuXG5cdFx0dmFyIGQwMSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50LnggLSBwcmV2aW91cy54LCAyKSArIE1hdGgucG93KGN1cnJlbnQueSAtIHByZXZpb3VzLnksIDIpKTtcblx0XHR2YXIgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KG5leHQueCAtIGN1cnJlbnQueCwgMikgKyBNYXRoLnBvdyhuZXh0LnkgLSBjdXJyZW50LnksIDIpKTtcblxuXHRcdHZhciBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcblx0XHR2YXIgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cblx0XHQvLyBJZiBhbGwgcG9pbnRzIGFyZSB0aGUgc2FtZSwgczAxICYgczAyIHdpbGwgYmUgaW5mXG5cdFx0czAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG5cdFx0czEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cblx0XHR2YXIgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcblx0XHR2YXIgZmIgPSB0ICogczEyO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHByZXZpb3VzOiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fSxcblx0XHRcdG5leHQ6IHtcblx0XHRcdFx0eDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblx0aGVscGVycy5FUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5cdGhlbHBlcnMuc3BsaW5lQ3VydmVNb25vdG9uZSA9IGZ1bmN0aW9uKHBvaW50cykge1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuXHRcdC8vIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcblx0XHQvLyBiZXR3ZWVuIHRoZSBkYXRhc2V0IGRpc2NyZXRlIHBvaW50cyBkdWUgdG8gdGhlIGludGVycG9sYXRpb24uXG5cdFx0Ly8gU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuXG5cdFx0dmFyIHBvaW50c1dpdGhUYW5nZW50cyA9IChwb2ludHMgfHwgW10pLm1hcChmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bW9kZWw6IHBvaW50Ll9tb2RlbCxcblx0XHRcdFx0ZGVsdGFLOiAwLFxuXHRcdFx0XHRtSzogMFxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuXHRcdHZhciBwb2ludHNMZW4gPSBwb2ludHNXaXRoVGFuZ2VudHMubGVuZ3RoO1xuXHRcdHZhciBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50LCBwb2ludEFmdGVyO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0dmFyIHNsb3BlRGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KTtcblxuXHRcdFx0XHQvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcblx0XHRcdFx0cG9pbnRDdXJyZW50LmRlbHRhSyA9IHNsb3BlRGVsdGFYICE9PSAwID8gKHBvaW50QWZ0ZXIubW9kZWwueSAtIHBvaW50Q3VycmVudC5tb2RlbC55KSAvIHNsb3BlRGVsdGFYIDogMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFwb2ludEJlZm9yZSB8fCBwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKCFwb2ludEFmdGVyIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEJlZm9yZS5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2lnbihwb2ludEJlZm9yZS5kZWx0YUspICE9PSB0aGlzLnNpZ24ocG9pbnRDdXJyZW50LmRlbHRhSykpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IChwb2ludEJlZm9yZS5kZWx0YUsgKyBwb2ludEN1cnJlbnQuZGVsdGFLKSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuXHRcdHZhciBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdHBvaW50QWZ0ZXIgPSBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhlbHBlcnMuYWxtb3N0RXF1YWxzKHBvaW50Q3VycmVudC5kZWx0YUssIDAsIHRoaXMuRVBTSUxPTikpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRBZnRlci5tSyA9IDA7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRhbHBoYUsgPSBwb2ludEN1cnJlbnQubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0YmV0YUsgPSBwb2ludEFmdGVyLm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuXHRcdFx0aWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG5cdFx0XHRwb2ludEN1cnJlbnQubUsgPSBhbHBoYUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHBvaW50QWZ0ZXIubUsgPSBiZXRhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGUgY29udHJvbCBwb2ludHNcblx0XHR2YXIgZGVsdGFYO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEJlZm9yZSAmJiAhcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRDdXJyZW50Lm1vZGVsLnggLSBwb2ludEJlZm9yZS5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBwb2ludEN1cnJlbnQubW9kZWwueCAtIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IHBvaW50Q3VycmVudC5tb2RlbC55IC0gZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50QWZ0ZXIgJiYgIXBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggKyBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IHBvaW50Q3VycmVudC5tb2RlbC55ICsgZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycy5uZXh0SXRlbSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGluZGV4LCBsb29wKSB7XG5cdFx0aWYgKGxvb3ApIHtcblx0XHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCArIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdIDogY29sbGVjdGlvbltpbmRleCArIDFdO1xuXHR9O1xuXHRoZWxwZXJzLnByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGluZGV4LCBsb29wKSB7XG5cdFx0aWYgKGxvb3ApIHtcblx0XHRcdHJldHVybiBpbmRleCA8PSAwID8gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XG5cdH07XG5cdC8vIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG5cdGhlbHBlcnMubmljZU51bSA9IGZ1bmN0aW9uKHJhbmdlLCByb3VuZCkge1xuXHRcdHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChyYW5nZSkpO1xuXHRcdHZhciBmcmFjdGlvbiA9IHJhbmdlIC8gTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcblx0XHR2YXIgbmljZUZyYWN0aW9uO1xuXG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRpZiAoZnJhY3Rpb24gPCAxLjUpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPCAzKSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDI7XG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgNykge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSAxLjApIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSAyKSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gNSkge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gNTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5pY2VGcmFjdGlvbiAqIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG5cdH07XG5cdC8vIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsIC0gaHR0cDovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG5cdGhlbHBlcnMucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcblx0XHRcdH07XG5cdH0oKSk7XG5cdC8vIC0tIERPTSBtZXRob2RzXG5cdGhlbHBlcnMuZ2V0UmVsYXRpdmVQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2dCwgY2hhcnQpIHtcblx0XHR2YXIgbW91c2VYLCBtb3VzZVk7XG5cdFx0dmFyIGUgPSBldnQub3JpZ2luYWxFdmVudCB8fCBldnQ7XG5cdFx0dmFyIGNhbnZhcyA9IGV2dC5jdXJyZW50VGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50O1xuXHRcdHZhciBib3VuZGluZ1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcblx0XHRpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdG1vdXNlWCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb3VzZVggPSBlLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSBlLmNsaWVudFk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgbW91c2UgY29vcmRpbmF0ZXMgaW50byBjYW52YXMgY29vcmRpbmF0ZXNcblx0XHQvLyBieSBmb2xsb3dpbmcgdGhlIHBhdHRlcm4gbGFpZCBvdXQgYnkgJ2plcnJ5aicgaW4gdGhlIGNvbW1lbnRzIG9mXG5cdFx0Ly8gaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vYWR2YW5jZWQvaHRtbDUtY2FudmFzLW1vdXNlLWNvb3JkaW5hdGVzL1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoaGVscGVycy5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWxlZnQnKSk7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGhlbHBlcnMuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy10b3AnKSk7XG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQoaGVscGVycy5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXJpZ2h0JykpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChoZWxwZXJzLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctYm90dG9tJykpO1xuXHRcdHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG5cdFx0dmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cblx0XHQvLyBXZSBkaXZpZGUgYnkgdGhlIGN1cnJlbnQgZGV2aWNlIHBpeGVsIHJhdGlvLCBiZWNhdXNlIHRoZSBjYW52YXMgaXMgc2NhbGVkIHVwIGJ5IHRoYXQgYW1vdW50IGluIGVhY2ggZGlyZWN0aW9uLiBIb3dldmVyXG5cdFx0Ly8gdGhlIGJhY2tlbmQgbW9kZWwgaXMgaW4gdW5zY2FsZWQgY29vcmRpbmF0ZXMuIFNpbmNlIHdlIGFyZSBnb2luZyB0byBkZWFsIHdpdGggb3VyIG1vZGVsIGNvb3JkaW5hdGVzLCB3ZSBnbyBiYWNrIGhlcmVcblx0XHRtb3VzZVggPSBNYXRoLnJvdW5kKChtb3VzZVggLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0KSAvICh3aWR0aCkgKiBjYW52YXMud2lkdGggLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cdFx0bW91c2VZID0gTWF0aC5yb3VuZCgobW91c2VZIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3ApIC8gKGhlaWdodCkgKiBjYW52YXMuaGVpZ2h0IC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IG1vdXNlWCxcblx0XHRcdHk6IG1vdXNlWVxuXHRcdH07XG5cblx0fTtcblxuXHQvLyBQcml2YXRlIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG5cdGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcblx0XHR2YXIgdmFsdWVJblBpeGVscztcblx0XHRpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuXG5cdFx0XHRpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG5cdFx0XHRcdC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuXHRcdFx0XHR2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZUluUGl4ZWxzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaWYgdGhlIGdpdmVuIHZhbHVlIGNvbnRhaW5zIGFuIGVmZmVjdGl2ZSBjb25zdHJhaW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNDb25zdHJhaW5lZFZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICdub25lJztcblx0fVxuXG5cdC8vIFByaXZhdGUgaGVscGVyIHRvIGdldCBhIGNvbnN0cmFpbnQgZGltZW5zaW9uXG5cdC8vIEBwYXJhbSBkb21Ob2RlIDogdGhlIG5vZGUgdG8gY2hlY2sgdGhlIGNvbnN0cmFpbnQgb25cblx0Ly8gQHBhcmFtIG1heFN0eWxlIDogdGhlIHN0eWxlIHRoYXQgZGVmaW5lcyB0aGUgbWF4aW11bSBmb3IgdGhlIGRpcmVjdGlvbiB3ZSBhcmUgdXNpbmcgKG1heFdpZHRoIC8gbWF4SGVpZ2h0KVxuXHQvLyBAcGFyYW0gcGVyY2VudGFnZVByb3BlcnR5IDogcHJvcGVydHkgb2YgcGFyZW50IHRvIHVzZSB3aGVuIGNhbGN1bGF0aW5nIHdpZHRoIGFzIGEgcGVyY2VudGFnZVxuXHQvLyBAc2VlIGh0dHA6Ly93d3cubmF0aGFuYWVsam9uZXMuY29tL2Jsb2cvMjAxMy9yZWFkaW5nLW1heC13aWR0aC1jcm9zcy1icm93c2VyXG5cdGZ1bmN0aW9uIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgbWF4U3R5bGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkge1xuXHRcdHZhciB2aWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0dmFyIHBhcmVudE5vZGUgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG5cdFx0dmFyIGNvbnN0cmFpbmVkTm9kZSA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKVttYXhTdHlsZV07XG5cdFx0dmFyIGNvbnN0cmFpbmVkQ29udGFpbmVyID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgaGFzQ05vZGUgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWROb2RlKTtcblx0XHR2YXIgaGFzQ0NvbnRhaW5lciA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZENvbnRhaW5lcik7XG5cdFx0dmFyIGluZmluaXR5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdFx0aWYgKGhhc0NOb2RlIHx8IGhhc0NDb250YWluZXIpIHtcblx0XHRcdHJldHVybiBNYXRoLm1pbihcblx0XHRcdFx0aGFzQ05vZGUgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkTm9kZSwgZG9tTm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5LFxuXHRcdFx0XHRoYXNDQ29udGFpbmVyID8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZENvbnRhaW5lciwgcGFyZW50Tm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ25vbmUnO1xuXHR9XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMuZ2V0Q29uc3RyYWludFdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtd2lkdGgnLCAnY2xpZW50V2lkdGgnKTtcblx0fTtcblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcblx0aGVscGVycy5nZXRDb25zdHJhaW50SGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtaGVpZ2h0JywgJ2NsaWVudEhlaWdodCcpO1xuXHR9O1xuXHRoZWxwZXJzLmdldE1heGltdW1XaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRXaWR0aDtcblx0XHR9XG5cblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUludChoZWxwZXJzLmdldFN0eWxlKGNvbnRhaW5lciwgJ3BhZGRpbmctbGVmdCcpLCAxMCk7XG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IHBhcnNlSW50KGhlbHBlcnMuZ2V0U3R5bGUoY29udGFpbmVyLCAncGFkZGluZy1yaWdodCcpLCAxMCk7XG5cdFx0dmFyIHcgPSBjb250YWluZXIuY2xpZW50V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgY3cgPSBoZWxwZXJzLmdldENvbnN0cmFpbnRXaWR0aChkb21Ob2RlKTtcblx0XHRyZXR1cm4gaXNOYU4oY3cpID8gdyA6IE1hdGgubWluKHcsIGN3KTtcblx0fTtcblx0aGVscGVycy5nZXRNYXhpbXVtSGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudEhlaWdodDtcblx0XHR9XG5cblx0XHR2YXIgcGFkZGluZ1RvcCA9IHBhcnNlSW50KGhlbHBlcnMuZ2V0U3R5bGUoY29udGFpbmVyLCAncGFkZGluZy10b3AnKSwgMTApO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoaGVscGVycy5nZXRTdHlsZShjb250YWluZXIsICdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG5cdFx0dmFyIGggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cdFx0dmFyIGNoID0gaGVscGVycy5nZXRDb25zdHJhaW50SGVpZ2h0KGRvbU5vZGUpO1xuXHRcdHJldHVybiBpc05hTihjaCkgPyBoIDogTWF0aC5taW4oaCwgY2gpO1xuXHR9O1xuXHRoZWxwZXJzLmdldFN0eWxlID0gZnVuY3Rpb24oZWwsIHByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIGVsLmN1cnJlbnRTdHlsZSA/XG5cdFx0XHRlbC5jdXJyZW50U3R5bGVbcHJvcGVydHldIDpcblx0XHRcdGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuXHR9O1xuXHRoZWxwZXJzLnJldGluYVNjYWxlID0gZnVuY3Rpb24oY2hhcnQsIGZvcmNlUmF0aW8pIHtcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXHRcdGlmIChwaXhlbFJhdGlvID09PSAxKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHR2YXIgaGVpZ2h0ID0gY2hhcnQuaGVpZ2h0O1xuXHRcdHZhciB3aWR0aCA9IGNoYXJ0LndpZHRoO1xuXG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuXHRcdGNoYXJ0LmN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblxuXHRcdC8vIElmIG5vIHN0eWxlIGhhcyBiZWVuIHNldCBvbiB0aGUgY2FudmFzLCB0aGUgcmVuZGVyIHNpemUgaXMgdXNlZCBhcyBkaXNwbGF5IHNpemUsXG5cdFx0Ly8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcblx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdH07XG5cdC8vIC0tIENhbnZhcyBtZXRob2RzXG5cdGhlbHBlcnMuZm9udFN0cmluZyA9IGZ1bmN0aW9uKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XG5cdFx0cmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcblx0fTtcblx0aGVscGVycy5sb25nZXN0VGV4dCA9IGZ1bmN0aW9uKGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcblx0XHRjYWNoZSA9IGNhY2hlIHx8IHt9O1xuXHRcdHZhciBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG5cdFx0dmFyIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuXHRcdGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG5cdFx0XHRkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuXHRcdFx0Z2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuXHRcdFx0Y2FjaGUuZm9udCA9IGZvbnQ7XG5cdFx0fVxuXG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdHZhciBsb25nZXN0ID0gMDtcblx0XHRoZWxwZXJzLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0aWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaGVscGVycy5pc0FycmF5KHRoaW5nKSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRsb25nZXN0ID0gaGVscGVycy5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG5cdFx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuXHRcdFx0XHQvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG5cdFx0XHRcdGhlbHBlcnMuZWFjaCh0aGluZywgZnVuY3Rpb24obmVzdGVkVGhpbmcpIHtcblx0XHRcdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcblx0XHRcdFx0XHRpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaGVscGVycy5pc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuXHRcdFx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuXHRcdGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcblx0XHRcdFx0ZGVsZXRlIGRhdGFbZ2NbaV1dO1xuXHRcdFx0fVxuXHRcdFx0Z2Muc3BsaWNlKDAsIGdjTGVuKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMubWVhc3VyZVRleHQgPSBmdW5jdGlvbihjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcblx0XHR2YXIgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuXHRcdGlmICghdGV4dFdpZHRoKSB7XG5cdFx0XHR0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcblx0XHRcdGdjLnB1c2goc3RyaW5nKTtcblx0XHR9XG5cdFx0aWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcblx0XHRcdGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG5cdFx0fVxuXHRcdHJldHVybiBsb25nZXN0O1xuXHR9O1xuXHRoZWxwZXJzLm51bWJlck9mTGFiZWxMaW5lcyA9IGZ1bmN0aW9uKGFycmF5T2ZUaGluZ3MpIHtcblx0XHR2YXIgbnVtYmVyT2ZMaW5lcyA9IDE7XG5cdFx0aGVscGVycy5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHRpZiAoaGVscGVycy5pc0FycmF5KHRoaW5nKSkge1xuXHRcdFx0XHRpZiAodGhpbmcubGVuZ3RoID4gbnVtYmVyT2ZMaW5lcykge1xuXHRcdFx0XHRcdG51bWJlck9mTGluZXMgPSB0aGluZy5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gbnVtYmVyT2ZMaW5lcztcblx0fTtcblxuXHRoZWxwZXJzLmNvbG9yID0gIWNvbG9yID9cblx0XHRmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignQ29sb3IuanMgbm90IGZvdW5kIScpO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHQvKiBnbG9iYWwgQ2FudmFzR3JhZGllbnQgKi9cblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50KSB7XG5cdFx0XHRcdHZhbHVlID0gZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbG9yKHZhbHVlKTtcblx0XHR9O1xuXG5cdGhlbHBlcnMuZ2V0SG92ZXJDb2xvciA9IGZ1bmN0aW9uKGNvbG9yVmFsdWUpIHtcblx0XHQvKiBnbG9iYWwgQ2FudmFzUGF0dGVybiAqL1xuXHRcdHJldHVybiAoY29sb3JWYWx1ZSBpbnN0YW5jZW9mIENhbnZhc1BhdHRlcm4pID9cblx0XHRcdGNvbG9yVmFsdWUgOlxuXHRcdFx0aGVscGVycy5jb2xvcihjb2xvclZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLnJnYlN0cmluZygpO1xuXHR9O1xufTtcblxufSx7XCIyNVwiOjI1LFwiM1wiOjMsXCI0NVwiOjQ1fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIGFuIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fElFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBmb3JcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0XG4gKiBAcmV0dXJucyB7UG9pbnR9IHRoZSBldmVudCBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XG5cdGlmIChlLm5hdGl2ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBlLngsXG5cdFx0XHR5OiBlLnlcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGhlbHBlcnMuZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHRyYXZlcnNlIGFsbCBvZiB0aGUgdmlzaWJsZSBlbGVtZW50cyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSBjaGFydCB7Y2hhcnR9IHRoZSBjaGFydFxuICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqL1xuZnVuY3Rpb24gcGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGhhbmRsZXIpIHtcblx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0dmFyIG1ldGEsIGksIGosIGlsZW4sIGpsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGlmICghY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtqXTtcblx0XHRcdGlmICghZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0gaXRlbXMge0NoYXJ0RWxlbWVudFtdfSBlbGVtZW50cyB0byBmaWx0ZXJcbiAqIEBwYXJhbSBwb3NpdGlvbiB7UG9pbnR9IHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvXG4gKiBAcmV0dXJuIHtDaGFydEVsZW1lbnRbXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSB7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0ZWggY2hhcnRcbiAqIEBwYXJhbSBjaGFydCB7Q2hhcnR9IHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSBwb3NpdGlvbiB7UG9pbnR9IHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvXG4gKiBAcGFyYW0gaW50ZXJzZWN0IHtCb29sZWFufSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIGRpc3RhbmNlTWV0cmljIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gcHJvdmlkZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHNcbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBpbnRlcnNlY3QsIGRpc3RhbmNlTWV0cmljKSB7XG5cdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0dmFyIG5lYXJlc3RJdGVtcyA9IFtdO1xuXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0aWYgKGludGVyc2VjdCAmJiAhZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQoKTtcblx0XHR2YXIgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcblxuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRuZWFyZXN0SXRlbXMgPSBbZWxlbWVudF07XG5cdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHQvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuXHRcdFx0bmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyB0aGUgYXhpcyBtb2RlLiB4fHl8eHlcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcblx0dmFyIHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG5cdHZhciB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuXG5cdHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuXHRcdHZhciBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuXHRcdHZhciBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBpbmRleE1vZGUoY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdC8vIERlZmF1bHQgYXhpcyBmb3IgaW5kZXggbW9kZSBpcyAneCcgdG8gbWF0Y2ggb2xkIGJlaGF2aW91clxuXHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuXHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0dmFyIGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgZmFsc2UsIGRpc3RhbmNlTWV0cmljKTtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0aWYgKCFpdGVtcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSkge1xuXHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBtZXRhLmRhdGFbaXRlbXNbMF0uX2luZGV4XTtcblxuXHRcdFx0Ly8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxuXHRcdFx0aWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xuXHRcdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgSUludGVyYWN0aW9uT3B0aW9uc1xuICovXG4vKipcbiAqIElmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvaW50XG4gKiBAbmFtZSBJSW50ZXJmYWNlT3B0aW9ucyNib29sZWFuXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Ly8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcblx0bW9kZXM6IHtcblx0XHRzaW5nbGU6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudHM7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZWxlbWVudHMuc2xpY2UoMCwgMSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbFxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjBcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRsYWJlbDogaW5kZXhNb2RlLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcblx0XHQgKiBAc2luY2UgdjIuNC4wXG5cdFx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIHRvIHVzZSBkdXJpbmcgaW50ZXJhY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0aW5kZXg6IGluZGV4TW9kZSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0gY2hhcnQge2NoYXJ0fSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIGUge0V2ZW50fSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIG9wdGlvbnMge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRkYXRhc2V0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5Jztcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHRcdFx0dmFyIGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgZmFsc2UsIGRpc3RhbmNlTWV0cmljKTtcblxuXHRcdFx0aWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0aXRlbXMgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5fZGF0YXNldEluZGV4KS5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54LWF4aXNcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLiBVc2UgaW5kZXggbW9kZSBhbmQgaW50ZXJzZWN0ID09IHRydWVcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHQneC1heGlzJzogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHJldHVybiBpbmRleE1vZGUoY2hhcnQsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0gY2hhcnQge2NoYXJ0fSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIGUge0V2ZW50fSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHBvaW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRyZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRuZWFyZXN0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5Jztcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHRcdFx0dmFyIG5lYXJlc3RJdGVtcyA9IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIG9wdGlvbnMuaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYyk7XG5cblx0XHRcdC8vIFdlIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSB0aGUgZXZlbnQuIE5vdyBzb3J0IGJ5IHNtYWxsZXN0XG5cdFx0XHRpZiAobmVhcmVzdEl0ZW1zLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0bmVhcmVzdEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHZhciBzaXplQSA9IGEuZ2V0QXJlYSgpO1xuXHRcdFx0XHRcdHZhciBzaXplQiA9IGIuZ2V0QXJlYSgpO1xuXHRcdFx0XHRcdHZhciByZXQgPSBzaXplQSAtIHNpemVCO1xuXG5cdFx0XHRcdFx0aWYgKHJldCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgZXF1YWwgc29ydCBieSBkYXRhc2V0IGluZGV4XG5cdFx0XHRcdFx0XHRyZXQgPSBhLl9kYXRhc2V0SW5kZXggLSBiLl9kYXRhc2V0SW5kZXg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IDEgaXRlbVxuXHRcdFx0cmV0dXJuIG5lYXJlc3RJdGVtcy5zbGljZSgwLCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0gY2hhcnQge2NoYXJ0fSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIGUge0V2ZW50fSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIG9wdGlvbnMge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHg6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluWFJhbmdlKHBvc2l0aW9uLngpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuXHRcdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxuXHRcdCAqIEBwYXJhbSBjaGFydCB7Y2hhcnR9IHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0gZSB7RXZlbnR9IHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0gb3B0aW9ucyB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0eTogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5ZUmFuZ2UocG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG5cdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59O1xuXG59LHtcIjQ1XCI6NDV9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHJlc3BvbnNpdmU6IHRydWUsXG5cdHJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvbjogMCxcblx0bWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcblx0ZXZlbnRzOiBbJ21vdXNlbW92ZScsICdtb3VzZW91dCcsICdjbGljaycsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddLFxuXHRob3Zlcjoge1xuXHRcdG9uSG92ZXI6IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdGludGVyc2VjdDogdHJ1ZSxcblx0XHRhbmltYXRpb25EdXJhdGlvbjogNDAwXG5cdH0sXG5cdG9uQ2xpY2s6IG51bGwsXG5cdGRlZmF1bHRDb2xvcjogJ3JnYmEoMCwwLDAsMC4xKScsXG5cdGRlZmF1bHRGb250Q29sb3I6ICcjNjY2Jyxcblx0ZGVmYXVsdEZvbnRGYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcblx0ZGVmYXVsdEZvbnRTaXplOiAxMixcblx0ZGVmYXVsdEZvbnRTdHlsZTogJ25vcm1hbCcsXG5cdHNob3dMaW5lczogdHJ1ZSxcblxuXHQvLyBFbGVtZW50IGRlZmF1bHRzIGRlZmluZWQgaW4gZWxlbWVudCBleHRlbnNpb25zXG5cdGVsZW1lbnRzOiB7fSxcblxuXHQvLyBMYXlvdXQgb3B0aW9ucyBzdWNoIGFzIHBhZGRpbmdcblx0bGF5b3V0OiB7XG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRib3R0b206IDAsXG5cdFx0XHRsZWZ0OiAwXG5cdFx0fVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblxuXHQvLyBPY2N1cHkgdGhlIGdsb2JhbCB2YXJpYWJsZSBvZiBDaGFydCwgYW5kIGNyZWF0ZSBhIHNpbXBsZSBiYXNlIGNsYXNzXG5cdHZhciBDaGFydCA9IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xuXHRcdHRoaXMuY29uc3RydWN0KGl0ZW0sIGNvbmZpZyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Q2hhcnQuQ2hhcnQgPSBDaGFydDtcblxuXHRyZXR1cm4gQ2hhcnQ7XG59O1xuXG59LHtcIjI1XCI6MjV9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRmdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuXHRcdHJldHVybiBoZWxwZXJzLndoZXJlKGFycmF5LCBmdW5jdGlvbih2KSB7XG5cdFx0XHRyZXR1cm4gdi5wb3NpdGlvbiA9PT0gcG9zaXRpb247XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcblx0XHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcblx0XHRcdHYuX3RtcEluZGV4XyA9IGk7XG5cdFx0XHRyZXR1cm4gdjtcblx0XHR9KTtcblx0XHRhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcblx0XHRcdHZhciB2MSA9IHJldmVyc2UgPyBhIDogYjtcblx0XHRcdHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG5cdFx0XHRcdHYwLl90bXBJbmRleF8gLSB2MS5fdG1wSW5kZXhfIDpcblx0XHRcdFx0djAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuXHRcdH0pO1xuXHRcdGFycmF5LmZvckVhY2goZnVuY3Rpb24odikge1xuXHRcdFx0ZGVsZXRlIHYuX3RtcEluZGV4Xztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW50ZXJmYWNlIElMYXlvdXRJdGVtXG5cdCAqIEBwcm9wIHtTdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcblx0ICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuXHQgKiBAcHJvcCB7TnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG5cdCAqIEBwcm9wIHtCb29sZWFufSBmdWxsV2lkdGggLSBpZiB0cnVlLCBhbmQgdGhlIGl0ZW0gaXMgaG9yaXpvbnRhbCwgdGhlbiBwdXNoIHZlcnRpY2FsIGJveGVzIGRvd25cblx0ICogQHByb3Age0Z1bmN0aW9ufSBpc0hvcml6b250YWwgLSByZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBpdGVtIGlzIGhvcml6b250YWwgKGllLiB0b3Agb3IgYm90dG9tKVxuXHQgKiBAcHJvcCB7RnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuXHQgKiBAcHJvcCB7RnVuY3Rpb259IGdldFBhZGRpbmcgLSAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYWRkaW5nIG9uIHRoZSBlZGdlc1xuXHQgKiBAcHJvcCB7TnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcblx0ICogQHByb3Age051bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcblx0ICogQHByb3Age051bWJlcn0gbGVmdCAtIExlZnQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuXHQgKiBAcHJvcCB7TnVtYmVyfSB0b3AgLSBUb3AgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuXHQgKiBAcHJvcCB7TnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcblx0ICogQHByb3Age051bWJlcn0gYm90dG9tIC0gQm90dG9tIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcblx0ICovXG5cblx0Ly8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG5cdC8vIFNjYWxlcywgTGVnZW5kcyBhbmQgUGx1Z2lucyBhbGwgcmVseSBvbiB0aGUgbGF5b3V0IHNlcnZpY2UgYW5kIGNhbiBlYXNpbHkgcmVnaXN0ZXIgdG8gYmUgcGxhY2VkIGFueXdoZXJlIHRoZXkgbmVlZFxuXHQvLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXG5cdENoYXJ0LmxheW91dFNlcnZpY2UgPSB7XG5cdFx0ZGVmYXVsdHM6IHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0XHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XG5cdFx0ICovXG5cdFx0YWRkQm94OiBmdW5jdGlvbihjaGFydCwgaXRlbSkge1xuXHRcdFx0aWYgKCFjaGFydC5ib3hlcykge1xuXHRcdFx0XHRjaGFydC5ib3hlcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHRcdFx0aXRlbS5mdWxsV2lkdGggPSBpdGVtLmZ1bGxXaWR0aCB8fCBmYWxzZTtcblx0XHRcdGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuXHRcdFx0aXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuXG5cdFx0XHRjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHJlbW92ZSB0aGUgYm94IGZyb21cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0XHQgKi9cblx0XHRyZW1vdmVCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0Y2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyAob3IgdXBkYXRlcykgb3B0aW9ucyBvbiB0aGUgZ2l2ZW4gYGl0ZW1gLlxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gdGhlIGl0ZW0gdG8gY29uZmlndXJlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBuZXcgaXRlbSBvcHRpb25zLlxuXHRcdCAqL1xuXHRcdGNvbmZpZ3VyZTogZnVuY3Rpb24oY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwcm9wcyA9IFsnZnVsbFdpZHRoJywgJ3Bvc2l0aW9uJywgJ3dlaWdodCddO1xuXHRcdFx0dmFyIGlsZW4gPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRcdGl0ZW1bcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXG5cdFx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG5cdFx0ICovXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihjaGFydCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0aWYgKCFjaGFydCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsYXlvdXRPcHRpb25zID0gY2hhcnQub3B0aW9ucy5sYXlvdXQgfHwge307XG5cdFx0XHR2YXIgcGFkZGluZyA9IGhlbHBlcnMub3B0aW9ucy50b1BhZGRpbmcobGF5b3V0T3B0aW9ucy5wYWRkaW5nKTtcblx0XHRcdHZhciBsZWZ0UGFkZGluZyA9IHBhZGRpbmcubGVmdDtcblx0XHRcdHZhciByaWdodFBhZGRpbmcgPSBwYWRkaW5nLnJpZ2h0O1xuXHRcdFx0dmFyIHRvcFBhZGRpbmcgPSBwYWRkaW5nLnRvcDtcblx0XHRcdHZhciBib3R0b21QYWRkaW5nID0gcGFkZGluZy5ib3R0b207XG5cblx0XHRcdHZhciBsZWZ0Qm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnbGVmdCcpO1xuXHRcdFx0dmFyIHJpZ2h0Qm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAncmlnaHQnKTtcblx0XHRcdHZhciB0b3BCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICd0b3AnKTtcblx0XHRcdHZhciBib3R0b21Cb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdib3R0b20nKTtcblx0XHRcdHZhciBjaGFydEFyZWFCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdjaGFydEFyZWEnKTtcblxuXHRcdFx0Ly8gU29ydCBib3hlcyBieSB3ZWlnaHQuIEEgaGlnaGVyIHdlaWdodCBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuXHRcdFx0c29ydEJ5V2VpZ2h0KGxlZnRCb3hlcywgdHJ1ZSk7XG5cdFx0XHRzb3J0QnlXZWlnaHQocmlnaHRCb3hlcywgZmFsc2UpO1xuXHRcdFx0c29ydEJ5V2VpZ2h0KHRvcEJveGVzLCB0cnVlKTtcblx0XHRcdHNvcnRCeVdlaWdodChib3R0b21Cb3hlcywgZmFsc2UpO1xuXG5cdFx0XHQvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXG5cdFx0XHQvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cblx0XHRcdC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG5cdFx0XHQvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcblx0XHRcdC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuXHRcdFx0Ly8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG5cdFx0XHQvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cblx0XHRcdC8vXG5cdFx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcblx0XHRcdC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcblx0XHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdFx0Ly8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG5cdFx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcblx0XHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0XHQvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdFx0Ly9cblx0XHRcdC8vIFdoYXQgd2UgZG8gdG8gZmluZCB0aGUgYmVzdCBzaXppbmcsIHdlIGRvIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIDEuIERldGVybWluZSB0aGUgbWluaW11bSBzaXplIG9mIHRoZSBjaGFydCBhcmVhLlxuXHRcdFx0Ly8gMi4gU3BsaXQgdGhlIHJlbWFpbmluZyB3aWR0aCBlcXVhbGx5IGJldHdlZW4gZWFjaCB2ZXJ0aWNhbCBheGlzXG5cdFx0XHQvLyAzLiBTcGxpdCB0aGUgcmVtYWluaW5nIGhlaWdodCBlcXVhbGx5IGJldHdlZW4gZWFjaCBob3Jpem9udGFsIGF4aXNcblx0XHRcdC8vIDQuIEdpdmUgZWFjaCBsYXlvdXQgdGhlIG1heGltdW0gc2l6ZSBpdCBjYW4gYmUuIFRoZSBsYXlvdXQgd2lsbCByZXR1cm4gaXQncyBtaW5pbXVtIHNpemVcblx0XHRcdC8vIDUuIEFkanVzdCB0aGUgc2l6ZXMgb2YgZWFjaCBheGlzIGJhc2VkIG9uIGl0J3MgbWluaW11bSByZXBvcnRlZCBzaXplLlxuXHRcdFx0Ly8gNi4gUmVmaXQgZWFjaCBheGlzXG5cdFx0XHQvLyA3LiBQb3NpdGlvbiBlYWNoIGF4aXMgaW4gdGhlIGZpbmFsIGxvY2F0aW9uXG5cdFx0XHQvLyA4LiBUZWxsIHRoZSBjaGFydCB0aGUgZmluYWwgbG9jYXRpb24gb2YgdGhlIGNoYXJ0IGFyZWFcblx0XHRcdC8vIDkuIFRlbGwgYW55IGF4ZXMgdGhhdCBvdmVybGF5IHRoZSBjaGFydCBhcmVhIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGNoYXJ0IGFyZWFcblxuXHRcdFx0Ly8gU3RlcCAxXG5cdFx0XHR2YXIgY2hhcnRXaWR0aCA9IHdpZHRoIC0gbGVmdFBhZGRpbmcgLSByaWdodFBhZGRpbmc7XG5cdFx0XHR2YXIgY2hhcnRIZWlnaHQgPSBoZWlnaHQgLSB0b3BQYWRkaW5nIC0gYm90dG9tUGFkZGluZztcblx0XHRcdHZhciBjaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGggLyAyOyAvLyBtaW4gNTAlXG5cdFx0XHR2YXIgY2hhcnRBcmVhSGVpZ2h0ID0gY2hhcnRIZWlnaHQgLyAyOyAvLyBtaW4gNTAlXG5cblx0XHRcdC8vIFN0ZXAgMlxuXHRcdFx0dmFyIHZlcnRpY2FsQm94V2lkdGggPSAod2lkdGggLSBjaGFydEFyZWFXaWR0aCkgLyAobGVmdEJveGVzLmxlbmd0aCArIHJpZ2h0Qm94ZXMubGVuZ3RoKTtcblxuXHRcdFx0Ly8gU3RlcCAzXG5cdFx0XHR2YXIgaG9yaXpvbnRhbEJveEhlaWdodCA9IChoZWlnaHQgLSBjaGFydEFyZWFIZWlnaHQpIC8gKHRvcEJveGVzLmxlbmd0aCArIGJvdHRvbUJveGVzLmxlbmd0aCk7XG5cblx0XHRcdC8vIFN0ZXAgNFxuXHRcdFx0dmFyIG1heENoYXJ0QXJlYVdpZHRoID0gY2hhcnRXaWR0aDtcblx0XHRcdHZhciBtYXhDaGFydEFyZWFIZWlnaHQgPSBjaGFydEhlaWdodDtcblx0XHRcdHZhciBtaW5Cb3hTaXplcyA9IFtdO1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRNaW5pbXVtQm94U2l6ZShib3gpIHtcblx0XHRcdFx0dmFyIG1pblNpemU7XG5cdFx0XHRcdHZhciBpc0hvcml6b250YWwgPSBib3guaXNIb3Jpem9udGFsKCk7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdG1pblNpemUgPSBib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGhvcml6b250YWxCb3hIZWlnaHQpO1xuXHRcdFx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCAtPSBtaW5TaXplLmhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZSh2ZXJ0aWNhbEJveFdpZHRoLCBjaGFydEFyZWFIZWlnaHQpO1xuXHRcdFx0XHRcdG1heENoYXJ0QXJlYVdpZHRoIC09IG1pblNpemUud2lkdGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtaW5Cb3hTaXplcy5wdXNoKHtcblx0XHRcdFx0XHRob3Jpem9udGFsOiBpc0hvcml6b250YWwsXG5cdFx0XHRcdFx0bWluU2l6ZTogbWluU2l6ZSxcblx0XHRcdFx0XHRib3g6IGJveCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGhlbHBlcnMuZWFjaChsZWZ0Qm94ZXMuY29uY2F0KHJpZ2h0Qm94ZXMsIHRvcEJveGVzLCBib3R0b21Cb3hlcyksIGdldE1pbmltdW1Cb3hTaXplKTtcblxuXHRcdFx0Ly8gSWYgYSBob3Jpem9udGFsIGJveCBoYXMgcGFkZGluZywgd2UgbW92ZSB0aGUgbGVmdCBib3hlcyBvdmVyIHRvIGF2b2lkIHVnbHkgY2hhcnRzIChzZWUgaXNzdWUgIzI0NzgpXG5cdFx0XHR2YXIgbWF4SG9yaXpvbnRhbExlZnRQYWRkaW5nID0gMDtcblx0XHRcdHZhciBtYXhIb3Jpem9udGFsUmlnaHRQYWRkaW5nID0gMDtcblx0XHRcdHZhciBtYXhWZXJ0aWNhbFRvcFBhZGRpbmcgPSAwO1xuXHRcdFx0dmFyIG1heFZlcnRpY2FsQm90dG9tUGFkZGluZyA9IDA7XG5cblx0XHRcdGhlbHBlcnMuZWFjaCh0b3BCb3hlcy5jb25jYXQoYm90dG9tQm94ZXMpLCBmdW5jdGlvbihob3Jpem9udGFsQm94KSB7XG5cdFx0XHRcdGlmIChob3Jpem9udGFsQm94LmdldFBhZGRpbmcpIHtcblx0XHRcdFx0XHR2YXIgYm94UGFkZGluZyA9IGhvcml6b250YWxCb3guZ2V0UGFkZGluZygpO1xuXHRcdFx0XHRcdG1heEhvcml6b250YWxMZWZ0UGFkZGluZyA9IE1hdGgubWF4KG1heEhvcml6b250YWxMZWZ0UGFkZGluZywgYm94UGFkZGluZy5sZWZ0KTtcblx0XHRcdFx0XHRtYXhIb3Jpem9udGFsUmlnaHRQYWRkaW5nID0gTWF0aC5tYXgobWF4SG9yaXpvbnRhbFJpZ2h0UGFkZGluZywgYm94UGFkZGluZy5yaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzKSwgZnVuY3Rpb24odmVydGljYWxCb3gpIHtcblx0XHRcdFx0aWYgKHZlcnRpY2FsQm94LmdldFBhZGRpbmcpIHtcblx0XHRcdFx0XHR2YXIgYm94UGFkZGluZyA9IHZlcnRpY2FsQm94LmdldFBhZGRpbmcoKTtcblx0XHRcdFx0XHRtYXhWZXJ0aWNhbFRvcFBhZGRpbmcgPSBNYXRoLm1heChtYXhWZXJ0aWNhbFRvcFBhZGRpbmcsIGJveFBhZGRpbmcudG9wKTtcblx0XHRcdFx0XHRtYXhWZXJ0aWNhbEJvdHRvbVBhZGRpbmcgPSBNYXRoLm1heChtYXhWZXJ0aWNhbEJvdHRvbVBhZGRpbmcsIGJveFBhZGRpbmcuYm90dG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIG1heENoYXJ0QXJlYUhlaWdodCBhbmQgbWF4Q2hhcnRBcmVhV2lkdGggYXJlIHRoZSBzaXplIHRoZSBjaGFydCBhcmVhIGNvdWxkXG5cdFx0XHQvLyBiZSBpZiB0aGUgYXhlcyBhcmUgZHJhd24gYXQgdGhlaXIgbWluaW11bSBzaXplcy5cblx0XHRcdC8vIFN0ZXBzIDUgJiA2XG5cdFx0XHR2YXIgdG90YWxMZWZ0Qm94ZXNXaWR0aCA9IGxlZnRQYWRkaW5nO1xuXHRcdFx0dmFyIHRvdGFsUmlnaHRCb3hlc1dpZHRoID0gcmlnaHRQYWRkaW5nO1xuXHRcdFx0dmFyIHRvdGFsVG9wQm94ZXNIZWlnaHQgPSB0b3BQYWRkaW5nO1xuXHRcdFx0dmFyIHRvdGFsQm90dG9tQm94ZXNIZWlnaHQgPSBib3R0b21QYWRkaW5nO1xuXG5cdFx0XHQvLyBGdW5jdGlvbiB0byBmaXQgYSBib3hcblx0XHRcdGZ1bmN0aW9uIGZpdEJveChib3gpIHtcblx0XHRcdFx0dmFyIG1pbkJveFNpemUgPSBoZWxwZXJzLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pbkJveCkge1xuXHRcdFx0XHRcdHJldHVybiBtaW5Cb3guYm94ID09PSBib3g7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChtaW5Cb3hTaXplKSB7XG5cdFx0XHRcdFx0aWYgKGJveC5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRcdFx0XHRsZWZ0OiBNYXRoLm1heCh0b3RhbExlZnRCb3hlc1dpZHRoLCBtYXhIb3Jpem9udGFsTGVmdFBhZGRpbmcpLFxuXHRcdFx0XHRcdFx0XHRyaWdodDogTWF0aC5tYXgodG90YWxSaWdodEJveGVzV2lkdGgsIG1heEhvcml6b250YWxSaWdodFBhZGRpbmcpLFxuXHRcdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRcdGJvdHRvbTogMFxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgdXNlIG1pbiBzaXplIGhlcmUgYmVjYXVzZSBvZiBsYWJlbCByb3RhdGlvbi4gV2hlbiB0aGUgbGFiZWxzIGFyZSByb3RhdGVkLCB0aGVpciByb3RhdGlvbiBoaWdobHkgZGVwZW5kc1xuXHRcdFx0XHRcdFx0Ly8gb24gdGhlIG1hcmdpbi4gU29tZXRpbWVzIHRoZXkgbmVlZCB0byBpbmNyZWFzZSBpbiBzaXplIHNsaWdodGx5XG5cdFx0XHRcdFx0XHRib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGNoYXJ0SGVpZ2h0IC8gMiwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib3gudXBkYXRlKG1pbkJveFNpemUubWluU2l6ZS53aWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlLCBhbmQgY2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCByaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdFx0aGVscGVycy5lYWNoKGxlZnRCb3hlcy5jb25jYXQocmlnaHRCb3hlcyksIGZpdEJveCk7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChsZWZ0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbExlZnRCb3hlc1dpZHRoICs9IGJveC53aWR0aDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gocmlnaHRCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdHRvdGFsUmlnaHRCb3hlc1dpZHRoICs9IGJveC53aWR0aDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBTZXQgdGhlIExlZnQgYW5kIFJpZ2h0IG1hcmdpbnMgZm9yIHRoZSBob3Jpem9udGFsIGJveGVzXG5cdFx0XHRoZWxwZXJzLmVhY2godG9wQm94ZXMuY29uY2F0KGJvdHRvbUJveGVzKSwgZml0Qm94KTtcblxuXHRcdFx0Ly8gRmlndXJlIG91dCBob3cgbXVjaCBtYXJnaW4gaXMgb24gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRoZSB2ZXJ0aWNhbCBib3hlc1xuXHRcdFx0aGVscGVycy5lYWNoKHRvcEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0dG90YWxUb3BCb3hlc0hlaWdodCArPSBib3guaGVpZ2h0O1xuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChib3R0b21Cb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdHRvdGFsQm90dG9tQm94ZXNIZWlnaHQgKz0gYm94LmhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHRmdW5jdGlvbiBmaW5hbEZpdFZlcnRpY2FsQm94KGJveCkge1xuXHRcdFx0XHR2YXIgbWluQm94U2l6ZSA9IGhlbHBlcnMuZmluZE5leHRXaGVyZShtaW5Cb3hTaXplcywgZnVuY3Rpb24obWluU2l6ZSkge1xuXHRcdFx0XHRcdHJldHVybiBtaW5TaXplLmJveCA9PT0gYm94O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR2YXIgc2NhbGVNYXJnaW4gPSB7XG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0XHR0b3A6IHRvdGFsVG9wQm94ZXNIZWlnaHQsXG5cdFx0XHRcdFx0Ym90dG9tOiB0b3RhbEJvdHRvbUJveGVzSGVpZ2h0XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKG1pbkJveFNpemUpIHtcblx0XHRcdFx0XHRib3gudXBkYXRlKG1pbkJveFNpemUubWluU2l6ZS53aWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0LCBzY2FsZU1hcmdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTGV0IHRoZSBsZWZ0IGxheW91dCBrbm93IHRoZSBmaW5hbCBtYXJnaW5cblx0XHRcdGhlbHBlcnMuZWFjaChsZWZ0Qm94ZXMuY29uY2F0KHJpZ2h0Qm94ZXMpLCBmaW5hbEZpdFZlcnRpY2FsQm94KTtcblxuXHRcdFx0Ly8gUmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgc2l6ZSBvZiBlYWNoIGxheW91dCBtaWdodCBoYXZlIGNoYW5nZWQgc2xpZ2h0bHkgZHVlIHRvIHRoZSBtYXJnaW5zIChsYWJlbCByb3RhdGlvbiBmb3IgaW5zdGFuY2UpXG5cdFx0XHR0b3RhbExlZnRCb3hlc1dpZHRoID0gbGVmdFBhZGRpbmc7XG5cdFx0XHR0b3RhbFJpZ2h0Qm94ZXNXaWR0aCA9IHJpZ2h0UGFkZGluZztcblx0XHRcdHRvdGFsVG9wQm94ZXNIZWlnaHQgPSB0b3BQYWRkaW5nO1xuXHRcdFx0dG90YWxCb3R0b21Cb3hlc0hlaWdodCA9IGJvdHRvbVBhZGRpbmc7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChsZWZ0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbExlZnRCb3hlc1dpZHRoICs9IGJveC53aWR0aDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gocmlnaHRCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdHRvdGFsUmlnaHRCb3hlc1dpZHRoICs9IGJveC53aWR0aDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2godG9wQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbFRvcEJveGVzSGVpZ2h0ICs9IGJveC5oZWlnaHQ7XG5cdFx0XHR9KTtcblx0XHRcdGhlbHBlcnMuZWFjaChib3R0b21Cb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdHRvdGFsQm90dG9tQm94ZXNIZWlnaHQgKz0gYm94LmhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBXZSBtYXkgYmUgYWRkaW5nIHNvbWUgcGFkZGluZyB0byBhY2NvdW50IGZvciByb3RhdGVkIHggYXhpcyBsYWJlbHNcblx0XHRcdHZhciBsZWZ0UGFkZGluZ0FkZGl0aW9uID0gTWF0aC5tYXgobWF4SG9yaXpvbnRhbExlZnRQYWRkaW5nIC0gdG90YWxMZWZ0Qm94ZXNXaWR0aCwgMCk7XG5cdFx0XHR0b3RhbExlZnRCb3hlc1dpZHRoICs9IGxlZnRQYWRkaW5nQWRkaXRpb247XG5cdFx0XHR0b3RhbFJpZ2h0Qm94ZXNXaWR0aCArPSBNYXRoLm1heChtYXhIb3Jpem9udGFsUmlnaHRQYWRkaW5nIC0gdG90YWxSaWdodEJveGVzV2lkdGgsIDApO1xuXG5cdFx0XHR2YXIgdG9wUGFkZGluZ0FkZGl0aW9uID0gTWF0aC5tYXgobWF4VmVydGljYWxUb3BQYWRkaW5nIC0gdG90YWxUb3BCb3hlc0hlaWdodCwgMCk7XG5cdFx0XHR0b3RhbFRvcEJveGVzSGVpZ2h0ICs9IHRvcFBhZGRpbmdBZGRpdGlvbjtcblx0XHRcdHRvdGFsQm90dG9tQm94ZXNIZWlnaHQgKz0gTWF0aC5tYXgobWF4VmVydGljYWxCb3R0b21QYWRkaW5nIC0gdG90YWxCb3R0b21Cb3hlc0hlaWdodCwgMCk7XG5cblx0XHRcdC8vIEZpZ3VyZSBvdXQgaWYgb3VyIGNoYXJ0IGFyZWEgY2hhbmdlZC4gVGhpcyB3b3VsZCBvY2N1ciBpZiB0aGUgZGF0YXNldCBsYXlvdXQgbGFiZWwgcm90YXRpb25cblx0XHRcdC8vIGNoYW5nZWQgZHVlIHRvIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGUgbWFyZ2lucyBpbiBzdGVwIDYuIFNpbmNlIHdlIGNhbiBvbmx5IGdldCBiaWdnZXIsIHRoaXMgaXMgc2FmZSB0byBkb1xuXHRcdFx0Ly8gd2l0aG91dCBjYWxsaW5nIGBmaXRgIGFnYWluXG5cdFx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ID0gaGVpZ2h0IC0gdG90YWxUb3BCb3hlc0hlaWdodCAtIHRvdGFsQm90dG9tQm94ZXNIZWlnaHQ7XG5cdFx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhV2lkdGggPSB3aWR0aCAtIHRvdGFsTGVmdEJveGVzV2lkdGggLSB0b3RhbFJpZ2h0Qm94ZXNXaWR0aDtcblxuXHRcdFx0aWYgKG5ld01heENoYXJ0QXJlYVdpZHRoICE9PSBtYXhDaGFydEFyZWFXaWR0aCB8fCBuZXdNYXhDaGFydEFyZWFIZWlnaHQgIT09IG1heENoYXJ0QXJlYUhlaWdodCkge1xuXHRcdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0XHRib3guaGVpZ2h0ID0gbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2gocmlnaHRCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdFx0Ym94LmhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKHRvcEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHtcblx0XHRcdFx0XHRcdGJveC53aWR0aCA9IG5ld01heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKGJvdHRvbUJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHtcblx0XHRcdFx0XHRcdGJveC53aWR0aCA9IG5ld01heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bWF4Q2hhcnRBcmVhSGVpZ2h0ID0gbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXHRcdFx0XHRtYXhDaGFydEFyZWFXaWR0aCA9IG5ld01heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGVwIDcgLSBQb3NpdGlvbiB0aGUgYm94ZXNcblx0XHRcdHZhciBsZWZ0ID0gbGVmdFBhZGRpbmcgKyBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdFx0dmFyIHRvcCA9IHRvcFBhZGRpbmcgKyB0b3BQYWRkaW5nQWRkaXRpb247XG5cblx0XHRcdGZ1bmN0aW9uIHBsYWNlQm94KGJveCkge1xuXHRcdFx0XHRpZiAoYm94LmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdFx0Ym94LmxlZnQgPSBib3guZnVsbFdpZHRoID8gbGVmdFBhZGRpbmcgOiB0b3RhbExlZnRCb3hlc1dpZHRoO1xuXHRcdFx0XHRcdGJveC5yaWdodCA9IGJveC5mdWxsV2lkdGggPyB3aWR0aCAtIHJpZ2h0UGFkZGluZyA6IHRvdGFsTGVmdEJveGVzV2lkdGggKyBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0XHRib3gudG9wID0gdG9wO1xuXHRcdFx0XHRcdGJveC5ib3R0b20gPSB0b3AgKyBib3guaGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gTW92ZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdFx0dG9wID0gYm94LmJvdHRvbTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ym94LmxlZnQgPSBsZWZ0O1xuXHRcdFx0XHRcdGJveC5yaWdodCA9IGxlZnQgKyBib3gud2lkdGg7XG5cdFx0XHRcdFx0Ym94LnRvcCA9IHRvdGFsVG9wQm94ZXNIZWlnaHQ7XG5cdFx0XHRcdFx0Ym94LmJvdHRvbSA9IHRvdGFsVG9wQm94ZXNIZWlnaHQgKyBtYXhDaGFydEFyZWFIZWlnaHQ7XG5cblx0XHRcdFx0XHQvLyBNb3ZlIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0XHRsZWZ0ID0gYm94LnJpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGhlbHBlcnMuZWFjaChsZWZ0Qm94ZXMuY29uY2F0KHRvcEJveGVzKSwgcGxhY2VCb3gpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciBjaGFydCB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0XHRsZWZ0ICs9IG1heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0dG9wICs9IG1heENoYXJ0QXJlYUhlaWdodDtcblxuXHRcdFx0aGVscGVycy5lYWNoKHJpZ2h0Qm94ZXMsIHBsYWNlQm94KTtcblx0XHRcdGhlbHBlcnMuZWFjaChib3R0b21Cb3hlcywgcGxhY2VCb3gpO1xuXG5cdFx0XHQvLyBTdGVwIDhcblx0XHRcdGNoYXJ0LmNoYXJ0QXJlYSA9IHtcblx0XHRcdFx0bGVmdDogdG90YWxMZWZ0Qm94ZXNXaWR0aCxcblx0XHRcdFx0dG9wOiB0b3RhbFRvcEJveGVzSGVpZ2h0LFxuXHRcdFx0XHRyaWdodDogdG90YWxMZWZ0Qm94ZXNXaWR0aCArIG1heENoYXJ0QXJlYVdpZHRoLFxuXHRcdFx0XHRib3R0b206IHRvdGFsVG9wQm94ZXNIZWlnaHQgKyBtYXhDaGFydEFyZWFIZWlnaHRcblx0XHRcdH07XG5cblx0XHRcdC8vIFN0ZXAgOVxuXHRcdFx0aGVscGVycy5lYWNoKGNoYXJ0QXJlYUJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0Ym94LmxlZnQgPSBjaGFydC5jaGFydEFyZWEubGVmdDtcblx0XHRcdFx0Ym94LnRvcCA9IGNoYXJ0LmNoYXJ0QXJlYS50b3A7XG5cdFx0XHRcdGJveC5yaWdodCA9IGNoYXJ0LmNoYXJ0QXJlYS5yaWdodDtcblx0XHRcdFx0Ym94LmJvdHRvbSA9IGNoYXJ0LmNoYXJ0QXJlYS5ib3R0b207XG5cblx0XHRcdFx0Ym94LnVwZGF0ZShtYXhDaGFydEFyZWFXaWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn07XG5cbn0se1wiNDVcIjo0NX1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRwbHVnaW5zOiB7fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHQvKipcblx0ICogVGhlIHBsdWdpbiBzZXJ2aWNlIHNpbmdsZXRvblxuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpbnNcblx0ICogQHNpbmNlIDIuMS4wXG5cdCAqL1xuXHRDaGFydC5wbHVnaW5zID0ge1xuXHRcdC8qKlxuXHRcdCAqIEdsb2JhbGx5IHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9wbHVnaW5zOiBbXSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaWRlbnRpZmllciBpcyB1c2VkIHRvIGludmFsaWRhdGUgdGhlIGRlc2NyaXB0b3JzIGNhY2hlIGF0dGFjaGVkIHRvIGVhY2ggY2hhcnRcblx0XHQgKiB3aGVuIGEgZ2xvYmFsIHBsdWdpbiBpcyByZWdpc3RlcmVkIG9yIHVucmVnaXN0ZXJlZC4gSW4gdGhpcyBjYXNlLCB0aGUgY2FjaGUgSUQgaXNcblx0XHQgKiBpbmNyZW1lbnRlZCBhbmQgZGVzY3JpcHRvcnMgYXJlIHJlZ2VuZXJhdGVkIGR1cmluZyBmb2xsb3dpbmcgQVBJIGNhbGxzLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X2NhY2hlSWQ6IDAsXG5cblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkLlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cblx0XHQgKi9cblx0XHRyZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdFx0aWYgKHAuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuXHRcdFx0XHRcdHAucHVzaChwbHVnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIG9ubHkgaWYgcmVnaXN0ZXJlZC5cblx0XHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXG5cdFx0ICovXG5cdFx0dW5yZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdFx0dmFyIGlkeCA9IHAuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0XHRcdHAuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHRcdCAqIEBzaW5jZSAyLjEuNVxuXHRcdCAqL1xuXHRcdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcblx0XHRcdHRoaXMuX2NhY2hlSWQrKztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlZ2lzdGVyZWQgcGx1Z2lucz9cblx0XHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHRcdCAqIEBzaW5jZSAyLjEuNVxuXHRcdCAqL1xuXHRcdGNvdW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wbHVnaW5zLmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBwbHVnaW4gaW5zdGFuY2VzLlxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgcGx1Z2luIG9iamVjdHMuXG5cdFx0ICogQHNpbmNlIDIuMS41XG5cdFx0ICovXG5cdFx0Z2V0QWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wbHVnaW5zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHRcdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0XHQgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdFx0ICovXG5cdFx0bm90aWZ5OiBmdW5jdGlvbihjaGFydCwgaG9vaywgYXJncykge1xuXHRcdFx0dmFyIGRlc2NyaXB0b3JzID0gdGhpcy5kZXNjcmlwdG9ycyhjaGFydCk7XG5cdFx0XHR2YXIgaWxlbiA9IGRlc2NyaXB0b3JzLmxlbmd0aDtcblx0XHRcdHZhciBpLCBkZXNjcmlwdG9yLCBwbHVnaW4sIHBhcmFtcywgbWV0aG9kO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpXTtcblx0XHRcdFx0cGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG5cdFx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRwYXJhbXMgPSBbY2hhcnRdLmNvbmNhdChhcmdzIHx8IFtdKTtcblx0XHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xuXHRcdFx0XHRcdGlmIChtZXRob2QuYXBwbHkocGx1Z2luLCBwYXJhbXMpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBkZXNjcmlwdG9ycyBvZiBlbmFibGVkIHBsdWdpbnMgZm9yIHRoZSBnaXZlbiBjaGFydC5cblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IFt7IHBsdWdpbiwgb3B0aW9ucyB9XVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBjaGFydC5fcGx1Z2lucyB8fCAoY2hhcnQuX3BsdWdpbnMgPSB7fSk7XG5cdFx0XHRpZiAoY2FjaGUuaWQgPT09IHRoaXMuX2NhY2hlSWQpIHtcblx0XHRcdFx0cmV0dXJuIGNhY2hlLmRlc2NyaXB0b3JzO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGx1Z2lucyA9IFtdO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3JzID0gW107XG5cdFx0XHR2YXIgY29uZmlnID0gKGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZykgfHwge307XG5cdFx0XHR2YXIgb3B0aW9ucyA9IChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zKSB8fCB7fTtcblxuXHRcdFx0dGhpcy5fcGx1Z2lucy5jb25jYXQoY29uZmlnLnBsdWdpbnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdHZhciBpZHggPSBwbHVnaW5zLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaWQgPSBwbHVnaW4uaWQ7XG5cdFx0XHRcdHZhciBvcHRzID0gb3B0aW9uc1tpZF07XG5cdFx0XHRcdGlmIChvcHRzID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRzID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0b3B0cyA9IGhlbHBlcnMuY2xvbmUoZGVmYXVsdHMuZ2xvYmFsLnBsdWdpbnNbaWRdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0XHRkZXNjcmlwdG9ycy5wdXNoKHtcblx0XHRcdFx0XHRwbHVnaW46IHBsdWdpbixcblx0XHRcdFx0XHRvcHRpb25zOiBvcHRzIHx8IHt9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGNhY2hlLmRlc2NyaXB0b3JzID0gZGVzY3JpcHRvcnM7XG5cdFx0XHRjYWNoZS5pZCA9IHRoaXMuX2NhY2hlSWQ7XG5cdFx0XHRyZXR1cm4gZGVzY3JpcHRvcnM7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQbHVnaW4gZXh0ZW5zaW9uIGhvb2tzLlxuXHQgKiBAaW50ZXJmYWNlIElQbHVnaW5cblx0ICogQHNpbmNlIDIuMS4wXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZUluaXRcblx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSBpbml0aWFsaXppbmcgYGNoYXJ0YC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVySW5pdFxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgYGNoYXJ0YCBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVVcGRhdGVcblx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSB1cGRhdGluZyBgY2hhcnRgLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCwgdGhlIHVwZGF0ZVxuXHQgKiBpcyBjYW5jZWxsZWQgKGFuZCB0aHVzIHN1YnNlcXVlbnQgcmVuZGVyKHMpKSB1bnRpbCBhbm90aGVyIGB1cGRhdGVgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgY2hhcnQgdXBkYXRlLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlclVwZGF0ZVxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgYGNoYXJ0YCBoYXMgYmVlbiB1cGRhdGVkIGFuZCBiZWZvcmUgcmVuZGVyaW5nLiBOb3RlIHRoYXQgdGhpc1xuXHQgKiBob29rIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgY2hhcnQgdXBkYXRlIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlRGF0YXNldHNVcGRhdGVcbiBcdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgdXBkYXRpbmcgdGhlIGBjaGFydGAgZGF0YXNldHMuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLFxuXHQgKiB0aGUgZGF0YXNldHMgdXBkYXRlIGlzIGNhbmNlbGxlZCB1bnRpbCBhbm90aGVyIGB1cGRhdGVgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBmYWxzZSB0byBjYW5jZWwgdGhlIGRhdGFzZXRzIHVwZGF0ZS5cblx0ICogQHNpbmNlIHZlcnNpb24gMi4xLjVcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJEYXRhc2V0c1VwZGF0ZVxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBjaGFydGAgZGF0YXNldHMgaGF2ZSBiZWVuIHVwZGF0ZWQuIE5vdGUgdGhhdCB0aGlzIGhvb2tcblx0ICogd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSBkYXRhc2V0cyB1cGRhdGUgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAc2luY2UgdmVyc2lvbiAyLjEuNVxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVEYXRhc2V0VXBkYXRlXG4gXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIHVwZGF0aW5nIHRoZSBgY2hhcnRgIGRhdGFzZXQgYXQgdGhlIGdpdmVuIGBhcmdzLmluZGV4YC4gSWYgYW55IHBsdWdpblxuXHQgKiByZXR1cm5zIGBmYWxzZWAsIHRoZSBkYXRhc2V0cyB1cGRhdGUgaXMgY2FuY2VsbGVkIHVudGlsIGFub3RoZXIgYHVwZGF0ZWAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBUaGUgY2FsbCBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmluZGV4IC0gVGhlIGRhdGFzZXQgaW5kZXguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLm1ldGEgLSBUaGUgZGF0YXNldCBtZXRhZGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgY2hhcnQgZGF0YXNldHMgZHJhd2luZy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJEYXRhc2V0VXBkYXRlXG4gXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBjaGFydGAgZGF0YXNldHMgYXQgdGhlIGdpdmVuIGBhcmdzLmluZGV4YCBoYXMgYmVlbiB1cGRhdGVkLiBOb3RlXG5cdCAqIHRoYXQgdGhpcyBob29rIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgZGF0YXNldHMgdXBkYXRlIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBUaGUgY2FsbCBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmluZGV4IC0gVGhlIGRhdGFzZXQgaW5kZXguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLm1ldGEgLSBUaGUgZGF0YXNldCBtZXRhZGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZUxheW91dFxuXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIGxheWluZyBvdXQgYGNoYXJ0YC4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsXG5cdCAqIHRoZSBsYXlvdXQgdXBkYXRlIGlzIGNhbmNlbGxlZCB1bnRpbCBhbm90aGVyIGB1cGRhdGVgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgY2hhcnQgbGF5b3V0LlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckxheW91dFxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBjaGFydGAgaGFzIGJlZW4gbGF5ZWQgb3V0LiBOb3RlIHRoYXQgdGhpcyBob29rIHdpbGwgbm90XG5cdCAqIGJlIGNhbGxlZCBpZiB0aGUgbGF5b3V0IHVwZGF0ZSBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZVJlbmRlclxuXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBgY2hhcnRgLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCxcblx0ICogdGhlIHJlbmRlcmluZyBpcyBjYW5jZWxsZWQgdW50aWwgYW5vdGhlciBgcmVuZGVyYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCB0byBjYW5jZWwgdGhlIGNoYXJ0IHJlbmRlcmluZy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJSZW5kZXJcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgY2hhcnRgIGhhcyBiZWVuIGZ1bGx5IHJlbmRlcmVkIChhbmQgYW5pbWF0aW9uIGNvbXBsZXRlZCkuIE5vdGVcblx0ICogdGhhdCB0aGlzIGhvb2sgd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSByZW5kZXJpbmcgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVEcmF3XG5cdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgZHJhd2luZyBgY2hhcnRgIGF0IGV2ZXJ5IGFuaW1hdGlvbiBmcmFtZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuXG5cdCAqIGVhc2luZyB2YWx1ZS4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsIHRoZSBmcmFtZSBkcmF3aW5nIGlzIGNhbmNlbGxlZCB1bnRpbFxuXHQgKiBhbm90aGVyIGByZW5kZXJgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVhc2luZ1ZhbHVlIC0gVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHZhbHVlLCBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgdG8gY2FuY2VsIHRoZSBjaGFydCBkcmF3aW5nLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckRyYXdcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgY2hhcnRgIGhhcyBiZWVuIGRyYXduIGZvciB0aGUgc3BlY2lmaWMgZWFzaW5nIHZhbHVlLiBOb3RlXG5cdCAqIHRoYXQgdGhpcyBob29rIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgZHJhd2luZyBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVhc2luZ1ZhbHVlIC0gVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHZhbHVlLCBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlRGF0YXNldHNEcmF3XG4gXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIGRyYXdpbmcgdGhlIGBjaGFydGAgZGF0YXNldHMuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLFxuXHQgKiB0aGUgZGF0YXNldHMgZHJhd2luZyBpcyBjYW5jZWxsZWQgdW50aWwgYW5vdGhlciBgcmVuZGVyYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlYXNpbmdWYWx1ZSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiB2YWx1ZSwgYmV0d2VlbiAwLjAgYW5kIDEuMC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgY2hhcnQgZGF0YXNldHMgZHJhd2luZy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJEYXRhc2V0c0RyYXdcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgY2hhcnRgIGRhdGFzZXRzIGhhdmUgYmVlbiBkcmF3bi4gTm90ZSB0aGF0IHRoaXMgaG9va1xuXHQgKiB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIGRhdGFzZXRzIGRyYXdpbmcgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlYXNpbmdWYWx1ZSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiB2YWx1ZSwgYmV0d2VlbiAwLjAgYW5kIDEuMC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZURhdGFzZXREcmF3XG4gXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIGRyYXdpbmcgdGhlIGBjaGFydGAgZGF0YXNldCBhdCB0aGUgZ2l2ZW4gYGFyZ3MuaW5kZXhgIChkYXRhc2V0c1xuXHQgKiBhcmUgZHJhd24gaW4gdGhlIHJldmVyc2Ugb3JkZXIpLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCwgdGhlIGRhdGFzZXRzIGRyYXdpbmdcblx0ICogaXMgY2FuY2VsbGVkIHVudGlsIGFub3RoZXIgYHJlbmRlcmAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBUaGUgY2FsbCBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmluZGV4IC0gVGhlIGRhdGFzZXQgaW5kZXguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLm1ldGEgLSBUaGUgZGF0YXNldCBtZXRhZGF0YS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZWFzaW5nVmFsdWUgLSBUaGUgY3VycmVudCBhbmltYXRpb24gdmFsdWUsIGJldHdlZW4gMC4wIGFuZCAxLjAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCB0byBjYW5jZWwgdGhlIGNoYXJ0IGRhdGFzZXRzIGRyYXdpbmcuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyRGF0YXNldERyYXdcbiBcdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGNoYXJ0YCBkYXRhc2V0cyBhdCB0aGUgZ2l2ZW4gYGFyZ3MuaW5kZXhgIGhhdmUgYmVlbiBkcmF3blxuXHQgKiAoZGF0YXNldHMgYXJlIGRyYXduIGluIHRoZSByZXZlcnNlIG9yZGVyKS4gTm90ZSB0aGF0IHRoaXMgaG9vayB3aWxsIG5vdCBiZSBjYWxsZWRcblx0ICogaWYgdGhlIGRhdGFzZXRzIGRyYXdpbmcgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIFRoZSBjYWxsIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuaW5kZXggLSBUaGUgZGF0YXNldCBpbmRleC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MubWV0YSAtIFRoZSBkYXRhc2V0IG1ldGFkYXRhLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYXJncy5lYXNpbmdWYWx1ZSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiB2YWx1ZSwgYmV0d2VlbiAwLjAgYW5kIDEuMC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZUV2ZW50XG4gXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIHNwZWNpZmllZCBgZXZlbnRgLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCxcblx0ICogdGhlIGV2ZW50IHdpbGwgYmUgZGlzY2FyZGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJFdmVudFxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBldmVudGAgaGFzIGJlZW4gY29uc3VtZWQuIE5vdGUgdGhhdCB0aGlzIGhvb2tcblx0ICogd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSBgZXZlbnRgIGhhcyBiZWVuIHByZXZpb3VzbHkgZGlzY2FyZGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jcmVzaXplXG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgY2hhcnQgYXMgYmVlbiByZXNpemVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIFRoZSBuZXcgY2FudmFzIGRpc3BsYXkgc2l6ZSAoZXEuIGNhbnZhcy5zdHlsZSB3aWR0aCAmIGhlaWdodCkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNkZXN0cm95XG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgY2hhcnQgYXMgYmVlbiBkZXN0cm95ZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5wbHVnaW5zIGluc3RlYWRcblx0ICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Q2hhcnQucGx1Z2luU2VydmljZSA9IENoYXJ0LnBsdWdpbnM7XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbmhlcml0aW5nIGZyb20gQ2hhcnQuUGx1Z2luZ0Jhc2UgaGFzIG5vXG5cdCAqIGVmZmVjdCwgaW5zdGVhZCBzaW1wbHkgY3JlYXRlL3JlZ2lzdGVyIHBsdWdpbnMgdmlhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cblx0ICogQGludGVyZmFjZSBDaGFydC5QbHVnaW5CYXNlXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Q2hhcnQuUGx1Z2luQmFzZSA9IEVsZW1lbnQuZXh0ZW5kKHt9KTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjI2XCI6MjYsXCI0NVwiOjQ1fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgyNik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xudmFyIFRpY2tzID0gcmVxdWlyZSgzNCk7XG5cbmRlZmF1bHRzLl9zZXQoJ3NjYWxlJywge1xuXHRkaXNwbGF5OiB0cnVlLFxuXHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRvZmZzZXQ6IGZhbHNlLFxuXG5cdC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuXHRncmlkTGluZXM6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcblx0XHRsaW5lV2lkdGg6IDEsXG5cdFx0ZHJhd0JvcmRlcjogdHJ1ZSxcblx0XHRkcmF3T25DaGFydEFyZWE6IHRydWUsXG5cdFx0ZHJhd1RpY2tzOiB0cnVlLFxuXHRcdHRpY2tNYXJrTGVuZ3RoOiAxMCxcblx0XHR6ZXJvTGluZVdpZHRoOiAxLFxuXHRcdHplcm9MaW5lQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMjUpJyxcblx0XHR6ZXJvTGluZUJvcmRlckRhc2g6IFtdLFxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogMC4wLFxuXHRcdG9mZnNldEdyaWRMaW5lczogZmFsc2UsXG5cdFx0Ym9yZGVyRGFzaDogW10sXG5cdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wXG5cdH0sXG5cblx0Ly8gc2NhbGUgbGFiZWxcblx0c2NhbGVMYWJlbDoge1xuXHRcdC8vIGRpc3BsYXkgcHJvcGVydHlcblx0XHRkaXNwbGF5OiBmYWxzZSxcblxuXHRcdC8vIGFjdHVhbCBsYWJlbFxuXHRcdGxhYmVsU3RyaW5nOiAnJyxcblxuXHRcdC8vIGxpbmUgaGVpZ2h0XG5cdFx0bGluZUhlaWdodDogMS4yLFxuXG5cdFx0Ly8gdG9wL2JvdHRvbSBwYWRkaW5nXG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiA0LFxuXHRcdFx0Ym90dG9tOiA0XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0YmVnaW5BdFplcm86IGZhbHNlLFxuXHRcdG1pblJvdGF0aW9uOiAwLFxuXHRcdG1heFJvdGF0aW9uOiA1MCxcblx0XHRtaXJyb3I6IGZhbHNlLFxuXHRcdHBhZGRpbmc6IDAsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRhdXRvU2tpcDogdHJ1ZSxcblx0XHRhdXRvU2tpcFBhZGRpbmc6IDAsXG5cdFx0bGFiZWxPZmZzZXQ6IDAsXG5cdFx0Ly8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG5cdFx0Y2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuXHRcdG1pbm9yOiB7fSxcblx0XHRtYWpvcjoge31cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGxhYmVsc0Zyb21UaWNrcyh0aWNrcykge1xuXHR2YXIgbGFiZWxzID0gW107XG5cdHZhciBpLCBpbGVuO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRsYWJlbHMucHVzaCh0aWNrc1tpXS5sYWJlbCk7XG5cdH1cblxuXHRyZXR1cm4gbGFiZWxzO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lVmFsdWUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpbmRleCk7XG5cblx0aWYgKG9mZnNldEdyaWRMaW5lcykge1xuXHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0bGluZVZhbHVlIC09IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGluZVZhbHVlIC09IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaW5kZXggLSAxKSkgLyAyO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbGluZVZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0ZnVuY3Rpb24gY29tcHV0ZVRleHRTaXplKGNvbnRleHQsIHRpY2ssIGZvbnQpIHtcblx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KHRpY2spID9cblx0XHRcdGhlbHBlcnMubG9uZ2VzdFRleHQoY29udGV4dCwgZm9udCwgdGljaykgOlxuXHRcdFx0Y29udGV4dC5tZWFzdXJlVGV4dCh0aWNrKS53aWR0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlRm9udE9wdGlvbnMob3B0aW9ucykge1xuXHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHR2YXIgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSk7XG5cdFx0dmFyIGZhbWlseSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRzdHlsZTogc3R5bGUsXG5cdFx0XHRmYW1pbHk6IGZhbWlseSxcblx0XHRcdGZvbnQ6IGhlbHBlcnMuZm9udFN0cmluZyhzaXplLCBzdHlsZSwgZmFtaWx5KVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUxpbmVIZWlnaHQob3B0aW9ucykge1xuXHRcdHJldHVybiBoZWxwZXJzLm9wdGlvbnMudG9MaW5lSGVpZ2h0KFxuXHRcdFx0aGVscGVycy52YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIDEuMiksXG5cdFx0XHRoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFNpemUsIGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpKTtcblx0fVxuXG5cdENoYXJ0LlNjYWxlID0gRWxlbWVudC5leHRlbmQoe1xuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxuXHRcdCAqIEBtZXRob2QgZ2V0UGFkZGluZ1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHJldHVybnMge1BhZGRpbmd9IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHRcdCAqL1xuXHRcdGdldFBhZGRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGxlZnQ6IG1lLnBhZGRpbmdMZWZ0IHx8IDAsXG5cdFx0XHRcdHRvcDogbWUucGFkZGluZ1RvcCB8fCAwLFxuXHRcdFx0XHRyaWdodDogbWUucGFkZGluZ1JpZ2h0IHx8IDAsXG5cdFx0XHRcdGJvdHRvbTogbWUucGFkZGluZ0JvdHRvbSB8fCAwXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBzY2FsZSB0aWNrIG9iamVjdHMgKHtsYWJlbCwgbWFqb3J9KVxuXHRcdCAqIEBzaW5jZSAyLjdcblx0XHQgKi9cblx0XHRnZXRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGlja3M7XG5cdFx0fSxcblxuXHRcdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5bGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0XHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG5cdFx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG5cdFx0bWVyZ2VUaWNrc09wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXHRcdFx0aWYgKHRpY2tzLm1pbm9yID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aWNrcy5taW5vciA9IHtcblx0XHRcdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpY2tzLm1ham9yID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aWNrcy5tYWpvciA9IHtcblx0XHRcdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHRpY2tzKSB7XG5cdFx0XHRcdGlmIChrZXkgIT09ICdtYWpvcicgJiYga2V5ICE9PSAnbWlub3InKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aWNrcy5taW5vcltrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0dGlja3MubWlub3Jba2V5XSA9IHRpY2tzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdGlja3MubWFqb3Jba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHRpY2tzLm1ham9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcblx0XHR9LFxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBpLCBpbGVuLCBsYWJlbHMsIGxhYmVsLCB0aWNrcywgdGljaztcblxuXHRcdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0XHRtZS5tYXJnaW5zID0gaGVscGVycy5leHRlbmQoe1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRib3R0b206IDBcblx0XHRcdH0sIG1hcmdpbnMpO1xuXHRcdFx0bWUubG9uZ2VzdFRleHRDYWNoZSA9IG1lLmxvbmdlc3RUZXh0Q2FjaGUgfHwge307XG5cblx0XHRcdC8vIERpbWVuc2lvbnNcblx0XHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG5cdFx0XHQvLyBEYXRhIG1pbi9tYXhcblx0XHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcblx0XHRcdG1lLmRldGVybWluZURhdGFMaW1pdHMoKTtcblx0XHRcdG1lLmFmdGVyRGF0YUxpbWl0cygpO1xuXG5cdFx0XHQvLyBUaWNrcyAtIGB0aGlzLnRpY2tzYCBpcyBub3cgREVQUkVDQVRFRCFcblx0XHRcdC8vIEludGVybmFsIHRpY2tzIGFyZSBub3cgc3RvcmVkIGFzIG9iamVjdHMgaW4gdGhlIFBSSVZBVEUgYHRoaXMuX3RpY2tzYCBtZW1iZXJcblx0XHRcdC8vIGFuZCBtdXN0IG5vdCBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIG91dHNpZGUgdGhpcyBjbGFzcy4gYHRoaXMudGlja3NgIGJlaW5nXG5cdFx0XHQvLyBhcm91bmQgZm9yIGxvbmcgdGltZSBhbmQgbm90IG1hcmtlZCBhcyBwcml2YXRlLCB3ZSBjYW4ndCBjaGFuZ2UgaXRzIHN0cnVjdHVyZVxuXHRcdFx0Ly8gd2l0aG91dCB1bmV4cGVjdGVkIGJyZWFraW5nIGNoYW5nZXMuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2NhbGUgdGlja3MsXG5cdFx0XHQvLyB1c2Ugc2NhbGUuZ2V0VGlja3MoKSBpbnN0ZWFkLlxuXG5cdFx0XHRtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cblx0XHRcdC8vIE5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIGJ1dCBmb3IgQkFDS1dBUkQgQ09NUEFULFxuXHRcdFx0Ly8gd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IHNldCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kKS5cblx0XHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG5cdFx0XHRtZS5hZnRlckJ1aWxkVGlja3MoKTtcblxuXHRcdFx0bWUuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cblx0XHRcdC8vIE5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHJldHVybiB0aGUgZm9ybWF0dGVkIHRpY2sgbGFiZWxzIGJ1dCBmb3IgQkFDS1dBUkRcblx0XHRcdC8vIENPTVBBVCwgd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IGNoYW5nZWQgYnkgY2FsbGluZ1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QgYW5kIHN1cHBvc2VkIHRvIGNvbnRhaW4gb25seSBzdHJpbmcgdmFsdWVzKS5cblx0XHRcdGxhYmVscyA9IG1lLmNvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB8fCBtZS50aWNrcztcblxuXHRcdFx0bWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuXHRcdFx0bWUudGlja3MgPSBsYWJlbHM7ICAgLy8gQkFDS1dBUkQgQ09NUEFUSUJJTElUWVxuXG5cdFx0XHQvLyBJTVBPUlRBTlQ6IGZyb20gdGhpcyBwb2ludCwgd2UgY29uc2lkZXIgdGhhdCBgdGhpcy50aWNrc2Agd2lsbCBORVZFUiBjaGFuZ2UhXG5cblx0XHRcdC8vIEJBQ0tXQVJEIENPTVBBVDogc3luY2hyb25pemUgYF90aWNrc2Agd2l0aCBsYWJlbHMgKHNvIHBvdGVudGlhbGx5IGB0aGlzLnRpY2tzYClcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGxhYmVsID0gbGFiZWxzW2ldO1xuXHRcdFx0XHR0aWNrID0gdGlja3NbaV07XG5cdFx0XHRcdGlmICghdGljaykge1xuXHRcdFx0XHRcdHRpY2tzLnB1c2godGljayA9IHtcblx0XHRcdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0XHRcdG1ham9yOiBmYWxzZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpY2subGFiZWwgPSBsYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRtZS5fdGlja3MgPSB0aWNrcztcblxuXHRcdFx0Ly8gVGljayBSb3RhdGlvblxuXHRcdFx0bWUuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0XHRtZS5jYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHRcdG1lLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0XHQvLyBGaXRcblx0XHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdFx0bWUuZml0KCk7XG5cdFx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdFx0Ly9cblx0XHRcdG1lLmFmdGVyVXBkYXRlKCk7XG5cblx0XHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdFx0fSxcblx0XHRhZnRlclVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcblx0XHR9LFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZVNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0XHR9LFxuXHRcdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXHRcdH0sXG5cdFx0YWZ0ZXJTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBsaW1pdHNcblx0XHRiZWZvcmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZURhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdFx0fSxcblx0XHRkZXRlcm1pbmVEYXRhTGltaXRzOiBoZWxwZXJzLm5vb3AsXG5cdFx0YWZ0ZXJEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRGF0YUxpbWl0cywgW3RoaXNdKTtcblx0XHR9LFxuXG5cdFx0Ly9cblx0XHRiZWZvcmVCdWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUJ1aWxkVGlja3MsIFt0aGlzXSk7XG5cdFx0fSxcblx0XHRidWlsZFRpY2tzOiBoZWxwZXJzLm5vb3AsXG5cdFx0YWZ0ZXJCdWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW3RoaXNdKTtcblx0XHR9LFxuXG5cdFx0YmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcblx0XHR9LFxuXHRcdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHQvLyBDb252ZXJ0IHRpY2tzIHRvIHN0cmluZ3Ncblx0XHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0XHRtZS50aWNrcyA9IG1lLnRpY2tzLm1hcCh0aWNrT3B0cy51c2VyQ2FsbGJhY2sgfHwgdGlja09wdHMuY2FsbGJhY2ssIHRoaXMpO1xuXHRcdH0sXG5cdFx0YWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xuXHRcdH0sXG5cdFx0Y2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY29udGV4dCA9IG1lLmN0eDtcblx0XHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0XHR2YXIgbGFiZWxzID0gbGFiZWxzRnJvbVRpY2tzKG1lLl90aWNrcyk7XG5cblx0XHRcdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJ5IGNhbGN1bGF0aW5nIHRoZSBkaWZmZXJlbmNlXG5cdFx0XHQvLyBiZXR3ZWVuIHggb2Zmc2V0cyBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnRPcHRpb25zKHRpY2tPcHRzKTtcblx0XHRcdGNvbnRleHQuZm9udCA9IHRpY2tGb250LmZvbnQ7XG5cblx0XHRcdHZhciBsYWJlbFJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcblxuXHRcdFx0aWYgKGxhYmVscy5sZW5ndGggJiYgbWUub3B0aW9ucy5kaXNwbGF5ICYmIG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHZhciBvcmlnaW5hbExhYmVsV2lkdGggPSBoZWxwZXJzLmxvbmdlc3RUZXh0KGNvbnRleHQsIHRpY2tGb250LmZvbnQsIGxhYmVscywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHRcdHZhciBsYWJlbFdpZHRoID0gb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0XHR2YXIgY29zUm90YXRpb24sIHNpblJvdGF0aW9uO1xuXG5cdFx0XHRcdC8vIEFsbG93IDMgcGl4ZWxzIHgyIHBhZGRpbmcgZWl0aGVyIHNpZGUgZm9yIGxhYmVsIHJlYWRhYmlsaXR5XG5cdFx0XHRcdHZhciB0aWNrV2lkdGggPSBtZS5nZXRQaXhlbEZvclRpY2soMSkgLSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSA2O1xuXG5cdFx0XHRcdC8vIE1heCBsYWJlbCByb3RhdGlvbiBjYW4gYmUgc2V0IG9yIGRlZmF1bHQgdG8gOTAgLSBhbHNvIGFjdCBhcyBhIGxvb3AgY291bnRlclxuXHRcdFx0XHR3aGlsZSAobGFiZWxXaWR0aCA+IHRpY2tXaWR0aCAmJiBsYWJlbFJvdGF0aW9uIDwgdGlja09wdHMubWF4Um90YXRpb24pIHtcblx0XHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycy50b1JhZGlhbnMobGFiZWxSb3RhdGlvbik7XG5cdFx0XHRcdFx0Y29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHRcdHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuXHRcdFx0XHRcdGlmIChzaW5Sb3RhdGlvbiAqIG9yaWdpbmFsTGFiZWxXaWR0aCA+IG1lLm1heEhlaWdodCkge1xuXHRcdFx0XHRcdFx0Ly8gZ28gYmFjayBvbmUgc3RlcFxuXHRcdFx0XHRcdFx0bGFiZWxSb3RhdGlvbi0tO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGFiZWxSb3RhdGlvbisrO1xuXHRcdFx0XHRcdGxhYmVsV2lkdGggPSBjb3NSb3RhdGlvbiAqIG9yaWdpbmFsTGFiZWxXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRtZS5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcblx0XHR9LFxuXHRcdGFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xuXHRcdH0sXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlRml0OiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcblx0XHR9LFxuXHRcdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0Ly8gUmVzZXRcblx0XHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHtcblx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRcdGhlaWdodDogMFxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxPcHRzID0gb3B0cy5zY2FsZUxhYmVsO1xuXHRcdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udE9wdGlvbnModGlja09wdHMpO1xuXHRcdFx0dmFyIHRpY2tNYXJrTGVuZ3RoID0gb3B0cy5ncmlkTGluZXMudGlja01hcmtMZW5ndGg7XG5cblx0XHRcdC8vIFdpZHRoXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdC8vIHN1YnRyYWN0IHRoZSBtYXJnaW5zIHRvIGxpbmUgdXAgd2l0aCB0aGUgY2hhcnRBcmVhIGlmIHdlIGFyZSBhIGZ1bGwgd2lkdGggc2NhbGVcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXhXaWR0aCAtIG1lLm1hcmdpbnMubGVmdCAtIG1lLm1hcmdpbnMucmlnaHQgOiBtZS5tYXhXaWR0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBkaXNwbGF5ICYmIGdyaWRMaW5lT3B0cy5kcmF3VGlja3MgPyB0aWNrTWFya0xlbmd0aCA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhlaWdodFxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IGRpc3BsYXkgJiYgZ3JpZExpbmVPcHRzLmRyYXdUaWNrcyA/IHRpY2tNYXJrTGVuZ3RoIDogMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFyZSB3ZSBzaG93aW5nIGEgdGl0bGUgZm9yIHRoZSBzY2FsZT9cblx0XHRcdGlmIChzY2FsZUxhYmVsT3B0cy5kaXNwbGF5ICYmIGRpc3BsYXkpIHtcblx0XHRcdFx0dmFyIHNjYWxlTGFiZWxMaW5lSGVpZ2h0ID0gcGFyc2VMaW5lSGVpZ2h0KHNjYWxlTGFiZWxPcHRzKTtcblx0XHRcdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycy5vcHRpb25zLnRvUGFkZGluZyhzY2FsZUxhYmVsT3B0cy5wYWRkaW5nKTtcblx0XHRcdFx0dmFyIGRlbHRhSGVpZ2h0ID0gc2NhbGVMYWJlbExpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy5oZWlnaHQ7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdG1pblNpemUuaGVpZ2h0ICs9IGRlbHRhSGVpZ2h0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1pblNpemUud2lkdGggKz0gZGVsdGFIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGVtXG5cdFx0XHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBsYXJnZXN0VGV4dFdpZHRoID0gaGVscGVycy5sb25nZXN0VGV4dChtZS5jdHgsIHRpY2tGb250LmZvbnQsIGxhYmVscywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHRcdHZhciB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzID0gaGVscGVycy5udW1iZXJPZkxhYmVsTGluZXMobGFiZWxzKTtcblx0XHRcdFx0dmFyIGxpbmVTcGFjZSA9IHRpY2tGb250LnNpemUgKiAwLjU7XG5cdFx0XHRcdHZhciB0aWNrUGFkZGluZyA9IG1lLm9wdGlvbnMudGlja3MucGFkZGluZztcblxuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0Ly8gQSBob3Jpem9udGFsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgaGVpZ2h0LlxuXHRcdFx0XHRcdG1lLmxvbmdlc3RMYWJlbFdpZHRoID0gbGFyZ2VzdFRleHRXaWR0aDtcblxuXHRcdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0XHQvLyBUT0RPIC0gaW1wcm92ZSB0aGlzIGNhbGN1bGF0aW9uXG5cdFx0XHRcdFx0dmFyIGxhYmVsSGVpZ2h0ID0gKHNpblJvdGF0aW9uICogbGFyZ2VzdFRleHRXaWR0aClcblx0XHRcdFx0XHRcdCsgKHRpY2tGb250LnNpemUgKiB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzKVxuXHRcdFx0XHRcdFx0KyAobGluZVNwYWNlICogKHRhbGxlc3RMYWJlbEhlaWdodEluTGluZXMgLSAxKSlcblx0XHRcdFx0XHRcdCsgbGluZVNwYWNlOyAvLyBwYWRkaW5nXG5cblx0XHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKG1lLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcblxuXHRcdFx0XHRcdG1lLmN0eC5mb250ID0gdGlja0ZvbnQuZm9udDtcblx0XHRcdFx0XHR2YXIgZmlyc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFiZWxzWzBdLCB0aWNrRm9udC5mb250KTtcblx0XHRcdFx0XHR2YXIgbGFzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdLCB0aWNrRm9udC5mb250KTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSB0aGF0IG91ciB0aWNrcyBhcmUgYWx3YXlzIGluc2lkZSB0aGUgY2FudmFzLiBXaGVuIHJvdGF0ZWQsIHRpY2tzIGFyZSByaWdodCBhbGlnbmVkXG5cdFx0XHRcdFx0Ly8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG5cdFx0XHRcdFx0aWYgKG1lLmxhYmVsUm90YXRpb24gIT09IDApIHtcblx0XHRcdFx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gb3B0cy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBmaXJzdExhYmVsV2lkdGgpICsgMyA6IChjb3NSb3RhdGlvbiAqIGxpbmVTcGFjZSkgKyAzOyAvLyBhZGQgMyBweCB0byBtb3ZlIGF3YXkgZnJvbSBjYW52YXMgZWRnZXNcblx0XHRcdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IG9wdHMucG9zaXRpb24gPT09ICdib3R0b20nID8gKGNvc1JvdGF0aW9uICogbGluZVNwYWNlKSArIDMgOiAoY29zUm90YXRpb24gKiBsYXN0TGFiZWxXaWR0aCkgKyAzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtZS5wYWRkaW5nTGVmdCA9IGZpcnN0TGFiZWxXaWR0aCAvIDIgKyAzOyAvLyBhZGQgMyBweCB0byBtb3ZlIGF3YXkgZnJvbSBjYW52YXMgZWRnZXNcblx0XHRcdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IGxhc3RMYWJlbFdpZHRoIC8gMiArIDM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEEgdmVydGljYWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSB3aWR0aC4gTGFiZWxzIGFyZSB0aGVcblx0XHRcdFx0XHQvLyBkb21pbmFudCBmYWN0b3IgaGVyZSwgc28gZ2V0IHRoYXQgbGVuZ3RoIGZpcnN0IGFuZCBhY2NvdW50IGZvciBwYWRkaW5nXG5cdFx0XHRcdFx0aWYgKHRpY2tPcHRzLm1pcnJvcikge1xuXHRcdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHVzZSBsaW5lU3BhY2UgZm9yIGNvbnNpc3RlbmN5IHdpdGggaG9yaXpvbnRhbCBheGlzXG5cdFx0XHRcdFx0XHQvLyB0aWNrUGFkZGluZyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGhvcml6b250YWxcblx0XHRcdFx0XHRcdGxhcmdlc3RUZXh0V2lkdGggKz0gdGlja1BhZGRpbmcgKyBsaW5lU3BhY2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IE1hdGgubWluKG1lLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFyZ2VzdFRleHRXaWR0aCk7XG5cblx0XHRcdFx0XHRtZS5wYWRkaW5nVG9wID0gdGlja0ZvbnQuc2l6ZSAvIDI7XG5cdFx0XHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG1lLmhhbmRsZU1hcmdpbnMoKTtcblxuXHRcdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSBtYXJnaW5zIGFuZCBwYWRkaW5nIGludGVyYWN0aW9uc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0aGFuZGxlTWFyZ2luczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0aWYgKG1lLm1hcmdpbnMpIHtcblx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heChtZS5wYWRkaW5nTGVmdCAtIG1lLm1hcmdpbnMubGVmdCwgMCk7XG5cdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSBNYXRoLm1heChtZS5wYWRkaW5nVG9wIC0gbWUubWFyZ2lucy50b3AsIDApO1xuXHRcdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heChtZS5wYWRkaW5nUmlnaHQgLSBtZS5tYXJnaW5zLnJpZ2h0LCAwKTtcblx0XHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IE1hdGgubWF4KG1lLnBhZGRpbmdCb3R0b20gLSBtZS5tYXJnaW5zLmJvdHRvbSwgMCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFmdGVyRml0OiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuXHRcdH0sXG5cblx0XHQvLyBTaGFyZWQgTWV0aG9kc1xuXHRcdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuXHRcdH0sXG5cdFx0aXNGdWxsV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuZnVsbFdpZHRoKTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRoZSBjb3JyZWN0IHZhbHVlLiBOYU4gYmFkIGlucHV0cywgSWYgdGhlIHZhbHVlIHR5cGUgaXMgb2JqZWN0IGdldCB0aGUgeCBvciB5IGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlIGhvcml6b250YWwgb3Igbm90XG5cdFx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcblx0XHRcdC8vIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZmlyc3Rcblx0XHRcdGlmIChoZWxwZXJzLmlzTnVsbE9yVW5kZWYocmF3VmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9XG5cdFx0XHQvLyBpc05hTihvYmplY3QpIHJldHVybnMgdHJ1ZSwgc28gbWFrZSBzdXJlIE5hTiBpcyBjaGVja2luZyBmb3IgYSBudW1iZXI7IERpc2NhcmQgSW5maW5pdGUgdmFsdWVzXG5cdFx0XHRpZiAodHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocmF3VmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBpdCBpcyBpbiBmYWN0IGFuIG9iamVjdCwgZGl2ZSBpbiBvbmUgbW9yZSBsZXZlbFxuXHRcdFx0aWYgKHJhd1ZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdFx0aWYgKHJhd1ZhbHVlLnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZS54KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAocmF3VmFsdWUueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZS55KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBWYWx1ZSBpcyBnb29kLCByZXR1cm4gaXRcblx0XHRcdHJldHVybiByYXdWYWx1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gVXNlZCB0byBnZXQgdGhlIHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBpbmRleFxuXHRcdC8vIGZ1bmN0aW9uIGdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleClcblx0XHRnZXRMYWJlbEZvckluZGV4OiBoZWxwZXJzLm5vb3AsXG5cblx0XHQvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0XHRnZXRQaXhlbEZvclZhbHVlOiBoZWxwZXJzLm5vb3AsXG5cblx0XHQvLyBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHRcdGdldFZhbHVlRm9yUGl4ZWw6IGhlbHBlcnMubm9vcCxcblxuXHRcdC8vIFVzZWQgZm9yIHRpY2sgbG9jYXRpb24sIHNob3VsZFxuXHRcdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCk7XG5cdFx0XHRcdHZhciB0aWNrV2lkdGggPSBpbm5lcldpZHRoIC8gTWF0aC5tYXgoKG1lLl90aWNrcy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpKSwgMSk7XG5cdFx0XHRcdHZhciBwaXhlbCA9ICh0aWNrV2lkdGggKiBpbmRleCkgKyBtZS5wYWRkaW5nTGVmdDtcblxuXHRcdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdFx0cGl4ZWwgKz0gdGlja1dpZHRoIC8gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyBNYXRoLnJvdW5kKHBpeGVsKTtcblx0XHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRcdHJldHVybiBmaW5hbFZhbDtcblx0XHRcdH1cblx0XHRcdHZhciBpbm5lckhlaWdodCA9IG1lLmhlaWdodCAtIChtZS5wYWRkaW5nVG9wICsgbWUucGFkZGluZ0JvdHRvbSk7XG5cdFx0XHRyZXR1cm4gbWUudG9wICsgKGluZGV4ICogKGlubmVySGVpZ2h0IC8gKG1lLl90aWNrcy5sZW5ndGggLSAxKSkpO1xuXHRcdH0sXG5cblx0XHQvLyBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0XHRnZXRQaXhlbEZvckRlY2ltYWw6IGZ1bmN0aW9uKGRlY2ltYWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCk7XG5cdFx0XHRcdHZhciB2YWx1ZU9mZnNldCA9IChpbm5lcldpZHRoICogZGVjaW1hbCkgKyBtZS5wYWRkaW5nTGVmdDtcblxuXHRcdFx0XHR2YXIgZmluYWxWYWwgPSBtZS5sZWZ0ICsgTWF0aC5yb3VuZCh2YWx1ZU9mZnNldCk7XG5cdFx0XHRcdGZpbmFsVmFsICs9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXJnaW5zLmxlZnQgOiAwO1xuXHRcdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWUudG9wICsgKGRlY2ltYWwgKiBtZS5oZWlnaHQpO1xuXHRcdH0sXG5cblx0XHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcblx0XHR9LFxuXG5cdFx0Z2V0QmFzZVZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdFx0dmFyIG1heCA9IG1lLm1heDtcblxuXHRcdFx0cmV0dXJuIG1lLmJlZ2luQXRaZXJvID8gMCA6XG5cdFx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG5cdFx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG5cdFx0XHRcdDA7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfYXV0b1NraXA6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0XHR2YXIgc2tpcFJhdGlvO1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3MubWlub3I7XG5cdFx0XHR2YXIgdGlja0NvdW50ID0gdGlja3MubGVuZ3RoO1xuXHRcdFx0dmFyIGxhYmVsUm90YXRpb25SYWRpYW5zID0gaGVscGVycy50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhsYWJlbFJvdGF0aW9uUmFkaWFucyk7XG5cdFx0XHR2YXIgbG9uZ2VzdFJvdGF0ZWRMYWJlbCA9IG1lLmxvbmdlc3RMYWJlbFdpZHRoICogY29zUm90YXRpb247XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHR2YXIgaSwgdGljaywgc2hvdWxkU2tpcDtcblxuXHRcdFx0Ly8gZmlndXJlIG91dCB0aGUgbWF4aW11bSBudW1iZXIgb2YgZ3JpZGxpbmVzIHRvIHNob3dcblx0XHRcdHZhciBtYXhUaWNrcztcblx0XHRcdGlmIChvcHRpb25UaWNrcy5tYXhUaWNrc0xpbWl0KSB7XG5cdFx0XHRcdG1heFRpY2tzID0gb3B0aW9uVGlja3MubWF4VGlja3NMaW1pdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRza2lwUmF0aW8gPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoKGxvbmdlc3RSb3RhdGVkTGFiZWwgKyBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcpICogdGlja0NvdW50ID4gKG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KSkpIHtcblx0XHRcdFx0XHRza2lwUmF0aW8gPSAxICsgTWF0aC5mbG9vcigoKGxvbmdlc3RSb3RhdGVkTGFiZWwgKyBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcpICogdGlja0NvdW50KSAvIChtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCkpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIHRoZXkgZGVmaW5lZCBhIG1heCBudW1iZXIgb2Ygb3B0aW9uVGlja3MsXG5cdFx0XHRcdC8vIGluY3JlYXNlIHNraXBSYXRpbyB1bnRpbCB0aGF0IG51bWJlciBpcyBtZXRcblx0XHRcdFx0aWYgKG1heFRpY2tzICYmIHRpY2tDb3VudCA+IG1heFRpY2tzKSB7XG5cdFx0XHRcdFx0c2tpcFJhdGlvID0gTWF0aC5tYXgoc2tpcFJhdGlvLCBNYXRoLmZsb29yKHRpY2tDb3VudCAvIG1heFRpY2tzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRpY2tDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHRpY2sgPSB0aWNrc1tpXTtcblxuXHRcdFx0XHQvLyBTaW5jZSB3ZSBhbHdheXMgc2hvdyB0aGUgbGFzdCB0aWNrLHdlIG5lZWQgbWF5IG5lZWQgdG8gaGlkZSB0aGUgbGFzdCBzaG93biBvbmUgYmVmb3JlXG5cdFx0XHRcdHNob3VsZFNraXAgPSAoc2tpcFJhdGlvID4gMSAmJiBpICUgc2tpcFJhdGlvID4gMCkgfHwgKGkgJSBza2lwUmF0aW8gPT09IDAgJiYgaSArIHNraXBSYXRpbyA+PSB0aWNrQ291bnQpO1xuXHRcdFx0XHRpZiAoc2hvdWxkU2tpcCAmJiBpICE9PSB0aWNrQ291bnQgLSAxIHx8IGhlbHBlcnMuaXNOdWxsT3JVbmRlZih0aWNrLmxhYmVsKSkge1xuXHRcdFx0XHRcdC8vIGxlYXZlIHRpY2sgaW4gcGxhY2UgYnV0IG1ha2Ugc3VyZSBpdCdzIG5vdCBkaXNwbGF5ZWQgKCM0NjM1KVxuXHRcdFx0XHRcdGRlbGV0ZSB0aWNrLmxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHRpY2spO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgc2NhbGUgb24gdGhlIGNhbnZhc1xuXHRcdC8vIEBwYXJhbSB7cmVjdGFuZ2xlfSBjaGFydEFyZWEgOiB0aGUgYXJlYSBvZiB0aGUgY2hhcnQgdG8gZHJhdyBmdWxsIGdyaWQgbGluZXMgb25cblx0XHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0XHRpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdFx0dmFyIG9wdGlvblRpY2tzID0gb3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHRcdHZhciBvcHRpb25NYWpvclRpY2tzID0gb3B0aW9ucy50aWNrcy5tYWpvciB8fCBvcHRpb25UaWNrcztcblx0XHRcdHZhciBncmlkTGluZXMgPSBvcHRpb25zLmdyaWRMaW5lcztcblx0XHRcdHZhciBzY2FsZUxhYmVsID0gb3B0aW9ucy5zY2FsZUxhYmVsO1xuXG5cdFx0XHR2YXIgaXNSb3RhdGVkID0gbWUubGFiZWxSb3RhdGlvbiAhPT0gMDtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0dmFyIHRpY2tzID0gb3B0aW9uVGlja3MuYXV0b1NraXAgPyBtZS5fYXV0b1NraXAobWUuZ2V0VGlja3MoKSkgOiBtZS5nZXRUaWNrcygpO1xuXHRcdFx0dmFyIHRpY2tGb250Q29sb3IgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KG9wdGlvblRpY2tzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnRPcHRpb25zKG9wdGlvblRpY2tzKTtcblx0XHRcdHZhciBtYWpvclRpY2tGb250Q29sb3IgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KG9wdGlvbk1ham9yVGlja3MuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdHZhciBtYWpvclRpY2tGb250ID0gcGFyc2VGb250T3B0aW9ucyhvcHRpb25NYWpvclRpY2tzKTtcblxuXHRcdFx0dmFyIHRsID0gZ3JpZExpbmVzLmRyYXdUaWNrcyA/IGdyaWRMaW5lcy50aWNrTWFya0xlbmd0aCA6IDA7XG5cblx0XHRcdHZhciBzY2FsZUxhYmVsRm9udENvbG9yID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChzY2FsZUxhYmVsLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBwYXJzZUZvbnRPcHRpb25zKHNjYWxlTGFiZWwpO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycy5vcHRpb25zLnRvUGFkZGluZyhzY2FsZUxhYmVsLnBhZGRpbmcpO1xuXHRcdFx0dmFyIGxhYmVsUm90YXRpb25SYWRpYW5zID0gaGVscGVycy50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cblx0XHRcdHZhciBpdGVtc1RvRHJhdyA9IFtdO1xuXG5cdFx0XHR2YXIgeFRpY2tTdGFydCA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdyaWdodCcgPyBtZS5sZWZ0IDogbWUucmlnaHQgLSB0bDtcblx0XHRcdHZhciB4VGlja0VuZCA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdyaWdodCcgPyBtZS5sZWZ0ICsgdGwgOiBtZS5yaWdodDtcblx0XHRcdHZhciB5VGlja1N0YXJ0ID0gb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyBtZS50b3AgOiBtZS5ib3R0b20gLSB0bDtcblx0XHRcdHZhciB5VGlja0VuZCA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nID8gbWUudG9wICsgdGwgOiBtZS5ib3R0b207XG5cblx0XHRcdGhlbHBlcnMuZWFjaCh0aWNrcywgZnVuY3Rpb24odGljaywgaW5kZXgpIHtcblx0XHRcdFx0Ly8gYXV0b3NraXBwZXIgc2tpcHBlZCB0aGlzIHRpY2sgKCM0NjM1KVxuXHRcdFx0XHRpZiAodGljay5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGxhYmVsID0gdGljay5sYWJlbDtcblx0XHRcdFx0dmFyIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBib3JkZXJEYXNoLCBib3JkZXJEYXNoT2Zmc2V0O1xuXHRcdFx0XHRpZiAoaW5kZXggPT09IG1lLnplcm9MaW5lSW5kZXggJiYgb3B0aW9ucy5vZmZzZXQgPT09IGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpIHtcblx0XHRcdFx0XHQvLyBEcmF3IHRoZSBmaXJzdCBpbmRleCBzcGVjaWFsbHlcblx0XHRcdFx0XHRsaW5lV2lkdGggPSBncmlkTGluZXMuemVyb0xpbmVXaWR0aDtcblx0XHRcdFx0XHRsaW5lQ29sb3IgPSBncmlkTGluZXMuemVyb0xpbmVDb2xvcjtcblx0XHRcdFx0XHRib3JkZXJEYXNoID0gZ3JpZExpbmVzLnplcm9MaW5lQm9yZGVyRGFzaDtcblx0XHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLnplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaW5lV2lkdGggPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpbmRleCk7XG5cdFx0XHRcdFx0bGluZUNvbG9yID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCBpbmRleCk7XG5cdFx0XHRcdFx0Ym9yZGVyRGFzaCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoZ3JpZExpbmVzLmJvcmRlckRhc2gsIGdsb2JhbERlZmF1bHRzLmJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGdyaWRMaW5lcy5ib3JkZXJEYXNoT2Zmc2V0LCBnbG9iYWxEZWZhdWx0cy5ib3JkZXJEYXNoT2Zmc2V0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbW1vbiBwcm9wZXJ0aWVzXG5cdFx0XHRcdHZhciB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyLCBsYWJlbFgsIGxhYmVsWTtcblx0XHRcdFx0dmFyIHRleHRBbGlnbiA9ICdtaWRkbGUnO1xuXHRcdFx0XHR2YXIgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdHZhciB0aWNrUGFkZGluZyA9IG9wdGlvblRpY2tzLnBhZGRpbmc7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdHZhciBsYWJlbFlPZmZzZXQgPSB0bCArIHRpY2tQYWRkaW5nO1xuXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRcdFx0XHQvLyBib3R0b21cblx0XHRcdFx0XHRcdHRleHRCYXNlbGluZSA9ICFpc1JvdGF0ZWQgPyAndG9wJyA6ICdtaWRkbGUnO1xuXHRcdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRcdGxhYmVsWSA9IG1lLnRvcCArIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdG9wXG5cdFx0XHRcdFx0XHR0ZXh0QmFzZWxpbmUgPSAhaXNSb3RhdGVkID8gJ2JvdHRvbScgOiAnbWlkZGxlJztcblx0XHRcdFx0XHRcdHRleHRBbGlnbiA9ICFpc1JvdGF0ZWQgPyAnY2VudGVyJyA6ICdsZWZ0Jztcblx0XHRcdFx0XHRcdGxhYmVsWSA9IG1lLmJvdHRvbSAtIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgeExpbmVWYWx1ZSA9IGdldExpbmVWYWx1ZShtZSwgaW5kZXgsIGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMgJiYgdGlja3MubGVuZ3RoID4gMSk7XG5cdFx0XHRcdFx0aWYgKHhMaW5lVmFsdWUgPCBtZS5sZWZ0KSB7XG5cdFx0XHRcdFx0XHRsaW5lQ29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHhMaW5lVmFsdWUgKz0gaGVscGVycy5hbGlhc1BpeGVsKGxpbmVXaWR0aCk7XG5cblx0XHRcdFx0XHRsYWJlbFggPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7IC8vIHggdmFsdWVzIGZvciBvcHRpb25UaWNrcyAobmVlZCB0byBjb25zaWRlciBvZmZzZXRMYWJlbCBvcHRpb24pXG5cblx0XHRcdFx0XHR0eDEgPSB0eDIgPSB4MSA9IHgyID0geExpbmVWYWx1ZTtcblx0XHRcdFx0XHR0eTEgPSB5VGlja1N0YXJ0O1xuXHRcdFx0XHRcdHR5MiA9IHlUaWNrRW5kO1xuXHRcdFx0XHRcdHkxID0gY2hhcnRBcmVhLnRvcDtcblx0XHRcdFx0XHR5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGlzTGVmdCA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jztcblx0XHRcdFx0XHR2YXIgbGFiZWxYT2Zmc2V0O1xuXG5cdFx0XHRcdFx0aWYgKG9wdGlvblRpY2tzLm1pcnJvcikge1xuXHRcdFx0XHRcdFx0dGV4dEFsaWduID0gaXNMZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRcdGxhYmVsWE9mZnNldCA9IHRpY2tQYWRkaW5nO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0ZXh0QWxpZ24gPSBpc0xlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuXHRcdFx0XHRcdFx0bGFiZWxYT2Zmc2V0ID0gdGwgKyB0aWNrUGFkZGluZztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsYWJlbFggPSBpc0xlZnQgPyBtZS5yaWdodCAtIGxhYmVsWE9mZnNldCA6IG1lLmxlZnQgKyBsYWJlbFhPZmZzZXQ7XG5cblx0XHRcdFx0XHR2YXIgeUxpbmVWYWx1ZSA9IGdldExpbmVWYWx1ZShtZSwgaW5kZXgsIGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMgJiYgdGlja3MubGVuZ3RoID4gMSk7XG5cdFx0XHRcdFx0aWYgKHlMaW5lVmFsdWUgPCBtZS50b3ApIHtcblx0XHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eUxpbmVWYWx1ZSArPSBoZWxwZXJzLmFsaWFzUGl4ZWwobGluZVdpZHRoKTtcblxuXHRcdFx0XHRcdGxhYmVsWSA9IG1lLmdldFBpeGVsRm9yVGljayhpbmRleCkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcblxuXHRcdFx0XHRcdHR4MSA9IHhUaWNrU3RhcnQ7XG5cdFx0XHRcdFx0dHgyID0geFRpY2tFbmQ7XG5cdFx0XHRcdFx0eDEgPSBjaGFydEFyZWEubGVmdDtcblx0XHRcdFx0XHR4MiA9IGNoYXJ0QXJlYS5yaWdodDtcblx0XHRcdFx0XHR0eTEgPSB0eTIgPSB5MSA9IHkyID0geUxpbmVWYWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGl0ZW1zVG9EcmF3LnB1c2goe1xuXHRcdFx0XHRcdHR4MTogdHgxLFxuXHRcdFx0XHRcdHR5MTogdHkxLFxuXHRcdFx0XHRcdHR4MjogdHgyLFxuXHRcdFx0XHRcdHR5MjogdHkyLFxuXHRcdFx0XHRcdHgxOiB4MSxcblx0XHRcdFx0XHR5MTogeTEsXG5cdFx0XHRcdFx0eDI6IHgyLFxuXHRcdFx0XHRcdHkyOiB5Mixcblx0XHRcdFx0XHRsYWJlbFg6IGxhYmVsWCxcblx0XHRcdFx0XHRsYWJlbFk6IGxhYmVsWSxcblx0XHRcdFx0XHRnbFdpZHRoOiBsaW5lV2lkdGgsXG5cdFx0XHRcdFx0Z2xDb2xvcjogbGluZUNvbG9yLFxuXHRcdFx0XHRcdGdsQm9yZGVyRGFzaDogYm9yZGVyRGFzaCxcblx0XHRcdFx0XHRnbEJvcmRlckRhc2hPZmZzZXQ6IGJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdFx0cm90YXRpb246IC0xICogbGFiZWxSb3RhdGlvblJhZGlhbnMsXG5cdFx0XHRcdFx0bGFiZWw6IGxhYmVsLFxuXHRcdFx0XHRcdG1ham9yOiB0aWNrLm1ham9yLFxuXHRcdFx0XHRcdHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuXHRcdFx0XHRcdHRleHRBbGlnbjogdGV4dEFsaWduXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIERyYXcgYWxsIG9mIHRoZSB0aWNrIGxhYmVscywgdGljayBtYXJrcywgYW5kIGdyaWQgbGluZXMgYXQgdGhlIGNvcnJlY3QgcGxhY2VzXG5cdFx0XHRoZWxwZXJzLmVhY2goaXRlbXNUb0RyYXcsIGZ1bmN0aW9uKGl0ZW1Ub0RyYXcpIHtcblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kaXNwbGF5KSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdFx0Y29udGV4dC5saW5lV2lkdGggPSBpdGVtVG9EcmF3LmdsV2lkdGg7XG5cdFx0XHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IGl0ZW1Ub0RyYXcuZ2xDb2xvcjtcblx0XHRcdFx0XHRpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRMaW5lRGFzaChpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaCk7XG5cdFx0XHRcdFx0XHRjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gaXRlbVRvRHJhdy5nbEJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRcdGlmIChncmlkTGluZXMuZHJhd1RpY2tzKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhpdGVtVG9EcmF3LnR4MSwgaXRlbVRvRHJhdy50eTEpO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5saW5lVG8oaXRlbVRvRHJhdy50eDIsIGl0ZW1Ub0RyYXcudHkyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdPbkNoYXJ0QXJlYSkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5tb3ZlVG8oaXRlbVRvRHJhdy54MSwgaXRlbVRvRHJhdy55MSk7XG5cdFx0XHRcdFx0XHRjb250ZXh0LmxpbmVUbyhpdGVtVG9EcmF3LngyLCBpdGVtVG9EcmF3LnkyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0XHRcdGNvbnRleHQucmVzdG9yZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdGlvblRpY2tzLmRpc3BsYXkpIHtcblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgZHJhdyB0ZXh0IGluIHRoZSBjb3JyZWN0IGNvbG9yIGFuZCBmb250XG5cdFx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdFx0Y29udGV4dC50cmFuc2xhdGUoaXRlbVRvRHJhdy5sYWJlbFgsIGl0ZW1Ub0RyYXcubGFiZWxZKTtcblx0XHRcdFx0XHRjb250ZXh0LnJvdGF0ZShpdGVtVG9EcmF3LnJvdGF0aW9uKTtcblx0XHRcdFx0XHRjb250ZXh0LmZvbnQgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udC5mb250IDogdGlja0ZvbnQuZm9udDtcblx0XHRcdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IGl0ZW1Ub0RyYXcubWFqb3IgPyBtYWpvclRpY2tGb250Q29sb3IgOiB0aWNrRm9udENvbG9yO1xuXHRcdFx0XHRcdGNvbnRleHQudGV4dEJhc2VsaW5lID0gaXRlbVRvRHJhdy50ZXh0QmFzZWxpbmU7XG5cdFx0XHRcdFx0Y29udGV4dC50ZXh0QWxpZ24gPSBpdGVtVG9EcmF3LnRleHRBbGlnbjtcblxuXHRcdFx0XHRcdHZhciBsYWJlbCA9IGl0ZW1Ub0RyYXcubGFiZWw7XG5cdFx0XHRcdFx0aWYgKGhlbHBlcnMuaXNBcnJheShsYWJlbCkpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCB5ID0gMDsgaSA8IGxhYmVsLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdlIGp1c3QgbWFrZSBzdXJlIHRoZSBtdWx0aWxpbmUgZWxlbWVudCBpcyBhIHN0cmluZyBoZXJlLi5cblx0XHRcdFx0XHRcdFx0Y29udGV4dC5maWxsVGV4dCgnJyArIGxhYmVsW2ldLCAwLCB5KTtcblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgc2FtZSBsaW5lU3BhY2luZyBhcyBjYWxjdWxhdGVkIEAgTCMzMjBcblx0XHRcdFx0XHRcdFx0eSArPSAodGlja0ZvbnQuc2l6ZSAqIDEuNSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuZmlsbFRleHQobGFiZWwsIDAsIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChzY2FsZUxhYmVsLmRpc3BsYXkpIHtcblx0XHRcdFx0Ly8gRHJhdyB0aGUgc2NhbGUgbGFiZWxcblx0XHRcdFx0dmFyIHNjYWxlTGFiZWxYO1xuXHRcdFx0XHR2YXIgc2NhbGVMYWJlbFk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0XHRcdHZhciBoYWxmTGluZUhlaWdodCA9IHBhcnNlTGluZUhlaWdodChzY2FsZUxhYmVsKSAvIDI7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdHNjYWxlTGFiZWxYID0gbWUubGVmdCArICgobWUucmlnaHQgLSBtZS5sZWZ0KSAvIDIpOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcblx0XHRcdFx0XHRzY2FsZUxhYmVsWSA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nXG5cdFx0XHRcdFx0XHQ/IG1lLmJvdHRvbSAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcuYm90dG9tXG5cdFx0XHRcdFx0XHQ6IG1lLnRvcCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBpc0xlZnQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRcdFx0c2NhbGVMYWJlbFggPSBpc0xlZnRcblx0XHRcdFx0XHRcdD8gbWUubGVmdCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wXG5cdFx0XHRcdFx0XHQ6IG1lLnJpZ2h0IC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHRcdFx0c2NhbGVMYWJlbFkgPSBtZS50b3AgKyAoKG1lLmJvdHRvbSAtIG1lLnRvcCkgLyAyKTtcblx0XHRcdFx0XHRyb3RhdGlvbiA9IGlzTGVmdCA/IC0wLjUgKiBNYXRoLlBJIDogMC41ICogTWF0aC5QSTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRjb250ZXh0LnRyYW5zbGF0ZShzY2FsZUxhYmVsWCwgc2NhbGVMYWJlbFkpO1xuXHRcdFx0XHRjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRcdGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gc2NhbGVMYWJlbEZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRcdGNvbnRleHQuZm9udCA9IHNjYWxlTGFiZWxGb250LmZvbnQ7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFRleHQoc2NhbGVMYWJlbC5sYWJlbFN0cmluZywgMCwgMCk7XG5cdFx0XHRcdGNvbnRleHQucmVzdG9yZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdCb3JkZXIpIHtcblx0XHRcdFx0Ly8gRHJhdyB0aGUgbGluZSBhdCB0aGUgZWRnZSBvZiB0aGUgYXhpc1xuXHRcdFx0XHRjb250ZXh0LmxpbmVXaWR0aCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIDApO1xuXHRcdFx0XHRjb250ZXh0LnN0cm9rZVN0eWxlID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCAwKTtcblx0XHRcdFx0dmFyIHgxID0gbWUubGVmdDtcblx0XHRcdFx0dmFyIHgyID0gbWUucmlnaHQ7XG5cdFx0XHRcdHZhciB5MSA9IG1lLnRvcDtcblx0XHRcdFx0dmFyIHkyID0gbWUuYm90dG9tO1xuXG5cdFx0XHRcdHZhciBhbGlhc1BpeGVsID0gaGVscGVycy5hbGlhc1BpeGVsKGNvbnRleHQubGluZVdpZHRoKTtcblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdHkxID0geTIgPSBvcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyA/IG1lLmJvdHRvbSA6IG1lLnRvcDtcblx0XHRcdFx0XHR5MSArPSBhbGlhc1BpeGVsO1xuXHRcdFx0XHRcdHkyICs9IGFsaWFzUGl4ZWw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSB4MiA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0JyA/IG1lLnJpZ2h0IDogbWUubGVmdDtcblx0XHRcdFx0XHR4MSArPSBhbGlhc1BpeGVsO1xuXHRcdFx0XHRcdHgyICs9IGFsaWFzUGl4ZWw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjb250ZXh0Lm1vdmVUbyh4MSwgeTEpO1xuXHRcdFx0XHRjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXHRcdFx0XHRjb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG59LHtcIjI1XCI6MjUsXCIyNlwiOjI2LFwiMzRcIjozNCxcIjQ1XCI6NDV9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LnNjYWxlU2VydmljZSA9IHtcblx0XHQvLyBTY2FsZSByZWdpc3RyYXRpb24gb2JqZWN0LiBFeHRlbnNpb25zIGNhbiByZWdpc3RlciBuZXcgc2NhbGUgdHlwZXMgKHN1Y2ggYXMgbG9nIG9yIERCIHNjYWxlcykgYW5kIHRoZW5cblx0XHQvLyB1c2UgdGhlIG5ldyBjaGFydCBvcHRpb25zIHRvIGdyYWIgdGhlIGNvcnJlY3Qgc2NhbGVcblx0XHRjb25zdHJ1Y3RvcnM6IHt9LFxuXHRcdC8vIFVzZSBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBzbyB0aGF0IHdlIGNhbiBtb3ZlIHRvIGFuIEVTNiBtYXAgd2hlbiB3ZSBubyBsb25nZXIgbmVlZCB0byBzdXBwb3J0XG5cdFx0Ly8gb2xkIGJyb3dzZXJzXG5cblx0XHQvLyBTY2FsZSBjb25maWcgZGVmYXVsdHNcblx0XHRkZWZhdWx0czoge30sXG5cdFx0cmVnaXN0ZXJTY2FsZVR5cGU6IGZ1bmN0aW9uKHR5cGUsIHNjYWxlQ29uc3RydWN0b3IsIHNjYWxlRGVmYXVsdHMpIHtcblx0XHRcdHRoaXMuY29uc3RydWN0b3JzW3R5cGVdID0gc2NhbGVDb25zdHJ1Y3Rvcjtcblx0XHRcdHRoaXMuZGVmYXVsdHNbdHlwZV0gPSBoZWxwZXJzLmNsb25lKHNjYWxlRGVmYXVsdHMpO1xuXHRcdH0sXG5cdFx0Z2V0U2NhbGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JzLmhhc093blByb3BlcnR5KHR5cGUpID8gdGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gOiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHRnZXRTY2FsZURlZmF1bHRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHQvLyBSZXR1cm4gdGhlIHNjYWxlIGRlZmF1bHRzIG1lcmdlZCB3aXRoIHRoZSBnbG9iYWwgc2V0dGluZ3Mgc28gdGhhdCB3ZSBhbHdheXMgdXNlIHRoZSBsYXRlc3Qgb25lc1xuXHRcdFx0cmV0dXJuIHRoaXMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkodHlwZSkgPyBoZWxwZXJzLm1lcmdlKHt9LCBbZGVmYXVsdHMuc2NhbGUsIHRoaXMuZGVmYXVsdHNbdHlwZV1dKSA6IHt9O1xuXHRcdH0sXG5cdFx0dXBkYXRlU2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSwgYWRkaXRpb25zKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0aWYgKG1lLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRcdG1lLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycy5leHRlbmQobWUuZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdC8vIEFkZHMgZWFjaCBzY2FsZSB0byB0aGUgY2hhcnQuYm94ZXMgYXJyYXkgdG8gYmUgc2l6ZWQgYWNjb3JkaW5nbHlcblx0XHRcdGhlbHBlcnMuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG5cdFx0XHRcdC8vIFNldCBJTGF5b3V0SXRlbSBwYXJhbWV0ZXJzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRzY2FsZS5mdWxsV2lkdGggPSBzY2FsZS5vcHRpb25zLmZ1bGxXaWR0aDtcblx0XHRcdFx0c2NhbGUucG9zaXRpb24gPSBzY2FsZS5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0XHRzY2FsZS53ZWlnaHQgPSBzY2FsZS5vcHRpb25zLndlaWdodDtcblx0XHRcdFx0Q2hhcnQubGF5b3V0U2VydmljZS5hZGRCb3goY2hhcnQsIHNjYWxlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjQ1XCI6NDV9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBnZW5lcmF0b3JzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5nZW5lcmF0b3JzXG5cdCAqL1xuXHRnZW5lcmF0b3JzOiB7XG5cdFx0LyoqXG5cdFx0ICogSW50ZXJmYWNlIGZvciB0aGUgb3B0aW9ucyBwcm92aWRlZCB0byB0aGUgbnVtZXJpYyB0aWNrIGdlbmVyYXRvclxuXHRcdCAqIEBpbnRlcmZhY2UgSU51bWVyaWNUaWNrR2VuZXJhdGlvbk9wdGlvbnNcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gZGlzcGxheVxuXHRcdCAqIEBuYW1lIElOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zI21heFRpY2tzXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCB0aWNrLlxuXHRcdCAqIEBuYW1lIElOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zI3N0ZXBTaXplXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQG9wdGlvbmFsXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogRm9yY2VkIG1pbmltdW0gZm9yIHRoZSB0aWNrcy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIG1pbmltdW0gb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHRpY2sgbWluaW11bVxuXHRcdCAqIEBuYW1lIElOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zI21pblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBvcHRpb25hbFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSB0aWNrcy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIG1heGltdW0gb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHRpY2sgbWF4aW11bVxuXHRcdCAqIEBuYW1lIElOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zI21heFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBvcHRpb25hbFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5nZW5lcmF0b3JzLmxpbmVhclxuXHRcdCAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB7SU51bWVyaWNUaWNrR2VuZXJhdGlvbk9wdGlvbnN9IHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG5cdFx0ICogQHBhcmFtIGRhdGFSYW5nZSB7SVJhbmdlfSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcblx0XHQgKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPn0gYXJyYXkgb2YgdGljayB2YWx1ZXNcblx0XHQgKi9cblx0XHRsaW5lYXI6IGZ1bmN0aW9uKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0XHRcdHZhciB0aWNrcyA9IFtdO1xuXHRcdFx0Ly8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXG5cdFx0XHQvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTA2ODgxL25pY2UtbGFiZWwtYWxnb3JpdGhtLWZvci1jaGFydHMtd2l0aC1taW5pbXVtLXRpY2tzXG5cdFx0XHQvLyBmb3IgZGV0YWlscy5cblxuXHRcdFx0dmFyIHNwYWNpbmc7XG5cdFx0XHRpZiAoZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemUgJiYgZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemUgPiAwKSB7XG5cdFx0XHRcdHNwYWNpbmcgPSBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwU2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBuaWNlUmFuZ2UgPSBoZWxwZXJzLm5pY2VOdW0oZGF0YVJhbmdlLm1heCAtIGRhdGFSYW5nZS5taW4sIGZhbHNlKTtcblx0XHRcdFx0c3BhY2luZyA9IGhlbHBlcnMubmljZU51bShuaWNlUmFuZ2UgLyAoZ2VuZXJhdGlvbk9wdGlvbnMubWF4VGlja3MgLSAxKSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbmljZU1pbiA9IE1hdGguZmxvb3IoZGF0YVJhbmdlLm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcblx0XHRcdHZhciBuaWNlTWF4ID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG5cblx0XHRcdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cblx0XHRcdGlmIChnZW5lcmF0aW9uT3B0aW9ucy5taW4gJiYgZ2VuZXJhdGlvbk9wdGlvbnMubWF4ICYmIGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplKSB7XG5cdFx0XHRcdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHdob2xlIG51bWJlciwgdXNlIGl0LlxuXHRcdFx0XHRpZiAoaGVscGVycy5hbG1vc3RXaG9sZSgoZ2VuZXJhdGlvbk9wdGlvbnMubWF4IC0gZ2VuZXJhdGlvbk9wdGlvbnMubWluKSAvIGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRcdFx0XHRuaWNlTWluID0gZ2VuZXJhdGlvbk9wdGlvbnMubWluO1xuXHRcdFx0XHRcdG5pY2VNYXggPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuXHRcdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuXHRcdFx0aWYgKGhlbHBlcnMuYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRcdFx0bnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCB0aGUgdmFsdWVzIGludG8gdGhlIHRpY2tzIGFycmF5XG5cdFx0XHR0aWNrcy5wdXNoKGdlbmVyYXRpb25PcHRpb25zLm1pbiAhPT0gdW5kZWZpbmVkID8gZ2VuZXJhdGlvbk9wdGlvbnMubWluIDogbmljZU1pbik7XG5cdFx0XHRmb3IgKHZhciBqID0gMTsgaiA8IG51bVNwYWNlczsgKytqKSB7XG5cdFx0XHRcdHRpY2tzLnB1c2gobmljZU1pbiArIChqICogc3BhY2luZykpO1xuXHRcdFx0fVxuXHRcdFx0dGlja3MucHVzaChnZW5lcmF0aW9uT3B0aW9ucy5tYXggIT09IHVuZGVmaW5lZCA/IGdlbmVyYXRpb25PcHRpb25zLm1heCA6IG5pY2VNYXgpO1xuXG5cdFx0XHRyZXR1cm4gdGlja3M7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRlIGEgc2V0IG9mIGxvZ2FyaXRobWljIHRpY2tzXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5nZW5lcmF0b3JzLmxvZ2FyaXRobWljXG5cdFx0ICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHtJTnVtZXJpY1RpY2tHZW5lcmF0aW9uT3B0aW9uc30gdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3Ncblx0XHQgKiBAcGFyYW0gZGF0YVJhbmdlIHtJUmFuZ2V9IHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuXHRcdCAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXI+fSBhcnJheSBvZiB0aWNrIHZhbHVlc1xuXHRcdCAqL1xuXHRcdGxvZ2FyaXRobWljOiBmdW5jdGlvbihnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdFx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cblx0XHRcdC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuXHRcdFx0Ly8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDUwXG5cdFx0XHQvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuXHRcdFx0Ly8gdGhlIGdyYXBoXG5cdFx0XHR2YXIgdGlja1ZhbCA9IHZhbHVlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcblxuXHRcdFx0dmFyIGVuZEV4cCA9IE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChkYXRhUmFuZ2UubWF4KSk7XG5cdFx0XHR2YXIgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcblx0XHRcdHZhciBleHAsIHNpZ25pZmljYW5kO1xuXG5cdFx0XHRpZiAodGlja1ZhbCA9PT0gMCkge1xuXHRcdFx0XHRleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMubG9nMTAoZGF0YVJhbmdlLm1pbk5vdFplcm8pKTtcblx0XHRcdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKGRhdGFSYW5nZS5taW5Ob3RaZXJvIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXG5cdFx0XHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XG5cdFx0XHRcdHRpY2tWYWwgPSBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXhwID0gTWF0aC5mbG9vcihoZWxwZXJzLmxvZzEwKHRpY2tWYWwpKTtcblx0XHRcdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cdFx0XHR9XG5cblx0XHRcdGRvIHtcblx0XHRcdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcblxuXHRcdFx0XHQrK3NpZ25pZmljYW5kO1xuXHRcdFx0XHRpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG5cdFx0XHRcdFx0c2lnbmlmaWNhbmQgPSAxO1xuXHRcdFx0XHRcdCsrZXhwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGlja1ZhbCA9IHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XG5cdFx0XHR9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcblxuXHRcdFx0dmFyIGxhc3RUaWNrID0gdmFsdWVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcblx0XHRcdHRpY2tzLnB1c2gobGFzdFRpY2spO1xuXG5cdFx0XHRyZXR1cm4gdGlja3M7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG5cdCAqL1xuXHRmb3JtYXR0ZXJzOiB7XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG5cdFx0ICogQHJldHVybiB7U3RyaW5nfEFycmF5fSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuXHRcdCAqL1xuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIGxpbmVhciBudW1lcmljIHRpY2tzXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHRcdCAqIEBwYXJhbSB0aWNrVmFsdWUge051bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuXHRcdCAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG5cdFx0ICogQHBhcmFtIHRpY2tzIHtBcnJheTxOdW1iZXI+fSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuXHRcdCAqL1xuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgbG90cyBvZiB0aWNrcywgZG9uJ3QgdXNlIHRoZSBvbmVzXG5cdFx0XHR2YXIgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0gLSB0aWNrc1sxXSA6IHRpY2tzWzFdIC0gdGlja3NbMF07XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YSkgPiAxKSB7XG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuXHRcdFx0XHRcdC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0ZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycy5sb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuXHRcdFx0dmFyIHRpY2tTdHJpbmcgPSAnJztcblxuXHRcdFx0aWYgKHRpY2tWYWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR2YXIgbnVtRGVjaW1hbCA9IC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSk7XG5cdFx0XHRcdG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1EZWNpbWFsLCAyMCksIDApOyAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuXHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRml4ZWQobnVtRGVjaW1hbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aWNrU3RyaW5nID0gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aWNrU3RyaW5nO1xuXHRcdH0sXG5cblx0XHRsb2dhcml0aG1pYzogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdHZhciByZW1haW4gPSB0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycy5sb2cxMCh0aWNrVmFsdWUpKSkpO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnMCc7XG5cdFx0XHR9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1IHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0aWNrcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdHJldHVybiB0aWNrVmFsdWUudG9FeHBvbmVudGlhbCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxufTtcblxufSx7XCI0NVwiOjQ1fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgyNik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRvb2x0aXBzOiB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRjdXN0b206IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdHBvc2l0aW9uOiAnYXZlcmFnZScsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG5cdFx0dGl0bGVGb250U3R5bGU6ICdib2xkJyxcblx0XHR0aXRsZVNwYWNpbmc6IDIsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IDYsXG5cdFx0dGl0bGVGb250Q29sb3I6ICcjZmZmJyxcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXG5cdFx0Ym9keVNwYWNpbmc6IDIsXG5cdFx0Ym9keUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxuXHRcdGZvb3RlckZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdGZvb3RlclNwYWNpbmc6IDIsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxuXHRcdGZvb3RlckZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGZvb3RlckFsaWduOiAnbGVmdCcsXG5cdFx0eVBhZGRpbmc6IDYsXG5cdFx0eFBhZGRpbmc6IDYsXG5cdFx0Y2FyZXRQYWRkaW5nOiAyLFxuXHRcdGNhcmV0U2l6ZTogNSxcblx0XHRjb3JuZXJSYWRpdXM6IDYsXG5cdFx0bXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcblx0XHRib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXHRcdGJvcmRlcldpZHRoOiAwLFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVUaXRsZTogaGVscGVycy5ub29wLFxuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtcywgZGF0YSkge1xuXHRcdFx0XHQvLyBQaWNrIGZpcnN0IHhMYWJlbCBmb3Igbm93XG5cdFx0XHRcdHZhciB0aXRsZSA9ICcnO1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cblx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG5cblx0XHRcdFx0XHRpZiAoaXRlbS54TGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS54TGFiZWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmluZGV4IDwgbGFiZWxDb3VudCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBsYWJlbHNbaXRlbS5pbmRleF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyVGl0bGU6IGhlbHBlcnMubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0XHRiZWZvcmVMYWJlbDogaGVscGVycy5ub29wLFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblxuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRsYWJlbCArPSAnOiAnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnlMYWJlbDtcblx0XHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsQ29sb3I6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBjaGFydCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciBhY3RpdmVFbGVtZW50ID0gbWV0YS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblx0XHRcdFx0dmFyIHZpZXcgPSBhY3RpdmVFbGVtZW50Ll92aWV3O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGJvcmRlckNvbG9yOiB2aWV3LmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogdmlldy5iYWNrZ3JvdW5kQ29sb3Jcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRsYWJlbFRleHRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9vcHRpb25zLmJvZHlGb250Q29sb3I7XG5cdFx0XHR9LFxuXHRcdFx0YWZ0ZXJMYWJlbDogaGVscGVycy5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGFmdGVyQm9keTogaGVscGVycy5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUZvb3RlcjogaGVscGVycy5ub29wLFxuXHRcdFx0Zm9vdGVyOiBoZWxwZXJzLm5vb3AsXG5cdFx0XHRhZnRlckZvb3RlcjogaGVscGVycy5ub29wXG5cdFx0fVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdC8qKlxuIFx0ICogSGVscGVyIG1ldGhvZCB0byBtZXJnZSB0aGUgb3BhY2l0eSBpbnRvIGEgY29sb3JcbiBcdCAqL1xuXHRmdW5jdGlvbiBtZXJnZU9wYWNpdHkoY29sb3JTdHJpbmcsIG9wYWNpdHkpIHtcblx0XHR2YXIgY29sb3IgPSBoZWxwZXJzLmNvbG9yKGNvbG9yU3RyaW5nKTtcblx0XHRyZXR1cm4gY29sb3IuYWxwaGEob3BhY2l0eSAqIGNvbG9yLmFscGhhKCkpLnJnYmFTdHJpbmcoKTtcblx0fVxuXG5cdC8vIEhlbHBlciB0byBwdXNoIG9yIGNvbmNhdCBiYXNlZCBvbiBpZiB0aGUgMm5kIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBub3Rcblx0ZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuXHRcdGlmICh0b1B1c2gpIHtcblx0XHRcdGlmIChoZWxwZXJzLmlzQXJyYXkodG9QdXNoKSkge1xuXHRcdFx0XHQvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJhc2UucHVzaCh0b1B1c2gpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0Ly8gUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG5cdC8vIEBwYXJhbSBlbGVtZW50IDogdGhlIGNoYXJ0IGVsZW1lbnQgKHBvaW50LCBhcmMsIGJhcikgdG8gY3JlYXRlIHRoZSB0b29sdGlwIGl0ZW0gZm9yXG5cdC8vIEByZXR1cm4gOiBuZXcgdG9vbHRpcCBpdGVtXG5cdGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGVsZW1lbnQpIHtcblx0XHR2YXIgeFNjYWxlID0gZWxlbWVudC5feFNjYWxlO1xuXHRcdHZhciB5U2NhbGUgPSBlbGVtZW50Ll95U2NhbGUgfHwgZWxlbWVudC5fc2NhbGU7IC8vIGhhbmRsZSByYWRhciB8fCBwb2xhckFyZWEgY2hhcnRzXG5cdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IGVsZW1lbnQuX2RhdGFzZXRJbmRleDtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4TGFiZWw6IHhTY2FsZSA/IHhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0XHR5TGFiZWw6IHlTY2FsZSA/IHlTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcblx0XHRcdHg6IGVsZW1lbnQuX21vZGVsLngsXG5cdFx0XHR5OiBlbGVtZW50Ll9tb2RlbC55XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgdG8gZ2V0IHRoZSByZXNldCBtb2RlbCBmb3IgdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHRvb2x0aXBPcHRzIHtPYmplY3R9IHRoZSB0b29sdGlwIG9wdGlvbnNcblx0ICovXG5cdGZ1bmN0aW9uIGdldEJhc2VNb2RlbCh0b29sdGlwT3B0cykge1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGRlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdC8vIFBvc2l0aW9uaW5nXG5cdFx0XHR4UGFkZGluZzogdG9vbHRpcE9wdHMueFBhZGRpbmcsXG5cdFx0XHR5UGFkZGluZzogdG9vbHRpcE9wdHMueVBhZGRpbmcsXG5cdFx0XHR4QWxpZ246IHRvb2x0aXBPcHRzLnhBbGlnbixcblx0XHRcdHlBbGlnbjogdG9vbHRpcE9wdHMueUFsaWduLFxuXG5cdFx0XHQvLyBCb2R5XG5cdFx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxuXHRcdFx0X2JvZHlGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy5ib2R5Rm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdFx0X2JvZHlGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdFx0X2JvZHlBbGlnbjogdG9vbHRpcE9wdHMuYm9keUFsaWduLFxuXHRcdFx0Ym9keUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy5ib2R5Rm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0XHRib2R5U3BhY2luZzogdG9vbHRpcE9wdHMuYm9keVNwYWNpbmcsXG5cblx0XHRcdC8vIFRpdGxlXG5cdFx0XHR0aXRsZUZvbnRDb2xvcjogdG9vbHRpcE9wdHMudGl0bGVGb250Q29sb3IsXG5cdFx0XHRfdGl0bGVGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy50aXRsZUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdF90aXRsZUZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMudGl0bGVGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdFx0dGl0bGVGb250U2l6ZTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMudGl0bGVGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRcdF90aXRsZUFsaWduOiB0b29sdGlwT3B0cy50aXRsZUFsaWduLFxuXHRcdFx0dGl0bGVTcGFjaW5nOiB0b29sdGlwT3B0cy50aXRsZVNwYWNpbmcsXG5cdFx0XHR0aXRsZU1hcmdpbkJvdHRvbTogdG9vbHRpcE9wdHMudGl0bGVNYXJnaW5Cb3R0b20sXG5cblx0XHRcdC8vIEZvb3RlclxuXHRcdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXG5cdFx0XHRfZm9vdGVyRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdFx0X2Zvb3RlckZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMuZm9vdGVyRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRcdGZvb3RlckZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRcdF9mb290ZXJBbGlnbjogdG9vbHRpcE9wdHMuZm9vdGVyQWxpZ24sXG5cdFx0XHRmb290ZXJTcGFjaW5nOiB0b29sdGlwT3B0cy5mb290ZXJTcGFjaW5nLFxuXHRcdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXG5cblx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdGNhcmV0U2l6ZTogdG9vbHRpcE9wdHMuY2FyZXRTaXplLFxuXHRcdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBPcHRzLmJhY2tncm91bmRDb2xvcixcblx0XHRcdG9wYWNpdHk6IDAsXG5cdFx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcblx0XHRcdGRpc3BsYXlDb2xvcnM6IHRvb2x0aXBPcHRzLmRpc3BsYXlDb2xvcnMsXG5cdFx0XHRib3JkZXJDb2xvcjogdG9vbHRpcE9wdHMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgbW9kZWwpIHtcblx0XHR2YXIgY3R4ID0gdG9vbHRpcC5fY2hhcnQuY3R4O1xuXG5cdFx0dmFyIGhlaWdodCA9IG1vZGVsLnlQYWRkaW5nICogMjsgLy8gVG9vbHRpcCBQYWRkaW5nXG5cdFx0dmFyIHdpZHRoID0gMDtcblxuXHRcdC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuXHRcdHZhciBib2R5ID0gbW9kZWwuYm9keTtcblx0XHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XG5cdFx0XHRyZXR1cm4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoO1xuXHRcdH0sIDApO1xuXHRcdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XG5cblx0XHR2YXIgdGl0bGVMaW5lQ291bnQgPSBtb2RlbC50aXRsZS5sZW5ndGg7XG5cdFx0dmFyIGZvb3RlckxpbmVDb3VudCA9IG1vZGVsLmZvb3Rlci5sZW5ndGg7XG5cdFx0dmFyIHRpdGxlRm9udFNpemUgPSBtb2RlbC50aXRsZUZvbnRTaXplO1xuXHRcdHZhciBib2R5Rm9udFNpemUgPSBtb2RlbC5ib2R5Rm9udFNpemU7XG5cdFx0dmFyIGZvb3RlckZvbnRTaXplID0gbW9kZWwuZm9vdGVyRm9udFNpemU7XG5cblx0XHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnRTaXplOyAvLyBUaXRsZSBMaW5lc1xuXHRcdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/ICh0aXRsZUxpbmVDb3VudCAtIDEpICogbW9kZWwudGl0bGVTcGFjaW5nIDogMDsgLy8gVGl0bGUgTGluZSBTcGFjaW5nXG5cdFx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ID8gbW9kZWwudGl0bGVNYXJnaW5Cb3R0b20gOiAwOyAvLyBUaXRsZSdzIGJvdHRvbSBNYXJnaW5cblx0XHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoICogYm9keUZvbnRTaXplOyAvLyBCb2R5IExpbmVzXG5cdFx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCA/IChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG1vZGVsLmJvZHlTcGFjaW5nIDogMDsgLy8gQm9keSBMaW5lIFNwYWNpbmdcblx0XHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ID8gbW9kZWwuZm9vdGVyTWFyZ2luVG9wIDogMDsgLy8gRm9vdGVyIE1hcmdpblxuXHRcdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgKiAoZm9vdGVyRm9udFNpemUpOyAvLyBGb290ZXIgTGluZXNcblx0XHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ID8gKGZvb3RlckxpbmVDb3VudCAtIDEpICogbW9kZWwuZm9vdGVyU3BhY2luZyA6IDA7IC8vIEZvb3RlciBMaW5lIFNwYWNpbmdcblxuXHRcdC8vIFRpdGxlIHdpZHRoXG5cdFx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XG5cdFx0dmFyIG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG5cdFx0fTtcblxuXHRcdGN0eC5mb250ID0gaGVscGVycy5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIG1vZGVsLl90aXRsZUZvbnRTdHlsZSwgbW9kZWwuX3RpdGxlRm9udEZhbWlseSk7XG5cdFx0aGVscGVycy5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG5cdFx0Ly8gQm9keSB3aWR0aFxuXHRcdGN0eC5mb250ID0gaGVscGVycy5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgbW9kZWwuX2JvZHlGb250U3R5bGUsIG1vZGVsLl9ib2R5Rm9udEZhbWlseSk7XG5cdFx0aGVscGVycy5lYWNoKG1vZGVsLmJlZm9yZUJvZHkuY29uY2F0KG1vZGVsLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cblx0XHQvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcblx0XHR3aWR0aFBhZGRpbmcgPSBtb2RlbC5kaXNwbGF5Q29sb3JzID8gKGJvZHlGb250U2l6ZSArIDIpIDogMDtcblx0XHRoZWxwZXJzLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0pIHtcblx0XHRcdGhlbHBlcnMuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG5cdFx0XHRoZWxwZXJzLmVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG5cdFx0XHRoZWxwZXJzLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG5cdFx0fSk7XG5cblx0XHQvLyBSZXNldCBiYWNrIHRvIDBcblx0XHR3aWR0aFBhZGRpbmcgPSAwO1xuXG5cdFx0Ly8gRm9vdGVyIHdpZHRoXG5cdFx0Y3R4LmZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcoZm9vdGVyRm9udFNpemUsIG1vZGVsLl9mb290ZXJGb250U3R5bGUsIG1vZGVsLl9mb290ZXJGb250RmFtaWx5KTtcblx0XHRoZWxwZXJzLmVhY2gobW9kZWwuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG5cdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHR3aWR0aCArPSAyICogbW9kZWwueFBhZGRpbmc7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcblx0ICovXG5cdGZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XG5cdFx0dmFyIG1vZGVsID0gdG9vbHRpcC5fbW9kZWw7XG5cdFx0dmFyIGNoYXJ0ID0gdG9vbHRpcC5fY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgeEFsaWduID0gJ2NlbnRlcic7XG5cdFx0dmFyIHlBbGlnbiA9ICdjZW50ZXInO1xuXG5cdFx0aWYgKG1vZGVsLnkgPCBzaXplLmhlaWdodCkge1xuXHRcdFx0eUFsaWduID0gJ3RvcCc7XG5cdFx0fSBlbHNlIGlmIChtb2RlbC55ID4gKGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KSkge1xuXHRcdFx0eUFsaWduID0gJ2JvdHRvbSc7XG5cdFx0fVxuXG5cdFx0dmFyIGxmLCByZjsgLy8gZnVuY3Rpb25zIHRvIGRldGVybWluZSBsZWZ0LCByaWdodCBhbGlnbm1lbnRcblx0XHR2YXIgb2xmLCBvcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgaWYgbGVmdC9yaWdodCBhbGlnbm1lbnQgY2F1c2VzIHRvb2x0aXAgdG8gZ28gb3V0c2lkZSBjaGFydFxuXHRcdHZhciB5ZjsgLy8gZnVuY3Rpb24gdG8gZ2V0IHRoZSB5IGFsaWdubWVudCBpZiB0aGUgdG9vbHRpcCBnb2VzIG91dHNpZGUgb2YgdGhlIGxlZnQgb3IgcmlnaHQgZWRnZXNcblx0XHR2YXIgbWlkWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuXHRcdHZhciBtaWRZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0bGYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRcdHJldHVybiB4IDw9IG1pZFg7XG5cdFx0XHR9O1xuXHRcdFx0cmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRcdHJldHVybiB4ID4gbWlkWDtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0XHRyZXR1cm4geCA8PSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdFx0fTtcblx0XHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0XHRyZXR1cm4geCA+PSAoY2hhcnQud2lkdGggLSAoc2l6ZS53aWR0aCAvIDIpKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0b2xmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggKyBzaXplLndpZHRoID4gY2hhcnQud2lkdGg7XG5cdFx0fTtcblx0XHRvcmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCAtIHNpemUud2lkdGggPCAwO1xuXHRcdH07XG5cdFx0eWYgPSBmdW5jdGlvbih5KSB7XG5cdFx0XHRyZXR1cm4geSA8PSBtaWRZID8gJ3RvcCcgOiAnYm90dG9tJztcblx0XHR9O1xuXG5cdFx0aWYgKGxmKG1vZGVsLngpKSB7XG5cdFx0XHR4QWxpZ24gPSAnbGVmdCc7XG5cblx0XHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xuXHRcdFx0aWYgKG9sZihtb2RlbC54KSkge1xuXHRcdFx0XHR4QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChyZihtb2RlbC54KSkge1xuXHRcdFx0eEFsaWduID0gJ3JpZ2h0JztcblxuXHRcdFx0Ly8gSXMgdG9vbHRpcCB0b28gd2lkZSBhbmQgZ29lcyBvdXRzaWRlIGxlZnQgZWRnZSBvZiBjYW52YXM/XG5cdFx0XHRpZiAob3JmKG1vZGVsLngpKSB7XG5cdFx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0XHR5QWxpZ24gPSB5Zihtb2RlbC55KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgb3B0cyA9IHRvb2x0aXAuX29wdGlvbnM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHhBbGlnbjogb3B0cy54QWxpZ24gPyBvcHRzLnhBbGlnbiA6IHhBbGlnbixcblx0XHRcdHlBbGlnbjogb3B0cy55QWxpZ24gPyBvcHRzLnlBbGlnbiA6IHlBbGlnblxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQEhlbHBlciB0byBnZXQgdGhlIGxvY2F0aW9uIGEgdG9vbHRpcCBuZWVkcyB0byBiZSBwbGFjZWQgYXQgZ2l2ZW4gdGhlIGluaXRpYWwgcG9zaXRpb24gKHZpYSB0aGUgdm0pIGFuZCB0aGUgc2l6ZSBhbmQgYWxpZ25tZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQodm0sIHNpemUsIGFsaWdubWVudCkge1xuXHRcdC8vIEJhY2tncm91bmQgUG9zaXRpb25cblx0XHR2YXIgeCA9IHZtLng7XG5cdFx0dmFyIHkgPSB2bS55O1xuXG5cdFx0dmFyIGNhcmV0U2l6ZSA9IHZtLmNhcmV0U2l6ZTtcblx0XHR2YXIgY2FyZXRQYWRkaW5nID0gdm0uY2FyZXRQYWRkaW5nO1xuXHRcdHZhciBjb3JuZXJSYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cdFx0dmFyIHhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG5cdFx0dmFyIHlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdFx0dmFyIHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuXHRcdHZhciByYWRpdXNBbmRQYWRkaW5nID0gY29ybmVyUmFkaXVzICsgY2FyZXRQYWRkaW5nO1xuXG5cdFx0aWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0eCAtPSBzaXplLndpZHRoO1xuXHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0eCAtPSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdH1cblxuXHRcdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHR5ICs9IHBhZGRpbmdBbmRTaXplO1xuXHRcdH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuXHRcdFx0eSAtPSBzaXplLmhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR5IC09IChzaXplLmhlaWdodCAvIDIpO1xuXHRcdH1cblxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHRcdHggLT0gcGFkZGluZ0FuZFNpemU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0eCAtPSByYWRpdXNBbmRQYWRkaW5nO1xuXHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHR4ICs9IHJhZGl1c0FuZFBhZGRpbmc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5XG5cdFx0fTtcblx0fVxuXG5cdENoYXJ0LlRvb2x0aXAgPSBFbGVtZW50LmV4dGVuZCh7XG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRoZSB0aXRsZVxuXHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0Z2V0VGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cdFx0XHR2YXIgY2FsbGJhY2tzID0gb3B0cy5jYWxsYmFja3M7XG5cblx0XHRcdHZhciBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHRcdHZhciB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHRcdHZhciBhZnRlclRpdGxlID0gY2FsbGJhY2tzLmFmdGVyVGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIGJlZm9yZVRpdGxlKTtcblx0XHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCB0aXRsZSk7XG5cdFx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgYWZ0ZXJUaXRsZSk7XG5cblx0XHRcdHJldHVybiBsaW5lcztcblx0XHR9LFxuXG5cdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRnZXRCZWZvcmVCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsaW5lcyA9IHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBoZWxwZXJzLmlzQXJyYXkobGluZXMpID8gbGluZXMgOiBsaW5lcyAhPT0gdW5kZWZpbmVkID8gW2xpbmVzXSA6IFtdO1xuXHRcdH0sXG5cblx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRcdGdldEJvZHk6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtcywgZGF0YSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XG5cdFx0XHR2YXIgYm9keUl0ZW1zID0gW107XG5cblx0XHRcdGhlbHBlcnMuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHRcdHZhciBib2R5SXRlbSA9IHtcblx0XHRcdFx0XHRiZWZvcmU6IFtdLFxuXHRcdFx0XHRcdGxpbmVzOiBbXSxcblx0XHRcdFx0XHRhZnRlcjogW11cblx0XHRcdFx0fTtcblx0XHRcdFx0cHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgY2FsbGJhY2tzLmJlZm9yZUxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cdFx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgY2FsbGJhY2tzLmxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cdFx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKTtcblxuXHRcdFx0XHRib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGJvZHlJdGVtcztcblx0XHR9LFxuXG5cdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRnZXRBZnRlckJvZHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGxpbmVzID0gdGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KGxpbmVzKSA/IGxpbmVzIDogbGluZXMgIT09IHVuZGVmaW5lZCA/IFtsaW5lc10gOiBbXTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRoZSBmb290ZXIgYW5kIGJlZm9yZUZvb3RlciBhbmQgYWZ0ZXJGb290ZXIgbGluZXNcblx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRcdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNhbGxiYWNrcyA9IG1lLl9vcHRpb25zLmNhbGxiYWNrcztcblxuXHRcdFx0dmFyIGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHRcdHZhciBhZnRlckZvb3RlciA9IGNhbGxiYWNrcy5hZnRlckZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdFx0dmFyIGxpbmVzID0gW107XG5cdFx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgYmVmb3JlRm9vdGVyKTtcblx0XHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBmb290ZXIpO1xuXHRcdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIGFmdGVyRm9vdGVyKTtcblxuXHRcdFx0cmV0dXJuIGxpbmVzO1xuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKGNoYW5nZWQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXG5cdFx0XHQvLyBOZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIG1vZGVsIGJlY2F1c2UgaXRzIGZhc3RlciB0aGFuIHVzaW5nIGV4dGVuZCBhbmQgaXQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgb3B0aW1pemF0aW9uIGluIENoYXJ0LkVsZW1lbnQudHJhbnNpdGlvblxuXHRcdFx0Ly8gdGhhdCBkb2VzIF92aWV3ID0gX21vZGVsIGlmIGVhc2UgPT09IDEuIFRoaXMgY2F1c2VzIHRoZSAybmQgdG9vbHRpcCB1cGRhdGUgdG8gc2V0IHByb3BlcnRpZXMgaW4gYm90aCB0aGUgdmlldyBhbmQgbW9kZWwgYXQgdGhlIHNhbWUgdGltZVxuXHRcdFx0Ly8gd2hpY2ggYnJlYWtzIGFueSBhbmltYXRpb25zLlxuXHRcdFx0dmFyIGV4aXN0aW5nTW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWwgPSBnZXRCYXNlTW9kZWwob3B0cyk7XG5cdFx0XHR2YXIgYWN0aXZlID0gbWUuX2FjdGl2ZTtcblxuXHRcdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcblxuXHRcdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlcmUgYWN0aXZlLmxlbmd0aCA9PT0gMCB3ZSBuZWVkIHRvIGtlZXAgdGhlc2UgYXQgZXhpc3RpbmcgdmFsdWVzIGZvciBnb29kIGFuaW1hdGlvbnNcblx0XHRcdHZhciBhbGlnbm1lbnQgPSB7XG5cdFx0XHRcdHhBbGlnbjogZXhpc3RpbmdNb2RlbC54QWxpZ24sXG5cdFx0XHRcdHlBbGlnbjogZXhpc3RpbmdNb2RlbC55QWxpZ25cblx0XHRcdH07XG5cdFx0XHR2YXIgYmFja2dyb3VuZFBvaW50ID0ge1xuXHRcdFx0XHR4OiBleGlzdGluZ01vZGVsLngsXG5cdFx0XHRcdHk6IGV4aXN0aW5nTW9kZWwueVxuXHRcdFx0fTtcblx0XHRcdHZhciB0b29sdGlwU2l6ZSA9IHtcblx0XHRcdFx0d2lkdGg6IGV4aXN0aW5nTW9kZWwud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogZXhpc3RpbmdNb2RlbC5oZWlnaHRcblx0XHRcdH07XG5cdFx0XHR2YXIgdG9vbHRpcFBvc2l0aW9uID0ge1xuXHRcdFx0XHR4OiBleGlzdGluZ01vZGVsLmNhcmV0WCxcblx0XHRcdFx0eTogZXhpc3RpbmdNb2RlbC5jYXJldFlcblx0XHRcdH07XG5cblx0XHRcdHZhciBpLCBsZW47XG5cblx0XHRcdGlmIChhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRcdG1vZGVsLm9wYWNpdHkgPSAxO1xuXG5cdFx0XHRcdHZhciBsYWJlbENvbG9ycyA9IFtdO1xuXHRcdFx0XHR2YXIgbGFiZWxUZXh0Q29sb3JzID0gW107XG5cdFx0XHRcdHRvb2x0aXBQb3NpdGlvbiA9IENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0oYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XG5cblx0XHRcdFx0dmFyIHRvb2x0aXBJdGVtcyA9IFtdO1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdFx0XHR0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbShhY3RpdmVbaV0pKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgZmlsdGVyIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG5cdFx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xuXHRcdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdHMuZmlsdGVyKGEsIGRhdGEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG5cdFx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XG5cdFx0XHRcdFx0dG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdHMuaXRlbVNvcnQoYSwgYiwgZGF0YSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgY29sb3JzIGZvciBib3hlc1xuXHRcdFx0XHRoZWxwZXJzLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuXHRcdFx0XHRcdGxhYmVsQ29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XG5cdFx0XHRcdFx0bGFiZWxUZXh0Q29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxUZXh0Q29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xuXHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdC8vIEJ1aWxkIHRoZSBUZXh0IExpbmVzXG5cdFx0XHRcdG1vZGVsLnRpdGxlID0gbWUuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdFx0bW9kZWwuYmVmb3JlQm9keSA9IG1lLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdFx0bW9kZWwuYm9keSA9IG1lLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdFx0bW9kZWwuYWZ0ZXJCb2R5ID0gbWUuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRcdG1vZGVsLmZvb3RlciA9IG1lLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIGRhdGEpO1xuXG5cdFx0XHRcdC8vIEluaXRpYWwgcG9zaXRpb25pbmcgYW5kIGNvbG9yc1xuXHRcdFx0XHRtb2RlbC54ID0gTWF0aC5yb3VuZCh0b29sdGlwUG9zaXRpb24ueCk7XG5cdFx0XHRcdG1vZGVsLnkgPSBNYXRoLnJvdW5kKHRvb2x0aXBQb3NpdGlvbi55KTtcblx0XHRcdFx0bW9kZWwuY2FyZXRQYWRkaW5nID0gb3B0cy5jYXJldFBhZGRpbmc7XG5cdFx0XHRcdG1vZGVsLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG5cdFx0XHRcdG1vZGVsLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcblxuXHRcdFx0XHQvLyBkYXRhIHBvaW50c1xuXHRcdFx0XHRtb2RlbC5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuXG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGFsaWdubWVudCBvZiB0aGUgdG9vbHRpcFxuXHRcdFx0XHR0b29sdGlwU2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG1vZGVsKTtcblx0XHRcdFx0YWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMsIHRvb2x0aXBTaXplKTtcblx0XHRcdFx0Ly8gRmluYWwgU2l6ZSBhbmQgUG9zaXRpb25cblx0XHRcdFx0YmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG1vZGVsLCB0b29sdGlwU2l6ZSwgYWxpZ25tZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vZGVsLm9wYWNpdHkgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdFx0bW9kZWwueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblx0XHRcdG1vZGVsLnggPSBiYWNrZ3JvdW5kUG9pbnQueDtcblx0XHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcblx0XHRcdG1vZGVsLndpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XG5cdFx0XHRtb2RlbC5oZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XG5cblx0XHRcdC8vIFBvaW50IHdoZXJlIHRoZSBjYXJldCBvbiB0aGUgdG9vbHRpcCBwb2ludHMgdG9cblx0XHRcdG1vZGVsLmNhcmV0WCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdFx0bW9kZWwuY2FyZXRZID0gdG9vbHRpcFBvc2l0aW9uLnk7XG5cblx0XHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xuXG5cdFx0XHRpZiAoY2hhbmdlZCAmJiBvcHRzLmN1c3RvbSkge1xuXHRcdFx0XHRvcHRzLmN1c3RvbS5jYWxsKG1lLCBtb2RlbCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZTtcblx0XHR9LFxuXHRcdGRyYXdDYXJldDogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHZhciBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pO1xuXG5cdFx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuXHRcdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcblx0XHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG5cdFx0fSxcblx0XHRnZXRDYXJldFBvc2l0aW9uOiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIHZtKSB7XG5cdFx0XHR2YXIgeDEsIHgyLCB4MywgeTEsIHkyLCB5Mztcblx0XHRcdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdFx0XHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHRcdFx0dmFyIHhBbGlnbiA9IHZtLnhBbGlnbjtcblx0XHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0XHR2YXIgcHRYID0gdG9vbHRpcFBvaW50Lng7XG5cdFx0XHR2YXIgcHRZID0gdG9vbHRpcFBvaW50Lnk7XG5cdFx0XHR2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0dmFyIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG5cdFx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0XHR5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0XHR4MSA9IHB0WDtcblx0XHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHRcdHgzID0geDE7XG5cblx0XHRcdFx0XHR5MSA9IHkyICsgY2FyZXRTaXplO1xuXHRcdFx0XHRcdHkzID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSBwdFggKyB3aWR0aDtcblx0XHRcdFx0XHR4MiA9IHgxICsgY2FyZXRTaXplO1xuXHRcdFx0XHRcdHgzID0geDE7XG5cblx0XHRcdFx0XHR5MSA9IHkyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHRcdHkzID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHRcdHgyID0gcHRYICsgY29ybmVyUmFkaXVzICsgKGNhcmV0U2l6ZSk7XG5cdFx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHRcdHgyID0gcHRYICsgd2lkdGggLSBjb3JuZXJSYWRpdXMgLSBjYXJldFNpemU7XG5cdFx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHgyID0gcHRYICsgKHdpZHRoIC8gMik7XG5cdFx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHRcdFx0eTEgPSBwdFk7XG5cdFx0XHRcdFx0eTIgPSB5MSAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR5MyA9IHkxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkxID0gcHRZICsgaGVpZ2h0O1xuXHRcdFx0XHRcdHkyID0geTEgKyBjYXJldFNpemU7XG5cdFx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdFx0XHQvLyBpbnZlcnQgZHJhd2luZyBvcmRlclxuXHRcdFx0XHRcdHZhciB0bXAgPSB4Mztcblx0XHRcdFx0XHR4MyA9IHgxO1xuXHRcdFx0XHRcdHgxID0gdG1wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge3gxOiB4MSwgeDI6IHgyLCB4MzogeDMsIHkxOiB5MSwgeTI6IHkyLCB5MzogeTN9O1xuXHRcdH0sXG5cdFx0ZHJhd1RpdGxlOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgb3BhY2l0eSkge1xuXHRcdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XG5cblx0XHRcdGlmICh0aXRsZS5sZW5ndGgpIHtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl90aXRsZUFsaWduO1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdFx0dmFyIHRpdGxlRm9udFNpemUgPSB2bS50aXRsZUZvbnRTaXplO1xuXHRcdFx0XHR2YXIgdGl0bGVTcGFjaW5nID0gdm0udGl0bGVTcGFjaW5nO1xuXG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0udGl0bGVGb250Q29sb3IsIG9wYWNpdHkpO1xuXHRcdFx0XHRjdHguZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCB2bS5fdGl0bGVGb250U3R5bGUsIHZtLl90aXRsZUZvbnRGYW1pbHkpO1xuXG5cdFx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpdGxlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBwdC54LCBwdC55KTtcblx0XHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cblx0XHRcdFx0XHRpZiAoaSArIDEgPT09IHRpdGxlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cHQueSArPSB2bS50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZzsgLy8gSWYgTGFzdCwgYWRkIG1hcmdpbiwgcmVtb3ZlIHNwYWNpbmdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgb3BhY2l0eSkge1xuXHRcdFx0dmFyIGJvZHlGb250U2l6ZSA9IHZtLmJvZHlGb250U2l6ZTtcblx0XHRcdHZhciBib2R5U3BhY2luZyA9IHZtLmJvZHlTcGFjaW5nO1xuXHRcdFx0dmFyIGJvZHkgPSB2bS5ib2R5O1xuXG5cdFx0XHRjdHgudGV4dEFsaWduID0gdm0uX2JvZHlBbGlnbjtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblx0XHRcdGN0eC5mb250ID0gaGVscGVycy5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgdm0uX2JvZHlGb250U3R5bGUsIHZtLl9ib2R5Rm9udEZhbWlseSk7XG5cblx0XHRcdC8vIEJlZm9yZSBCb2R5XG5cdFx0XHR2YXIgeExpbmVQYWRkaW5nID0gMDtcblx0XHRcdHZhciBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIHB0LnggKyB4TGluZVBhZGRpbmcsIHB0LnkpO1xuXHRcdFx0XHRwdC55ICs9IGJvZHlGb250U2l6ZSArIGJvZHlTcGFjaW5nO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQmVmb3JlIGJvZHkgbGluZXNcblx0XHRcdGhlbHBlcnMuZWFjaCh2bS5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG5cblx0XHRcdHZhciBkcmF3Q29sb3JCb3hlcyA9IHZtLmRpc3BsYXlDb2xvcnM7XG5cdFx0XHR4TGluZVBhZGRpbmcgPSBkcmF3Q29sb3JCb3hlcyA/IChib2R5Rm9udFNpemUgKyAyKSA6IDA7XG5cblx0XHRcdC8vIERyYXcgYm9keSBsaW5lcyBub3dcblx0XHRcdGhlbHBlcnMuZWFjaChib2R5LCBmdW5jdGlvbihib2R5SXRlbSwgaSkge1xuXHRcdFx0XHRoZWxwZXJzLmVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKGJvZHlJdGVtLmxpbmVzLCBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdFx0Ly8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcblx0XHRcdFx0XHRpZiAoZHJhd0NvbG9yQm94ZXMpIHtcblx0XHRcdFx0XHRcdC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLmxlZ2VuZENvbG9yQmFja2dyb3VuZCwgb3BhY2l0eSk7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QocHQueCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0XHQvLyBCb3JkZXJcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLmxhYmVsQ29sb3JzW2ldLmJvcmRlckNvbG9yLCBvcGFjaXR5KTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KHB0LngsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdFx0Ly8gSW5uZXIgc3F1YXJlXG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLmxhYmVsQ29sb3JzW2ldLmJhY2tncm91bmRDb2xvciwgb3BhY2l0eSk7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QocHQueCArIDEsIHB0LnkgKyAxLCBib2R5Rm9udFNpemUgLSAyLCBib2R5Rm9udFNpemUgLSAyKTtcblx0XHRcdFx0XHRcdHZhciB0ZXh0Q29sb3IgPSBtZXJnZU9wYWNpdHkodm0ubGFiZWxUZXh0Q29sb3JzW2ldLCBvcGFjaXR5KTtcblx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmlsbExpbmVPZlRleHQobGluZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFJlc2V0IGJhY2sgdG8gMCBmb3IgYWZ0ZXIgYm9keVxuXHRcdFx0eExpbmVQYWRkaW5nID0gMDtcblxuXHRcdFx0Ly8gQWZ0ZXIgYm9keSBsaW5lc1xuXHRcdFx0aGVscGVycy5lYWNoKHZtLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXHRcdFx0cHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG5cdFx0fSxcblx0XHRkcmF3Rm9vdGVyOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgb3BhY2l0eSkge1xuXHRcdFx0dmFyIGZvb3RlciA9IHZtLmZvb3RlcjtcblxuXHRcdFx0aWYgKGZvb3Rlci5sZW5ndGgpIHtcblx0XHRcdFx0cHQueSArPSB2bS5mb290ZXJNYXJnaW5Ub3A7XG5cblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl9mb290ZXJBbGlnbjtcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0uZm9vdGVyRm9udENvbG9yLCBvcGFjaXR5KTtcblx0XHRcdFx0Y3R4LmZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcodm0uZm9vdGVyRm9udFNpemUsIHZtLl9mb290ZXJGb250U3R5bGUsIHZtLl9mb290ZXJGb250RmFtaWx5KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2goZm9vdGVyLCBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIHB0LngsIHB0LnkpO1xuXHRcdFx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyRm9udFNpemUgKyB2bS5mb290ZXJTcGFjaW5nO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRyYXdCYWNrZ3JvdW5kOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUsIG9wYWNpdHkpIHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0uYmFja2dyb3VuZENvbG9yLCBvcGFjaXR5KTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG1lcmdlT3BhY2l0eSh2bS5ib3JkZXJDb2xvciwgb3BhY2l0eSk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XG5cdFx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcblx0XHRcdHZhciB4ID0gcHQueDtcblx0XHRcdHZhciB5ID0gcHQueTtcblx0XHRcdHZhciB3aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdFx0dmFyIGhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblx0XHRcdHZhciByYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG5cdFx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0XHRpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuXHRcdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcblx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRcdFx0Y3R4LmZpbGwoKTtcblxuXHRcdFx0aWYgKHZtLmJvcmRlcldpZHRoID4gMCkge1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0XHRpZiAodm0ub3BhY2l0eSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0b29sdGlwU2l6ZSA9IHtcblx0XHRcdFx0d2lkdGg6IHZtLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHZtLmhlaWdodFxuXHRcdFx0fTtcblx0XHRcdHZhciBwdCA9IHtcblx0XHRcdFx0eDogdm0ueCxcblx0XHRcdFx0eTogdm0ueVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuXHRcdFx0dmFyIG9wYWNpdHkgPSBNYXRoLmFicyh2bS5vcGFjaXR5IDwgMWUtMykgPyAwIDogdm0ub3BhY2l0eTtcblxuXHRcdFx0Ly8gVHJ1dGh5L2ZhbHNleSB2YWx1ZSBmb3IgZW1wdHkgdG9vbHRpcFxuXHRcdFx0dmFyIGhhc1Rvb2x0aXBDb250ZW50ID0gdm0udGl0bGUubGVuZ3RoIHx8IHZtLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHZtLmJvZHkubGVuZ3RoIHx8IHZtLmFmdGVyQm9keS5sZW5ndGggfHwgdm0uZm9vdGVyLmxlbmd0aDtcblxuXHRcdFx0aWYgKHRoaXMuX29wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuXHRcdFx0XHQvLyBEcmF3IEJhY2tncm91bmRcblx0XHRcdFx0dGhpcy5kcmF3QmFja2dyb3VuZChwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUsIG9wYWNpdHkpO1xuXG5cdFx0XHRcdC8vIERyYXcgVGl0bGUsIEJvZHksIGFuZCBGb290ZXJcblx0XHRcdFx0cHQueCArPSB2bS54UGFkZGluZztcblx0XHRcdFx0cHQueSArPSB2bS55UGFkZGluZztcblxuXHRcdFx0XHQvLyBUaXRsZXNcblx0XHRcdFx0dGhpcy5kcmF3VGl0bGUocHQsIHZtLCBjdHgsIG9wYWNpdHkpO1xuXG5cdFx0XHRcdC8vIEJvZHlcblx0XHRcdFx0dGhpcy5kcmF3Qm9keShwdCwgdm0sIGN0eCwgb3BhY2l0eSk7XG5cblx0XHRcdFx0Ly8gRm9vdGVyXG5cdFx0XHRcdHRoaXMuZHJhd0Zvb3RlcihwdCwgdm0sIGN0eCwgb3BhY2l0eSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSBhbiBldmVudFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSB0b29sdGlwIGNoYW5nZWRcblx0XHQgKi9cblx0XHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRpb25zID0gbWUuX29wdGlvbnM7XG5cdFx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0XHRtZS5fbGFzdEFjdGl2ZSA9IG1lLl9sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcblx0XHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdFx0bWUuX2FjdGl2ZSA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuX2FjdGl2ZSA9IG1lLl9jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuXHRcdFx0Y2hhbmdlZCA9ICFoZWxwZXJzLmFycmF5RXF1YWxzKG1lLl9hY3RpdmUsIG1lLl9sYXN0QWN0aXZlKTtcblxuXHRcdFx0Ly8gSWYgdG9vbHRpcCBkaWRuJ3QgY2hhbmdlLCBkbyBub3QgaGFuZGxlIHRoZSB0YXJnZXQgZXZlbnRcblx0XHRcdGlmICghY2hhbmdlZCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmN1c3RvbSkge1xuXHRcdFx0XHRtZS5fZXZlbnRQb3NpdGlvbiA9IHtcblx0XHRcdFx0XHR4OiBlLngsXG5cdFx0XHRcdFx0eTogZS55XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdFx0XHRtZS51cGRhdGUodHJ1ZSk7XG5cdFx0XHRcdG1lLnBpdm90KCk7XG5cblx0XHRcdFx0Ly8gU2VlIGlmIG91ciB0b29sdGlwIHBvc2l0aW9uIGNoYW5nZWRcblx0XHRcdFx0Y2hhbmdlZCB8PSAobW9kZWwueCAhPT0gbWUuX21vZGVsLngpIHx8IChtb2RlbC55ICE9PSBtZS5fbW9kZWwueSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEBuYW1lc3BhY2UgQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVyc1xuXHQgKi9cblx0Q2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycyA9IHtcblx0XHQvKipcblx0XHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLmF2ZXJhZ2Vcblx0XHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0RWxlbWVudFtdfSB0aGUgZWxlbWVudHMgYmVpbmcgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwXG5cdFx0ICogQHJldHVybnMge1BvaW50fSB0b29sdGlwIHBvc2l0aW9uXG5cdFx0ICovXG5cdFx0YXZlcmFnZTogZnVuY3Rpb24oZWxlbWVudHMpIHtcblx0XHRcdGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGksIGxlbjtcblx0XHRcdHZhciB4ID0gMDtcblx0XHRcdHZhciB5ID0gMDtcblx0XHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuXHRcdFx0XHRcdHZhciBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcblx0XHRcdFx0XHR4ICs9IHBvcy54O1xuXHRcdFx0XHRcdHkgKz0gcG9zLnk7XG5cdFx0XHRcdFx0Kytjb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiBNYXRoLnJvdW5kKHggLyBjb3VudCksXG5cdFx0XHRcdHk6IE1hdGgucm91bmQoeSAvIGNvdW50KVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMubmVhcmVzdFxuXHRcdCAqIEBwYXJhbSBlbGVtZW50cyB7Q2hhcnQuRWxlbWVudFtdfSB0aGUgdG9vbHRpcCBlbGVtZW50c1xuXHRcdCAqIEBwYXJhbSBldmVudFBvc2l0aW9uIHtQb2ludH0gdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBpbiBjYW52YXMgY29vcmRpbmF0ZXNcblx0XHQgKiBAcmV0dXJucyB7UG9pbnR9IHRoZSB0b29sdGlwIHBvc2l0aW9uXG5cdFx0ICovXG5cdFx0bmVhcmVzdDogZnVuY3Rpb24oZWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcblx0XHRcdHZhciB4ID0gZXZlbnRQb3NpdGlvbi54O1xuXHRcdFx0dmFyIHkgPSBldmVudFBvc2l0aW9uLnk7XG5cdFx0XHR2YXIgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0XHR2YXIgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdFx0dmFyIGVsID0gZWxlbWVudHNbaV07XG5cdFx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG5cdFx0XHRcdFx0dmFyIGQgPSBoZWxwZXJzLmRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG5cdFx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkO1xuXHRcdFx0XHRcdFx0bmVhcmVzdEVsZW1lbnQgPSBlbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5lYXJlc3RFbGVtZW50KSB7XG5cdFx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0XHR4ID0gdHAueDtcblx0XHRcdFx0eSA9IHRwLnk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHlcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xufTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNixcIjQ1XCI6NDV9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKDI2KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRhcmM6IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiAnI2ZmZicsXG5cdFx0XHRib3JkZXJXaWR0aDogMlxuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudC5leHRlbmQoe1xuXHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRpZiAodm0pIHtcblx0XHRcdHJldHVybiAoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgPCBNYXRoLnBvdyh2bS5yYWRpdXMgKyB2bS5ob3ZlclJhZGl1cywgMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24oY2hhcnRYLCBjaGFydFkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHR2YXIgcG9pbnRSZWxhdGl2ZVBvc2l0aW9uID0gaGVscGVycy5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG5cdFx0XHR2YXJcdGFuZ2xlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmFuZ2xlO1xuXHRcdFx0dmFyIGRpc3RhbmNlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmRpc3RhbmNlO1xuXG5cdFx0XHQvLyBTYW5pdGlzZSBhbmdsZSByYW5nZVxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gdm0uZW5kQW5nbGU7XG5cdFx0XHR3aGlsZSAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XG5cdFx0XHRcdGVuZEFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoYW5nbGUgPiBlbmRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSAtPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBvcGVuL2Nsb3NlIGFuZ2xlXG5cdFx0XHR2YXIgYmV0d2VlbkFuZ2xlcyA9IChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciB3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gdm0uaW5uZXJSYWRpdXMgJiYgZGlzdGFuY2UgPD0gdm0ub3V0ZXJSYWRpdXMpO1xuXG5cdFx0XHRyZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBoYWxmQW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XG5cdFx0dmFyIGhhbGZSYWRpdXMgPSAodm0uaW5uZXJSYWRpdXMgKyB2bS5vdXRlclJhZGl1cykgLyAyO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG5cdFx0XHR5OiB2bS55ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpKSAqIChNYXRoLnBvdyh2bS5vdXRlclJhZGl1cywgMikgLSBNYXRoLnBvdyh2bS5pbm5lclJhZGl1cywgMikpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY2VudHJlQW5nbGUgPSB2bS5zdGFydEFuZ2xlICsgKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gMik7XG5cdFx0dmFyIHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgKE1hdGguY29zKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSksXG5cdFx0XHR5OiB2bS55ICsgKE1hdGguc2luKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSlcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgc0EgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdHZhciBlQSA9IHZtLmVuZEFuZ2xlO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5vdXRlclJhZGl1cywgc0EsIGVBKTtcblx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cblx0XHRjdHguZmlsbCgpO1xuXHRcdGN0eC5saW5lSm9pbiA9ICdiZXZlbCc7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGgpIHtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG59LHtcIjI1XCI6MjUsXCIyNlwiOjI2LFwiNDVcIjo0NX1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxudmFyIGdsb2JhbERlZmF1bHRzID0gZGVmYXVsdHMuZ2xvYmFsO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0bGluZToge1xuXHRcdFx0dGVuc2lvbjogMC40LFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogMyxcblx0XHRcdGJvcmRlckNvbG9yOiBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuXHRcdFx0Ym9yZGVyRGFzaDogW10sXG5cdFx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG5cdFx0XHRib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG5cdFx0XHRjYXBCZXppZXJQb2ludHM6IHRydWUsXG5cdFx0XHRmaWxsOiB0cnVlLCAvLyBkbyB3ZSBmaWxsIGluIHRoZSBhcmVhIGJldHdlZW4gdGhlIGxpbmUgYW5kIGl0cyBiYXNlIGF4aXNcblx0XHR9XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdm0gPSBtZS5fdmlldztcblx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcblx0XHR2YXIgc3BhbkdhcHMgPSB2bS5zcGFuR2Fwcztcblx0XHR2YXIgcG9pbnRzID0gbWUuX2NoaWxkcmVuLnNsaWNlKCk7IC8vIGNsb25lIGFycmF5XG5cdFx0dmFyIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIGxhc3REcmF3bkluZGV4ID0gLTE7XG5cdFx0dmFyIGluZGV4LCBjdXJyZW50LCBwcmV2aW91cywgY3VycmVudFZNO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGxvb3BpbmcsIGFkZGluZyB0aGUgZmlyc3QgcG9pbnQgYWdhaW5cblx0XHRpZiAobWUuX2xvb3AgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmUgT3B0aW9uc1xuXHRcdGN0eC5saW5lQ2FwID0gdm0uYm9yZGVyQ2FwU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckNhcFN0eWxlO1xuXG5cdFx0Ly8gSUUgOSBhbmQgMTAgZG8gbm90IHN1cHBvcnQgbGluZSBkYXNoXG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xuXHRcdH1cblxuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZtLmJvcmRlckRhc2hPZmZzZXQgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0Y3R4LmxpbmVKb2luID0gdm0uYm9yZGVySm9pblN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJKb2luU3R5bGU7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJXaWR0aDtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7XG5cblx0XHQvLyBTdHJva2UgTGluZVxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRsYXN0RHJhd25JbmRleCA9IC0xO1xuXG5cdFx0Zm9yIChpbmRleCA9IDA7IGluZGV4IDwgcG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuXHRcdFx0Y3VycmVudCA9IHBvaW50c1tpbmRleF07XG5cdFx0XHRwcmV2aW91cyA9IGhlbHBlcnMucHJldmlvdXNJdGVtKHBvaW50cywgaW5kZXgpO1xuXHRcdFx0Y3VycmVudFZNID0gY3VycmVudC5fdmlldztcblxuXHRcdFx0Ly8gRmlyc3QgcG9pbnQgbW92ZXMgdG8gaXQncyBzdGFydGluZyBwb3NpdGlvbiBubyBtYXR0ZXIgd2hhdFxuXHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0bGFzdERyYXduSW5kZXggPSBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJldmlvdXMgPSBsYXN0RHJhd25JbmRleCA9PT0gLTEgPyBwcmV2aW91cyA6IHBvaW50c1tsYXN0RHJhd25JbmRleF07XG5cblx0XHRcdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xuXHRcdFx0XHRcdGlmICgobGFzdERyYXduSW5kZXggIT09IChpbmRleCAtIDEpICYmICFzcGFuR2FwcykgfHwgbGFzdERyYXduSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGVyZSB3YXMgYSBnYXAgYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHBvaW50IGFmdGVyIHRoZSBnYXBcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTGluZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdFx0XHRoZWxwZXJzLmNhbnZhcy5saW5lVG8oY3R4LCBwcmV2aW91cy5fdmlldywgY3VycmVudC5fdmlldyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbn0se1wiMjVcIjoyNSxcIjI2XCI6MjYsXCI0NVwiOjQ1fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgyNik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG52YXIgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHBvaW50OiB7XG5cdFx0XHRyYWRpdXM6IDMsXG5cdFx0XHRwb2ludFN0eWxlOiAnY2lyY2xlJyxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdFx0Ly8gSG92ZXJcblx0XHRcdGhpdFJhZGl1czogMSxcblx0XHRcdGhvdmVyUmFkaXVzOiA0LFxuXHRcdFx0aG92ZXJCb3JkZXJXaWR0aDogMVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIHhSYW5nZShtb3VzZVgpIHtcblx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0cmV0dXJuIHZtID8gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzLCAyKSkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24geVJhbmdlKG1vdXNlWSkge1xuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRyZXR1cm4gdm0gPyAoTWF0aC5wb3cobW91c2VZIC0gdm0ueSwgMikgPCBNYXRoLnBvdyh2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMsIDIpKSA6IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQuZXh0ZW5kKHtcblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bSA/ICgoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB2bS55LCAyKSkgPCBNYXRoLnBvdyh2bS5oaXRSYWRpdXMgKyB2bS5yYWRpdXMsIDIpKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGluTGFiZWxSYW5nZTogeFJhbmdlLFxuXHRpblhSYW5nZTogeFJhbmdlLFxuXHRpbllSYW5nZTogeVJhbmdlLFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLl92aWV3LnJhZGl1cywgMik7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueSxcblx0XHRcdHBhZGRpbmc6IHZtLnJhZGl1cyArIHZtLmJvcmRlcldpZHRoXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBtb2RlbCA9IHRoaXMuX21vZGVsO1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHBvaW50U3R5bGUgPSB2bS5wb2ludFN0eWxlO1xuXHRcdHZhciByYWRpdXMgPSB2bS5yYWRpdXM7XG5cdFx0dmFyIHggPSB2bS54O1xuXHRcdHZhciB5ID0gdm0ueTtcblx0XHR2YXIgY29sb3IgPSBoZWxwZXJzLmNvbG9yO1xuXHRcdHZhciBlcnJNYXJnaW4gPSAxLjAxOyAvLyAxLjAxIGlzIG1hcmdpbiBmb3IgQWNjdW11bGF0ZWQgZXJyb3IuIChFc3BlY2lhbGx5IEVkZ2UsIElFLilcblx0XHR2YXIgcmF0aW8gPSAwO1xuXG5cdFx0aWYgKHZtLnNraXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBkZWZhdWx0Q29sb3I7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodm0uYm9yZGVyV2lkdGgsIGRlZmF1bHRzLmdsb2JhbC5lbGVtZW50cy5wb2ludC5ib3JkZXJXaWR0aCk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvciB8fCBkZWZhdWx0Q29sb3I7XG5cblx0XHQvLyBDbGlwaW5nIGZvciBQb2ludHMuXG5cdFx0Ly8gZ29pbmcgb3V0IGZyb20gaW5uZXIgY2hhckFyZWE/XG5cdFx0aWYgKChjaGFydEFyZWEgIT09IHVuZGVmaW5lZCkgJiYgKChtb2RlbC54IDwgY2hhcnRBcmVhLmxlZnQpIHx8IChjaGFydEFyZWEucmlnaHQgKiBlcnJNYXJnaW4gPCBtb2RlbC54KSB8fCAobW9kZWwueSA8IGNoYXJ0QXJlYS50b3ApIHx8IChjaGFydEFyZWEuYm90dG9tICogZXJyTWFyZ2luIDwgbW9kZWwueSkpKSB7XG5cdFx0XHQvLyBQb2ludCBmYWRlIG91dFxuXHRcdFx0aWYgKG1vZGVsLnggPCBjaGFydEFyZWEubGVmdCkge1xuXHRcdFx0XHRyYXRpbyA9ICh4IC0gbW9kZWwueCkgLyAoY2hhcnRBcmVhLmxlZnQgLSBtb2RlbC54KTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcnRBcmVhLnJpZ2h0ICogZXJyTWFyZ2luIDwgbW9kZWwueCkge1xuXHRcdFx0XHRyYXRpbyA9IChtb2RlbC54IC0geCkgLyAobW9kZWwueCAtIGNoYXJ0QXJlYS5yaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKG1vZGVsLnkgPCBjaGFydEFyZWEudG9wKSB7XG5cdFx0XHRcdHJhdGlvID0gKHkgLSBtb2RlbC55KSAvIChjaGFydEFyZWEudG9wIC0gbW9kZWwueSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJ0QXJlYS5ib3R0b20gKiBlcnJNYXJnaW4gPCBtb2RlbC55KSB7XG5cdFx0XHRcdHJhdGlvID0gKG1vZGVsLnkgLSB5KSAvIChtb2RlbC55IC0gY2hhcnRBcmVhLmJvdHRvbSk7XG5cdFx0XHR9XG5cdFx0XHRyYXRpbyA9IE1hdGgucm91bmQocmF0aW8gKiAxMDApIC8gMTAwO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29sb3IoY3R4LnN0cm9rZVN0eWxlKS5hbHBoYShyYXRpbykucmdiU3RyaW5nKCk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gY29sb3IoY3R4LmZpbGxTdHlsZSkuYWxwaGEocmF0aW8pLnJnYlN0cmluZygpO1xuXHRcdH1cblxuXHRcdGhlbHBlcnMuY2FudmFzLmRyYXdQb2ludChjdHgsIHBvaW50U3R5bGUsIHJhZGl1cywgeCwgeSk7XG5cdH1cbn0pO1xuXG59LHtcIjI1XCI6MjUsXCIyNlwiOjI2LFwiNDVcIjo0NX1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdib3R0b20nLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDBcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBpc1ZlcnRpY2FsKGJhcikge1xuXHRyZXR1cm4gYmFyLl92aWV3LndpZHRoICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSBiYXIge0NoYXJ0LkVsZW1lbnQuUmVjdGFuZ2xlfSB0aGUgYmFyXG4gKiBAcmV0dXJuIHtCb3VuZHN9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyKSB7XG5cdHZhciB2bSA9IGJhci5fdmlldztcblx0dmFyIHgxLCB4MiwgeTEsIHkyO1xuXG5cdGlmIChpc1ZlcnRpY2FsKGJhcikpIHtcblx0XHQvLyB2ZXJ0aWNhbFxuXHRcdHZhciBoYWxmV2lkdGggPSB2bS53aWR0aCAvIDI7XG5cdFx0eDEgPSB2bS54IC0gaGFsZldpZHRoO1xuXHRcdHgyID0gdm0ueCArIGhhbGZXaWR0aDtcblx0XHR5MSA9IE1hdGgubWluKHZtLnksIHZtLmJhc2UpO1xuXHRcdHkyID0gTWF0aC5tYXgodm0ueSwgdm0uYmFzZSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaG9yaXpvbnRhbCBiYXJcblx0XHR2YXIgaGFsZkhlaWdodCA9IHZtLmhlaWdodCAvIDI7XG5cdFx0eDEgPSBNYXRoLm1pbih2bS54LCB2bS5iYXNlKTtcblx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xuXHRcdHkxID0gdm0ueSAtIGhhbGZIZWlnaHQ7XG5cdFx0eTIgPSB2bS55ICsgaGFsZkhlaWdodDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogeDEsXG5cdFx0dG9wOiB5MSxcblx0XHRyaWdodDogeDIsXG5cdFx0Ym90dG9tOiB5MlxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHNpZ25YLCBzaWduWSwgYm9yZGVyU2tpcHBlZDtcblx0XHR2YXIgYm9yZGVyV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblxuXHRcdGlmICghdm0uaG9yaXpvbnRhbCkge1xuXHRcdFx0Ly8gYmFyXG5cdFx0XHRsZWZ0ID0gdm0ueCAtIHZtLndpZHRoIC8gMjtcblx0XHRcdHJpZ2h0ID0gdm0ueCArIHZtLndpZHRoIC8gMjtcblx0XHRcdHRvcCA9IHZtLnk7XG5cdFx0XHRib3R0b20gPSB2bS5iYXNlO1xuXHRcdFx0c2lnblggPSAxO1xuXHRcdFx0c2lnblkgPSBib3R0b20gPiB0b3AgPyAxIDogLTE7XG5cdFx0XHRib3JkZXJTa2lwcGVkID0gdm0uYm9yZGVyU2tpcHBlZCB8fCAnYm90dG9tJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaG9yaXpvbnRhbCBiYXJcblx0XHRcdGxlZnQgPSB2bS5iYXNlO1xuXHRcdFx0cmlnaHQgPSB2bS54O1xuXHRcdFx0dG9wID0gdm0ueSAtIHZtLmhlaWdodCAvIDI7XG5cdFx0XHRib3R0b20gPSB2bS55ICsgdm0uaGVpZ2h0IC8gMjtcblx0XHRcdHNpZ25YID0gcmlnaHQgPiBsZWZ0ID8gMSA6IC0xO1xuXHRcdFx0c2lnblkgPSAxO1xuXHRcdFx0Ym9yZGVyU2tpcHBlZCA9IHZtLmJvcmRlclNraXBwZWQgfHwgJ2xlZnQnO1xuXHRcdH1cblxuXHRcdC8vIENhbnZhcyBkb2Vzbid0IGFsbG93IHVzIHRvIHN0cm9rZSBpbnNpZGUgdGhlIHdpZHRoIHNvIHdlIGNhblxuXHRcdC8vIGFkanVzdCB0aGUgc2l6ZXMgdG8gZml0IGlmIHdlJ3JlIHNldHRpbmcgYSBzdHJva2Ugb24gdGhlIGxpbmVcblx0XHRpZiAoYm9yZGVyV2lkdGgpIHtcblx0XHRcdC8vIGJvcmRlcldpZHRoIHNob2xkIGJlIGxlc3MgdGhhbiBiYXIgd2lkdGggYW5kIGJhciBoZWlnaHQuXG5cdFx0XHR2YXIgYmFyU2l6ZSA9IE1hdGgubWluKE1hdGguYWJzKGxlZnQgLSByaWdodCksIE1hdGguYWJzKHRvcCAtIGJvdHRvbSkpO1xuXHRcdFx0Ym9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCA+IGJhclNpemUgPyBiYXJTaXplIDogYm9yZGVyV2lkdGg7XG5cdFx0XHR2YXIgaGFsZlN0cm9rZSA9IGJvcmRlcldpZHRoIC8gMjtcblx0XHRcdC8vIEFkanVzdCBib3JkZXJXaWR0aCB3aGVuIGJhciB0b3AgcG9zaXRpb24gaXMgbmVhciB2bS5iYXNlKHplcm8pLlxuXHRcdFx0dmFyIGJvcmRlckxlZnQgPSBsZWZ0ICsgKGJvcmRlclNraXBwZWQgIT09ICdsZWZ0JyA/IGhhbGZTdHJva2UgKiBzaWduWCA6IDApO1xuXHRcdFx0dmFyIGJvcmRlclJpZ2h0ID0gcmlnaHQgKyAoYm9yZGVyU2tpcHBlZCAhPT0gJ3JpZ2h0JyA/IC1oYWxmU3Ryb2tlICogc2lnblggOiAwKTtcblx0XHRcdHZhciBib3JkZXJUb3AgPSB0b3AgKyAoYm9yZGVyU2tpcHBlZCAhPT0gJ3RvcCcgPyBoYWxmU3Ryb2tlICogc2lnblkgOiAwKTtcblx0XHRcdHZhciBib3JkZXJCb3R0b20gPSBib3R0b20gKyAoYm9yZGVyU2tpcHBlZCAhPT0gJ2JvdHRvbScgPyAtaGFsZlN0cm9rZSAqIHNpZ25ZIDogMCk7XG5cdFx0XHQvLyBub3QgYmVjb21lIGEgdmVydGljYWwgbGluZT9cblx0XHRcdGlmIChib3JkZXJMZWZ0ICE9PSBib3JkZXJSaWdodCkge1xuXHRcdFx0XHR0b3AgPSBib3JkZXJUb3A7XG5cdFx0XHRcdGJvdHRvbSA9IGJvcmRlckJvdHRvbTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdCBiZWNvbWUgYSBob3Jpem9udGFsIGxpbmU/XG5cdFx0XHRpZiAoYm9yZGVyVG9wICE9PSBib3JkZXJCb3R0b20pIHtcblx0XHRcdFx0bGVmdCA9IGJvcmRlckxlZnQ7XG5cdFx0XHRcdHJpZ2h0ID0gYm9yZGVyUmlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuXG5cdFx0Ly8gQ29ybmVyIHBvaW50cywgZnJvbSBib3R0b20tbGVmdCB0byBib3R0b20tcmlnaHQgY2xvY2t3aXNlXG5cdFx0Ly8gfCAxIDIgfFxuXHRcdC8vIHwgMCAzIHxcblx0XHR2YXIgY29ybmVycyA9IFtcblx0XHRcdFtsZWZ0LCBib3R0b21dLFxuXHRcdFx0W2xlZnQsIHRvcF0sXG5cdFx0XHRbcmlnaHQsIHRvcF0sXG5cdFx0XHRbcmlnaHQsIGJvdHRvbV1cblx0XHRdO1xuXG5cdFx0Ly8gRmluZCBmaXJzdCAoc3RhcnRpbmcpIGNvcm5lciB3aXRoIGZhbGxiYWNrIHRvICdib3R0b20nXG5cdFx0dmFyIGJvcmRlcnMgPSBbJ2JvdHRvbScsICdsZWZ0JywgJ3RvcCcsICdyaWdodCddO1xuXHRcdHZhciBzdGFydENvcm5lciA9IGJvcmRlcnMuaW5kZXhPZihib3JkZXJTa2lwcGVkLCAwKTtcblx0XHRpZiAoc3RhcnRDb3JuZXIgPT09IC0xKSB7XG5cdFx0XHRzdGFydENvcm5lciA9IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29ybmVyQXQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBjb3JuZXJzWyhzdGFydENvcm5lciArIGluZGV4KSAlIDRdO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgcmVjdGFuZ2xlIGZyb20gJ3N0YXJ0Q29ybmVyJ1xuXHRcdHZhciBjb3JuZXIgPSBjb3JuZXJBdCgwKTtcblx0XHRjdHgubW92ZVRvKGNvcm5lclswXSwgY29ybmVyWzFdKTtcblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRjb3JuZXIgPSBjb3JuZXJBdChpKTtcblx0XHRcdGN0eC5saW5lVG8oY29ybmVyWzBdLCBjb3JuZXJbMV0pO1xuXHRcdH1cblxuXHRcdGN0eC5maWxsKCk7XG5cdFx0aWYgKGJvcmRlcldpZHRoKSB7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0uYmFzZSAtIHZtLnk7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHR2YXIgaW5SYW5nZSA9IGZhbHNlO1xuXG5cdFx0aWYgKHRoaXMuX3ZpZXcpIHtcblx0XHRcdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModGhpcyk7XG5cdFx0XHRpblJhbmdlID0gbW91c2VYID49IGJvdW5kcy5sZWZ0ICYmIG1vdXNlWCA8PSBib3VuZHMucmlnaHQgJiYgbW91c2VZID49IGJvdW5kcy50b3AgJiYgbW91c2VZIDw9IGJvdW5kcy5ib3R0b207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluUmFuZ2U7XG5cdH0sXG5cblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKCFtZS5fdmlldykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpblJhbmdlID0gZmFsc2U7XG5cdFx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyhtZSk7XG5cblx0XHRpZiAoaXNWZXJ0aWNhbChtZSkpIHtcblx0XHRcdGluUmFuZ2UgPSBtb3VzZVggPj0gYm91bmRzLmxlZnQgJiYgbW91c2VYIDw9IGJvdW5kcy5yaWdodDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5SYW5nZSA9IG1vdXNlWSA+PSBib3VuZHMudG9wICYmIG1vdXNlWSA8PSBib3VuZHMuYm90dG9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBpblJhbmdlO1xuXHR9LFxuXG5cdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHR2YXIgYm91bmRzID0gZ2V0QmFyQm91bmRzKHRoaXMpO1xuXHRcdHJldHVybiBtb3VzZVggPj0gYm91bmRzLmxlZnQgJiYgbW91c2VYIDw9IGJvdW5kcy5yaWdodDtcblx0fSxcblxuXHRpbllSYW5nZTogZnVuY3Rpb24obW91c2VZKSB7XG5cdFx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh0aGlzKTtcblx0XHRyZXR1cm4gbW91c2VZID49IGJvdW5kcy50b3AgJiYgbW91c2VZIDw9IGJvdW5kcy5ib3R0b207XG5cdH0sXG5cblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIHgsIHk7XG5cdFx0aWYgKGlzVmVydGljYWwodGhpcykpIHtcblx0XHRcdHggPSB2bS54O1xuXHRcdFx0eSA9ICh2bS55ICsgdm0uYmFzZSkgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gKHZtLnggKyB2bS5iYXNlKSAvIDI7XG5cdFx0XHR5ID0gdm0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3g6IHgsIHk6IHl9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHZtLndpZHRoICogTWF0aC5hYnModm0ueSAtIHZtLmJhc2UpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9XG59KTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNn1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcbm1vZHVsZS5leHBvcnRzLkFyYyA9IHJlcXVpcmUoMzYpO1xubW9kdWxlLmV4cG9ydHMuTGluZSA9IHJlcXVpcmUoMzcpO1xubW9kdWxlLmV4cG9ydHMuUG9pbnQgPSByZXF1aXJlKDM4KTtcbm1vZHVsZS5leHBvcnRzLlJlY3RhbmdsZSA9IHJlcXVpcmUoMzkpO1xuXG59LHtcIjM2XCI6MzYsXCIzN1wiOjM3LFwiMzhcIjozOCxcIjM5XCI6Mzl9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0Mik7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNhbnZhc1xuICovXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGBjaGFydGAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGZvciB3aGljaCB0byBjbGVhciB0aGUgY2FudmFzLlxuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Y2hhcnQuY3R4LmNsZWFyUmVjdCgwLCAwLCBjaGFydC53aWR0aCwgY2hhcnQuaGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIFwicGF0aFwiIGZvciBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyBhdCBwb3NpdGlvbiAoeCwgeSkgd2l0aCBhXG5cdCAqIGdpdmVuIHNpemUgKHdpZHRoLCBoZWlnaHQpIGFuZCB0aGUgc2FtZSBgcmFkaXVzYCBmb3IgYWxsIGNvcm5lcnMuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBUaGUgY2FudmFzIDJEIENvbnRleHQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgeSBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgcmVjdGFuZ2xlJ3Mgd2lkdGguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVjdGFuZ2xlJ3MgaGVpZ2h0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gVGhlIHJvdW5kZWQgYW1vdW50IChpbiBwaXhlbHMpIGZvciB0aGUgZm91ciBjb3JuZXJzLlxuXHQgKiBAdG9kbyBoYW5kbGUgYHJhZGl1c2AgYXMgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdCBhcnJheS9vYmplY3Q/XG5cdCAqL1xuXHRyb3VuZGVkUmVjdDogZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHR2YXIgcnggPSBNYXRoLm1pbihyYWRpdXMsIHdpZHRoIC8gMik7XG5cdFx0XHR2YXIgcnkgPSBNYXRoLm1pbihyYWRpdXMsIGhlaWdodCAvIDIpO1xuXG5cdFx0XHRjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcblx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcnkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJ4LCB5ICsgaGVpZ2h0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcblx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByeSk7XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgKyByeSk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcngsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhd1BvaW50OiBmdW5jdGlvbihjdHgsIHN0eWxlLCByYWRpdXMsIHgsIHkpIHtcblx0XHR2YXIgdHlwZSwgZWRnZUxlbmd0aCwgeE9mZnNldCwgeU9mZnNldCwgaGVpZ2h0LCBzaXplO1xuXG5cdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIHggLSBzdHlsZS53aWR0aCAvIDIsIHkgLSBzdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3dpdGNoIChzdHlsZSkge1xuXHRcdC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndHJpYW5nbGUnOlxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0ZWRnZUxlbmd0aCA9IDMgKiByYWRpdXMgLyBNYXRoLnNxcnQoMyk7XG5cdFx0XHRoZWlnaHQgPSBlZGdlTGVuZ3RoICogTWF0aC5zcXJ0KDMpIC8gMjtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIGVkZ2VMZW5ndGggLyAyLCB5ICsgaGVpZ2h0IC8gMyk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBlZGdlTGVuZ3RoIC8gMiwgeSArIGhlaWdodCAvIDMpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4LCB5IC0gMiAqIGhlaWdodCAvIDMpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3QnOlxuXHRcdFx0c2l6ZSA9IDEgLyBNYXRoLlNRUlQyICogcmFkaXVzO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcblx0XHRcdGN0eC5zdHJva2VSZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3RSb3VuZGVkJzpcblx0XHRcdHZhciBvZmZzZXQgPSByYWRpdXMgLyBNYXRoLlNRUlQyO1xuXHRcdFx0dmFyIGxlZnRYID0geCAtIG9mZnNldDtcblx0XHRcdHZhciB0b3BZID0geSAtIG9mZnNldDtcblx0XHRcdHZhciBzaWRlU2l6ZSA9IE1hdGguU1FSVDIgKiByYWRpdXM7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLnJvdW5kZWRSZWN0KGN0eCwgbGVmdFgsIHRvcFksIHNpZGVTaXplLCBzaWRlU2l6ZSwgcmFkaXVzIC8gMik7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdFJvdCc6XG5cdFx0XHRzaXplID0gMSAvIE1hdGguU1FSVDIgKiByYWRpdXM7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHggLSBzaXplLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCwgeSArIHNpemUpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgc2l6ZSwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgLSBzaXplKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdjcm9zcyc6XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4LCB5IC0gcmFkaXVzKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHJhZGl1cywgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY3Jvc3NSb3QnOlxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKE1hdGguUEkgLyA0KSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihNYXRoLlBJIC8gNCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdGFyJzpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSArIHJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgLSByYWRpdXMpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0gcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSk7XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MoTWF0aC5QSSAvIDQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKE1hdGguUEkgLyA0KSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0gcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdkYXNoJzpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHR9LFxuXG5cdGNsaXBBcmVhOiBmdW5jdGlvbihjdHgsIGFyZWEpIHtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcblx0XHRjdHguY2xpcCgpO1xuXHR9LFxuXG5cdHVuY2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH0sXG5cblx0bGluZVRvOiBmdW5jdGlvbihjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcblx0XHRpZiAodGFyZ2V0LnN0ZXBwZWRMaW5lKSB7XG5cdFx0XHRpZiAoKHRhcmdldC5zdGVwcGVkTGluZSA9PT0gJ2FmdGVyJyAmJiAhZmxpcCkgfHwgKHRhcmdldC5zdGVwcGVkTGluZSAhPT0gJ2FmdGVyJyAmJiBmbGlwKSkge1xuXHRcdFx0XHRjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGFyZ2V0LnRlbnNpb24pIHtcblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmV6aWVyQ3VydmVUbyhcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1ggOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WCxcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1kgOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WSxcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFggOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNYLFxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WSA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1ksXG5cdFx0XHR0YXJnZXQueCxcblx0XHRcdHRhcmdldC55KTtcblx0fVxufTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5jbGVhciBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNsZWFyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmNsZWFyID0gZXhwb3J0cy5jbGVhcjtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzLnJvdW5kZWRSZWN0IGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZHJhd1JvdW5kZWRSZWN0YW5nbGVcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuZHJhd1JvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbihjdHgpIHtcblx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRleHBvcnRzLnJvdW5kZWRSZWN0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG5cdGN0eC5jbG9zZVBhdGgoKTtcbn07XG5cbn0se1wiNDJcIjo0Mn1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnNcbiAqL1xudmFyIGhlbHBlcnMgPSB7XG5cdC8qKlxuXHQgKiBBbiBlbXB0eSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgZm9yIG9wdGlvbmFsIGNhbGxiYWNrLlxuXHQgKi9cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdHVpZDogKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZCA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGlkKys7XG5cdFx0fTtcblx0fSgpKSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc051bGxPclVuZGVmOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc09iamVjdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZU9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gYXJyYXkgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIFRoZSBhcnJheSB0byBsb29rdXAgZm9yIHZhbHVlIGF0IGBpbmRleGAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVbaW5kZXhdYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVBdEluZGV4T3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuXHQgKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihmbiwgYXJncywgdGhpc0FyZykge1xuXHRcdGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG5cdCAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuXHQgKi9cblx0ZWFjaDogZnVuY3Rpb24obG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG5cdFx0dmFyIGksIGxlbiwga2V5cztcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xuXHRcdFx0bGVuID0gbG9vcGFibGUubGVuZ3RoO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNPYmplY3QobG9vcGFibGUpKSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuXHRcdFx0bGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0ODUzOTc0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHBhcmFtIHtBcnJheX0gYTEgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICovXG5cdGFycmF5RXF1YWxzOiBmdW5jdGlvbihhMCwgYTEpIHtcblx0XHR2YXIgaSwgaWxlbiwgdjAsIHYxO1xuXG5cdFx0aWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2MCA9IGEwW2ldO1xuXHRcdFx0djEgPSBhMVtpXTtcblxuXHRcdFx0aWYgKHYwIGluc3RhbmNlb2YgQXJyYXkgJiYgdjEgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRpZiAoIWhlbHBlcnMuYXJyYXlFcXVhbHModjAsIHYxKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2MCAhPT0gdjEpIHtcblx0XHRcdFx0Ly8gTk9URTogdHdvIGRpZmZlcmVudCBvYmplY3QgaW5zdGFuY2VzIHdpbGwgbmV2ZXIgYmUgZXF1YWw6IHt4OjIwfSAhPSB7eDoyMH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cblx0ICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Y2xvbmU6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkoc291cmNlKSkge1xuXHRcdFx0cmV0dXJuIHNvdXJjZS5tYXAoaGVscGVycy5jbG9uZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0dmFyIHRhcmdldCA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXHRcdFx0dmFyIGtsZW4gPSBrZXlzLmxlbmd0aDtcblx0XHRcdHZhciBrID0gMDtcblxuXHRcdFx0Zm9yICg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0dGFyZ2V0W2tleXNba11dID0gaGVscGVycy5jbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzb3VyY2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cblx0ICogTm90ZShTQik6IHRoaXMgbWV0aG9kIGlzIGFsc28gdXNlZCBieSBjb25maWdNZXJnZSBhbmQgc2NhbGVNZXJnZSBhcyBmYWxsYmFjay5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9tZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldO1xuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRpZiAoaGVscGVycy5pc09iamVjdCh0dmFsKSAmJiBoZWxwZXJzLmlzT2JqZWN0KHN2YWwpKSB7XG5cdFx0XHRoZWxwZXJzLm1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgc291cmNlW2tleV0gaW4gdGFyZ2V0W2tleV0gb25seSBpZiB0YXJnZXRba2V5XSBpcyB1bmRlZmluZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VySWY6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldO1xuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRpZiAoaGVscGVycy5pc09iamVjdCh0dmFsKSAmJiBoZWxwZXJzLmlzT2JqZWN0KHN2YWwpKSB7XG5cdFx0XHRoZWxwZXJzLm1lcmdlSWYodHZhbCwgc3ZhbCk7XG5cdFx0fSBlbHNlIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycy5jbG9uZShzdmFsKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG5cdCAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cblx0ICogQHBhcmFtIHtPYmplY3R8QXJyYXkoT2JqZWN0KX0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBNZXJnaW5nIG9wdGlvbnM6XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm1lcmdlcl0gLSBUaGUgbWVyZ2UgbWV0aG9kIChrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYHRhcmdldGAgb2JqZWN0LlxuXHQgKi9cblx0bWVyZ2U6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHNvdXJjZXMgPSBoZWxwZXJzLmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuXHRcdHZhciBpbGVuID0gc291cmNlcy5sZW5ndGg7XG5cdFx0dmFyIG1lcmdlLCBpLCBrZXlzLCBrbGVuLCBrO1xuXG5cdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHRhcmdldCkpIHtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0bWVyZ2UgPSBvcHRpb25zLm1lcmdlciB8fCBoZWxwZXJzLl9tZXJnZXI7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXHRcdFx0Zm9yIChrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdG1lcmdlKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgKm9ubHkqIGlmIG5vdCBkZWZpbmVkIGluIHRhcmdldC5cblx0ICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheShPYmplY3QpfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlSWY6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IGhlbHBlcnMuX21lcmdlcklmfSk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGVscGVycztcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbGxiYWNrIGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5jYWxsQ2FsbGJhY2tcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuY2FsbENhbGxiYWNrID0gaGVscGVycy5jYWxsYmFjaztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGluc3RlYWQuXG4gKiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhLCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuaW5kZXhPZlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb21JbmRleCkge1xuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSwgZnJvbUluZGV4KTtcbn07XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlT3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG59LHt9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0Mik7XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQHNlZSBodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuICovXG52YXIgZWZmZWN0cyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQ7XG5cdH0sXG5cblx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtdCAqICh0IC0gMik7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5DdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtKCh0ID0gdCAtIDEpICogdCAqIHQgKiB0IC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJblF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluU2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpICsgMTtcblx0fSxcblxuXHRlYXNlT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkgLyAyKSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG5cdH0sXG5cblx0ZWFzZU91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQ2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID49IDEpIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VPdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKHQgPSB0IC0gMSkgKiB0KTtcblx0fSxcblxuXHRlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0fSxcblxuXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjM7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA9PT0gMikge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuNDU7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdGlmICh0IDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cdH0sXG5cdGVhc2VJbkJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG5cdH0sXG5cblx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpO1xuXHR9LFxuXG5cdGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8ICgxIC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiB0ICogdDtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMiAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAwLjc1O1xuXHRcdH1cblx0XHRpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIDAuOTM3NTtcblx0XHR9XG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NTtcblx0fSxcblxuXHRlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8IDAuNSkge1xuXHRcdFx0cmV0dXJuIGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNTtcblx0XHR9XG5cdFx0cmV0dXJuIGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41O1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0ZWZmZWN0czogZWZmZWN0c1xufTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzIGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5lYXNpbmdFZmZlY3RzXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmVhc2luZ0VmZmVjdHMgPSBlZmZlY3RzO1xuXG59LHtcIjQyXCI6NDJ9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0Mik7XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMub3B0aW9uc1xuICogQG5hbWVzcGFjZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHR0b0xpbmVIZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBzaXplKSB7XG5cdFx0dmFyIG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xuXHRcdGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuXHRcdFx0cmV0dXJuIHNpemUgKiAxLjI7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSArbWF0Y2hlc1syXTtcblxuXHRcdHN3aXRjaCAobWF0Y2hlc1szXSkge1xuXHRcdGNhc2UgJ3B4Jzpcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRjYXNlICclJzpcblx0XHRcdHZhbHVlIC89IDEwMDtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gc2l6ZSAqIHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcblx0ICogIGVsc2UsIGlmIGFuZCBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9QYWRkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciB0LCByLCBiLCBsO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xuXHRcdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xuXHRcdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogdCxcblx0XHRcdHJpZ2h0OiByLFxuXHRcdFx0Ym90dG9tOiBiLFxuXHRcdFx0bGVmdDogbCxcblx0XHRcdGhlaWdodDogdCArIGIsXG5cdFx0XHR3aWR0aDogbCArIHJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtBcnJheVtdfSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuXHQgKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcblx0ICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRyZXNvbHZlOiBmdW5jdGlvbihpbnB1dHMsIGNvbnRleHQsIGluZGV4KSB7XG5cdFx0dmFyIGksIGlsZW4sIHZhbHVlO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHZhbHVlID0gaW5wdXRzW2ldO1xuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaGVscGVycy5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW2luZGV4XTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbn0se1wiNDJcIjo0Mn1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKDQyKTtcbm1vZHVsZS5leHBvcnRzLmVhc2luZyA9IHJlcXVpcmUoNDMpO1xubW9kdWxlLmV4cG9ydHMuY2FudmFzID0gcmVxdWlyZSg0MSk7XG5tb2R1bGUuZXhwb3J0cy5vcHRpb25zID0gcmVxdWlyZSg0NCk7XG5cbn0se1wiNDFcIjo0MSxcIjQyXCI6NDIsXCI0M1wiOjQzLFwiNDRcIjo0NH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcblx0fVxufTtcblxufSx7fV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBDaGFydC5QbGF0Zm9ybSBpbXBsZW1lbnRhdGlvbiBmb3IgdGFyZ2V0aW5nIGEgd2ViIGJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbnZhciBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG52YXIgQ1NTX1BSRUZJWCA9ICdjaGFydGpzLSc7XG52YXIgQ1NTX1JFTkRFUl9NT05JVE9SID0gQ1NTX1BSRUZJWCArICdyZW5kZXItbW9uaXRvcic7XG52YXIgQ1NTX1JFTkRFUl9BTklNQVRJT04gPSBDU1NfUFJFRklYICsgJ3JlbmRlci1hbmltYXRpb24nO1xudmFyIEFOSU1BVElPTl9TVEFSVF9FVkVOVFMgPSBbJ2FuaW1hdGlvbnN0YXJ0JywgJ3dlYmtpdEFuaW1hdGlvblN0YXJ0J107XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbnZhciBFVkVOVF9UWVBFUyA9IHtcblx0dG91Y2hzdGFydDogJ21vdXNlZG93bicsXG5cdHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG5cdHRvdWNoZW5kOiAnbW91c2V1cCcsXG5cdHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuXHRwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG5cdHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcblx0cG9pbnRlcnVwOiAnbW91c2V1cCcsXG5cdHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0Jyxcblx0cG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuZnVuY3Rpb24gcmVhZFVzZWRTaXplKGVsZW1lbnQsIHByb3BlcnR5KSB7XG5cdHZhciB2YWx1ZSA9IGhlbHBlcnMuZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuXHR2YXIgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuXHRyZXR1cm4gbWF0Y2hlcyA/IE51bWJlcihtYXRjaGVzWzFdKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGNvbmZpZykge1xuXHR2YXIgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG5cblx0Ly8gTk9URShTQikgY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAhPT0gY2FudmFzLndpZHRoOiBpbiB0aGUgZmlyc3QgY2FzZSBpdFxuXHQvLyByZXR1cm5zIG51bGwgb3IgJycgaWYgbm8gZXhwbGljaXQgdmFsdWUgaGFzIGJlZW4gc2V0IHRvIHRoZSBjYW52YXMgYXR0cmlidXRlLlxuXHR2YXIgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG5cdHZhciByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cblx0Ly8gQ2hhcnQuanMgbW9kaWZpZXMgc29tZSBjYW52YXMgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byByZXN0b3JlIG9uIGRlc3Ryb3lcblx0Y2FudmFzW0VYUEFORE9fS0VZXSA9IHtcblx0XHRpbml0aWFsOiB7XG5cdFx0XHRoZWlnaHQ6IHJlbmRlckhlaWdodCxcblx0XHRcdHdpZHRoOiByZW5kZXJXaWR0aCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG5cdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuXHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGhcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxuXHQvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNTM4XG5cdHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG5cblx0aWYgKHJlbmRlcldpZHRoID09PSBudWxsIHx8IHJlbmRlcldpZHRoID09PSAnJykge1xuXHRcdHZhciBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcblx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRpZiAocmVuZGVySGVpZ2h0ID09PSBudWxsIHx8IHJlbmRlckhlaWdodCA9PT0gJycpIHtcblx0XHRpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcblx0XHRcdC8vIElmIG5vIGV4cGxpY2l0IHJlbmRlciBoZWlnaHQgYW5kIHN0eWxlIGhlaWdodCwgbGV0J3MgYXBwbHkgdGhlIGFzcGVjdCByYXRpbyxcblx0XHRcdC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuXHRcdFx0Ly8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGNvbmZpZy5vcHRpb25zLmFzcGVjdFJhdGlvIHx8IDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcblx0XHRcdGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2FudmFzO1xufVxuXG4vKipcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgc3VwcG9ydHMgPSBmYWxzZTtcblx0dHJ5IHtcblx0XHR2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdXBwb3J0cyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2UnLCBudWxsLCBvcHRpb25zKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3Jcblx0fVxuXHRyZXR1cm4gc3VwcG9ydHM7XG59KCkpO1xuXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDI4N1xudmFyIGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgeCwgeSwgbmF0aXZlRXZlbnQpIHtcblx0cmV0dXJuIHtcblx0XHR0eXBlOiB0eXBlLFxuXHRcdGNoYXJ0OiBjaGFydCxcblx0XHRuYXRpdmU6IG5hdGl2ZUV2ZW50IHx8IG51bGwsXG5cdFx0eDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG5cdFx0eTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG5cdH07XG59XG5cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcblx0dmFyIHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuXHR2YXIgcG9zID0gaGVscGVycy5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xuXHR2YXIgdGlja2luZyA9IGZhbHNlO1xuXHR2YXIgYXJncyA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuXG5cdFx0aWYgKCF0aWNraW5nKSB7XG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcblx0XHRcdGhlbHBlcnMucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRpY2tpbmcgPSBmYWxzZTtcblx0XHRcdFx0Zm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVyKGhhbmRsZXIpIHtcblx0dmFyIHJlc2l6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0dmFyIGNscyA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcblx0dmFyIG1heFNpemUgPSAxMDAwMDAwO1xuXHR2YXIgc3R5bGUgPVxuXHRcdCdwb3NpdGlvbjphYnNvbHV0ZTsnICtcblx0XHQnbGVmdDowOycgK1xuXHRcdCd0b3A6MDsnICtcblx0XHQncmlnaHQ6MDsnICtcblx0XHQnYm90dG9tOjA7JyArXG5cdFx0J292ZXJmbG93OmhpZGRlbjsnICtcblx0XHQncG9pbnRlci1ldmVudHM6bm9uZTsnICtcblx0XHQndmlzaWJpbGl0eTpoaWRkZW47JyArXG5cdFx0J3otaW5kZXg6LTE7JztcblxuXHRyZXNpemVyLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcblx0cmVzaXplci5jbGFzc05hbWUgPSBjbHM7XG5cdHJlc2l6ZXIuaW5uZXJIVE1MID1cblx0XHQnPGRpdiBjbGFzcz1cIicgKyBjbHMgKyAnLWV4cGFuZFwiIHN0eWxlPVwiJyArIHN0eWxlICsgJ1wiPicgK1xuXHRcdFx0JzxkaXYgc3R5bGU9XCInICtcblx0XHRcdFx0J3Bvc2l0aW9uOmFic29sdXRlOycgK1xuXHRcdFx0XHQnd2lkdGg6JyArIG1heFNpemUgKyAncHg7JyArXG5cdFx0XHRcdCdoZWlnaHQ6JyArIG1heFNpemUgKyAncHg7JyArXG5cdFx0XHRcdCdsZWZ0OjA7JyArXG5cdFx0XHRcdCd0b3A6MFwiPicgK1xuXHRcdFx0JzwvZGl2PicgK1xuXHRcdCc8L2Rpdj4nICtcblx0XHQnPGRpdiBjbGFzcz1cIicgKyBjbHMgKyAnLXNocmlua1wiIHN0eWxlPVwiJyArIHN0eWxlICsgJ1wiPicgK1xuXHRcdFx0JzxkaXYgc3R5bGU9XCInICtcblx0XHRcdFx0J3Bvc2l0aW9uOmFic29sdXRlOycgK1xuXHRcdFx0XHQnd2lkdGg6MjAwJTsnICtcblx0XHRcdFx0J2hlaWdodDoyMDAlOycgK1xuXHRcdFx0XHQnbGVmdDowOyAnICtcblx0XHRcdFx0J3RvcDowXCI+JyArXG5cdFx0XHQnPC9kaXY+JyArXG5cdFx0JzwvZGl2Pic7XG5cblx0dmFyIGV4cGFuZCA9IHJlc2l6ZXIuY2hpbGROb2Rlc1swXTtcblx0dmFyIHNocmluayA9IHJlc2l6ZXIuY2hpbGROb2Rlc1sxXTtcblxuXHRyZXNpemVyLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdGV4cGFuZC5zY3JvbGxMZWZ0ID0gbWF4U2l6ZTtcblx0XHRleHBhbmQuc2Nyb2xsVG9wID0gbWF4U2l6ZTtcblx0XHRzaHJpbmsuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdH07XG5cdHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0aGFuZGxlcigpO1xuXHR9O1xuXG5cdGFkZEV2ZW50TGlzdGVuZXIoZXhwYW5kLCAnc2Nyb2xsJywgb25TY3JvbGwuYmluZChleHBhbmQsICdleHBhbmQnKSk7XG5cdGFkZEV2ZW50TGlzdGVuZXIoc2hyaW5rLCAnc2Nyb2xsJywgb25TY3JvbGwuYmluZChzaHJpbmssICdzaHJpbmsnKSk7XG5cblx0cmV0dXJuIHJlc2l6ZXI7XG59XG5cbi8vIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2RldGVjdC1ub2RlLWluc2VydGlvblxuZnVuY3Rpb24gd2F0Y2hGb3JSZW5kZXIobm9kZSwgaGFuZGxlcikge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblx0dmFyIHByb3h5ID0gZXhwYW5kby5yZW5kZXJQcm94eSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5hbmltYXRpb25OYW1lID09PSBDU1NfUkVOREVSX0FOSU1BVElPTikge1xuXHRcdFx0aGFuZGxlcigpO1xuXHRcdH1cblx0fTtcblxuXHRoZWxwZXJzLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xuXHRcdGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgdHlwZSwgcHJveHkpO1xuXHR9KTtcblxuXHRub2RlLmNsYXNzTGlzdC5hZGQoQ1NTX1JFTkRFUl9NT05JVE9SKTtcbn1cblxuZnVuY3Rpb24gdW53YXRjaEZvclJlbmRlcihub2RlKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHk7XG5cblx0aWYgKHByb3h5KSB7XG5cdFx0aGVscGVycy5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgdHlwZSwgcHJveHkpO1xuXHRcdH0pO1xuXG5cdFx0ZGVsZXRlIGV4cGFuZG8ucmVuZGVyUHJveHk7XG5cdH1cblxuXHRub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ1NTX1JFTkRFUl9NT05JVE9SKTtcbn1cblxuZnVuY3Rpb24gYWRkUmVzaXplTGlzdGVuZXIobm9kZSwgbGlzdGVuZXIsIGNoYXJ0KSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXG5cdC8vIExldCdzIGtlZXAgdHJhY2sgb2YgdGhpcyBhZGRlZCByZXNpemVyIGFuZCB0aHVzIGF2b2lkIERPTSBxdWVyeSB3aGVuIHJlbW92aW5nIGl0LlxuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplciA9IGNyZWF0ZVJlc2l6ZXIodGhyb3R0bGVkKGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHJldHVybiBsaXN0ZW5lcihjcmVhdGVFdmVudCgncmVzaXplJywgY2hhcnQpKTtcblx0XHR9XG5cdH0pKTtcblxuXHQvLyBUaGUgcmVzaXplciBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZSBwYXJlbnQsIHNvIHdlIGZpcnN0IG5lZWQgdG8gYmVcblx0Ly8gc3VyZSB0aGF0IGBub2RlYCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NIGJlZm9yZSBpbmplY3RpbmcgdGhlIHJlc2l6ZXIgZWxlbWVudC5cblx0d2F0Y2hGb3JSZW5kZXIobm9kZSwgZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGV4cGFuZG8ucmVzaXplcikge1xuXHRcdFx0dmFyIGNvbnRhaW5lciA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdGlmIChjb250YWluZXIgJiYgY29udGFpbmVyICE9PSByZXNpemVyLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0Y29udGFpbmVyLmluc2VydEJlZm9yZShyZXNpemVyLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBjb250YWluZXIgc2l6ZSBtaWdodCBoYXZlIGNoYW5nZWQsIGxldCdzIHJlc2V0IHRoZSByZXNpemVyIHN0YXRlLlxuXHRcdFx0cmVzaXplci5fcmVzZXQoKTtcblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVSZXNpemVMaXN0ZW5lcihub2RlKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XG5cdHZhciByZXNpemVyID0gZXhwYW5kby5yZXNpemVyO1xuXG5cdGRlbGV0ZSBleHBhbmRvLnJlc2l6ZXI7XG5cdHVud2F0Y2hGb3JSZW5kZXIobm9kZSk7XG5cblx0aWYgKHJlc2l6ZXIgJiYgcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0cmVzaXplci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlc2l6ZXIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGluamVjdENTUyhwbGF0Zm9ybSwgY3NzKSB7XG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5MjIxMzlcblx0dmFyIHN0eWxlID0gcGxhdGZvcm0uX3N0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdGlmICghcGxhdGZvcm0uX3N0eWxlKSB7XG5cdFx0cGxhdGZvcm0uX3N0eWxlID0gc3R5bGU7XG5cdFx0Y3NzID0gJy8qIENoYXJ0LmpzICovXFxuJyArIGNzcztcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcblx0XHRkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fVxuXG5cdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgd2hldGhlciB0aGlzIHBsYXRmb3JtIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBrZXlmcmFtZXMgPSAnZnJvbXtvcGFjaXR5OjAuOTl9dG97b3BhY2l0eToxfSc7XG5cblx0XHRpbmplY3RDU1ModGhpcyxcblx0XHRcdC8vIERPTSByZW5kZXJpbmcgZGV0ZWN0aW9uXG5cdFx0XHQvLyBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cblx0XHRcdCdALXdlYmtpdC1rZXlmcmFtZXMgJyArIENTU19SRU5ERVJfQU5JTUFUSU9OICsgJ3snICsga2V5ZnJhbWVzICsgJ30nICtcblx0XHRcdCdAa2V5ZnJhbWVzICcgKyBDU1NfUkVOREVSX0FOSU1BVElPTiArICd7JyArIGtleWZyYW1lcyArICd9JyArXG5cdFx0XHQnLicgKyBDU1NfUkVOREVSX01PTklUT1IgKyAneycgK1xuXHRcdFx0XHQnLXdlYmtpdC1hbmltYXRpb246JyArIENTU19SRU5ERVJfQU5JTUFUSU9OICsgJyAwLjAwMXM7JyArXG5cdFx0XHRcdCdhbmltYXRpb246JyArIENTU19SRU5ERVJfQU5JTUFUSU9OICsgJyAwLjAwMXM7JyArXG5cdFx0XHQnfSdcblx0XHQpO1xuXHR9LFxuXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG5cdFx0fSBlbHNlIGlmIChpdGVtLmxlbmd0aCkge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG5cdFx0XHRpdGVtID0gaXRlbVswXTtcblx0XHR9XG5cblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0Ly8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuXHRcdC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHR2YXIgY29udGV4dCA9IGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgaXRlbSBpc1xuXHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcblx0XHQvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xuXHRcdC8vIGEgc3VmZmljaWVudCBjb25kaXRpb24gaWYgdGhlIGl0ZW0gaGFzIGEgY29udGV4dDJEIHdoaWNoIGhhcyBpdGVtIGFzIGBjYW52YXNgLlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuXHRcdGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBpdGVtKSB7XG5cdFx0XHRpbml0Q2FudmFzKGl0ZW0sIGNvbmZpZyk7XG5cdFx0XHRyZXR1cm4gY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcblx0XHRpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcblx0XHRbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0dmFyIHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcblx0XHRcdGlmIChoZWxwZXJzLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG5cdFx0XHRcdGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGhlbHBlcnMuZWFjaChpbml0aWFsLnN0eWxlIHx8IHt9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRjYW52YXMuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVGhlIGNhbnZhcyByZW5kZXIgc2l6ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCAoYW5kIHRodXMgdGhlIHN0YXRlIHN0YWNrIGRpc2NhcmRlZCksXG5cdFx0Ly8gd2UgY2FuJ3QgdXNlIHNhdmUoKSBhbmQgcmVzdG9yZSgpIHRvIHJlc3RvcmUgdGhlIGluaXRpYWwgc3RhdGUuIFNvIG1ha2Ugc3VyZSB0aGF0IGF0XG5cdFx0Ly8gbGVhc3QgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IHNldHRpbmcgdGhlIGNhbnZhcyB3aWR0aC5cblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDUyNS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbFxuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcblxuXHRcdGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuXHR9LFxuXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0YWRkUmVzaXplTGlzdGVuZXIoY2FudmFzLCBsaXN0ZW5lciwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IChsaXN0ZW5lcltFWFBBTkRPX0tFWV0gPSB7fSk7XG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwgKGV4cGFuZG8ucHJveGllcyA9IHt9KTtcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0bGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuXHRcdH07XG5cblx0XHRhZGRFdmVudExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0cmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FudmFzLCBsaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGFuZG8gPSBsaXN0ZW5lcltFWFBBTkRPX0tFWV0gfHwge307XG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwge307XG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdO1xuXHRcdGlmICghcHJveHkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9XG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWRkRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuYWRkRXZlbnQgPSBhZGRFdmVudExpc3RlbmVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLlxuICogRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5yZW1vdmVFdmVudFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5yZW1vdmVFdmVudCA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbn0se1wiNDVcIjo0NX1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcbnZhciBiYXNpYyA9IHJlcXVpcmUoNDYpO1xudmFyIGRvbSA9IHJlcXVpcmUoNDcpO1xuXG4vLyBAVE9ETyBNYWtlIHBvc3NpYmxlIHRvIHNlbGVjdCBhbm90aGVyIHBsYXRmb3JtIGF0IGJ1aWxkIHRpbWUuXG52YXIgaW1wbGVtZW50YXRpb24gPSBkb20uX2VuYWJsZWQgPyBkb20gOiBiYXNpYztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsYXRmb3JtXG4gKiBAc2VlIGh0dHBzOi8vY2hhcnRqcy5naXRib29rcy5pby9wcm9wb3NhbHMvY29udGVudC9QbGF0Zm9ybS5odG1sXG4gKiBAc2luY2UgMi40LjBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBoZWxwZXJzLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBuYXRpdmUgaXRlbSBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkIGluc3RhbmNlXG5cdCAqL1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtQ2hhcnQgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cblxufSwgaW1wbGVtZW50YXRpb24pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgSVBsYXRmb3JtXG4gKiBBbGxvd3MgYWJzdHJhY3RpbmcgcGxhdGZvcm0gZGVwZW5kZW5jaWVzIGF3YXkgZnJvbSB0aGUgY2hhcnRcbiAqIEBib3Jyb3dzIENoYXJ0LnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0IGFzIGFjcXVpcmVDb250ZXh0XG4gKiBAYm9ycm93cyBDaGFydC5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dCBhcyByZWxlYXNlQ29udGV4dFxuICogQGJvcnJvd3MgQ2hhcnQucGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lciBhcyBhZGRFdmVudExpc3RlbmVyXG4gKiBAYm9ycm93cyBDaGFydC5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyIGFzIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgSUV2ZW50XG4gKiBAcHJvcCB7U3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUgbmFtZSwgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAqICdjb250ZXh0bWVudScsICdtb3VzZWVudGVyJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdtb3VzZW91dCcsXG4gKiAnY2xpY2snLCAnZGJsY2xpY2snLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcgYW5kICdyZXNpemUnXG4gKiBAcHJvcCB7Kn0gbmF0aXZlIC0gVGhlIG9yaWdpbmFsIG5hdGl2ZSBldmVudCAobnVsbCBmb3IgZW11bGF0ZWQgZXZlbnRzLCBlLmcuICdyZXNpemUnKVxuICogQHByb3Age051bWJlcn0geCAtIFRoZSBtb3VzZSB4IHBvc2l0aW9uLCByZWxhdGl2ZSB0byB0aGUgY2FudmFzIChudWxsIGZvciBpbmNvbXBhdGlibGUgZXZlbnRzKVxuICogQHByb3Age051bWJlcn0geSAtIFRoZSBtb3VzZSB5IHBvc2l0aW9uLCByZWxhdGl2ZSB0byB0aGUgY2FudmFzIChudWxsIGZvciBpbmNvbXBhdGlibGUgZXZlbnRzKVxuICovXG5cbn0se1wiNDVcIjo0NSxcIjQ2XCI6NDYsXCI0N1wiOjQ3fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBQbHVnaW4gYmFzZWQgb24gZGlzY3Vzc2lvbiBmcm9tIHRoZSBmb2xsb3dpbmcgQ2hhcnQuanMgaXNzdWVzOlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjM4MCNpc3N1ZWNvbW1lbnQtMjc5OTYxNTY5XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDQwI2lzc3VlY29tbWVudC0yNTY0NjE4OTdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGVsZW1lbnRzID0gcmVxdWlyZSg0MCk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHtcblx0XHRmaWxsZXI6IHtcblx0XHRcdHByb3BhZ2F0ZTogdHJ1ZVxuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cblx0dmFyIG1hcHBlcnMgPSB7XG5cdFx0ZGF0YXNldDogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcblx0XHRcdHZhciBjaGFydCA9IHNvdXJjZS5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuXHRcdFx0dmFyIHBvaW50cyA9ICh2aXNpYmxlICYmIG1ldGEuZGF0YXNldC5fY2hpbGRyZW4pIHx8IFtdO1xuXHRcdFx0dmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggfHwgMDtcblxuXHRcdFx0cmV0dXJuICFsZW5ndGggPyBudWxsIDogZnVuY3Rpb24ocG9pbnQsIGkpIHtcblx0XHRcdFx0cmV0dXJuIChpIDwgbGVuZ3RoICYmIHBvaW50c1tpXS5fdmlldykgfHwgbnVsbDtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGJvdW5kYXJ5OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdHZhciBib3VuZGFyeSA9IHNvdXJjZS5ib3VuZGFyeTtcblx0XHRcdHZhciB4ID0gYm91bmRhcnkgPyBib3VuZGFyeS54IDogbnVsbDtcblx0XHRcdHZhciB5ID0gYm91bmRhcnkgPyBib3VuZGFyeS55IDogbnVsbDtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0eDogeCA9PT0gbnVsbCA/IHBvaW50LnggOiB4LFxuXHRcdFx0XHRcdHk6IHkgPT09IG51bGwgPyBwb2ludC55IDogeSxcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEB0b2RvIGlmIChmaWxsWzBdID09PSAnIycpXG5cdGZ1bmN0aW9uIGRlY29kZUZpbGwoZWwsIGluZGV4LCBjb3VudCkge1xuXHRcdHZhciBtb2RlbCA9IGVsLl9tb2RlbCB8fCB7fTtcblx0XHR2YXIgZmlsbCA9IG1vZGVsLmZpbGw7XG5cdFx0dmFyIHRhcmdldDtcblxuXHRcdGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGZpbGwgPSAhIW1vZGVsLmJhY2tncm91bmRDb2xvcjtcblx0XHR9XG5cblx0XHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChmaWxsID09PSB0cnVlKSB7XG5cdFx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsLCAxMCk7XG5cdFx0aWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcblx0XHRcdGlmIChmaWxsWzBdID09PSAnLScgfHwgZmlsbFswXSA9PT0gJysnKSB7XG5cdFx0XHRcdHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0c3dpdGNoIChmaWxsKSB7XG5cdFx0Ly8gY29tcGF0aWJpbGl0eVxuXHRcdGNhc2UgJ2JvdHRvbSc6XG5cdFx0XHRyZXR1cm4gJ3N0YXJ0Jztcblx0XHRjYXNlICd0b3AnOlxuXHRcdFx0cmV0dXJuICdlbmQnO1xuXHRcdGNhc2UgJ3plcm8nOlxuXHRcdFx0cmV0dXJuICdvcmlnaW4nO1xuXHRcdC8vIHN1cHBvcnRlZCBib3VuZGFyaWVzXG5cdFx0Y2FzZSAnb3JpZ2luJzpcblx0XHRjYXNlICdzdGFydCc6XG5cdFx0Y2FzZSAnZW5kJzpcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdC8vIGludmFsaWQgZmlsbCB2YWx1ZXNcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcblx0XHR2YXIgbW9kZWwgPSBzb3VyY2UuZWwuX21vZGVsIHx8IHt9O1xuXHRcdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XG5cdFx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgdGFyZ2V0ID0gbnVsbDtcblx0XHR2YXIgaG9yaXpvbnRhbDtcblxuXHRcdGlmIChpc0Zpbml0ZShmaWxsKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogdW50aWwgdjMsIHdlIHN0aWxsIG5lZWQgdG8gc3VwcG9ydCBib3VuZGFyeSB2YWx1ZXMgc2V0IG9uXG5cdFx0Ly8gdGhlIG1vZGVsIChzY2FsZVRvcCwgc2NhbGVCb3R0b20gYW5kIHNjYWxlWmVybykgYmVjYXVzZSBzb21lIGV4dGVybmFsIHBsdWdpbnMgYW5kXG5cdFx0Ly8gY29udHJvbGxlcnMgbWlnaHQgc3RpbGwgdXNlIGl0IChlLmcuIHRoZSBTbWl0aCBjaGFydCkuXG5cblx0XHRpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuXHRcdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVCb3R0b20gPT09IHVuZGVmaW5lZCA/IHNjYWxlLmJvdHRvbSA6IG1vZGVsLnNjYWxlQm90dG9tO1xuXHRcdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcblx0XHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlVG9wID09PSB1bmRlZmluZWQgPyBzY2FsZS50b3AgOiBtb2RlbC5zY2FsZVRvcDtcblx0XHR9IGVsc2UgaWYgKG1vZGVsLnNjYWxlWmVybyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XG5cdFx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUG9zaXRpb24pIHtcblx0XHRcdHRhcmdldCA9IHNjYWxlLmdldEJhc2VQb3NpdGlvbigpO1xuXHRcdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG5cdFx0XHR0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0XHRpZiAodGFyZ2V0LnggIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0YXJnZXQpKSB7XG5cdFx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR4OiBob3Jpem9udGFsID8gdGFyZ2V0IDogbnVsbCxcblx0XHRcdFx0XHR5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG5cdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuXHRcdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdFx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xuXHRcdHZhciB0YXJnZXQ7XG5cblx0XHRpZiAoIXByb3BhZ2F0ZSkge1xuXHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcblx0XHRcdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0XHR9XG5cblx0XHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG5cdFx0XHRpZiAoIXRhcmdldCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0YXJnZXQudmlzaWJsZSkge1xuXHRcdFx0XHRyZXR1cm4gZmlsbDtcblx0XHRcdH1cblxuXHRcdFx0dmlzaXRlZC5wdXNoKGZpbGwpO1xuXHRcdFx0ZmlsbCA9IHRhcmdldC5maWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZU1hcHBlcihzb3VyY2UpIHtcblx0XHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHRcdHZhciB0eXBlID0gJ2RhdGFzZXQnO1xuXG5cdFx0aWYgKGZpbGwgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0XHR0eXBlID0gJ2JvdW5kYXJ5Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFwcGVyc1t0eXBlXShzb3VyY2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNEcmF3YWJsZShwb2ludCkge1xuXHRcdHJldHVybiBwb2ludCAmJiAhcG9pbnQuc2tpcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpIHtcblx0XHR2YXIgaTtcblxuXHRcdGlmICghbGVuMCB8fCAhbGVuMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGJ1aWxkaW5nIGZpcnN0IGFyZWEgY3VydmUgKG5vcm1hbClcblx0XHRjdHgubW92ZVRvKGN1cnZlMFswXS54LCBjdXJ2ZTBbMF0ueSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGxlbjA7ICsraSkge1xuXHRcdFx0aGVscGVycy5jYW52YXMubGluZVRvKGN0eCwgY3VydmUwW2kgLSAxXSwgY3VydmUwW2ldKTtcblx0XHR9XG5cblx0XHQvLyBqb2luaW5nIHRoZSB0d28gYXJlYSBjdXJ2ZXNcblx0XHRjdHgubGluZVRvKGN1cnZlMVtsZW4xIC0gMV0ueCwgY3VydmUxW2xlbjEgLSAxXS55KTtcblxuXHRcdC8vIGJ1aWxkaW5nIG9wcG9zaXRlIGFyZWEgY3VydmUgKHJldmVyc2UpXG5cdFx0Zm9yIChpID0gbGVuMSAtIDE7IGkgPiAwOyAtLWkpIHtcblx0XHRcdGhlbHBlcnMuY2FudmFzLmxpbmVUbyhjdHgsIGN1cnZlMVtpXSwgY3VydmUxW2kgLSAxXSwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZG9GaWxsKGN0eCwgcG9pbnRzLCBtYXBwZXIsIHZpZXcsIGNvbG9yLCBsb29wKSB7XG5cdFx0dmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgc3BhbiA9IHZpZXcuc3BhbkdhcHM7XG5cdFx0dmFyIGN1cnZlMCA9IFtdO1xuXHRcdHZhciBjdXJ2ZTEgPSBbXTtcblx0XHR2YXIgbGVuMCA9IDA7XG5cdFx0dmFyIGxlbjEgPSAwO1xuXHRcdHZhciBpLCBpbGVuLCBpbmRleCwgcDAsIHAxLCBkMCwgZDE7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNvdW50ICsgISFsb29wKTsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aW5kZXggPSBpICUgY291bnQ7XG5cdFx0XHRwMCA9IHBvaW50c1tpbmRleF0uX3ZpZXc7XG5cdFx0XHRwMSA9IG1hcHBlcihwMCwgaW5kZXgsIHZpZXcpO1xuXHRcdFx0ZDAgPSBpc0RyYXdhYmxlKHAwKTtcblx0XHRcdGQxID0gaXNEcmF3YWJsZShwMSk7XG5cblx0XHRcdGlmIChkMCAmJiBkMSkge1xuXHRcdFx0XHRsZW4wID0gY3VydmUwLnB1c2gocDApO1xuXHRcdFx0XHRsZW4xID0gY3VydmUxLnB1c2gocDEpO1xuXHRcdFx0fSBlbHNlIGlmIChsZW4wICYmIGxlbjEpIHtcblx0XHRcdFx0aWYgKCFzcGFuKSB7XG5cdFx0XHRcdFx0ZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSk7XG5cdFx0XHRcdFx0bGVuMCA9IGxlbjEgPSAwO1xuXHRcdFx0XHRcdGN1cnZlMCA9IFtdO1xuXHRcdFx0XHRcdGN1cnZlMSA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChkMCkge1xuXHRcdFx0XHRcdFx0Y3VydmUwLnB1c2gocDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZDEpIHtcblx0XHRcdFx0XHRcdGN1cnZlMS5wdXNoKHAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcblxuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdFx0Y3R4LmZpbGwoKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0aWQ6ICdmaWxsZXInLFxuXG5cdFx0YWZ0ZXJEYXRhc2V0c1VwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG5cdFx0XHR2YXIgcHJvcGFnYXRlID0gb3B0aW9ucy5wcm9wYWdhdGU7XG5cdFx0XHR2YXIgc291cmNlcyA9IFtdO1xuXHRcdFx0dmFyIG1ldGEsIGksIGVsLCBzb3VyY2U7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0ZWwgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0XHRcdHNvdXJjZSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKGVsICYmIGVsLl9tb2RlbCAmJiBlbCBpbnN0YW5jZW9mIGVsZW1lbnRzLkxpbmUpIHtcblx0XHRcdFx0XHRzb3VyY2UgPSB7XG5cdFx0XHRcdFx0XHR2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdFx0ZmlsbDogZGVjb2RlRmlsbChlbCwgaSwgY291bnQpLFxuXHRcdFx0XHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0XHRcdFx0ZWw6IGVsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcblx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzb3VyY2UuZmlsbCA9IHJlc29sdmVUYXJnZXQoc291cmNlcywgaSwgcHJvcGFnYXRlKTtcblx0XHRcdFx0c291cmNlLmJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cdFx0XHRcdHNvdXJjZS5tYXBwZXIgPSBjcmVhdGVNYXBwZXIoc291cmNlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JlRGF0YXNldERyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzKSB7XG5cdFx0XHR2YXIgbWV0YSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXHRcdFx0aWYgKCFtZXRhKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGN0eCA9IGNoYXJ0LmN0eDtcblx0XHRcdHZhciBlbCA9IG1ldGEuZWw7XG5cdFx0XHR2YXIgdmlldyA9IGVsLl92aWV3O1xuXHRcdFx0dmFyIHBvaW50cyA9IGVsLl9jaGlsZHJlbiB8fCBbXTtcblx0XHRcdHZhciBtYXBwZXIgPSBtZXRhLm1hcHBlcjtcblx0XHRcdHZhciBjb2xvciA9IHZpZXcuYmFja2dyb3VuZENvbG9yIHx8IGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cblx0XHRcdGlmIChtYXBwZXIgJiYgY29sb3IgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRoZWxwZXJzLmNhbnZhcy5jbGlwQXJlYShjdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cdFx0XHRcdGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgZWwuX2xvb3ApO1xuXHRcdFx0XHRoZWxwZXJzLmNhbnZhcy51bmNsaXBBcmVhKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxufSx7XCIyNVwiOjI1LFwiNDBcIjo0MCxcIjQ1XCI6NDV9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKDI2KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGVnZW5kOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRwb3NpdGlvbjogJ3RvcCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdHJldmVyc2U6IGZhbHNlLFxuXHRcdHdlaWdodDogMTAwMCxcblxuXHRcdC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuXHRcdFx0dmFyIGNpID0gdGhpcy5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gY2kuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXG5cdFx0XHQvLyBTZWUgY29udHJvbGxlci5pc0RhdGFzZXRWaXNpYmxlIGNvbW1lbnRcblx0XHRcdG1ldGEuaGlkZGVuID0gbWV0YS5oaWRkZW4gPT09IG51bGwgPyAhY2kuZGF0YS5kYXRhc2V0c1tpbmRleF0uaGlkZGVuIDogbnVsbDtcblxuXHRcdFx0Ly8gV2UgaGlkIGEgZGF0YXNldCAuLi4gcmVyZW5kZXIgdGhlIGNoYXJ0XG5cdFx0XHRjaS51cGRhdGUoKTtcblx0XHR9LFxuXG5cdFx0b25Ib3ZlcjogbnVsbCxcblxuXHRcdGxhYmVsczoge1xuXHRcdFx0Ym94V2lkdGg6IDQwLFxuXHRcdFx0cGFkZGluZzogMTAsXG5cdFx0XHQvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcblx0XHRcdC8vIFZhbGlkIHByb3BlcnRpZXMgdG8gcmV0dXJuOlxuXHRcdFx0Ly8gdGV4dCA6IHRleHQgdG8gZGlzcGxheVxuXHRcdFx0Ly8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcblx0XHRcdC8vIHN0cm9rZVN0eWxlOiBzdHJva2Ugb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBoaWRkZW4gOiBpZiB0aGlzIGxlZ2VuZCBpdGVtIHJlZmVycyB0byBhIGhpZGRlbiBpdGVtXG5cdFx0XHQvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXG5cdFx0XHQvLyBsaW5lRGFzaFxuXHRcdFx0Ly8gbGluZURhc2hPZmZzZXQgOlxuXHRcdFx0Ly8gbGluZUpvaW4gOlxuXHRcdFx0Ly8gbGluZVdpZHRoIDpcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdHJldHVybiBoZWxwZXJzLmlzQXJyYXkoZGF0YS5kYXRhc2V0cykgPyBkYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbihkYXRhc2V0LCBpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRleHQ6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6ICghaGVscGVycy5pc0FycmF5KGRhdGFzZXQuYmFja2dyb3VuZENvbG9yKSA/IGRhdGFzZXQuYmFja2dyb3VuZENvbG9yIDogZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3JbMF0pLFxuXHRcdFx0XHRcdFx0aGlkZGVuOiAhY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcblx0XHRcdFx0XHRcdGxpbmVDYXA6IGRhdGFzZXQuYm9yZGVyQ2FwU3R5bGUsXG5cdFx0XHRcdFx0XHRsaW5lRGFzaDogZGF0YXNldC5ib3JkZXJEYXNoLFxuXHRcdFx0XHRcdFx0bGluZURhc2hPZmZzZXQ6IGRhdGFzZXQuYm9yZGVyRGFzaE9mZnNldCxcblx0XHRcdFx0XHRcdGxpbmVKb2luOiBkYXRhc2V0LmJvcmRlckpvaW5TdHlsZSxcblx0XHRcdFx0XHRcdGxpbmVXaWR0aDogZGF0YXNldC5ib3JkZXJXaWR0aCxcblx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBkYXRhc2V0LmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdFx0cG9pbnRTdHlsZTogZGF0YXNldC5wb2ludFN0eWxlLFxuXG5cdFx0XHRcdFx0XHQvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xuXHRcdFx0XHRcdFx0ZGF0YXNldEluZGV4OiBpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSwgdGhpcykgOiBbXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRleHQgPSBbXTtcblx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0uYmFja2dyb3VuZENvbG9yICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdGlmIChjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmxhYmVsKSB7XG5cdFx0XHRcdHRleHQucHVzaChjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmxhYmVsKTtcblx0XHRcdH1cblx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHR9XG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBsYXlvdXQgPSBDaGFydC5sYXlvdXRTZXJ2aWNlO1xuXHR2YXIgbm9vcCA9IGhlbHBlcnMubm9vcDtcblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm94IHdpZHRoIGJhc2VkIG9uIHRoZSB1c2VQb2ludFN0eWxlIG9wdGlvblxuXHQgKiBAcGFyYW0gbGFiZWxvcHRzIHtPYmplY3R9IHRoZSBsYWJlbCBvcHRpb25zIG9uIHRoZSBsZWdlbmRcblx0ICogQHBhcmFtIGZvbnRTaXplIHtOdW1iZXJ9IHRoZSBsYWJlbCBmb250IHNpemVcblx0ICogQHJldHVybiB7TnVtYmVyfSB3aWR0aCBvZiB0aGUgY29sb3IgYm94IGFyZWFcblx0ICovXG5cdGZ1bmN0aW9uIGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpIHtcblx0XHRyZXR1cm4gbGFiZWxPcHRzLnVzZVBvaW50U3R5bGUgP1xuXHRcdFx0Zm9udFNpemUgKiBNYXRoLlNRUlQyIDpcblx0XHRcdGxhYmVsT3B0cy5ib3hXaWR0aDtcblx0fVxuXG5cdENoYXJ0LkxlZ2VuZCA9IEVsZW1lbnQuZXh0ZW5kKHtcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdFx0aGVscGVycy5leHRlbmQodGhpcywgY29uZmlnKTtcblxuXHRcdFx0Ly8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXG5cdFx0XHR0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHRcdC8vIEFyZSB3ZSBpbiBkb3VnaG51dCBtb2RlIHdoaWNoIGhhcyBhIGRpZmZlcmVudCBkYXRhIHR5cGVcblx0XHRcdHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cdFx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIGxlZ2VuZCB0eXBlcy5cblx0XHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBsZWdlbmQgdHlwZVxuXG5cdFx0YmVmb3JlVXBkYXRlOiBub29wLFxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdFx0Ly8gRGltZW5zaW9uc1xuXHRcdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cdFx0XHQvLyBMYWJlbHNcblx0XHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0XHRtZS5idWlsZExhYmVscygpO1xuXHRcdFx0bWUuYWZ0ZXJCdWlsZExhYmVscygpO1xuXG5cdFx0XHQvLyBGaXRcblx0XHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdFx0bWUuZml0KCk7XG5cdFx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdFx0Ly9cblx0XHRcdG1lLmFmdGVyVXBkYXRlKCk7XG5cblx0XHRcdHJldHVybiBtZS5taW5TaXplO1xuXHRcdH0sXG5cdFx0YWZ0ZXJVcGRhdGU6IG5vb3AsXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCxcblx0XHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdFx0bWUudG9wID0gMDtcblx0XHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblxuXHRcdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdFx0bWUubWluU2l6ZSA9IHtcblx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRcdGhlaWdodDogMFxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVCdWlsZExhYmVsczogbm9vcCxcblx0XHRidWlsZExhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGxhYmVsT3B0cyA9IG1lLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuXHRcdFx0dmFyIGxlZ2VuZEl0ZW1zID0gaGVscGVycy5jYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFttZS5jaGFydF0sIG1lKSB8fCBbXTtcblxuXHRcdFx0aWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcblx0XHRcdFx0bGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdHJldHVybiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIG1lLmNoYXJ0LmRhdGEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1lLm9wdGlvbnMucmV2ZXJzZSkge1xuXHRcdFx0XHRsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdG1lLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG5cdFx0fSxcblx0XHRhZnRlckJ1aWxkTGFiZWxzOiBub29wLFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZUZpdDogbm9vcCxcblx0XHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciBsYWJlbE9wdHMgPSBvcHRzLmxhYmVscztcblx0XHRcdHZhciBkaXNwbGF5ID0gb3B0cy5kaXNwbGF5O1xuXG5cdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXG5cdFx0XHR2YXIgZ2xvYmFsRGVmYXVsdCA9IGRlZmF1bHRzLmdsb2JhbDtcblx0XHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cdFx0XHR2YXIgZm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdChsYWJlbE9wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHQuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdHZhciBmb250U3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsYWJlbE9wdHMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdFx0dmFyIGZvbnRGYW1pbHkgPSB2YWx1ZU9yRGVmYXVsdChsYWJlbE9wdHMuZm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Rm9udEZhbWlseSk7XG5cdFx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycy5mb250U3RyaW5nKGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpO1xuXG5cdFx0XHQvLyBSZXNldCBoaXQgYm94ZXNcblx0XHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2Ugc2l6ZXMgaGVyZVxuXHRcdFx0aWYgKGRpc3BsYXkpIHtcblx0XHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQ7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdC8vIExhYmVsc1xuXG5cdFx0XHRcdFx0Ly8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXG5cdFx0XHRcdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzID0gWzBdO1xuXHRcdFx0XHRcdHZhciB0b3RhbEhlaWdodCA9IG1lLmxlZ2VuZEl0ZW1zLmxlbmd0aCA/IGZvbnRTaXplICsgKGxhYmVsT3B0cy5wYWRkaW5nKSA6IDA7XG5cblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHRcdGlmIChsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID49IG1lLndpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgKGxhYmVsT3B0cy5wYWRkaW5nKTtcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aF0gPSBtZS5sZWZ0O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuXHRcdFx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdG1pblNpemUuaGVpZ2h0ICs9IHRvdGFsSGVpZ2h0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHZQYWRkaW5nID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0dmFyIGNvbHVtbldpZHRocyA9IG1lLmNvbHVtbldpZHRocyA9IFtdO1xuXHRcdFx0XHRcdHZhciB0b3RhbFdpZHRoID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRDb2xXaWR0aCA9IDA7XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyB2UGFkZGluZztcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0XHR2YXIgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ID4gbWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdFx0Y29sdW1uV2lkdGhzLnB1c2goY3VycmVudENvbFdpZHRoKTsgLy8gcHJldmlvdXMgY29sdW1uIHdpZHRoXG5cblx0XHRcdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gMDtcblx0XHRcdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodDtcblxuXHRcdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRcdGhpdGJveGVzW2ldID0ge1xuXHRcdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBpdGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcblx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpO1xuXHRcdFx0XHRcdG1pblNpemUud2lkdGggKz0gdG90YWxXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0XHR9LFxuXHRcdGFmdGVyRml0OiBub29wLFxuXG5cdFx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0XHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgbGVnZW5kIG9uIHRoZSBjYW52YXNcblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0XHR2YXIgZ2xvYmFsRGVmYXVsdCA9IGRlZmF1bHRzLmdsb2JhbDtcblx0XHRcdHZhciBsaW5lRGVmYXVsdCA9IGdsb2JhbERlZmF1bHQuZWxlbWVudHMubGluZTtcblx0XHRcdHZhciBsZWdlbmRXaWR0aCA9IG1lLndpZHRoO1xuXHRcdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzO1xuXG5cdFx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cdFx0XHRcdHZhciBmb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdChsYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0XHR2YXIgZm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdChsYWJlbE9wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHQuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0dmFyIGZvbnRTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxhYmVsT3B0cy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHQuZGVmYXVsdEZvbnRTdHlsZSk7XG5cdFx0XHRcdHZhciBmb250RmFtaWx5ID0gdmFsdWVPckRlZmF1bHQobGFiZWxPcHRzLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHQuZGVmYXVsdEZvbnRGYW1pbHkpO1xuXHRcdFx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycy5mb250U3RyaW5nKGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpO1xuXHRcdFx0XHR2YXIgY3Vyc29yO1xuXG5cdFx0XHRcdC8vIENhbnZhcyBzZXR1cFxuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSAwLjU7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0XHRjdHguZm9udCA9IGxhYmVsRm9udDtcblxuXHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHRcdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cblx0XHRcdFx0Ly8gY3VycmVudCBwb3NpdGlvblxuXHRcdFx0XHR2YXIgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGdsb2JhbERlZmF1bHQuZGVmYXVsdENvbG9yKTtcblx0XHRcdFx0XHRjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgbGluZURlZmF1bHQuYm9yZGVyQ2FwU3R5bGUpO1xuXHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdFx0XHRcdGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sIGxpbmVEZWZhdWx0LmJvcmRlckpvaW5TdHlsZSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCBsaW5lRGVmYXVsdC5ib3JkZXJXaWR0aCk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Q29sb3IpO1xuXHRcdFx0XHRcdHZhciBpc0xpbmVXaWR0aFplcm8gPSAodmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIGxpbmVEZWZhdWx0LmJvcmRlcldpZHRoKSA9PT0gMCk7XG5cblx0XHRcdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG9wdHMubGFiZWxzICYmIG9wdHMubGFiZWxzLnVzZVBvaW50U3R5bGUpIHtcblx0XHRcdFx0XHRcdC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuXHRcdFx0XHRcdFx0Ly8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuXHRcdFx0XHRcdFx0dmFyIHJhZGl1cyA9IGZvbnRTaXplICogTWF0aC5TUVJUMiAvIDI7XG5cdFx0XHRcdFx0XHR2YXIgb2ZmU2V0ID0gcmFkaXVzIC8gTWF0aC5TUVJUMjtcblx0XHRcdFx0XHRcdHZhciBjZW50ZXJYID0geCArIG9mZlNldDtcblx0XHRcdFx0XHRcdHZhciBjZW50ZXJZID0geSArIG9mZlNldDtcblxuXHRcdFx0XHRcdFx0Ly8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRcdGhlbHBlcnMuY2FudmFzLmRyYXdQb2ludChjdHgsIGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSwgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuXHRcdFx0XHRcdFx0aWYgKCFpc0xpbmVXaWR0aFplcm8pIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN0eC5maWxsUmVjdCh4LCB5LCBib3hXaWR0aCwgZm9udFNpemUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCkge1xuXHRcdFx0XHRcdHZhciBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG5cdFx0XHRcdFx0dmFyIHhMZWZ0ID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB4O1xuXHRcdFx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcblxuXHRcdFx0XHRcdGN0eC5maWxsVGV4dChsZWdlbmRJdGVtLnRleHQsIHhMZWZ0LCB5TWlkZGxlKTtcblxuXHRcdFx0XHRcdGlmIChsZWdlbmRJdGVtLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cblx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAyO1xuXHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4TGVmdCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHhMZWZ0ICsgdGV4dFdpZHRoLCB5TWlkZGxlKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gSG9yaXpvbnRhbFxuXHRcdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbMF0pIC8gMiksXG5cdFx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnNvciA9IHtcblx0XHRcdFx0XHRcdHg6IG1lLmxlZnQgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdFx0bGluZTogMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaXRlbUhlaWdodCA9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdGhlbHBlcnMuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdHZhciB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgdGV4dFdpZHRoO1xuXHRcdFx0XHRcdHZhciB4ID0gY3Vyc29yLng7XG5cdFx0XHRcdFx0dmFyIHkgPSBjdXJzb3IueTtcblxuXHRcdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRcdGlmICh4ICsgd2lkdGggPj0gbGVnZW5kV2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0eSA9IGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IG1lLmxlZnQgKyAoKGxlZ2VuZFdpZHRoIC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pIC8gMik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh5ICsgaXRlbUhlaWdodCA+IG1lLmJvdHRvbSkge1xuXHRcdFx0XHRcdFx0eCA9IGN1cnNvci54ID0geCArIG1lLmNvbHVtbldpZHRoc1tjdXJzb3IubGluZV0gKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdHkgPSBjdXJzb3IueSA9IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkcmF3TGVnZW5kQm94KHgsIHksIGxlZ2VuZEl0ZW0pO1xuXG5cdFx0XHRcdFx0aGl0Ym94ZXNbaV0ubGVmdCA9IHg7XG5cdFx0XHRcdFx0aGl0Ym94ZXNbaV0udG9wID0geTtcblxuXHRcdFx0XHRcdC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuXHRcdFx0XHRcdGZpbGxUZXh0KHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCk7XG5cblx0XHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIChsYWJlbE9wdHMucGFkZGluZyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGEgY2hhbmdlIG9jY3VyZWRcblx0XHQgKi9cblx0XHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciB0eXBlID0gZS50eXBlID09PSAnbW91c2V1cCcgPyAnY2xpY2snIDogZS50eXBlO1xuXHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG5cdFx0XHRcdGlmICghb3B0cy5vbkhvdmVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0aWYgKCFvcHRzLm9uQ2xpY2spIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcblx0XHRcdHZhciB4ID0gZS54O1xuXHRcdFx0dmFyIHkgPSBlLnk7XG5cblx0XHRcdGlmICh4ID49IG1lLmxlZnQgJiYgeCA8PSBtZS5yaWdodCAmJiB5ID49IG1lLnRvcCAmJiB5IDw9IG1lLmJvdHRvbSkge1xuXHRcdFx0XHQvLyBTZWUgaWYgd2UgYXJlIHRvdWNoaW5nIG9uZSBvZiB0aGUgZGF0YXNldCBib3hlc1xuXHRcdFx0XHR2YXIgbGggPSBtZS5sZWdlbmRIaXRCb3hlcztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHZhciBoaXRCb3ggPSBsaFtpXTtcblxuXHRcdFx0XHRcdGlmICh4ID49IGhpdEJveC5sZWZ0ICYmIHggPD0gaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGggJiYgeSA+PSBoaXRCb3gudG9wICYmIHkgPD0gaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpIHtcblx0XHRcdFx0XHRcdC8vIFRvdWNoaW5nIGFuIGVsZW1lbnRcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0XHRcdFx0b3B0cy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBtZS5sZWdlbmRJdGVtc1tpXSk7XG5cdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIGUubmF0aXZlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRvcHRzLm9uSG92ZXIuY2FsbChtZSwgZS5uYXRpdmUsIG1lLmxlZ2VuZEl0ZW1zW2ldKTtcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cykge1xuXHRcdHZhciBsZWdlbmQgPSBuZXcgQ2hhcnQuTGVnZW5kKHtcblx0XHRcdGN0eDogY2hhcnQuY3R4LFxuXHRcdFx0b3B0aW9uczogbGVnZW5kT3B0cyxcblx0XHRcdGNoYXJ0OiBjaGFydFxuXHRcdH0pO1xuXG5cdFx0bGF5b3V0LmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcblx0XHRsYXlvdXQuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0aWQ6ICdsZWdlbmQnLFxuXG5cdFx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XG5cblx0XHRcdGlmIChsZWdlbmRPcHRzKSB7XG5cdFx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XG5cdFx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXG5cdFx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0XHRoZWxwZXJzLm1lcmdlSWYobGVnZW5kT3B0cywgZGVmYXVsdHMuZ2xvYmFsLmxlZ2VuZCk7XG5cblx0XHRcdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRcdGxheW91dC5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgbGVnZW5kT3B0cyk7XG5cdFx0XHRcdFx0bGVnZW5kLm9wdGlvbnMgPSBsZWdlbmRPcHRzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobGVnZW5kKSB7XG5cdFx0XHRcdGxheW91dC5yZW1vdmVCb3goY2hhcnQsIGxlZ2VuZCk7XG5cdFx0XHRcdGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXHRcdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRsZWdlbmQuaGFuZGxlRXZlbnQoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNixcIjQ1XCI6NDV9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKDI2KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0dGl0bGU6IHtcblx0XHRkaXNwbGF5OiBmYWxzZSxcblx0XHRmb250U3R5bGU6ICdib2xkJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0bGluZUhlaWdodDogMS4yLFxuXHRcdHBhZGRpbmc6IDEwLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHR0ZXh0OiAnJyxcblx0XHR3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGxheW91dCA9IENoYXJ0LmxheW91dFNlcnZpY2U7XG5cdHZhciBub29wID0gaGVscGVycy5ub29wO1xuXG5cdENoYXJ0LlRpdGxlID0gRWxlbWVudC5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGhlbHBlcnMuZXh0ZW5kKG1lLCBjb25maWcpO1xuXG5cdFx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cdFx0fSxcblxuXHRcdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cblx0XHRiZWZvcmVVcGRhdGU6IG5vb3AsXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuXHRcdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0XHQvLyBEaW1lbnNpb25zXG5cdFx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblx0XHRcdC8vIExhYmVsc1xuXHRcdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRcdG1lLmJ1aWxkTGFiZWxzKCk7XG5cdFx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHRcdC8vIEZpdFxuXHRcdFx0bWUuYmVmb3JlRml0KCk7XG5cdFx0XHRtZS5maXQoKTtcblx0XHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0XHQvL1xuXHRcdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cblx0XHR9LFxuXHRcdGFmdGVyVXBkYXRlOiBub29wLFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AsXG5cdFx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cblx0XHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH07XG5cdFx0fSxcblx0XHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AsXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AsXG5cdFx0YnVpbGRMYWJlbHM6IG5vb3AsXG5cdFx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVGaXQ6IG5vb3AsXG5cdFx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0XHR2YXIgZm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRTaXplLCBkZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcblx0XHRcdHZhciBsaW5lQ291bnQgPSBoZWxwZXJzLmlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuXHRcdFx0dmFyIGxpbmVIZWlnaHQgPSBoZWxwZXJzLm9wdGlvbnMudG9MaW5lSGVpZ2h0KG9wdHMubGluZUhlaWdodCwgZm9udFNpemUpO1xuXHRcdFx0dmFyIHRleHRTaXplID0gZGlzcGxheSA/IChsaW5lQ291bnQgKiBsaW5lSGVpZ2h0KSArIChvcHRzLnBhZGRpbmcgKiAyKSA6IDA7XG5cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IHRleHRTaXplO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IHRleHRTaXplO1xuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdFx0fVxuXG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblxuXHRcdH0sXG5cdFx0YWZ0ZXJGaXQ6IG5vb3AsXG5cblx0XHQvLyBTaGFyZWQgTWV0aG9kc1xuXHRcdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0cmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgdGl0bGUgYmxvY2sgb24gdGhlIGNhbnZhc1xuXHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdFx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBmb250U2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRcdHZhciBmb250U3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSk7XG5cdFx0XHRcdHZhciBmb250RmFtaWx5ID0gdmFsdWVPckRlZmF1bHQob3B0cy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSk7XG5cdFx0XHRcdHZhciB0aXRsZUZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcoZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSk7XG5cdFx0XHRcdHZhciBsaW5lSGVpZ2h0ID0gaGVscGVycy5vcHRpb25zLnRvTGluZUhlaWdodChvcHRzLmxpbmVIZWlnaHQsIGZvbnRTaXplKTtcblx0XHRcdFx0dmFyIG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgb3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXHRcdFx0XHR2YXIgdG9wID0gbWUudG9wO1xuXHRcdFx0XHR2YXIgbGVmdCA9IG1lLmxlZnQ7XG5cdFx0XHRcdHZhciBib3R0b20gPSBtZS5ib3R0b207XG5cdFx0XHRcdHZhciByaWdodCA9IG1lLnJpZ2h0O1xuXHRcdFx0XHR2YXIgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0XHRjdHguZm9udCA9IHRpdGxlRm9udDtcblxuXHRcdFx0XHQvLyBIb3Jpem9udGFsXG5cdFx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRcdHRpdGxlWCA9IGxlZnQgKyAoKHJpZ2h0IC0gbGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdFx0dGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuXHRcdFx0XHRcdG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpdGxlWCA9IG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IGxlZnQgKyBvZmZzZXQgOiByaWdodCAtIG9mZnNldDtcblx0XHRcdFx0XHR0aXRsZVkgPSB0b3AgKyAoKGJvdHRvbSAtIHRvcCkgLyAyKTtcblx0XHRcdFx0XHRtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcblx0XHRcdFx0XHRyb3RhdGlvbiA9IE1hdGguUEkgKiAob3B0cy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gLTAuNSA6IDAuNSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRjdHgudHJhbnNsYXRlKHRpdGxlWCwgdGl0bGVZKTtcblx0XHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG5cdFx0XHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xuXHRcdFx0XHRpZiAoaGVscGVycy5pc0FycmF5KHRleHQpKSB7XG5cdFx0XHRcdFx0dmFyIHkgPSAwO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIDAsIHksIG1heFdpZHRoKTtcblx0XHRcdFx0XHRcdHkgKz0gbGluZUhlaWdodDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIDAsIDAsIG1heFdpZHRoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpIHtcblx0XHR2YXIgdGl0bGUgPSBuZXcgQ2hhcnQuVGl0bGUoe1xuXHRcdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0XHRvcHRpb25zOiB0aXRsZU9wdHMsXG5cdFx0XHRjaGFydDogY2hhcnRcblx0XHR9KTtcblxuXHRcdGxheW91dC5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuXHRcdGxheW91dC5hZGRCb3goY2hhcnQsIHRpdGxlKTtcblx0XHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGlkOiAndGl0bGUnLFxuXG5cdFx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXG5cdFx0XHRpZiAodGl0bGVPcHRzKSB7XG5cdFx0XHRcdGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXHRcdFx0dmFyIHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuXG5cdFx0XHRpZiAodGl0bGVPcHRzKSB7XG5cdFx0XHRcdGhlbHBlcnMubWVyZ2VJZih0aXRsZU9wdHMsIGRlZmF1bHRzLmdsb2JhbC50aXRsZSk7XG5cblx0XHRcdFx0aWYgKHRpdGxlQmxvY2spIHtcblx0XHRcdFx0XHRsYXlvdXQuY29uZmlndXJlKGNoYXJ0LCB0aXRsZUJsb2NrLCB0aXRsZU9wdHMpO1xuXHRcdFx0XHRcdHRpdGxlQmxvY2sub3B0aW9ucyA9IHRpdGxlT3B0cztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRpdGxlQmxvY2spIHtcblx0XHRcdFx0Q2hhcnQubGF5b3V0U2VydmljZS5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuXHRcdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG59LHtcIjI1XCI6MjUsXCIyNlwiOjI2LFwiNDVcIjo0NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdC8vIERlZmF1bHQgY29uZmlnIGZvciBhIGNhdGVnb3J5IHNjYWxlXG5cdHZhciBkZWZhdWx0Q29uZmlnID0ge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xuXHR9O1xuXG5cdHZhciBEYXRhc2V0U2NhbGUgPSBDaGFydC5TY2FsZS5leHRlbmQoe1xuXHRcdC8qKlxuXHRcdCogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjb3JyZWN0IGxhYmVscy4gSWYgZGF0YS54TGFiZWxzIG9yIGRhdGEueUxhYmVscyBhcmUgZGVmaW5lZCwgdXNlIHRob3NlXG5cdFx0KiBlbHNlIGZhbGwgYmFjayB0byBkYXRhLmxhYmVsc1xuXHRcdCogQHByaXZhdGVcblx0XHQqL1xuXHRcdGdldExhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscztcblx0XHR9LFxuXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdFx0bWUubWluSW5kZXggPSAwO1xuXHRcdFx0bWUubWF4SW5kZXggPSBsYWJlbHMubGVuZ3RoIC0gMTtcblx0XHRcdHZhciBmaW5kSW5kZXg7XG5cblx0XHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1pbiB2YWx1ZVxuXHRcdFx0XHRmaW5kSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtZS5vcHRpb25zLnRpY2tzLm1pbik7XG5cdFx0XHRcdG1lLm1pbkluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1pbkluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5tYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtYXggdmFsdWVcblx0XHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWUub3B0aW9ucy50aWNrcy5tYXgpO1xuXHRcdFx0XHRtZS5tYXhJbmRleCA9IGZpbmRJbmRleCAhPT0gLTEgPyBmaW5kSW5kZXggOiBtZS5tYXhJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0bWUubWluID0gbGFiZWxzW21lLm1pbkluZGV4XTtcblx0XHRcdG1lLm1heCA9IGxhYmVsc1ttZS5tYXhJbmRleF07XG5cdFx0fSxcblxuXHRcdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHRcdC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG5cdFx0XHRtZS50aWNrcyA9IChtZS5taW5JbmRleCA9PT0gMCAmJiBtZS5tYXhJbmRleCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1lLm1pbkluZGV4LCBtZS5tYXhJbmRleCArIDEpO1xuXHRcdH0sXG5cblx0XHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGRhdGEgPSBtZS5jaGFydC5kYXRhO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0XHRpZiAoZGF0YS55TGFiZWxzICYmICFpc0hvcml6b250YWwpIHtcblx0XHRcdFx0cmV0dXJuIG1lLmdldFJpZ2h0VmFsdWUoZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZS50aWNrc1tpbmRleCAtIG1lLm1pbkluZGV4XTtcblx0XHR9LFxuXG5cdFx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdFx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdFx0Ly8gMSBpcyBhZGRlZCBiZWNhdXNlIHdlIG5lZWQgdGhlIGxlbmd0aCBidXQgd2UgaGF2ZSB0aGUgaW5kZXhlc1xuXHRcdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5tYXhJbmRleCArIDEgLSBtZS5taW5JbmRleCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBkYXRhIG9iamVjdCwgdGhlbiBpbmRleCBpcyB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXksXG5cdFx0XHQvLyBub3QgdGhlIGluZGV4IG9mIHRoZSBzY2FsZS4gV2UgbmVlZCB0byBjaGFuZ2UgdGhhdC5cblx0XHRcdHZhciB2YWx1ZUNhdGVnb3J5O1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHRcdFx0dmFsdWVDYXRlZ29yeSA9IG1lLmlzSG9yaXpvbnRhbCgpID8gdmFsdWUueCA6IHZhbHVlLnk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWVDYXRlZ29yeSAhPT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKGluZGV4KSkpIHtcblx0XHRcdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlQ2F0ZWdvcnkgfHwgdmFsdWU7XG5cdFx0XHRcdHZhciBpZHggPSBsYWJlbHMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRcdGluZGV4ID0gaWR4ICE9PSAtMSA/IGlkeCA6IGluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0dmFyIHZhbHVlV2lkdGggPSBtZS53aWR0aCAvIG9mZnNldEFtdDtcblx0XHRcdFx0dmFyIHdpZHRoT2Zmc2V0ID0gKHZhbHVlV2lkdGggKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0XHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdFx0XHR3aWR0aE9mZnNldCArPSAodmFsdWVXaWR0aCAvIDIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1lLmxlZnQgKyBNYXRoLnJvdW5kKHdpZHRoT2Zmc2V0KTtcblx0XHRcdH1cblx0XHRcdHZhciB2YWx1ZUhlaWdodCA9IG1lLmhlaWdodCAvIG9mZnNldEFtdDtcblx0XHRcdHZhciBoZWlnaHRPZmZzZXQgPSAodmFsdWVIZWlnaHQgKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdGhlaWdodE9mZnNldCArPSAodmFsdWVIZWlnaHQgLyAyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lLnRvcCArIE1hdGgucm91bmQoaGVpZ2h0T2Zmc2V0KTtcblx0XHR9LFxuXHRcdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0sIGluZGV4ICsgdGhpcy5taW5JbmRleCwgbnVsbCk7XG5cdFx0fSxcblx0XHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUuX3RpY2tzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblx0XHRcdHZhciBob3J6ID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHR2YXIgdmFsdWVEaW1lbnNpb24gPSAoaG9yeiA/IG1lLndpZHRoIDogbWUuaGVpZ2h0KSAvIG9mZnNldEFtdDtcblxuXHRcdFx0cGl4ZWwgLT0gaG9yeiA/IG1lLmxlZnQgOiBtZS50b3A7XG5cblx0XHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdFx0cGl4ZWwgLT0gKHZhbHVlRGltZW5zaW9uIC8gMik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwaXhlbCA8PSAwKSB7XG5cdFx0XHRcdHZhbHVlID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZChwaXhlbCAvIHZhbHVlRGltZW5zaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICsgbWUubWluSW5kZXg7XG5cdFx0fSxcblx0XHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xuXHRcdH1cblx0fSk7XG5cblx0Q2hhcnQuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKCdjYXRlZ29yeScsIERhdGFzZXRTY2FsZSwgZGVmYXVsdENvbmZpZyk7XG5cbn07XG5cbn0se31dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xudmFyIFRpY2tzID0gcmVxdWlyZSgzNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0XHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRcdHRpY2tzOiB7XG5cdFx0XHRjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0XHR9XG5cdH07XG5cblx0dmFyIExpbmVhclNjYWxlID0gQ2hhcnQuTGluZWFyU2NhbGVCYXNlLmV4dGVuZCh7XG5cblx0XHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHR2YXIgREVGQVVMVF9NSU4gPSAwO1xuXHRcdFx0dmFyIERFRkFVTFRfTUFYID0gMTtcblxuXHRcdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdFx0cmV0dXJuIGlzSG9yaXpvbnRhbCA/IG1ldGEueEF4aXNJRCA9PT0gbWUuaWQgOiBtZXRhLnlBeGlzSUQgPT09IG1lLmlkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaXJzdCBDYWxjdWxhdGUgdGhlIHJhbmdlXG5cdFx0XHRtZS5taW4gPSBudWxsO1xuXHRcdFx0bWUubWF4ID0gbnVsbDtcblxuXHRcdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRcdGlmIChoYXNTdGFja3MpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRcdG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0aGFzU3RhY2tzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0XHR2YXIgdmFsdWVzUGVyU3RhY2sgPSB7fTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdFx0bWV0YS50eXBlLFxuXHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHNlcGFyYXRlIHN0YWNrIGZvciBzdGFjaz11bmRlZmluZWQgZGF0YXNldHMgd2hlbiB0aGUgb3B0cy5zdGFja2VkIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdFx0bWV0YS5zdGFja1xuXHRcdFx0XHRcdF0uam9pbignLicpO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFsdWVzUGVyU3RhY2tba2V5XSA9IHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXM6IFtdLFxuXHRcdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlczogW11cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlc2UgcGVyIHR5cGVcblx0XHRcdFx0XHR2YXIgcG9zaXRpdmVWYWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldLnBvc2l0aXZlVmFsdWVzO1xuXHRcdFx0XHRcdHZhciBuZWdhdGl2ZVZhbHVlcyA9IHZhbHVlc1BlclN0YWNrW2tleV0ubmVnYXRpdmVWYWx1ZXM7XG5cblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzW2luZGV4XSA9IHBvc2l0aXZlVmFsdWVzW2luZGV4XSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gPSBuZWdhdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblxuXHRcdFx0XHRcdFx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzW2luZGV4XSA9IDEwMDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaCh2YWx1ZXNQZXJTdGFjaywgZnVuY3Rpb24odmFsdWVzRm9yVHlwZSkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YWx1ZXNGb3JUeXBlLnBvc2l0aXZlVmFsdWVzLmNvbmNhdCh2YWx1ZXNGb3JUeXBlLm5lZ2F0aXZlVmFsdWVzKTtcblx0XHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycy5taW4odmFsdWVzKTtcblx0XHRcdFx0XHR2YXIgbWF4VmFsID0gaGVscGVycy5tYXgodmFsdWVzKTtcblx0XHRcdFx0XHRtZS5taW4gPSBtZS5taW4gPT09IG51bGwgPyBtaW5WYWwgOiBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XG5cdFx0XHRcdFx0bWUubWF4ID0gbWUubWF4ID09PSBudWxsID8gbWF4VmFsIDogTWF0aC5tYXgobWUubWF4LCBtYXhWYWwpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCBtZS5taW4pIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+IG1lLm1heCkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5taW4gPSBpc0Zpbml0ZShtZS5taW4pICYmICFpc05hTihtZS5taW4pID8gbWUubWluIDogREVGQVVMVF9NSU47XG5cdFx0XHRtZS5tYXggPSBpc0Zpbml0ZShtZS5tYXgpICYmICFpc05hTihtZS5tYXgpID8gbWUubWF4IDogREVGQVVMVF9NQVg7XG5cblx0XHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuXHRcdH0sXG5cdFx0Z2V0VGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtYXhUaWNrcztcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0bWF4VGlja3MgPSBNYXRoLm1pbih0aWNrT3B0cy5tYXhUaWNrc0xpbWl0ID8gdGlja09wdHMubWF4VGlja3NMaW1pdCA6IDExLCBNYXRoLmNlaWwobWUud2lkdGggLyA1MCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVGhlIGZhY3RvciBvZiAyIHVzZWQgdG8gc2NhbGUgdGhlIGZvbnQgc2l6ZSBoYXMgYmVlbiBleHBlcmltZW50YWxseSBkZXRlcm1pbmVkLlxuXHRcdFx0XHR2YXIgdGlja0ZvbnRTaXplID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250U2l6ZSwgZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRcdG1heFRpY2tzID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCA/IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgOiAxMSwgTWF0aC5jZWlsKG1lLmhlaWdodCAvICgyICogdGlja0ZvbnRTaXplKSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF4VGlja3M7XG5cdFx0fSxcblx0XHQvLyBDYWxsZWQgYWZ0ZXIgdGhlIHRpY2tzIGFyZSBidWlsdC4gV2UgbmVlZFxuXHRcdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XG5cdFx0XHRcdHRoaXMudGlja3MucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdH0sXG5cdFx0Ly8gVXRpbHNcblx0XHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Ly8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBmaXQgaGFzIGJlZW4gcnVuIHNvIHRoYXRcblx0XHRcdC8vIHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMucmlnaHQsIGFuZCB0aGlzLmJvdHRvbSBoYXZlIGJlZW4gZGVmaW5lZFxuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBzdGFydCA9IG1lLnN0YXJ0O1xuXG5cdFx0XHR2YXIgcmlnaHRWYWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHRcdHZhciBwaXhlbDtcblx0XHRcdHZhciByYW5nZSA9IG1lLmVuZCAtIHN0YXJ0O1xuXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0cGl4ZWwgPSBtZS5sZWZ0ICsgKG1lLndpZHRoIC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKHBpeGVsKTtcblx0XHRcdH1cblxuXHRcdFx0cGl4ZWwgPSBtZS5ib3R0b20gLSAobWUuaGVpZ2h0IC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZChwaXhlbCk7XG5cdFx0fSxcblx0XHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHZhciBpbm5lckRpbWVuc2lvbiA9IGlzSG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdFx0dmFyIG9mZnNldCA9IChpc0hvcml6b250YWwgPyBwaXhlbCAtIG1lLmxlZnQgOiBtZS5ib3R0b20gLSBwaXhlbCkgLyBpbm5lckRpbWVuc2lvbjtcblx0XHRcdHJldHVybiBtZS5zdGFydCArICgobWUuZW5kIC0gbWUuc3RhcnQpICogb2Zmc2V0KTtcblx0XHR9LFxuXHRcdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xuXHRcdH1cblx0fSk7XG5cdENoYXJ0LnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSgnbGluZWFyJywgTGluZWFyU2NhbGUsIGRlZmF1bHRDb25maWcpO1xuXG59O1xuXG59LHtcIjI1XCI6MjUsXCIzNFwiOjM0LFwiNDVcIjo0NX1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcbnZhciBUaWNrcyA9IHJlcXVpcmUoMzQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIG5vb3AgPSBoZWxwZXJzLm5vb3A7XG5cblx0Q2hhcnQuTGluZWFyU2NhbGVCYXNlID0gQ2hhcnQuU2NhbGUuZXh0ZW5kKHtcblx0XHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuICt2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBDaGFydC5TY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdFx0Ly8gSWYgd2UgYXJlIGZvcmNpbmcgaXQgdG8gYmVnaW4gYXQgMCwgYnV0IDAgd2lsbCBhbHJlYWR5IGJlIHJlbmRlcmVkIG9uIHRoZSBjaGFydCxcblx0XHRcdC8vIGRvIG5vdGhpbmcgc2luY2UgdGhhdCB3b3VsZCBtYWtlIHRoZSBjaGFydCB3ZWlyZC4gSWYgdGhlIHVzZXIgcmVhbGx5IHdhbnRzIGEgd2VpcmQgY2hhcnRcblx0XHRcdC8vIGF4aXMsIHRoZXkgY2FuIG1hbnVhbGx5IG92ZXJyaWRlIGl0XG5cdFx0XHRpZiAodGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdFx0dmFyIG1pblNpZ24gPSBoZWxwZXJzLnNpZ24obWUubWluKTtcblx0XHRcdFx0dmFyIG1heFNpZ24gPSBoZWxwZXJzLnNpZ24obWUubWF4KTtcblxuXHRcdFx0XHRpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcblx0XHRcdFx0XHQvLyBtb3ZlIHRoZSB0b3AgdXAgdG8gMFxuXHRcdFx0XHRcdG1lLm1heCA9IDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcblx0XHRcdFx0XHQvLyBtb3ZlIHRoZSBib3R0b20gZG93biB0byAwXG5cdFx0XHRcdFx0bWUubWluID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2V0TWluID0gdGlja09wdHMubWluICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgc2V0TWF4ID0gdGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWF4ICE9PSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICh0aWNrT3B0cy5taW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5taW47XG5cdFx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5zdWdnZXN0ZWRNaW47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWUubWluID0gTWF0aC5taW4obWUubWluLCB0aWNrT3B0cy5zdWdnZXN0ZWRNaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aWNrT3B0cy5tYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5tYXg7XG5cdFx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5zdWdnZXN0ZWRNYXg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCB0aWNrT3B0cy5zdWdnZXN0ZWRNYXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZXRNaW4gIT09IHNldE1heCkge1xuXHRcdFx0XHQvLyBXZSBzZXQgdGhlIG1pbiBvciB0aGUgbWF4IGJ1dCBub3QgYm90aC5cblx0XHRcdFx0Ly8gU28gZW5zdXJlIHRoYXQgb3VyIHJhbmdlIGlzIGdvb2Rcblx0XHRcdFx0Ly8gSW52ZXJ0ZWQgb3IgMCBsZW5ndGggcmFuZ2UgY2FuIGhhcHBlbiB3aGVuXG5cdFx0XHRcdC8vIHRpY2tzLm1pbiBpcyBzZXQsIGFuZCBubyBkYXRhc2V0cyBhcmUgdmlzaWJsZVxuXHRcdFx0XHRpZiAobWUubWluID49IG1lLm1heCkge1xuXHRcdFx0XHRcdGlmIChzZXRNaW4pIHtcblx0XHRcdFx0XHRcdG1lLm1heCA9IG1lLm1pbiArIDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1heCAtIDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xuXHRcdFx0XHRtZS5tYXgrKztcblxuXHRcdFx0XHRpZiAoIXRpY2tPcHRzLmJlZ2luQXRaZXJvKSB7XG5cdFx0XHRcdFx0bWUubWluLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldFRpY2tMaW1pdDogbm9vcCxcblx0XHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IG5vb3AsXG5cblx0XHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0XHQvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2Zcblx0XHRcdC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA1MFxuXHRcdFx0Ly8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cblx0XHRcdC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3Ncblx0XHRcdHZhciBtYXhUaWNrcyA9IG1lLmdldFRpY2tMaW1pdCgpO1xuXHRcdFx0bWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cblx0XHRcdHZhciBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcblx0XHRcdFx0bWF4VGlja3M6IG1heFRpY2tzLFxuXHRcdFx0XHRtaW46IHRpY2tPcHRzLm1pbixcblx0XHRcdFx0bWF4OiB0aWNrT3B0cy5tYXgsXG5cdFx0XHRcdHN0ZXBTaXplOiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZpeGVkU3RlcFNpemUsIHRpY2tPcHRzLnN0ZXBTaXplKVxuXHRcdFx0fTtcblx0XHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gVGlja3MuZ2VuZXJhdG9ycy5saW5lYXIobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIG1lKTtcblxuXHRcdFx0bWUuaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzKCk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcblx0XHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdFx0bWUubWF4ID0gaGVscGVycy5tYXgodGlja3MpO1xuXHRcdFx0bWUubWluID0gaGVscGVycy5taW4odGlja3MpO1xuXG5cdFx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cblx0XHRcdFx0bWUuc3RhcnQgPSBtZS5tYXg7XG5cdFx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLnN0YXJ0ID0gbWUubWluO1xuXHRcdFx0XHRtZS5lbmQgPSBtZS5tYXg7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0bWUudGlja3NBc051bWJlcnMgPSBtZS50aWNrcy5zbGljZSgpO1xuXHRcdFx0bWUuemVyb0xpbmVJbmRleCA9IG1lLnRpY2tzLmluZGV4T2YoMCk7XG5cblx0XHRcdENoYXJ0LlNjYWxlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKG1lKTtcblx0XHR9XG5cdH0pO1xufTtcblxufSx7XCIzNFwiOjM0LFwiNDVcIjo0NX1dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcbnZhciBUaWNrcyA9IHJlcXVpcmUoMzQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGRlZmF1bHRDb25maWcgPSB7XG5cdFx0cG9zaXRpb246ICdsZWZ0JyxcblxuXHRcdC8vIGxhYmVsIHNldHRpbmdzXG5cdFx0dGlja3M6IHtcblx0XHRcdGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG5cdFx0fVxuXHR9O1xuXG5cdHZhciBMb2dhcml0aG1pY1NjYWxlID0gQ2hhcnQuU2NhbGUuZXh0ZW5kKHtcblx0XHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIFJhbmdlXG5cdFx0XHRtZS5taW4gPSBudWxsO1xuXHRcdFx0bWUubWF4ID0gbnVsbDtcblx0XHRcdG1lLm1pbk5vdFplcm8gPSBudWxsO1xuXG5cdFx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xuXHRcdFx0aWYgKGhhc1N0YWNrcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxuXHRcdFx0XHRcdFx0bWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRzLnN0YWNrZWQgfHwgaGFzU3RhY2tzKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXNQZXJTdGFjayA9IHt9O1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdHZhciBrZXkgPSBbXG5cdFx0XHRcdFx0XHRtZXRhLnR5cGUsXG5cdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHQoKG9wdHMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkgPyBkYXRhc2V0SW5kZXggOiAnJyksXG5cdFx0XHRcdFx0XHRtZXRhLnN0YWNrXG5cdFx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XTtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dmFsdWVzW2luZGV4XSA9IHZhbHVlc1tpbmRleF0gfHwgMDtcblxuXHRcdFx0XHRcdFx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSAxMDA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgbmVlZCB0byBzcGxpdCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgc2luY2UgdGhlIGxvZyBzY2FsZSBjYW4ndCBoYW5kbGUgYSAwIGNyb3NzaW5nXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVzW2luZGV4XSArPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycy5taW4odmFsdWVzRm9yVHlwZSk7XG5cdFx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMubWF4KHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0XHRtZS5tYXggPSBtZS5tYXggPT09IG51bGwgPyBtYXhWYWwgOiBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWUubWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT09IDAgJiYgKG1lLm1pbk5vdFplcm8gPT09IG51bGwgfHwgdmFsdWUgPCBtZS5taW5Ob3RaZXJvKSkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1pbk5vdFplcm8gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0bWUubWluID0gdmFsdWVPckRlZmF1bHQodGlja09wdHMubWluLCBtZS5taW4pO1xuXHRcdFx0bWUubWF4ID0gdmFsdWVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xuXG5cdFx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdFx0aWYgKG1lLm1pbiAhPT0gMCAmJiBtZS5taW4gIT09IG51bGwpIHtcblx0XHRcdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzLmxvZzEwKG1lLm1pbikpIC0gMSk7XG5cdFx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChtZS5tYXgpKSArIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lLm1pbiA9IDE7XG5cdFx0XHRcdFx0bWUubWF4ID0gMTA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRcdHZhciBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcblx0XHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRcdG1heDogdGlja09wdHMubWF4XG5cdFx0XHR9O1xuXHRcdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBUaWNrcy5nZW5lcmF0b3JzLmxvZ2FyaXRobWljKGdlbmVyYXRpb25PcHRpb25zLCBtZSk7XG5cblx0XHRcdGlmICghbWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XG5cdFx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0XHRtZS5tYXggPSBoZWxwZXJzLm1heCh0aWNrcyk7XG5cdFx0XHRtZS5taW4gPSBoZWxwZXJzLm1pbih0aWNrcyk7XG5cblx0XHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblxuXHRcdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcblx0XHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XG5cdFx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcblxuXHRcdFx0Q2hhcnQuU2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwodGhpcyk7XG5cdFx0fSxcblx0XHQvLyBHZXQgdGhlIGNvcnJlY3QgdG9vbHRpcCBsYWJlbFxuXHRcdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9LFxuXHRcdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrVmFsdWVzW2luZGV4XSk7XG5cdFx0fSxcblx0XHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBzdGFydCA9IG1lLnN0YXJ0O1xuXHRcdFx0dmFyIG5ld1ZhbCA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0XHR2YXIgaW5uZXJEaW1lbnNpb24sIHBpeGVsLCByYW5nZTtcblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHJhbmdlID0gaGVscGVycy5sb2cxMChtZS5lbmQpIC0gaGVscGVycy5sb2cxMChzdGFydCk7IC8vIHRvZG86IGlmIHN0YXJ0ID09PSAwXG5cdFx0XHRcdGlmIChuZXdWYWwgPT09IDApIHtcblx0XHRcdFx0XHRwaXhlbCA9IG1lLmxlZnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS53aWR0aDtcblx0XHRcdFx0XHRwaXhlbCA9IG1lLmxlZnQgKyAoaW5uZXJEaW1lbnNpb24gLyByYW5nZSAqIChoZWxwZXJzLmxvZzEwKG5ld1ZhbCkgLSBoZWxwZXJzLmxvZzEwKHN0YXJ0KSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBCb3R0b20gLSB0b3Agc2luY2UgcGl4ZWxzIGluY3JlYXNlIGRvd253YXJkIG9uIGEgc2NyZWVuXG5cdFx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAoc3RhcnQgPT09IDAgJiYgIXRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0XHRyYW5nZSA9IGhlbHBlcnMubG9nMTAobWUuZW5kKSAtIGhlbHBlcnMubG9nMTAobWUubWluTm90WmVybyk7XG5cdFx0XHRcdFx0aWYgKG5ld1ZhbCA9PT0gc3RhcnQpIHtcblx0XHRcdFx0XHRcdHBpeGVsID0gbWUuYm90dG9tO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobmV3VmFsID09PSBtZS5taW5Ob3RaZXJvKSB7XG5cdFx0XHRcdFx0XHRwaXhlbCA9IG1lLmJvdHRvbSAtIGlubmVyRGltZW5zaW9uICogMC4wMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGl4ZWwgPSBtZS5ib3R0b20gLSBpbm5lckRpbWVuc2lvbiAqIDAuMDIgLSAoaW5uZXJEaW1lbnNpb24gKiAwLjk4IC8gcmFuZ2UgKiAoaGVscGVycy5sb2cxMChuZXdWYWwpIC0gaGVscGVycy5sb2cxMChtZS5taW5Ob3RaZXJvKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChtZS5lbmQgPT09IDAgJiYgdGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHRcdHJhbmdlID0gaGVscGVycy5sb2cxMChtZS5zdGFydCkgLSBoZWxwZXJzLmxvZzEwKG1lLm1pbk5vdFplcm8pO1xuXHRcdFx0XHRcdGlmIChuZXdWYWwgPT09IG1lLmVuZCkge1xuXHRcdFx0XHRcdFx0cGl4ZWwgPSBtZS50b3A7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChuZXdWYWwgPT09IG1lLm1pbk5vdFplcm8pIHtcblx0XHRcdFx0XHRcdHBpeGVsID0gbWUudG9wICsgaW5uZXJEaW1lbnNpb24gKiAwLjAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwaXhlbCA9IG1lLnRvcCArIGlubmVyRGltZW5zaW9uICogMC4wMiArIChpbm5lckRpbWVuc2lvbiAqIDAuOTggLyByYW5nZSAqIChoZWxwZXJzLmxvZzEwKG5ld1ZhbCkgLSBoZWxwZXJzLmxvZzEwKG1lLm1pbk5vdFplcm8pKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG5ld1ZhbCA9PT0gMCkge1xuXHRcdFx0XHRcdHBpeGVsID0gdGlja09wdHMucmV2ZXJzZSA/IG1lLnRvcCA6IG1lLmJvdHRvbTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyYW5nZSA9IGhlbHBlcnMubG9nMTAobWUuZW5kKSAtIGhlbHBlcnMubG9nMTAoc3RhcnQpO1xuXHRcdFx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKGlubmVyRGltZW5zaW9uIC8gcmFuZ2UgKiAoaGVscGVycy5sb2cxMChuZXdWYWwpIC0gaGVscGVycy5sb2cxMChzdGFydCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBpeGVsO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgcmFuZ2UgPSBoZWxwZXJzLmxvZzEwKG1lLmVuZCkgLSBoZWxwZXJzLmxvZzEwKG1lLnN0YXJ0KTtcblx0XHRcdHZhciB2YWx1ZSwgaW5uZXJEaW1lbnNpb247XG5cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLndpZHRoO1xuXHRcdFx0XHR2YWx1ZSA9IG1lLnN0YXJ0ICogTWF0aC5wb3coMTAsIChwaXhlbCAtIG1lLmxlZnQpICogcmFuZ2UgLyBpbm5lckRpbWVuc2lvbik7XG5cdFx0XHR9IGVsc2UgeyAvLyB0b2RvOiBpZiBzdGFydCA9PT0gMFxuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdFx0dmFsdWUgPSBNYXRoLnBvdygxMCwgKG1lLmJvdHRvbSAtIHBpeGVsKSAqIHJhbmdlIC8gaW5uZXJEaW1lbnNpb24pIC8gbWUuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9KTtcblx0Q2hhcnQuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKCdsb2dhcml0aG1pYycsIExvZ2FyaXRobWljU2NhbGUsIGRlZmF1bHRDb25maWcpO1xuXG59O1xuXG59LHtcIjM0XCI6MzQsXCI0NVwiOjQ1fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG52YXIgVGlja3MgPSByZXF1aXJlKDM0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBnbG9iYWxEZWZhdWx0cyA9IGRlZmF1bHRzLmdsb2JhbDtcblxuXHR2YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSBzY2FsaW5nIHRoZSBjaGFydCBmcm9tIHRoZSBjZW50cmVcblx0XHRhbmltYXRlOiB0cnVlLFxuXHRcdHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuXHRcdGFuZ2xlTGluZXM6IHtcblx0XHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0XHRsaW5lV2lkdGg6IDFcblx0XHR9LFxuXG5cdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRjaXJjdWxhcjogZmFsc2Vcblx0XHR9LFxuXG5cdFx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0XHR0aWNrczoge1xuXHRcdFx0Ly8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcblx0XHRcdHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG5cdFx0XHQvLyBTdHJpbmcgLSBUaGUgY29sb3VyIG9mIHRoZSBsYWJlbCBiYWNrZHJvcFxuXHRcdFx0YmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC43NSknLFxuXG5cdFx0XHQvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyBhYm92ZSAmIGJlbG93IHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRcdGJhY2tkcm9wUGFkZGluZ1k6IDIsXG5cblx0XHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRcdGJhY2tkcm9wUGFkZGluZ1g6IDIsXG5cblx0XHRcdGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHRcdH0sXG5cblx0XHRwb2ludExhYmVsczoge1xuXHRcdFx0Ly8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXG5cdFx0XHRkaXNwbGF5OiB0cnVlLFxuXG5cdFx0XHQvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG5cdFx0XHRmb250U2l6ZTogMTAsXG5cblx0XHRcdC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuXHRcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRcdHJldHVybiBsYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWVDb3VudChzY2FsZSkge1xuXHRcdHZhciBvcHRzID0gc2NhbGUub3B0aW9ucztcblx0XHRyZXR1cm4gb3B0cy5hbmdsZUxpbmVzLmRpc3BsYXkgfHwgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5ID8gc2NhbGUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoIDogMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBvaW50TGFiZWxGb250T3B0aW9ucyhzY2FsZSkge1xuXHRcdHZhciBwb2ludExhYmVsT3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG5cdFx0dmFyIGZvbnRTaXplID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChwb2ludExhYmVsT3B0aW9ucy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHR2YXIgZm9udFN0eWxlID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChwb2ludExhYmVsT3B0aW9ucy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdHZhciBmb250RmFtaWx5ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChwb2ludExhYmVsT3B0aW9ucy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSk7XG5cdFx0dmFyIGZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcoZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2l6ZTogZm9udFNpemUsXG5cdFx0XHRzdHlsZTogZm9udFN0eWxlLFxuXHRcdFx0ZmFtaWx5OiBmb250RmFtaWx5LFxuXHRcdFx0Zm9udDogZm9udFxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udFNpemUsIGxhYmVsKSB7XG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheShsYWJlbCkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHc6IGhlbHBlcnMubG9uZ2VzdFRleHQoY3R4LCBjdHguZm9udCwgbGFiZWwpLFxuXHRcdFx0XHRoOiAobGFiZWwubGVuZ3RoICogZm9udFNpemUpICsgKChsYWJlbC5sZW5ndGggLSAxKSAqIDEuNSAqIGZvbnRTaXplKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dzogY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aCxcblx0XHRcdGg6IGZvbnRTaXplXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuXHRcdGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuXHRcdFx0XHRlbmQ6IHBvcyArIChzaXplIC8gMilcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3RhcnQ6IHBvcyAtIHNpemUgLSA1LFxuXHRcdFx0XHRlbmQ6IHBvc1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyxcblx0XHRcdGVuZDogcG9zICsgc2l6ZSArIDVcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG5cdCAqL1xuXHRmdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0XHQvKlxuXHRcdCAqIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcblx0XHQgKiBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcblx0XHQgKlxuXHRcdCAqIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcblx0XHQgKlxuXHRcdCAqIFNvbHV0aW9uOlxuXHRcdCAqXG5cdFx0ICogV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XG5cdFx0ICogYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cblx0XHQgKlxuXHRcdCAqIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXG5cdFx0ICpcblx0XHQgKiBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcblx0XHQgKiBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXG5cdFx0ICpcblx0XHQgKiBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuXHRcdCAqIGFsb25nIHdpdGggbGFiZWxzLlxuXHRcdCAqXG5cdFx0ICogT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuXHRcdCAqIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxuXHRcdCAqXG5cdFx0ICogVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG5cdFx0ICogYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcblx0XHQgKlxuXHRcdCAqIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXHRcdCAqL1xuXG5cdFx0dmFyIHBsRm9udCA9IGdldFBvaW50TGFiZWxGb250T3B0aW9ucyhzY2FsZSk7XG5cblx0XHQvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cblx0XHQvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcblx0XHR2YXIgbGFyZ2VzdFBvc3NpYmxlUmFkaXVzID0gTWF0aC5taW4oc2NhbGUuaGVpZ2h0IC8gMiwgc2NhbGUud2lkdGggLyAyKTtcblx0XHR2YXIgZnVydGhlc3RMaW1pdHMgPSB7XG5cdFx0XHRyOiBzY2FsZS53aWR0aCxcblx0XHRcdGw6IDAsXG5cdFx0XHR0OiBzY2FsZS5oZWlnaHQsXG5cdFx0XHRiOiAwXG5cdFx0fTtcblx0XHR2YXIgZnVydGhlc3RBbmdsZXMgPSB7fTtcblx0XHR2YXIgaSwgdGV4dFNpemUsIHBvaW50UG9zaXRpb247XG5cblx0XHRzY2FsZS5jdHguZm9udCA9IHBsRm9udC5mb250O1xuXHRcdHNjYWxlLl9wb2ludExhYmVsU2l6ZXMgPSBbXTtcblxuXHRcdHZhciB2YWx1ZUNvdW50ID0gZ2V0VmFsdWVDb3VudChzY2FsZSk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgbGFyZ2VzdFBvc3NpYmxlUmFkaXVzKTtcblx0XHRcdHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udC5zaXplLCBzY2FsZS5wb2ludExhYmVsc1tpXSB8fCAnJyk7XG5cdFx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cblx0XHRcdC8vIEFkZCBxdWFydGVyIGNpcmNsZSB0byBtYWtlIGRlZ3JlZSAwIG1lYW4gdG9wIG9mIGNpcmNsZVxuXHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XG5cdFx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpICUgMzYwO1xuXHRcdFx0dmFyIGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcblx0XHRcdHZhciB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuXG5cdFx0XHRpZiAoaExpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLmwpIHtcblx0XHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XG5cdFx0XHRcdGZ1cnRoZXN0QW5nbGVzLmwgPSBhbmdsZVJhZGlhbnM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcblx0XHRcdFx0ZnVydGhlc3RMaW1pdHMuciA9IGhMaW1pdHMuZW5kO1xuXHRcdFx0XHRmdXJ0aGVzdEFuZ2xlcy5yID0gYW5nbGVSYWRpYW5zO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodkxpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLnQpIHtcblx0XHRcdFx0ZnVydGhlc3RMaW1pdHMudCA9IHZMaW1pdHMuc3RhcnQ7XG5cdFx0XHRcdGZ1cnRoZXN0QW5nbGVzLnQgPSBhbmdsZVJhZGlhbnM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2TGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLmIpIHtcblx0XHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xuXHRcdFx0XHRmdXJ0aGVzdEFuZ2xlcy5iID0gYW5nbGVSYWRpYW5zO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNjYWxlLnNldFJlZHVjdGlvbnMobGFyZ2VzdFBvc3NpYmxlUmFkaXVzLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggbm8gcG9pbnQgbGFiZWxzXG5cdCAqL1xuXHRmdW5jdGlvbiBmaXQoc2NhbGUpIHtcblx0XHR2YXIgbGFyZ2VzdFBvc3NpYmxlUmFkaXVzID0gTWF0aC5taW4oc2NhbGUuaGVpZ2h0IC8gMiwgc2NhbGUud2lkdGggLyAyKTtcblx0XHRzY2FsZS5kcmF3aW5nQXJlYSA9IE1hdGgucm91bmQobGFyZ2VzdFBvc3NpYmxlUmFkaXVzKTtcblx0XHRzY2FsZS5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG5cdFx0aWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcblx0XHRcdHJldHVybiAnY2VudGVyJztcblx0XHR9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG5cdFx0XHRyZXR1cm4gJ2xlZnQnO1xuXHRcdH1cblxuXHRcdHJldHVybiAncmlnaHQnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgZm9udFNpemUpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHRleHQpKSB7XG5cdFx0XHR2YXIgeSA9IHBvc2l0aW9uLnk7XG5cdFx0XHR2YXIgc3BhY2luZyA9IDEuNSAqIGZvbnRTaXplO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIHBvc2l0aW9uLngsIHkpO1xuXHRcdFx0XHR5ICs9IHNwYWNpbmc7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHRleHRTaXplLCBwb3NpdGlvbikge1xuXHRcdGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuXHRcdFx0cG9zaXRpb24ueSAtPSAodGV4dFNpemUuaCAvIDIpO1xuXHRcdH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuXHRcdFx0cG9zaXRpb24ueSAtPSB0ZXh0U2l6ZS5oO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSkge1xuXHRcdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblx0XHR2YXIgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG5cdFx0dmFyIGFuZ2xlTGluZU9wdHMgPSBvcHRzLmFuZ2xlTGluZXM7XG5cdFx0dmFyIHBvaW50TGFiZWxPcHRzID0gb3B0cy5wb2ludExhYmVscztcblxuXHRcdGN0eC5saW5lV2lkdGggPSBhbmdsZUxpbmVPcHRzLmxpbmVXaWR0aDtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSBhbmdsZUxpbmVPcHRzLmNvbG9yO1xuXG5cdFx0dmFyIG91dGVyRGlzdGFuY2UgPSBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXgpO1xuXG5cdFx0Ly8gUG9pbnQgTGFiZWwgRm9udFxuXHRcdHZhciBwbEZvbnQgPSBnZXRQb2ludExhYmVsRm9udE9wdGlvbnMoc2NhbGUpO1xuXG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IGdldFZhbHVlQ291bnQoc2NhbGUpIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmIChhbmdsZUxpbmVPcHRzLmRpc3BsYXkpIHtcblx0XHRcdFx0dmFyIG91dGVyUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlcik7XG5cdFx0XHRcdGN0eC5saW5lVG8ob3V0ZXJQb3NpdGlvbi54LCBvdXRlclBvc2l0aW9uLnkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBvaW50TGFiZWxPcHRzLmRpc3BsYXkpIHtcblx0XHRcdFx0Ly8gRXh0cmEgM3B4IG91dCBmb3Igc29tZSBsYWJlbCBzcGFjaW5nXG5cdFx0XHRcdHZhciBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyA1KTtcblxuXHRcdFx0XHQvLyBLZWVwIHRoaXMgaW4gbG9vcCBzaW5jZSB3ZSBtYXkgc3VwcG9ydCBhcnJheSBwcm9wZXJ0aWVzIGhlcmVcblx0XHRcdFx0dmFyIHBvaW50TGFiZWxGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdChwb2ludExhYmVsT3B0cy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0XHRjdHguZm9udCA9IHBsRm9udC5mb250O1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gcG9pbnRMYWJlbEZvbnRDb2xvcjtcblxuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHRcdFx0dmFyIGFuZ2xlID0gaGVscGVycy50b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKTtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcblx0XHRcdFx0YWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCBzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldLCBwb2ludExhYmVsUG9zaXRpb24pO1xuXHRcdFx0XHRmaWxsVGV4dChjdHgsIHNjYWxlLnBvaW50TGFiZWxzW2ldIHx8ICcnLCBwb2ludExhYmVsUG9zaXRpb24sIHBsRm9udC5zaXplKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGluZGV4KSB7XG5cdFx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZU9wdHMuY29sb3IsIGluZGV4IC0gMSk7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lT3B0cy5saW5lV2lkdGgsIGluZGV4IC0gMSk7XG5cblx0XHRpZiAoc2NhbGUub3B0aW9ucy5ncmlkTGluZXMuY2lyY3VsYXIpIHtcblx0XHRcdC8vIERyYXcgY2lyY3VsYXIgYXJjcyBiZXR3ZWVuIHRoZSBwb2ludHNcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG5cdFx0XHR2YXIgdmFsdWVDb3VudCA9IGdldFZhbHVlQ291bnQoc2NhbGUpO1xuXG5cdFx0XHRpZiAodmFsdWVDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdHZhciBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuXHRcdFx0Y3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG5cdFx0XHRcdGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbnVtYmVyT3JaZXJvKHBhcmFtKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMuaXNOdW1iZXIocGFyYW0pID8gcGFyYW0gOiAwO1xuXHR9XG5cblx0dmFyIExpbmVhclJhZGlhbFNjYWxlID0gQ2hhcnQuTGluZWFyU2NhbGVCYXNlLmV4dGVuZCh7XG5cdFx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblx0XHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXHRcdFx0bWUueENlbnRlciA9IE1hdGgucm91bmQobWUud2lkdGggLyAyKTtcblx0XHRcdG1lLnlDZW50ZXIgPSBNYXRoLnJvdW5kKG1lLmhlaWdodCAvIDIpO1xuXG5cdFx0XHR2YXIgbWluU2l6ZSA9IGhlbHBlcnMubWluKFttZS5oZWlnaHQsIG1lLndpZHRoXSk7XG5cdFx0XHR2YXIgdGlja0ZvbnRTaXplID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdG1lLmRyYXdpbmdBcmVhID0gb3B0cy5kaXNwbGF5ID8gKG1pblNpemUgLyAyKSAtICh0aWNrRm9udFNpemUgLyAyICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSkgOiAobWluU2l6ZSAvIDIpO1xuXHRcdH0sXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdFx0dmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuXHRcdFx0aGVscGVycy5lYWNoKGNoYXJ0LmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWluID0gTWF0aC5taW4odmFsdWUsIG1pbik7XG5cdFx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1lLm1pbiA9IChtaW4gPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA/IDAgOiBtaW4pO1xuXHRcdFx0bWUubWF4ID0gKG1heCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID8gMCA6IG1heCk7XG5cblx0XHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHRcdG1lLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0XHR9LFxuXHRcdGdldFRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cdFx0XHR2YXIgdGlja0ZvbnRTaXplID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdHJldHVybiBNYXRoLm1pbih0aWNrT3B0cy5tYXhUaWNrc0xpbWl0ID8gdGlja09wdHMubWF4VGlja3NMaW1pdCA6IDExLCBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvICgxLjUgKiB0aWNrRm9udFNpemUpKSk7XG5cdFx0fSxcblx0XHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRDaGFydC5MaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xuXG5cdFx0XHQvLyBQb2ludCBsYWJlbHNcblx0XHRcdG1lLnBvaW50TGFiZWxzID0gbWUuY2hhcnQuZGF0YS5sYWJlbHMubWFwKG1lLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIG1lKTtcblx0XHR9LFxuXHRcdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9LFxuXHRcdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdFx0Zml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zml0KHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciByYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gZnVydGhlc3RMaW1pdHMubCAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLmwpO1xuXHRcdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xuXHRcdFx0dmFyIHJhZGl1c1JlZHVjdGlvblRvcCA9IC1mdXJ0aGVzdExpbWl0cy50IC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMudCk7XG5cdFx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uQm90dG9tID0gLU1hdGgubWF4KGZ1cnRoZXN0TGltaXRzLmIgLSBtZS5oZWlnaHQsIDApIC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMuYik7XG5cblx0XHRcdHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uTGVmdCk7XG5cdFx0XHRyYWRpdXNSZWR1Y3Rpb25SaWdodCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25SaWdodCk7XG5cdFx0XHRyYWRpdXNSZWR1Y3Rpb25Ub3AgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uVG9wKTtcblx0XHRcdHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXG5cdFx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKFxuXHRcdFx0XHRNYXRoLnJvdW5kKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25MZWZ0ICsgcmFkaXVzUmVkdWN0aW9uUmlnaHQpIC8gMiksXG5cdFx0XHRcdE1hdGgucm91bmQobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvblRvcCArIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSkgLyAyKSk7XG5cdFx0XHRtZS5zZXRDZW50ZXJQb2ludChyYWRpdXNSZWR1Y3Rpb25MZWZ0LCByYWRpdXNSZWR1Y3Rpb25SaWdodCwgcmFkaXVzUmVkdWN0aW9uVG9wLCByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXHRcdH0sXG5cdFx0c2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1heFJpZ2h0ID0gbWUud2lkdGggLSByaWdodE1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cdFx0XHR2YXIgbWF4TGVmdCA9IGxlZnRNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhO1xuXHRcdFx0dmFyIG1heFRvcCA9IHRvcE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0XHR2YXIgbWF4Qm90dG9tID0gbWUuaGVpZ2h0IC0gYm90dG9tTW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYTtcblxuXHRcdFx0bWUueENlbnRlciA9IE1hdGgucm91bmQoKChtYXhMZWZ0ICsgbWF4UmlnaHQpIC8gMikgKyBtZS5sZWZ0KTtcblx0XHRcdG1lLnlDZW50ZXIgPSBNYXRoLnJvdW5kKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wKTtcblx0XHR9LFxuXG5cdFx0Z2V0SW5kZXhBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHZhciBhbmdsZU11bHRpcGxpZXIgPSAoTWF0aC5QSSAqIDIpIC8gZ2V0VmFsdWVDb3VudCh0aGlzKTtcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gdGhpcy5jaGFydC5vcHRpb25zICYmIHRoaXMuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlID9cblx0XHRcdFx0dGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgOlxuXHRcdFx0XHQwO1xuXG5cdFx0XHR2YXIgc3RhcnRBbmdsZVJhZGlhbnMgPSBzdGFydEFuZ2xlICogTWF0aC5QSSAqIDIgLyAzNjA7XG5cblx0XHRcdC8vIFN0YXJ0IGZyb20gdGhlIHRvcCBpbnN0ZWFkIG9mIHJpZ2h0LCBzbyByZW1vdmUgYSBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblx0XHRcdHJldHVybiBpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHN0YXJ0QW5nbGVSYWRpYW5zO1xuXHRcdH0sXG5cdFx0Z2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIDA7IC8vIG51bGwgYWx3YXlzIGluIGNlbnRlclxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXG5cdFx0XHR2YXIgc2NhbGluZ0ZhY3RvciA9IG1lLmRyYXdpbmdBcmVhIC8gKG1lLm1heCAtIG1lLm1pbik7XG5cdFx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHRcdHJldHVybiAobWUubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3Rvcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodmFsdWUgLSBtZS5taW4pICogc2NhbGluZ0ZhY3Rvcjtcblx0XHR9LFxuXHRcdGdldFBvaW50UG9zaXRpb246IGZ1bmN0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdGhpc0FuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSAoTWF0aC5QSSAvIDIpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogTWF0aC5yb3VuZChNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyKSArIG1lLnhDZW50ZXIsXG5cdFx0XHRcdHk6IE1hdGgucm91bmQoTWF0aC5zaW4odGhpc0FuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlcikgKyBtZS55Q2VudGVyXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Z2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlOiBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0Z2V0QmFzZVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdFx0dmFyIG1heCA9IG1lLm1heDtcblxuXHRcdFx0cmV0dXJuIG1lLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLFxuXHRcdFx0XHRtZS5iZWdpbkF0WmVybyA/IDAgOlxuXHRcdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuXHRcdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0XHQwKTtcblx0XHR9LFxuXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblx0XHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cblx0XHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG5cblx0XHRcdFx0Ly8gVGljayBGb250XG5cdFx0XHRcdHZhciB0aWNrRm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0dmFyIHRpY2tGb250U3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdFx0XHR2YXIgdGlja0ZvbnRGYW1pbHkgPSB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSk7XG5cdFx0XHRcdHZhciB0aWNrTGFiZWxGb250ID0gaGVscGVycy5mb250U3RyaW5nKHRpY2tGb250U2l6ZSwgdGlja0ZvbnRTdHlsZSwgdGlja0ZvbnRGYW1pbHkpO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XG5cdFx0XHRcdFx0Ly8gRG9uJ3QgZHJhdyBhIGNlbnRyZSB2YWx1ZSAoaWYgaXQgaXMgbWluaW11bSlcblx0XHRcdFx0XHRpZiAoaW5kZXggPiAwIHx8IHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0XHRcdHZhciB5Q2VudGVyT2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblxuXHRcdFx0XHRcdFx0Ly8gRHJhdyBjaXJjdWxhciBsaW5lcyBhcm91bmQgdGhlIHNjYWxlXG5cdFx0XHRcdFx0XHRpZiAoZ3JpZExpbmVPcHRzLmRpc3BsYXkgJiYgaW5kZXggIT09IDApIHtcblx0XHRcdFx0XHRcdFx0ZHJhd1JhZGl1c0xpbmUobWUsIGdyaWRMaW5lT3B0cywgeUNlbnRlck9mZnNldCwgaW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodGlja09wdHMuZGlzcGxheSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHRcdFx0XHRcdGN0eC5mb250ID0gdGlja0xhYmVsRm9udDtcblxuXHRcdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xuXHRcdFx0XHRcdFx0XHRjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh0aWNrT3B0cy5zaG93TGFiZWxCYWNrZHJvcCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBsYWJlbFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja09wdHMuYmFja2Ryb3BDb2xvcjtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoXG5cdFx0XHRcdFx0XHRcdFx0XHQtbGFiZWxXaWR0aCAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYLFxuXHRcdFx0XHRcdFx0XHRcdFx0LXlDZW50ZXJPZmZzZXQgLSB0aWNrRm9udFNpemUgLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsV2lkdGggKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYICogMixcblx0XHRcdFx0XHRcdFx0XHRcdHRpY2tGb250U2l6ZSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja0ZvbnRDb2xvcjtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxhYmVsLCAwLCAteUNlbnRlck9mZnNldCk7XG5cdFx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAob3B0cy5hbmdsZUxpbmVzLmRpc3BsYXkgfHwgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG5cdFx0XHRcdFx0ZHJhd1BvaW50TGFiZWxzKG1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdENoYXJ0LnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSgncmFkaWFsTGluZWFyJywgTGluZWFyUmFkaWFsU2NhbGUsIGRlZmF1bHRDb25maWcpO1xuXG59O1xuXG59LHtcIjI1XCI6MjUsXCIzNFwiOjM0LFwiNDVcIjo0NX1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCB3aW5kb3c6IGZhbHNlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb21lbnQgPSByZXF1aXJlKDEpO1xubW9tZW50ID0gdHlwZW9mIG1vbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IG1vbWVudCA6IHdpbmRvdy5tb21lbnQ7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuLy8gSW50ZWdlciBjb25zdGFudHMgYXJlIGZyb20gdGhlIEVTNiBzcGVjLlxudmFyIE1JTl9JTlRFR0VSID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLTkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTUFYX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG52YXIgSU5URVJWQUxTID0ge1xuXHRtaWxsaXNlY29uZDoge1xuXHRcdG1ham9yOiB0cnVlLFxuXHRcdHNpemU6IDEsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDAsIDI1MCwgNTAwXVxuXHR9LFxuXHRzZWNvbmQ6IHtcblx0XHRtYWpvcjogdHJ1ZSxcblx0XHRzaXplOiAxMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDMwXVxuXHR9LFxuXHRtaW51dGU6IHtcblx0XHRtYWpvcjogdHJ1ZSxcblx0XHRzaXplOiA2MDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAzMF1cblx0fSxcblx0aG91cjoge1xuXHRcdG1ham9yOiB0cnVlLFxuXHRcdHNpemU6IDM2MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA2LCAxMl1cblx0fSxcblx0ZGF5OiB7XG5cdFx0bWFqb3I6IHRydWUsXG5cdFx0c2l6ZTogODY0MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1XVxuXHR9LFxuXHR3ZWVrOiB7XG5cdFx0bWFqb3I6IGZhbHNlLFxuXHRcdHNpemU6IDYwNDgwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdG1vbnRoOiB7XG5cdFx0bWFqb3I6IHRydWUsXG5cdFx0c2l6ZTogMi42MjhlOSxcblx0XHRzdGVwczogWzEsIDIsIDNdXG5cdH0sXG5cdHF1YXJ0ZXI6IHtcblx0XHRtYWpvcjogZmFsc2UsXG5cdFx0c2l6ZTogNy44ODRlOSxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdHllYXI6IHtcblx0XHRtYWpvcjogdHJ1ZSxcblx0XHRzaXplOiAzLjE1NGUxMFxuXHR9XG59O1xuXG52YXIgVU5JVFMgPSBPYmplY3Qua2V5cyhJTlRFUlZBTFMpO1xuXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuXHRyZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIGFycmF5VW5pcXVlKGl0ZW1zKSB7XG5cdHZhciBoYXNoID0ge307XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGksIGlsZW4sIGl0ZW07XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRpZiAoIWhhc2hbaXRlbV0pIHtcblx0XHRcdGhhc2hbaXRlbV0gPSB0cnVlO1xuXHRcdFx0b3V0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuICogKGBwb3NgKSBvbiB0aGUgc2NhbGUsIGJ5IHNlYXJjaGluZyBlbnRyaWVzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHJlcXVlc3RlZCB2YWx1ZS4gYHBvc2AgaXNcbiAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG4gKiBzdG9yZSBwcmUtY29tcHV0ZWQgcGl4ZWxzLCBidXQgdGhlIHNjYWxlIGRpbWVuc2lvbnMgYXJlIG5vdCBndWFyYW50ZWVkIGF0IHRoZSB0aW1lIHdlIG5lZWRcbiAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gdGltZXN0YW1wcyAtIHRpbWVzdGFtcHMgc29ydGVkIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlzdHJpYnV0aW9uIC0gSWYgJ2xpbmVhcicsIHRpbWVzdGFtcHMgd2lsbCBiZSBzcHJlYWQgbGluZWFybHkgYWxvbmcgdGhlIG1pblxuICogYW5kIG1heCByYW5nZSwgc28gYmFzaWNhbGx5LCB0aGUgdGFibGUgd2lsbCBjb250YWlucyBvbmx5IHR3byBpdGVtczoge21pbiwgMH0gYW5kIHttYXgsIDF9LlxuICogSWYgJ3NlcmllcycsIHRpbWVzdGFtcHMgd2lsbCBiZSBwb3NpdGlvbmVkIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gSW4gdGhpc1xuICogY2FzZSwgb25seSB0aW1lc3RhbXBzIHRoYXQgYnJlYWsgdGhlIHRpbWUgbGluZWFyaXR5IGFyZSByZWdpc3RlcmVkLCBtZWFuaW5nIHRoYXQgaW4gdGhlXG4gKiBiZXN0IGNhc2UsIGFsbCB0aW1lc3RhbXBzIGFyZSBsaW5lYXIsIHRoZSB0YWJsZSBjb250YWlucyBvbmx5IG1pbiBhbmQgbWF4LlxuICovXG5mdW5jdGlvbiBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMsIG1pbiwgbWF4LCBkaXN0cmlidXRpb24pIHtcblx0aWYgKGRpc3RyaWJ1dGlvbiA9PT0gJ2xpbmVhcicgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHt0aW1lOiBtaW4sIHBvczogMH0sXG5cdFx0XHR7dGltZTogbWF4LCBwb3M6IDF9XG5cdFx0XTtcblx0fVxuXG5cdHZhciB0YWJsZSA9IFtdO1xuXHR2YXIgaXRlbXMgPSBbbWluXTtcblx0dmFyIGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0Y3VyciA9IHRpbWVzdGFtcHNbaV07XG5cdFx0aWYgKGN1cnIgPiBtaW4gJiYgY3VyciA8IG1heCkge1xuXHRcdFx0aXRlbXMucHVzaChjdXJyKTtcblx0XHR9XG5cdH1cblxuXHRpdGVtcy5wdXNoKG1heCk7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG5leHQgPSBpdGVtc1tpICsgMV07XG5cdFx0cHJldiA9IGl0ZW1zW2kgLSAxXTtcblx0XHRjdXJyID0gaXRlbXNbaV07XG5cblx0XHQvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuXHRcdGlmIChwcmV2ID09PSB1bmRlZmluZWQgfHwgbmV4dCA9PT0gdW5kZWZpbmVkIHx8IE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG5cdFx0XHR0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRhYmxlO1xufVxuXG4vLyBAc2VlIGFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LmFudWpnYWtoYXIuY29tLzIwMTQvMDMvMDEvYmluYXJ5LXNlYXJjaC1pbi1qYXZhc2NyaXB0L1xuZnVuY3Rpb24gbG9va3VwKHRhYmxlLCBrZXksIHZhbHVlKSB7XG5cdHZhciBsbyA9IDA7XG5cdHZhciBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG5cdHZhciBtaWQsIGkwLCBpMTtcblxuXHR3aGlsZSAobG8gPj0gMCAmJiBsbyA8PSBoaSkge1xuXHRcdG1pZCA9IChsbyArIGhpKSA+PiAxO1xuXHRcdGkwID0gdGFibGVbbWlkIC0gMV0gfHwgbnVsbDtcblx0XHRpMSA9IHRhYmxlW21pZF07XG5cblx0XHRpZiAoIWkwKSB7XG5cdFx0XHQvLyBnaXZlbiB2YWx1ZSBpcyBvdXRzaWRlIHRhYmxlIChiZWZvcmUgZmlyc3QgaXRlbSlcblx0XHRcdHJldHVybiB7bG86IG51bGwsIGhpOiBpMX07XG5cdFx0fSBlbHNlIGlmIChpMVtrZXldIDwgdmFsdWUpIHtcblx0XHRcdGxvID0gbWlkICsgMTtcblx0XHR9IGVsc2UgaWYgKGkwW2tleV0gPiB2YWx1ZSkge1xuXHRcdFx0aGkgPSBtaWQgLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ge2xvOiBpMCwgaGk6IGkxfTtcblx0XHR9XG5cdH1cblxuXHQvLyBnaXZlbiB2YWx1ZSBpcyBvdXRzaWRlIHRhYmxlIChhZnRlciBsYXN0IGl0ZW0pXG5cdHJldHVybiB7bG86IGkxLCBoaTogbnVsbH07XG59XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIHRoZSBnaXZlbiBzb3VyY2UgYHZhbHVlYCB1c2luZyB0aGUgdGFibGUgaXRlbXMgYHNrZXlgIHZhbHVlcyBhbmRcbiAqIHJldHVybnMgdGhlIGFzc29jaWF0ZWQgYHRrZXlgIHZhbHVlLiBGb3IgZXhhbXBsZSwgaW50ZXJwb2xhdGUodGFibGUsICd0aW1lJywgNDIsICdwb3MnKVxuICogcmV0dXJucyB0aGUgcG9zaXRpb24gZm9yIGEgdGltZXN0YW1wIGVxdWFsIHRvIDQyLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXMgYXRcbiAqIGluZGV4IFswLCAxXSBvciBbbiAtIDEsIG5dIGFyZSB1c2VkIGZvciB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHNrZXksIHN2YWwsIHRrZXkpIHtcblx0dmFyIHJhbmdlID0gbG9va3VwKHRhYmxlLCBza2V5LCBzdmFsKTtcblxuXHQvLyBOb3RlOiB0aGUgbG9va3VwIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCAyIGl0ZW1zIChtaW4gYW5kIG1heClcblx0dmFyIHByZXYgPSAhcmFuZ2UubG8gPyB0YWJsZVswXSA6ICFyYW5nZS5oaSA/IHRhYmxlW3RhYmxlLmxlbmd0aCAtIDJdIDogcmFuZ2UubG87XG5cdHZhciBuZXh0ID0gIXJhbmdlLmxvID8gdGFibGVbMV0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAxXSA6IHJhbmdlLmhpO1xuXG5cdHZhciBzcGFuID0gbmV4dFtza2V5XSAtIHByZXZbc2tleV07XG5cdHZhciByYXRpbyA9IHNwYW4gPyAoc3ZhbCAtIHByZXZbc2tleV0pIC8gc3BhbiA6IDA7XG5cdHZhciBvZmZzZXQgPSAobmV4dFt0a2V5XSAtIHByZXZbdGtleV0pICogcmF0aW87XG5cblx0cmV0dXJuIHByZXZbdGtleV0gKyBvZmZzZXQ7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gdmFsdWUgdG8gYSBtb21lbnQgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiB0aW1lIG9wdGlvbnMuXG4gKiBAc2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvXG4gKi9cbmZ1bmN0aW9uIG1vbWVudGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuXHR2YXIgcGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XG5cdHZhciBmb3JtYXQgPSBvcHRpb25zLnBhcnNlciB8fCBvcHRpb25zLmZvcm1hdDtcblxuXHRpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBwYXJzZXIodmFsdWUpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gbW9tZW50KHZhbHVlLCBmb3JtYXQpO1xuXHR9XG5cblx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBtb21lbnQpKSB7XG5cdFx0dmFsdWUgPSBtb21lbnQodmFsdWUpO1xuXHR9XG5cblx0aWYgKHZhbHVlLmlzVmFsaWQoKSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8vIExhYmVscyBhcmUgaW4gYW4gaW5jb21wYXRpYmxlIG1vbWVudCBmb3JtYXQgYW5kIG5vIGBwYXJzZXJgIGhhcyBiZWVuIHByb3ZpZGVkLlxuXHQvLyBUaGUgdXNlciBtaWdodCBzdGlsbCB1c2UgdGhlIGRlcHJlY2F0ZWQgYGZvcm1hdGAgb3B0aW9uIHRvIGNvbnZlcnQgaGlzIGlucHV0cy5cblx0aWYgKHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZm9ybWF0KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIHNjYWxlKSB7XG5cdGlmIChoZWxwZXJzLmlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcblx0dmFyIHZhbHVlID0gbW9tZW50aWZ5KHNjYWxlLmdldFJpZ2h0VmFsdWUoaW5wdXQpLCBvcHRpb25zKTtcblx0aWYgKCF2YWx1ZS5pc1ZhbGlkKCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmIChvcHRpb25zLnJvdW5kKSB7XG5cdFx0dmFsdWUuc3RhcnRPZihvcHRpb25zLnJvdW5kKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZS52YWx1ZU9mKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHVuaXQgdG8gc2tpcCB0byBiZSBhYmxlIHRvIGRpc3BsYXkgdXAgdG8gYGNhcGFjaXR5YCBudW1iZXIgb2YgdGlja3NcbiAqIGluIGB1bml0YCBmb3IgdGhlIGdpdmVuIGBtaW5gIC8gYG1heGAgcmFuZ2UgYW5kIHJlc3BlY3RpbmcgdGhlIGludGVydmFsIHN0ZXBzIGNvbnN0cmFpbnRzLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgdW5pdCwgY2FwYWNpdHkpIHtcblx0dmFyIHJhbmdlID0gbWF4IC0gbWluO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbdW5pdF07XG5cdHZhciBtaWxsaXNlY29uZHMgPSBpbnRlcnZhbC5zaXplO1xuXHR2YXIgc3RlcHMgPSBpbnRlcnZhbC5zdGVwcztcblx0dmFyIGksIGlsZW4sIGZhY3RvcjtcblxuXHRpZiAoIXN0ZXBzKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChyYW5nZSAvICgoY2FwYWNpdHkgfHwgMSkgKiBtaWxsaXNlY29uZHMpKTtcblx0fVxuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBzdGVwcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRmYWN0b3IgPSBzdGVwc1tpXTtcblx0XHRpZiAoTWF0aC5jZWlsKHJhbmdlIC8gKG1pbGxpc2Vjb25kcyAqIGZhY3RvcikpIDw9IGNhcGFjaXR5KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFjdG9yO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0KG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuXHR2YXIgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblx0dmFyIGksIGludGVydmFsLCBmYWN0b3I7XG5cblx0Zm9yIChpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcblx0XHRpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG5cdFx0ZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwc1tpbnRlcnZhbC5zdGVwcy5sZW5ndGggLSAxXSA6IE1BWF9JTlRFR0VSO1xuXG5cdFx0aWYgKE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuXHRmb3IgKHZhciBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5tYWpvcikge1xuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXG4gKiBgbWlub3JgIHVuaXQsIGFsaWduZWQgb24gdGhlIGBtYWpvcmAgdW5pdCBhbmQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZShtaW4sIG1heCwgbWlub3IsIG1ham9yLCBjYXBhY2l0eSwgb3B0aW9ucykge1xuXHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdHZhciBzdGVwU2l6ZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodGltZU9wdHMuc3RlcFNpemUsIHRpbWVPcHRzLnVuaXRTdGVwU2l6ZSk7XG5cdHZhciB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcblx0dmFyIG1ham9yVGlja3NFbmFibGVkID0gb3B0aW9ucy50aWNrcy5tYWpvci5lbmFibGVkO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbbWlub3JdO1xuXHR2YXIgZmlyc3QgPSBtb21lbnQobWluKTtcblx0dmFyIGxhc3QgPSBtb21lbnQobWF4KTtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciB0aW1lO1xuXG5cdGlmICghc3RlcFNpemUpIHtcblx0XHRzdGVwU2l6ZSA9IGRldGVybWluZVN0ZXBTaXplKG1pbiwgbWF4LCBtaW5vciwgY2FwYWNpdHkpO1xuXHR9XG5cblx0Ly8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuXHRpZiAod2Vla2RheSkge1xuXHRcdGZpcnN0ID0gZmlyc3QuaXNvV2Vla2RheSh3ZWVrZGF5KTtcblx0XHRsYXN0ID0gbGFzdC5pc29XZWVrZGF5KHdlZWtkYXkpO1xuXHR9XG5cblx0Ly8gQWxpZ24gZmlyc3QvbGFzdCB0aWNrcyBvbiB1bml0XG5cdGZpcnN0ID0gZmlyc3Quc3RhcnRPZih3ZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cdGxhc3QgPSBsYXN0LnN0YXJ0T2Yod2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBsYXN0IHRpY2sgaW5jbHVkZSBtYXhcblx0aWYgKGxhc3QgPCBtYXgpIHtcblx0XHRsYXN0LmFkZCgxLCBtaW5vcik7XG5cdH1cblxuXHR0aW1lID0gbW9tZW50KGZpcnN0KTtcblxuXHRpZiAobWFqb3JUaWNrc0VuYWJsZWQgJiYgbWFqb3IgJiYgIXdlZWtkYXkgJiYgIXRpbWVPcHRzLnJvdW5kKSB7XG5cdFx0Ly8gQWxpZ24gdGhlIGZpcnN0IHRpY2sgb24gdGhlIHByZXZpb3VzIGBtaW5vcmAgdW5pdCBhbGlnbmVkIG9uIHRoZSBgbWFqb3JgIHVuaXQ6XG5cdFx0Ly8gd2UgZmlyc3QgYWxpZ25lZCB0aW1lIG9uIHRoZSBwcmV2aW91cyBgbWFqb3JgIHVuaXQgdGhlbiBhZGQgdGhlIG51bWJlciBvZiBmdWxsXG5cdFx0Ly8gc3RlcFNpemUgdGhlcmUgaXMgYmV0d2VlbiBmaXJzdCBhbmQgdGhlIHByZXZpb3VzIG1ham9yIHRpbWUuXG5cdFx0dGltZS5zdGFydE9mKG1ham9yKTtcblx0XHR0aW1lLmFkZCh+figoZmlyc3QgLSB0aW1lKSAvIChpbnRlcnZhbC5zaXplICogc3RlcFNpemUpKSAqIHN0ZXBTaXplLCBtaW5vcik7XG5cdH1cblxuXHRmb3IgKDsgdGltZSA8IGxhc3Q7IHRpbWUuYWRkKHN0ZXBTaXplLCBtaW5vcikpIHtcblx0XHR0aWNrcy5wdXNoKCt0aW1lKTtcblx0fVxuXG5cdHRpY2tzLnB1c2goK3RpbWUpO1xuXG5cdHJldHVybiB0aWNrcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByaWdodCBhbmQgbGVmdCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge2xlZnQsIHJpZ2h0fS5cbiAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XG5cdHZhciBsZWZ0ID0gMDtcblx0dmFyIHJpZ2h0ID0gMDtcblx0dmFyIHVwcGVyLCBsb3dlcjtcblxuXHRpZiAob3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0aWYgKCFvcHRpb25zLnRpbWUubWluKSB7XG5cdFx0XHR1cHBlciA9IHRpY2tzLmxlbmd0aCA+IDEgPyB0aWNrc1sxXSA6IG1heDtcblx0XHRcdGxvd2VyID0gdGlja3NbMF07XG5cdFx0XHRsZWZ0ID0gKFxuXHRcdFx0XHRpbnRlcnBvbGF0ZSh0YWJsZSwgJ3RpbWUnLCB1cHBlciwgJ3BvcycpIC1cblx0XHRcdFx0aW50ZXJwb2xhdGUodGFibGUsICd0aW1lJywgbG93ZXIsICdwb3MnKVxuXHRcdFx0KSAvIDI7XG5cdFx0fVxuXHRcdGlmICghb3B0aW9ucy50aW1lLm1heCkge1xuXHRcdFx0dXBwZXIgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXTtcblx0XHRcdGxvd2VyID0gdGlja3MubGVuZ3RoID4gMSA/IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDJdIDogbWluO1xuXHRcdFx0cmlnaHQgPSAoXG5cdFx0XHRcdGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIHVwcGVyLCAncG9zJykgLVxuXHRcdFx0XHRpbnRlcnBvbGF0ZSh0YWJsZSwgJ3RpbWUnLCBsb3dlciwgJ3BvcycpXG5cdFx0XHQpIC8gMjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodH07XG59XG5cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHModmFsdWVzLCBtYWpvclVuaXQpIHtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciBpLCBpbGVuLCB2YWx1ZSwgbWFqb3I7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHR2YWx1ZSA9IHZhbHVlc1tpXTtcblx0XHRtYWpvciA9IG1ham9yVW5pdCA/IHZhbHVlID09PSArbW9tZW50KHZhbHVlKS5zdGFydE9mKG1ham9yVW5pdCkgOiBmYWxzZTtcblxuXHRcdHRpY2tzLnB1c2goe1xuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0bWFqb3I6IG1ham9yXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cblx0XHQvKipcblx0XHQgKiBEYXRhIGRpc3RyaWJ1dGlvbiBhbG9uZyB0aGUgc2NhbGU6XG5cdFx0ICogLSAnbGluZWFyJzogZGF0YSBhcmUgc3ByZWFkIGFjY29yZGluZyB0byB0aGVpciB0aW1lIChkaXN0YW5jZXMgY2FuIHZhcnkpLFxuXHRcdCAqIC0gJ3Nlcmllcyc6IGRhdGEgYXJlIHNwcmVhZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuXG5cdFx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcblx0XHQgKiBAc2luY2UgMi43LjBcblx0XHQgKi9cblx0XHRkaXN0cmlidXRpb246ICdsaW5lYXInLFxuXG5cdFx0LyoqXG5cdFx0ICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuXHRcdCAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuXHRcdCAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuXHRcdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG5cdFx0ICogQHNpbmNlIDIuNy4wXG5cdFx0ICovXG5cdFx0Ym91bmRzOiAnZGF0YScsXG5cblx0XHR0aW1lOiB7XG5cdFx0XHRwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cDovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxuXHRcdFx0Zm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRCBmYWxzZSA9PSBkYXRlIG9iamVjdHMsIG1vbWVudCBvYmplY3QsIGNhbGxiYWNrIG9yIGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvXG5cdFx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRcdHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuXHRcdFx0ZGlzcGxheUZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURURcblx0XHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9nZXQtc2V0L2lzby13ZWVrZGF5L1xuXHRcdFx0bWluVW5pdDogJ21pbGxpc2Vjb25kJyxcblxuXHRcdFx0Ly8gZGVmYXVsdHMgdG8gdW5pdCdzIGNvcnJlc3BvbmRpbmcgdW5pdEZvcm1hdCBiZWxvdyBvciBvdmVycmlkZSB1c2luZyBwYXR0ZXJuIHN0cmluZyBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvZm9ybWF0L1xuXHRcdFx0ZGlzcGxheUZvcm1hdHM6IHtcblx0XHRcdFx0bWlsbGlzZWNvbmQ6ICdoOm1tOnNzLlNTUyBhJywgLy8gMTE6MjA6MDEuMTIzIEFNLFxuXHRcdFx0XHRzZWNvbmQ6ICdoOm1tOnNzIGEnLCAvLyAxMToyMDowMSBBTVxuXHRcdFx0XHRtaW51dGU6ICdoOm1tIGEnLCAvLyAxMToyMCBBTVxuXHRcdFx0XHRob3VyOiAnaEEnLCAvLyA1UE1cblx0XHRcdFx0ZGF5OiAnTU1NIEQnLCAvLyBTZXAgNFxuXHRcdFx0XHR3ZWVrOiAnbGwnLCAvLyBXZWVrIDQ2LCBvciBtYXliZSBcIltXXVdXIC0gWVlZWVwiID9cblx0XHRcdFx0bW9udGg6ICdNTU0gWVlZWScsIC8vIFNlcHQgMjAxNVxuXHRcdFx0XHRxdWFydGVyOiAnW1FdUSAtIFlZWVknLCAvLyBRM1xuXHRcdFx0XHR5ZWFyOiAnWVlZWScgLy8gMjAxNVxuXHRcdFx0fSxcblx0XHR9LFxuXHRcdHRpY2tzOiB7XG5cdFx0XHRhdXRvU2tpcDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XG5cdFx0XHQgKiAtICdhdXRvJzogZ2VuZXJhdGVzIFwib3B0aW1hbFwiIHRpY2tzIGJhc2VkIG9uIHNjYWxlIHNpemUgYW5kIHRpbWUgb3B0aW9ucy5cblx0XHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuXHRcdFx0ICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxuXHRcdFx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcblx0XHRcdCAqIEBzaW5jZSAyLjcuMFxuXHRcdFx0ICovXG5cdFx0XHRzb3VyY2U6ICdhdXRvJyxcblxuXHRcdFx0bWFqb3I6IHtcblx0XHRcdFx0ZW5hYmxlZDogZmFsc2Vcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIFRpbWVTY2FsZSA9IENoYXJ0LlNjYWxlLmV4dGVuZCh7XG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIW1vbWVudCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NoYXJ0LmpzIC0gTW9tZW50LmpzIGNvdWxkIG5vdCBiZSBmb3VuZCEgWW91IG11c3QgaW5jbHVkZSBpdCBiZWZvcmUgQ2hhcnQuanMgdG8gdXNlIHRoZSB0aW1lIHNjYWxlLiBEb3dubG9hZCBhdCBodHRwczovL21vbWVudGpzLmNvbScpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1lcmdlVGlja3NPcHRpb25zKCk7XG5cblx0XHRcdENoYXJ0LlNjYWxlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXG5cdFx0XHQvLyBERVBSRUNBVElPTlM6IG91dHB1dCBhIG1lc3NhZ2Ugb25seSBvbmUgdGltZSBwZXIgdXBkYXRlXG5cdFx0XHRpZiAob3B0aW9ucy50aW1lICYmIG9wdGlvbnMudGltZS5mb3JtYXQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdvcHRpb25zLnRpbWUuZm9ybWF0IGlzIGRlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IG9wdGlvbnMudGltZS5wYXJzZXIuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBDaGFydC5TY2FsZS5wcm90b3R5cGUudXBkYXRlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBbGxvd3MgZGF0YSB0byBiZSByZWZlcmVuY2VkIHZpYSAndCcgYXR0cmlidXRlXG5cdFx0ICovXG5cdFx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcblx0XHRcdGlmIChyYXdWYWx1ZSAmJiByYXdWYWx1ZS50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmF3VmFsdWUgPSByYXdWYWx1ZS50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENoYXJ0LlNjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgcmF3VmFsdWUpO1xuXHRcdH0sXG5cblx0XHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcblx0XHRcdHZhciBtaW4gPSBwYXJzZSh0aW1lT3B0cy5taW4sIG1lKSB8fCBNQVhfSU5URUdFUjtcblx0XHRcdHZhciBtYXggPSBwYXJzZSh0aW1lT3B0cy5tYXgsIG1lKSB8fCBNSU5fSU5URUdFUjtcblx0XHRcdHZhciB0aW1lc3RhbXBzID0gW107XG5cdFx0XHR2YXIgZGF0YXNldHMgPSBbXTtcblx0XHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHRcdHZhciBpLCBqLCBpbGVuLCBqbGVuLCBkYXRhLCB0aW1lc3RhbXA7XG5cblx0XHRcdC8vIENvbnZlcnQgbGFiZWxzIHRvIHRpbWVzdGFtcHNcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bGFiZWxzLnB1c2gocGFyc2UoY2hhcnQuZGF0YS5sYWJlbHNbaV0sIG1lKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgZGF0YSB0byB0aW1lc3RhbXBzXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRcdGRhdGEgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmRhdGE7XG5cblx0XHRcdFx0XHQvLyBMZXQncyBjb25zaWRlciB0aGF0IGFsbCBkYXRhIGhhdmUgdGhlIHNhbWUgZm9ybWF0LlxuXHRcdFx0XHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KGRhdGFbMF0pKSB7XG5cdFx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dGltZXN0YW1wID0gcGFyc2UoZGF0YVtqXSwgbWUpO1xuXHRcdFx0XHRcdFx0XHR0aW1lc3RhbXBzLnB1c2godGltZXN0YW1wKTtcblx0XHRcdFx0XHRcdFx0ZGF0YXNldHNbaV1bal0gPSB0aW1lc3RhbXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaC5hcHBseSh0aW1lc3RhbXBzLCBsYWJlbHMpO1xuXHRcdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGxhYmVscy5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gU29ydCBsYWJlbHMgKiphZnRlcioqIGRhdGEgaGF2ZSBiZWVuIGNvbnZlcnRlZFxuXHRcdFx0XHRsYWJlbHMgPSBhcnJheVVuaXF1ZShsYWJlbHMpLnNvcnQoc29ydGVyKTtcblx0XHRcdFx0bWluID0gTWF0aC5taW4obWluLCBsYWJlbHNbMF0pO1xuXHRcdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdFx0dGltZXN0YW1wcyA9IGFycmF5VW5pcXVlKHRpbWVzdGFtcHMpLnNvcnQoc29ydGVyKTtcblx0XHRcdFx0bWluID0gTWF0aC5taW4obWluLCB0aW1lc3RhbXBzWzBdKTtcblx0XHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHZhbGlkIG1pbi9tYXgsIGxldCdzIHVzZSB0b2RheSBsaW1pdHNcblx0XHRcdG1pbiA9IG1pbiA9PT0gTUFYX0lOVEVHRVIgPyArbW9tZW50KCkuc3RhcnRPZignZGF5JykgOiBtaW47XG5cdFx0XHRtYXggPSBtYXggPT09IE1JTl9JTlRFR0VSID8gK21vbWVudCgpLmVuZE9mKCdkYXknKSArIDEgOiBtYXg7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG1heCBpcyBzdHJpY3RseSBoaWdoZXIgdGhhbiBtaW4gKHJlcXVpcmVkIGJ5IHRoZSBsb29rdXAgdGFibGUpXG5cdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtaW4sIG1heCk7XG5cdFx0XHRtZS5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuXG5cdFx0XHQvLyBQUklWQVRFXG5cdFx0XHRtZS5faG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0bWUuX3RhYmxlID0gW107XG5cdFx0XHRtZS5fdGltZXN0YW1wcyA9IHtcblx0XHRcdFx0ZGF0YTogdGltZXN0YW1wcyxcblx0XHRcdFx0ZGF0YXNldHM6IGRhdGFzZXRzLFxuXHRcdFx0XHRsYWJlbHM6IGxhYmVsc1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHRcdHZhciBtYXggPSBtZS5tYXg7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdFx0XHR2YXIgZm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuXHRcdFx0dmFyIGNhcGFjaXR5ID0gbWUuZ2V0TGFiZWxDYXBhY2l0eShtaW4pO1xuXHRcdFx0dmFyIHVuaXQgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXQodGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KTtcblx0XHRcdHZhciBtYWpvclVuaXQgPSBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCk7XG5cdFx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdFx0dmFyIHRpY2tzID0gW107XG5cdFx0XHR2YXIgaSwgaWxlbiwgdGltZXN0YW1wO1xuXG5cdFx0XHRzd2l0Y2ggKG9wdGlvbnMudGlja3Muc291cmNlKSB7XG5cdFx0XHRjYXNlICdkYXRhJzpcblx0XHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmRhdGE7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbGFiZWxzJzpcblx0XHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmxhYmVscztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhdXRvJzpcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRpbWVzdGFtcHMgPSBnZW5lcmF0ZShtaW4sIG1heCwgdW5pdCwgbWFqb3JVbml0LCBjYXBhY2l0eSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0XHRtaW4gPSB0aW1lc3RhbXBzWzBdO1xuXHRcdFx0XHRtYXggPSB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVuZm9yY2UgbGltaXRzIHdpdGggdXNlciBtaW4vbWF4IG9wdGlvbnNcblx0XHRcdG1pbiA9IHBhcnNlKHRpbWVPcHRzLm1pbiwgbWUpIHx8IG1pbjtcblx0XHRcdG1heCA9IHBhcnNlKHRpbWVPcHRzLm1heCwgbWUpIHx8IG1heDtcblxuXHRcdFx0Ly8gUmVtb3ZlIHRpY2tzIG91dHNpZGUgdGhlIG1pbi9tYXggcmFuZ2Vcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHR0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdFx0XHRpZiAodGltZXN0YW1wID49IG1pbiAmJiB0aW1lc3RhbXAgPD0gbWF4KSB7XG5cdFx0XHRcdFx0dGlja3MucHVzaCh0aW1lc3RhbXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG1lLm1pbiA9IG1pbjtcblx0XHRcdG1lLm1heCA9IG1heDtcblxuXHRcdFx0Ly8gUFJJVkFURVxuXHRcdFx0bWUuX3VuaXQgPSB1bml0O1xuXHRcdFx0bWUuX21ham9yVW5pdCA9IG1ham9yVW5pdDtcblx0XHRcdG1lLl9taW5vckZvcm1hdCA9IGZvcm1hdHNbdW5pdF07XG5cdFx0XHRtZS5fbWFqb3JGb3JtYXQgPSBmb3JtYXRzW21ham9yVW5pdF07XG5cdFx0XHRtZS5fdGFibGUgPSBidWlsZExvb2t1cFRhYmxlKG1lLl90aW1lc3RhbXBzLmRhdGEsIG1pbiwgbWF4LCBvcHRpb25zLmRpc3RyaWJ1dGlvbik7XG5cdFx0XHRtZS5fb2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKG1lLl90YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKTtcblxuXHRcdFx0cmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGlja3MsIG1ham9yVW5pdCk7XG5cdFx0fSxcblxuXHRcdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgZGF0YSA9IG1lLmNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG5cdFx0XHR2YXIgbGFiZWwgPSBkYXRhLmxhYmVscyAmJiBpbmRleCA8IGRhdGEubGFiZWxzLmxlbmd0aCA/IGRhdGEubGFiZWxzW2luZGV4XSA6ICcnO1xuXHRcdFx0dmFyIHZhbHVlID0gZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdO1xuXG5cdFx0XHRpZiAoaGVscGVycy5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdFx0bGFiZWwgPSBtZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG5cdFx0XHRcdGxhYmVsID0gbW9tZW50aWZ5KGxhYmVsLCB0aW1lT3B0cykuZm9ybWF0KHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGlja0Zvcm1hdEZ1bmN0aW9uOiBmdW5jdGlvbih0aWNrLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGltZSA9IHRpY2sudmFsdWVPZigpO1xuXHRcdFx0dmFyIG1ham9yVW5pdCA9IG1lLl9tYWpvclVuaXQ7XG5cdFx0XHR2YXIgbWFqb3JGb3JtYXQgPSBtZS5fbWFqb3JGb3JtYXQ7XG5cdFx0XHR2YXIgbWFqb3JUaW1lID0gdGljay5jbG9uZSgpLnN0YXJ0T2YobWUuX21ham9yVW5pdCkudmFsdWVPZigpO1xuXHRcdFx0dmFyIG1ham9yVGlja09wdHMgPSBvcHRpb25zLnRpY2tzLm1ham9yO1xuXHRcdFx0dmFyIG1ham9yID0gbWFqb3JUaWNrT3B0cy5lbmFibGVkICYmIG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aW1lID09PSBtYWpvclRpbWU7XG5cdFx0XHR2YXIgbGFiZWwgPSB0aWNrLmZvcm1hdChtYWpvciA/IG1ham9yRm9ybWF0IDogbWUuX21pbm9yRm9ybWF0KTtcblx0XHRcdHZhciB0aWNrT3B0cyA9IG1ham9yID8gbWFqb3JUaWNrT3B0cyA6IG9wdGlvbnMudGlja3MubWlub3I7XG5cdFx0XHR2YXIgZm9ybWF0dGVyID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5jYWxsYmFjaywgdGlja09wdHMudXNlckNhbGxiYWNrKTtcblxuXHRcdFx0cmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlcihsYWJlbCwgaW5kZXgsIHRpY2tzKSA6IGxhYmVsO1xuXHRcdH0sXG5cblx0XHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcblx0XHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGxhYmVscy5wdXNoKHRoaXMudGlja0Zvcm1hdEZ1bmN0aW9uKG1vbWVudCh0aWNrc1tpXS52YWx1ZSksIGksIHRpY2tzKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsYWJlbHM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0UGl4ZWxGb3JPZmZzZXQ6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc2l6ZSA9IG1lLl9ob3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0XHR2YXIgc3RhcnQgPSBtZS5faG9yaXpvbnRhbCA/IG1lLmxlZnQgOiBtZS50b3A7XG5cdFx0XHR2YXIgcG9zID0gaW50ZXJwb2xhdGUobWUuX3RhYmxlLCAndGltZScsIHRpbWUsICdwb3MnKTtcblxuXHRcdFx0cmV0dXJuIHN0YXJ0ICsgc2l6ZSAqIChtZS5fb2Zmc2V0cy5sZWZ0ICsgcG9zKSAvIChtZS5fb2Zmc2V0cy5sZWZ0ICsgMSArIG1lLl9vZmZzZXRzLnJpZ2h0KTtcblx0XHR9LFxuXG5cdFx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdGltZSA9IG51bGw7XG5cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRpbWUgPSBtZS5fdGltZXN0YW1wcy5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdW2luZGV4XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRpbWUgPT09IG51bGwpIHtcblx0XHRcdFx0dGltZSA9IHBhcnNlKHZhbHVlLCBtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aW1lICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBtZS5nZXRQaXhlbEZvck9mZnNldCh0aW1lKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0dmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuXHRcdFx0cmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGggP1xuXHRcdFx0XHR0aGlzLmdldFBpeGVsRm9yT2Zmc2V0KHRpY2tzW2luZGV4XS52YWx1ZSkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH0sXG5cblx0XHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBzaXplID0gbWUuX2hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gbWUubGVmdCA6IG1lLnRvcDtcblx0XHRcdHZhciBwb3MgPSAoc2l6ZSA/IChwaXhlbCAtIHN0YXJ0KSAvIHNpemUgOiAwKSAqIChtZS5fb2Zmc2V0cy5sZWZ0ICsgMSArIG1lLl9vZmZzZXRzLmxlZnQpIC0gbWUuX29mZnNldHMucmlnaHQ7XG5cdFx0XHR2YXIgdGltZSA9IGludGVycG9sYXRlKG1lLl90YWJsZSwgJ3BvcycsIHBvcywgJ3RpbWUnKTtcblxuXHRcdFx0cmV0dXJuIG1vbWVudCh0aW1lKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiB3aGF0IHRoZSBsYWJlbCB3aWR0aCBtaWdodCBiZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0TGFiZWxXaWR0aDogZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzLnRvUmFkaWFucyh0aWNrc09wdHMubWF4Um90YXRpb24pO1xuXHRcdFx0dmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0dmFyIHRpY2tGb250U2l6ZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodGlja3NPcHRzLmZvbnRTaXplLCBkZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblxuXHRcdFx0cmV0dXJuICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdG1lLl9taW5vckZvcm1hdCA9IG1lLm9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcdC8vIFBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IGZvciBndWVzdGltYXRpb25cblxuXHRcdFx0dmFyIGV4YW1wbGVMYWJlbCA9IG1lLnRpY2tGb3JtYXRGdW5jdGlvbihtb21lbnQoZXhhbXBsZVRpbWUpLCAwLCBbXSk7XG5cdFx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5nZXRMYWJlbFdpZHRoKGV4YW1wbGVMYWJlbCk7XG5cdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLmlzSG9yaXpvbnRhbCgpID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cblx0XHRcdHJldHVybiBNYXRoLmZsb29yKGlubmVyV2lkdGggLyB0aWNrTGFiZWxXaWR0aCk7XG5cdFx0fVxuXHR9KTtcblxuXHRDaGFydC5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUoJ3RpbWUnLCBUaW1lU2NhbGUsIGRlZmF1bHRDb25maWcpO1xufTtcblxufSx7XCIxXCI6MSxcIjI1XCI6MjUsXCI0NVwiOjQ1fV19LHt9LFs3XSkoNylcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2NoYXJ0LmpzIiwiLypcblR1cmJvbGlua3MgNS4xLjFcbkNvcHlyaWdodCDCqSAyMDE4IEJhc2VjYW1wLCBMTENcbiAqL1xuKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpczsoZnVuY3Rpb24oKXsoZnVuY3Rpb24oKXt0aGlzLlR1cmJvbGlua3M9e3N1cHBvcnRlZDpmdW5jdGlvbigpe3JldHVybiBudWxsIT13aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUmJm51bGwhPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJm51bGwhPXdpbmRvdy5hZGRFdmVudExpc3RlbmVyfSgpLHZpc2l0OmZ1bmN0aW9uKHQscil7cmV0dXJuIGUuY29udHJvbGxlci52aXNpdCh0LHIpfSxjbGVhckNhY2hlOmZ1bmN0aW9uKCl7cmV0dXJuIGUuY29udHJvbGxlci5jbGVhckNhY2hlKCl9LHNldFByb2dyZXNzQmFyRGVsYXk6ZnVuY3Rpb24odCl7cmV0dXJuIGUuY29udHJvbGxlci5zZXRQcm9ncmVzc0JhckRlbGF5KHQpfX19KS5jYWxsKHRoaXMpfSkuY2FsbCh0KTt2YXIgZT10LlR1cmJvbGlua3M7KGZ1bmN0aW9uKCl7KGZ1bmN0aW9uKCl7dmFyIHQscixuLG89W10uc2xpY2U7ZS5jb3B5T2JqZWN0PWZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtyPXt9O2ZvcihlIGluIHQpbj10W2VdLHJbZV09bjtyZXR1cm4gcn0sZS5jbG9zZXN0PWZ1bmN0aW9uKGUscil7cmV0dXJuIHQuY2FsbChlLHIpfSx0PWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gdD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsbnVsbCE9KGU9dC5jbG9zZXN0KT9lOmZ1bmN0aW9uKHQpe3ZhciBlO2ZvcihlPXRoaXM7ZTspe2lmKGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmci5jYWxsKGUsdCkpcmV0dXJuIGU7ZT1lLnBhcmVudE5vZGV9fX0oKSxlLmRlZmVyPWZ1bmN0aW9uKHQpe3JldHVybiBzZXRUaW1lb3V0KHQsMSl9LGUudGhyb3R0bGU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9bnVsbCxmdW5jdGlvbigpe3ZhciByO3JldHVybiByPTE8PWFyZ3VtZW50cy5sZW5ndGg/by5jYWxsKGFyZ3VtZW50cywwKTpbXSxudWxsIT1lP2U6ZT1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGU9bnVsbCx0LmFwcGx5KG4scil9fSh0aGlzKSl9fSxlLmRpc3BhdGNoPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbyxpLHMsYSx1O3JldHVybiBhPW51bGwhPWU/ZTp7fSx1PWEudGFyZ2V0LHI9YS5jYW5jZWxhYmxlLG89YS5kYXRhLGk9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudHNcIiksaS5pbml0RXZlbnQodCwhMCxyPT09ITApLGkuZGF0YT1udWxsIT1vP286e30saS5jYW5jZWxhYmxlJiYhbiYmKHM9aS5wcmV2ZW50RGVmYXVsdCxpLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZHx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJkZWZhdWx0UHJldmVudGVkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiEwfX0pLHMuY2FsbCh0aGlzKX0pLChudWxsIT11P3U6ZG9jdW1lbnQpLmRpc3BhdGNoRXZlbnQoaSksaX0sbj1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0PWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpLHQuaW5pdEV2ZW50KFwidGVzdFwiLCEwLCEwKSx0LnByZXZlbnREZWZhdWx0KCksdC5kZWZhdWx0UHJldmVudGVkfSgpLGUubWF0Y2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5jYWxsKHQsZSl9LHI9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbjtyZXR1cm4gdD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsbnVsbCE9KGU9bnVsbCE9KHI9bnVsbCE9KG49dC5tYXRjaGVzU2VsZWN0b3IpP246dC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpP3I6dC5tc01hdGNoZXNTZWxlY3Rvcik/ZTp0Lm1vek1hdGNoZXNTZWxlY3Rvcn0oKSxlLnV1aWQ9ZnVuY3Rpb24oKXt2YXIgdCxlLHI7Zm9yKHI9XCJcIix0PWU9MTszNj49ZTt0PSsrZSlyKz05PT09dHx8MTQ9PT10fHwxOT09PXR8fDI0PT09dD9cIi1cIjoxNT09PXQ/XCI0XCI6MjA9PT10PyhNYXRoLmZsb29yKDQqTWF0aC5yYW5kb20oKSkrOCkudG9TdHJpbmcoMTYpOk1hdGguZmxvb3IoMTUqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO3JldHVybiByfX0pLmNhbGwodGhpcyksZnVuY3Rpb24oKXtlLkxvY2F0aW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgZSxyO251bGw9PXQmJih0PVwiXCIpLHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIiksci5ocmVmPXQudG9TdHJpbmcoKSx0aGlzLmFic29sdXRlVVJMPXIuaHJlZixlPXIuaGFzaC5sZW5ndGgsMj5lP3RoaXMucmVxdWVzdFVSTD10aGlzLmFic29sdXRlVVJMOih0aGlzLnJlcXVlc3RVUkw9dGhpcy5hYnNvbHV0ZVVSTC5zbGljZSgwLC1lKSx0aGlzLmFuY2hvcj1yLmhhc2guc2xpY2UoMSkpfXZhciBlLHIsbixvO3JldHVybiB0LndyYXA9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzP3Q6bmV3IHRoaXModCl9LHQucHJvdG90eXBlLmdldE9yaWdpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFic29sdXRlVVJMLnNwbGl0KFwiL1wiLDMpLmpvaW4oXCIvXCIpfSx0LnByb3RvdHlwZS5nZXRQYXRoPWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gbnVsbCE9KHQ9bnVsbCE9KGU9dGhpcy5yZXF1ZXN0VVJMLm1hdGNoKC9cXC9cXC9bXlxcL10qKFxcL1tePztdKikvKSk/ZVsxXTp2b2lkIDApP3Q6XCIvXCJ9LHQucHJvdG90eXBlLmdldFBhdGhDb21wb25lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UGF0aCgpLnNwbGl0KFwiL1wiKS5zbGljZSgxKX0sdC5wcm90b3R5cGUuZ2V0TGFzdFBhdGhDb21wb25lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRQYXRoQ29tcG9uZW50cygpLnNsaWNlKC0xKVswXX0sdC5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uPWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gbnVsbCE9KHQ9bnVsbCE9KGU9dGhpcy5nZXRMYXN0UGF0aENvbXBvbmVudCgpLm1hdGNoKC9cXC5bXi5dKiQvKSk/ZVswXTp2b2lkIDApP3Q6XCJcIn0sdC5wcm90b3R5cGUuaXNIVE1MPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZW5zaW9uKCkubWF0Y2goL14oPzp8XFwuKD86aHRtfGh0bWx8eGh0bWwpKSQvKX0sdC5wcm90b3R5cGUuaXNQcmVmaXhlZEJ5PWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXIodCksdGhpcy5pc0VxdWFsVG8odCl8fG8odGhpcy5hYnNvbHV0ZVVSTCxlKX0sdC5wcm90b3R5cGUuaXNFcXVhbFRvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFic29sdXRlVVJMPT09KG51bGwhPXQ/dC5hYnNvbHV0ZVVSTDp2b2lkIDApfSx0LnByb3RvdHlwZS50b0NhY2hlS2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdFVSTH0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWJzb2x1dGVVUkx9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWJzb2x1dGVVUkx9LHQucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hYnNvbHV0ZVVSTH0scj1mdW5jdGlvbih0KXtyZXR1cm4gZSh0LmdldE9yaWdpbigpK3QuZ2V0UGF0aCgpKX0sZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0LFwiL1wiKT90OnQrXCIvXCJ9LG89ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5zbGljZSgwLGUubGVuZ3RoKT09PWV9LG49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5zbGljZSgtZS5sZW5ndGgpPT09ZX0sdH0oKX0uY2FsbCh0aGlzKSxmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX07ZS5IdHRwUmVxdWVzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHIocixuLG8pe3RoaXMuZGVsZWdhdGU9cix0aGlzLnJlcXVlc3RDYW5jZWxlZD10KHRoaXMucmVxdWVzdENhbmNlbGVkLHRoaXMpLHRoaXMucmVxdWVzdFRpbWVkT3V0PXQodGhpcy5yZXF1ZXN0VGltZWRPdXQsdGhpcyksdGhpcy5yZXF1ZXN0RmFpbGVkPXQodGhpcy5yZXF1ZXN0RmFpbGVkLHRoaXMpLHRoaXMucmVxdWVzdExvYWRlZD10KHRoaXMucmVxdWVzdExvYWRlZCx0aGlzKSx0aGlzLnJlcXVlc3RQcm9ncmVzc2VkPXQodGhpcy5yZXF1ZXN0UHJvZ3Jlc3NlZCx0aGlzKSx0aGlzLnVybD1lLkxvY2F0aW9uLndyYXAobikucmVxdWVzdFVSTCx0aGlzLnJlZmVycmVyPWUuTG9jYXRpb24ud3JhcChvKS5hYnNvbHV0ZVVSTCx0aGlzLmNyZWF0ZVhIUigpfXJldHVybiByLk5FVFdPUktfRkFJTFVSRT0wLHIuVElNRU9VVF9GQUlMVVJFPS0xLHIudGltZW91dD02MCxyLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHRoaXMueGhyJiYhdGhpcy5zZW50Pyh0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQmVmb3JlUmVxdWVzdFN0YXJ0KCksdGhpcy5zZXRQcm9ncmVzcygwKSx0aGlzLnhoci5zZW5kKCksdGhpcy5zZW50PSEwLFwiZnVuY3Rpb25cIj09dHlwZW9mKHQ9dGhpcy5kZWxlZ2F0ZSkucmVxdWVzdFN0YXJ0ZWQ/dC5yZXF1ZXN0U3RhcnRlZCgpOnZvaWQgMCk6dm9pZCAwfSxyLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54aHImJnRoaXMuc2VudD90aGlzLnhoci5hYm9ydCgpOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdFByb2dyZXNzZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoQ29tcHV0YWJsZT90aGlzLnNldFByb2dyZXNzKHQubG9hZGVkL3QudG90YWwpOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdExvYWRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZFJlcXVlc3QoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIDIwMDw9KGU9dC54aHIuc3RhdHVzKSYmMzAwPmU/dC5kZWxlZ2F0ZS5yZXF1ZXN0Q29tcGxldGVkV2l0aFJlc3BvbnNlKHQueGhyLnJlc3BvbnNlVGV4dCx0Lnhoci5nZXRSZXNwb25zZUhlYWRlcihcIlR1cmJvbGlua3MtTG9jYXRpb25cIikpOih0LmZhaWxlZD0hMCx0LmRlbGVnYXRlLnJlcXVlc3RGYWlsZWRXaXRoU3RhdHVzQ29kZSh0Lnhoci5zdGF0dXMsdC54aHIucmVzcG9uc2VUZXh0KSl9fSh0aGlzKSl9LHIucHJvdG90eXBlLnJlcXVlc3RGYWlsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmRSZXF1ZXN0KGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmZhaWxlZD0hMCx0LmRlbGVnYXRlLnJlcXVlc3RGYWlsZWRXaXRoU3RhdHVzQ29kZSh0LmNvbnN0cnVjdG9yLk5FVFdPUktfRkFJTFVSRSl9fSh0aGlzKSl9LHIucHJvdG90eXBlLnJlcXVlc3RUaW1lZE91dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZFJlcXVlc3QoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuZmFpbGVkPSEwLHQuZGVsZWdhdGUucmVxdWVzdEZhaWxlZFdpdGhTdGF0dXNDb2RlKHQuY29uc3RydWN0b3IuVElNRU9VVF9GQUlMVVJFKX19KHRoaXMpKX0sci5wcm90b3R5cGUucmVxdWVzdENhbmNlbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kUmVxdWVzdCgpfSxyLnByb3RvdHlwZS5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZVJlcXVlc3RTdGFydD1mdW5jdGlvbigpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpyZXF1ZXN0LXN0YXJ0XCIse2RhdGE6e3VybDp0aGlzLnVybCx4aHI6dGhpcy54aHJ9fSl9LHIucHJvdG90eXBlLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJSZXF1ZXN0RW5kPWZ1bmN0aW9uKCl7cmV0dXJuIGUuZGlzcGF0Y2goXCJ0dXJib2xpbmtzOnJlcXVlc3QtZW5kXCIse2RhdGE6e3VybDp0aGlzLnVybCx4aHI6dGhpcy54aHJ9fSl9LHIucHJvdG90eXBlLmNyZWF0ZVhIUj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnhocj1uZXcgWE1MSHR0cFJlcXVlc3QsdGhpcy54aHIub3BlbihcIkdFVFwiLHRoaXMudXJsLCEwKSx0aGlzLnhoci50aW1lb3V0PTFlMyp0aGlzLmNvbnN0cnVjdG9yLnRpbWVvdXQsdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLFwidGV4dC9odG1sLCBhcHBsaWNhdGlvbi94aHRtbCt4bWxcIiksdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihcIlR1cmJvbGlua3MtUmVmZXJyZXJcIix0aGlzLnJlZmVycmVyKSx0aGlzLnhoci5vbnByb2dyZXNzPXRoaXMucmVxdWVzdFByb2dyZXNzZWQsdGhpcy54aHIub25sb2FkPXRoaXMucmVxdWVzdExvYWRlZCx0aGlzLnhoci5vbmVycm9yPXRoaXMucmVxdWVzdEZhaWxlZCx0aGlzLnhoci5vbnRpbWVvdXQ9dGhpcy5yZXF1ZXN0VGltZWRPdXQsdGhpcy54aHIub25hYm9ydD10aGlzLnJlcXVlc3RDYW5jZWxlZH0sci5wcm90b3R5cGUuZW5kUmVxdWVzdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54aHI/KHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlclJlcXVlc3RFbmQoKSxudWxsIT10JiZ0LmNhbGwodGhpcyksdGhpcy5kZXN0cm95KCkpOnZvaWQgMH0sci5wcm90b3R5cGUuc2V0UHJvZ3Jlc3M9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHRoaXMucHJvZ3Jlc3M9dCxcImZ1bmN0aW9uXCI9PXR5cGVvZihlPXRoaXMuZGVsZWdhdGUpLnJlcXVlc3RQcm9ncmVzc2VkP2UucmVxdWVzdFByb2dyZXNzZWQodGhpcy5wcm9ncmVzcyk6dm9pZCAwfSxyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHRoaXMuc2V0UHJvZ3Jlc3MoMSksXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmRlbGVnYXRlKS5yZXF1ZXN0RmluaXNoZWQmJnQucmVxdWVzdEZpbmlzaGVkKCksdGhpcy5kZWxlZ2F0ZT1udWxsLHRoaXMueGhyPW51bGx9LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19O2UuUHJvZ3Jlc3NCYXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy50cmlja2xlPXQodGhpcy50cmlja2xlLHRoaXMpLHRoaXMuc3R5bGVzaGVldEVsZW1lbnQ9dGhpcy5jcmVhdGVTdHlsZXNoZWV0RWxlbWVudCgpLHRoaXMucHJvZ3Jlc3NFbGVtZW50PXRoaXMuY3JlYXRlUHJvZ3Jlc3NFbGVtZW50KCl9dmFyIHI7cmV0dXJuIHI9MzAwLGUuZGVmYXVsdENTUz1cIi50dXJib2xpbmtzLXByb2dyZXNzLWJhciB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBoZWlnaHQ6IDNweDtcXG4gIGJhY2tncm91bmQ6ICMwMDc2ZmY7XFxuICB6LWluZGV4OiA5OTk5O1xcbiAgdHJhbnNpdGlvbjogd2lkdGggXCIrcitcIm1zIGVhc2Utb3V0LCBvcGFjaXR5IFwiK3IvMitcIm1zIFwiK3IvMitcIm1zIGVhc2UtaW47XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcbn1cIixlLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlzaWJsZT92b2lkIDA6KHRoaXMudmlzaWJsZT0hMCx0aGlzLmluc3RhbGxTdHlsZXNoZWV0RWxlbWVudCgpLHRoaXMuaW5zdGFsbFByb2dyZXNzRWxlbWVudCgpLHRoaXMuc3RhcnRUcmlja2xpbmcoKSl9LGUucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aXNpYmxlJiYhdGhpcy5oaWRpbmc/KHRoaXMuaGlkaW5nPSEwLHRoaXMuZmFkZVByb2dyZXNzRWxlbWVudChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC51bmluc3RhbGxQcm9ncmVzc0VsZW1lbnQoKSx0LnN0b3BUcmlja2xpbmcoKSx0LnZpc2libGU9ITEsdC5oaWRpbmc9ITF9fSh0aGlzKSkpOnZvaWQgMH0sZS5wcm90b3R5cGUuc2V0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudmFsdWU9dCx0aGlzLnJlZnJlc2goKX0sZS5wcm90b3R5cGUuaW5zdGFsbFN0eWxlc2hlZXRFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmhlYWQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVzaGVldEVsZW1lbnQsZG9jdW1lbnQuaGVhZC5maXJzdENoaWxkKX0sZS5wcm90b3R5cGUuaW5zdGFsbFByb2dyZXNzRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZS53aWR0aD0wLHRoaXMucHJvZ3Jlc3NFbGVtZW50LnN0eWxlLm9wYWNpdHk9MSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMucHJvZ3Jlc3NFbGVtZW50LGRvY3VtZW50LmJvZHkpLHRoaXMucmVmcmVzaCgpfSxlLnByb3RvdHlwZS5mYWRlUHJvZ3Jlc3NFbGVtZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZS5vcGFjaXR5PTAsc2V0VGltZW91dCh0LDEuNSpyKX0sZS5wcm90b3R5cGUudW5pbnN0YWxsUHJvZ3Jlc3NFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NFbGVtZW50LnBhcmVudE5vZGU/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMucHJvZ3Jlc3NFbGVtZW50KTp2b2lkIDB9LGUucHJvdG90eXBlLnN0YXJ0VHJpY2tsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMudHJpY2tsZUludGVydmFsP3RoaXMudHJpY2tsZUludGVydmFsOnRoaXMudHJpY2tsZUludGVydmFsPXNldEludGVydmFsKHRoaXMudHJpY2tsZSxyKX0sZS5wcm90b3R5cGUuc3RvcFRyaWNrbGluZz1mdW5jdGlvbigpe3JldHVybiBjbGVhckludGVydmFsKHRoaXMudHJpY2tsZUludGVydmFsKSx0aGlzLnRyaWNrbGVJbnRlcnZhbD1udWxsfSxlLnByb3RvdHlwZS50cmlja2xlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZStNYXRoLnJhbmRvbSgpLzEwMCl9LGUucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LnByb2dyZXNzRWxlbWVudC5zdHlsZS53aWR0aD0xMCs5MCp0LnZhbHVlK1wiJVwifX0odGhpcykpfSxlLnByb3RvdHlwZS5jcmVhdGVTdHlsZXNoZWV0RWxlbWVudD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSx0LnR5cGU9XCJ0ZXh0L2Nzc1wiLHQudGV4dENvbnRlbnQ9dGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0Q1NTLHR9LGUucHJvdG90eXBlLmNyZWF0ZVByb2dyZXNzRWxlbWVudD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdC5jbGFzc05hbWU9XCJ0dXJib2xpbmtzLXByb2dyZXNzLWJhclwiLHR9LGV9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19O2UuQnJvd3NlckFkYXB0ZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHIpe3RoaXMuY29udHJvbGxlcj1yLHRoaXMuc2hvd1Byb2dyZXNzQmFyPXQodGhpcy5zaG93UHJvZ3Jlc3NCYXIsdGhpcyksdGhpcy5wcm9ncmVzc0Jhcj1uZXcgZS5Qcm9ncmVzc0Jhcn12YXIgbixvLGk7cmV0dXJuIGk9ZS5IdHRwUmVxdWVzdCxuPWkuTkVUV09SS19GQUlMVVJFLG89aS5USU1FT1VUX0ZBSUxVUkUsci5wcm90b3R5cGUudmlzaXRQcm9wb3NlZFRvTG9jYXRpb25XaXRoQWN0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29udHJvbGxlci5zdGFydFZpc2l0VG9Mb2NhdGlvbldpdGhBY3Rpb24odCxlKX0sci5wcm90b3R5cGUudmlzaXRTdGFydGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0Lmlzc3VlUmVxdWVzdCgpLHQuY2hhbmdlSGlzdG9yeSgpLHQubG9hZENhY2hlZFNuYXBzaG90KCl9LHIucHJvdG90eXBlLnZpc2l0UmVxdWVzdFN0YXJ0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NCYXIuc2V0VmFsdWUoMCksdC5oYXNDYWNoZWRTbmFwc2hvdCgpfHxcInJlc3RvcmVcIiE9PXQuYWN0aW9uP3RoaXMuc2hvd1Byb2dyZXNzQmFyQWZ0ZXJEZWxheSgpOnRoaXMuc2hvd1Byb2dyZXNzQmFyKCl9LHIucHJvdG90eXBlLnZpc2l0UmVxdWVzdFByb2dyZXNzZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NCYXIuc2V0VmFsdWUodC5wcm9ncmVzcyl9LHIucHJvdG90eXBlLnZpc2l0UmVxdWVzdENvbXBsZXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5sb2FkUmVzcG9uc2UoKX0sci5wcm90b3R5cGUudmlzaXRSZXF1ZXN0RmFpbGVkV2l0aFN0YXR1c0NvZGU9ZnVuY3Rpb24odCxlKXtzd2l0Y2goZSl7Y2FzZSBuOmNhc2UgbzpyZXR1cm4gdGhpcy5yZWxvYWQoKTtkZWZhdWx0OnJldHVybiB0LmxvYWRSZXNwb25zZSgpfX0sci5wcm90b3R5cGUudmlzaXRSZXF1ZXN0RmluaXNoZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGlkZVByb2dyZXNzQmFyKCl9LHIucHJvdG90eXBlLnZpc2l0Q29tcGxldGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0LmZvbGxvd1JlZGlyZWN0KCl9LHIucHJvdG90eXBlLnBhZ2VJbnZhbGlkYXRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlbG9hZCgpfSxyLnByb3RvdHlwZS5zaG93UHJvZ3Jlc3NCYXJBZnRlckRlbGF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NCYXJUaW1lb3V0PXNldFRpbWVvdXQodGhpcy5zaG93UHJvZ3Jlc3NCYXIsdGhpcy5jb250cm9sbGVyLnByb2dyZXNzQmFyRGVsYXkpfSxyLnByb3RvdHlwZS5zaG93UHJvZ3Jlc3NCYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9ncmVzc0Jhci5zaG93KCl9LHIucHJvdG90eXBlLmhpZGVQcm9ncmVzc0Jhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb2dyZXNzQmFyLmhpZGUoKSxjbGVhclRpbWVvdXQodGhpcy5wcm9ncmVzc0JhclRpbWVvdXQpfSxyLnByb3RvdHlwZS5yZWxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpfSxyfSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fTtlLkhpc3Rvcnk9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUpe3RoaXMuZGVsZWdhdGU9ZSx0aGlzLm9uUGFnZUxvYWQ9dCh0aGlzLm9uUGFnZUxvYWQsdGhpcyksdGhpcy5vblBvcFN0YXRlPXQodGhpcy5vblBvcFN0YXRlLHRoaXMpfXJldHVybiByLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0ZWQ/dm9pZCAwOihhZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIix0aGlzLm9uUG9wU3RhdGUsITEpLGFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsdGhpcy5vblBhZ2VMb2FkLCExKSx0aGlzLnN0YXJ0ZWQ9ITApfSxyLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnRlZD8ocmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsdGhpcy5vblBvcFN0YXRlLCExKSxyZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLHRoaXMub25QYWdlTG9hZCwhMSksdGhpcy5zdGFydGVkPSExKTp2b2lkIDB9LHIucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdD1lLkxvY2F0aW9uLndyYXAodCksdGhpcy51cGRhdGUoXCJwdXNoXCIsdCxyKX0sci5wcm90b3R5cGUucmVwbGFjZT1mdW5jdGlvbih0LHIpe3JldHVybiB0PWUuTG9jYXRpb24ud3JhcCh0KSx0aGlzLnVwZGF0ZShcInJlcGxhY2VcIix0LHIpfSxyLnByb3RvdHlwZS5vblBvcFN0YXRlPWZ1bmN0aW9uKHQpe3ZhciByLG4sbyxpO3JldHVybiB0aGlzLnNob3VsZEhhbmRsZVBvcFN0YXRlKCkmJihpPW51bGwhPShuPXQuc3RhdGUpP24udHVyYm9saW5rczp2b2lkIDApPyhyPWUuTG9jYXRpb24ud3JhcCh3aW5kb3cubG9jYXRpb24pLG89aS5yZXN0b3JhdGlvbklkZW50aWZpZXIsdGhpcy5kZWxlZ2F0ZS5oaXN0b3J5UG9wcGVkVG9Mb2NhdGlvbldpdGhSZXN0b3JhdGlvbklkZW50aWZpZXIocixvKSk6dm9pZCAwfSxyLnByb3RvdHlwZS5vblBhZ2VMb2FkPWZ1bmN0aW9uKHQpe3JldHVybiBlLmRlZmVyKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LnBhZ2VMb2FkZWQ9ITB9fSh0aGlzKSl9LHIucHJvdG90eXBlLnNob3VsZEhhbmRsZVBvcFN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFnZUlzTG9hZGVkKCl9LHIucHJvdG90eXBlLnBhZ2VJc0xvYWRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhZ2VMb2FkZWR8fFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGV9LHIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbih0LGUscil7dmFyIG47cmV0dXJuIG49e3R1cmJvbGlua3M6e3Jlc3RvcmF0aW9uSWRlbnRpZmllcjpyfX0saGlzdG9yeVt0K1wiU3RhdGVcIl0obixudWxsLGUpfSxyfSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7ZS5TbmFwc2hvdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGUscjtyPXQuaGVhZCxlPXQuYm9keSx0aGlzLmhlYWQ9bnVsbCE9cj9yOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIpLHRoaXMuYm9keT1udWxsIT1lP2U6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJvZHlcIil9cmV0dXJuIHQud3JhcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHRoaXM/dDp0aGlzLmZyb21IVE1MKHQpfSx0LmZyb21IVE1MPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpLGUuaW5uZXJIVE1MPXQsdGhpcy5mcm9tRWxlbWVudChlKX0sdC5mcm9tRWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHRoaXMoe2hlYWQ6dC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKSxib2R5OnQucXVlcnlTZWxlY3RvcihcImJvZHlcIil9KX0sdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHQoe2hlYWQ6dGhpcy5oZWFkLmNsb25lTm9kZSghMCksYm9keTp0aGlzLmJvZHkuY2xvbmVOb2RlKCEwKX0pfSx0LnByb3RvdHlwZS5nZXRSb290TG9jYXRpb249ZnVuY3Rpb24oKXt2YXIgdCxyO3JldHVybiByPW51bGwhPSh0PXRoaXMuZ2V0U2V0dGluZyhcInJvb3RcIikpP3Q6XCIvXCIsbmV3IGUuTG9jYXRpb24ocil9LHQucHJvdG90eXBlLmdldENhY2hlQ29udHJvbFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U2V0dGluZyhcImNhY2hlLWNvbnRyb2xcIil9LHQucHJvdG90eXBlLmdldEVsZW1lbnRGb3JBbmNob3I9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiB0aGlzLmJvZHkucXVlcnlTZWxlY3RvcihcIltpZD0nXCIrdCtcIiddLCBhW25hbWU9J1wiK3QrXCInXVwiKX1jYXRjaChlKXt9fSx0LnByb3RvdHlwZS5oYXNBbmNob3I9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXRoaXMuZ2V0RWxlbWVudEZvckFuY2hvcih0KX0sdC5wcm90b3R5cGUuaXNQcmV2aWV3YWJsZT1mdW5jdGlvbigpe3JldHVyblwibm8tcHJldmlld1wiIT09dGhpcy5nZXRDYWNoZUNvbnRyb2xWYWx1ZSgpfSx0LnByb3RvdHlwZS5pc0NhY2hlYWJsZT1mdW5jdGlvbigpe3JldHVyblwibm8tY2FjaGVcIiE9PXRoaXMuZ2V0Q2FjaGVDb250cm9sVmFsdWUoKX0sdC5wcm90b3R5cGUuaXNWaXNpdGFibGU9ZnVuY3Rpb24oKXtyZXR1cm5cInJlbG9hZFwiIT09dGhpcy5nZXRTZXR0aW5nKFwidmlzaXQtY29udHJvbFwiKX0sdC5wcm90b3R5cGUuZ2V0U2V0dGluZz1mdW5jdGlvbih0KXt2YXIgZSxyO3JldHVybiByPXRoaXMuaGVhZC5xdWVyeVNlbGVjdG9yQWxsKFwibWV0YVtuYW1lPSd0dXJib2xpbmtzLVwiK3QrXCInXVwiKSxlPXJbci5sZW5ndGgtMV0sbnVsbCE9ZT9lLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIik6dm9pZCAwfSx0fSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9W10uc2xpY2U7ZS5SZW5kZXJlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9dmFyIHI7cmV0dXJuIGUucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGUscixuLG87cmV0dXJuIG49YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLGU9Mzw9YXJndW1lbnRzLmxlbmd0aD90LmNhbGwoYXJndW1lbnRzLDIpOltdLG89ZnVuY3Rpb24odCxlLHIpe3IucHJvdG90eXBlPXQucHJvdG90eXBlO3ZhciBuPW5ldyByLG89dC5hcHBseShuLGUpO3JldHVybiBPYmplY3Qobyk9PT1vP286bn0odGhpcyxlLGZ1bmN0aW9uKCl7fSksby5kZWxlZ2F0ZT1uLG8ucmVuZGVyKHIpLG99LGUucHJvdG90eXBlLnJlbmRlclZpZXc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUudmlld1dpbGxSZW5kZXIodGhpcy5uZXdCb2R5KSx0KCksdGhpcy5kZWxlZ2F0ZS52aWV3UmVuZGVyZWQodGhpcy5uZXdCb2R5KX0sZS5wcm90b3R5cGUuaW52YWxpZGF0ZVZpZXc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZS52aWV3SW52YWxpZGF0ZWQoKX0sZS5wcm90b3R5cGUuY3JlYXRlU2NyaXB0RWxlbWVudD1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm5cImZhbHNlXCI9PT10LmdldEF0dHJpYnV0ZShcImRhdGEtdHVyYm9saW5rcy1ldmFsXCIpP3Q6KGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxlLnRleHRDb250ZW50PXQudGV4dENvbnRlbnQsZS5hc3luYz0hMSxyKGUsdCksZSl9LHI9ZnVuY3Rpb24odCxlKXt2YXIgcixuLG8saSxzLGEsdTtmb3IoaT1lLmF0dHJpYnV0ZXMsYT1bXSxyPTAsbj1pLmxlbmd0aDtuPnI7cisrKXM9aVtyXSxvPXMubmFtZSx1PXMudmFsdWUsYS5wdXNoKHQuc2V0QXR0cmlidXRlKG8sdSkpO3JldHVybiBhfSxlfSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7ZS5IZWFkRGV0YWlscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGUscixpLHMsYSx1LGw7Zm9yKHRoaXMuZWxlbWVudD10LHRoaXMuZWxlbWVudHM9e30sbD10aGlzLmVsZW1lbnQuY2hpbGROb2RlcyxzPTAsdT1sLmxlbmd0aDt1PnM7cysrKWk9bFtzXSxpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJihhPWkub3V0ZXJIVE1MLHI9bnVsbCE9KGU9dGhpcy5lbGVtZW50cylbYV0/ZVthXTplW2FdPXt0eXBlOm8oaSksdHJhY2tlZDpuKGkpLGVsZW1lbnRzOltdfSxyLmVsZW1lbnRzLnB1c2goaSkpfXZhciBlLHIsbixvO3JldHVybiB0LnByb3RvdHlwZS5oYXNFbGVtZW50V2l0aEtleT1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbiB0aGlzLmVsZW1lbnRzfSx0LnByb3RvdHlwZS5nZXRUcmFja2VkRWxlbWVudFNpZ25hdHVyZT1mdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHIsbjtyPXRoaXMuZWxlbWVudHMsbj1bXTtmb3IodCBpbiByKWU9clt0XS50cmFja2VkLGUmJm4ucHVzaCh0KTtyZXR1cm4gbn0uY2FsbCh0aGlzKS5qb2luKFwiXCIpfSx0LnByb3RvdHlwZS5nZXRTY3JpcHRFbGVtZW50c05vdEluRGV0YWlscz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRFbGVtZW50c01hdGNoaW5nVHlwZU5vdEluRGV0YWlscyhcInNjcmlwdFwiLHQpfSx0LnByb3RvdHlwZS5nZXRTdHlsZXNoZWV0RWxlbWVudHNOb3RJbkRldGFpbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNNYXRjaGluZ1R5cGVOb3RJbkRldGFpbHMoXCJzdHlsZXNoZWV0XCIsdCl9LHQucHJvdG90eXBlLmdldEVsZW1lbnRzTWF0Y2hpbmdUeXBlTm90SW5EZXRhaWxzPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixvLGkscyxhO289dGhpcy5lbGVtZW50cyxzPVtdO2ZvcihuIGluIG8paT1vW25dLGE9aS50eXBlLHI9aS5lbGVtZW50cyxhIT09dHx8ZS5oYXNFbGVtZW50V2l0aEtleShuKXx8cy5wdXNoKHJbMF0pO3JldHVybiBzfSx0LnByb3RvdHlwZS5nZXRQcm92aXNpb25hbEVsZW1lbnRzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4sbyxpLHM7cj1bXSxuPXRoaXMuZWxlbWVudHM7Zm9yKGUgaW4gbilvPW5bZV0scz1vLnR5cGUsaT1vLnRyYWNrZWQsdD1vLmVsZW1lbnRzLG51bGwhPXN8fGk/dC5sZW5ndGg+MSYmci5wdXNoLmFwcGx5KHIsdC5zbGljZSgxKSk6ci5wdXNoLmFwcGx5KHIsdCk7cmV0dXJuIHJ9LG89ZnVuY3Rpb24odCl7cmV0dXJuIGUodCk/XCJzY3JpcHRcIjpyKHQpP1wic3R5bGVzaGVldFwiOnZvaWQgMH0sbj1mdW5jdGlvbih0KXtyZXR1cm5cInJlbG9hZFwiPT09dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvbGlua3MtdHJhY2tcIil9LGU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9dC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXCJzY3JpcHRcIj09PWV9LHI9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9dC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXCJzdHlsZVwiPT09ZXx8XCJsaW5rXCI9PT1lJiZcInN0eWxlc2hlZXRcIj09PXQuZ2V0QXR0cmlidXRlKFwicmVsXCIpfSx0fSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fWZvcih2YXIgbyBpbiBlKXIuY2FsbChlLG8pJiYodFtvXT1lW29dKTtyZXR1cm4gbi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsdC5wcm90b3R5cGU9bmV3IG4sdC5fX3N1cGVyX189ZS5wcm90b3R5cGUsdH0scj17fS5oYXNPd25Qcm9wZXJ0eTtlLlNuYXBzaG90UmVuZGVyZXI9ZnVuY3Rpb24ocil7ZnVuY3Rpb24gbih0LHIsbil7dGhpcy5jdXJyZW50U25hcHNob3Q9dCx0aGlzLm5ld1NuYXBzaG90PXIsdGhpcy5pc1ByZXZpZXc9bix0aGlzLmN1cnJlbnRIZWFkRGV0YWlscz1uZXcgZS5IZWFkRGV0YWlscyh0aGlzLmN1cnJlbnRTbmFwc2hvdC5oZWFkKSx0aGlzLm5ld0hlYWREZXRhaWxzPW5ldyBlLkhlYWREZXRhaWxzKHRoaXMubmV3U25hcHNob3QuaGVhZCksdGhpcy5uZXdCb2R5PXRoaXMubmV3U25hcHNob3QuYm9keX1yZXR1cm4gdChuLHIpLG4ucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zaG91bGRSZW5kZXIoKT8odGhpcy5tZXJnZUhlYWQoKSx0aGlzLnJlbmRlclZpZXcoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUucmVwbGFjZUJvZHkoKSxlLmlzUHJldmlld3x8ZS5mb2N1c0ZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQoKSx0KCl9fSh0aGlzKSkpOnRoaXMuaW52YWxpZGF0ZVZpZXcoKX0sbi5wcm90b3R5cGUubWVyZ2VIZWFkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29weU5ld0hlYWRTdHlsZXNoZWV0RWxlbWVudHMoKSx0aGlzLmNvcHlOZXdIZWFkU2NyaXB0RWxlbWVudHMoKSx0aGlzLnJlbW92ZUN1cnJlbnRIZWFkUHJvdmlzaW9uYWxFbGVtZW50cygpLHRoaXMuY29weU5ld0hlYWRQcm92aXNpb25hbEVsZW1lbnRzKCl9LG4ucHJvdG90eXBlLnJlcGxhY2VCb2R5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWN0aXZhdGVCb2R5U2NyaXB0RWxlbWVudHMoKSx0aGlzLmltcG9ydEJvZHlQZXJtYW5lbnRFbGVtZW50cygpLHRoaXMuYXNzaWduTmV3Qm9keSgpfSxuLnByb3RvdHlwZS5zaG91bGRSZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXdTbmFwc2hvdC5pc1Zpc2l0YWJsZSgpJiZ0aGlzLnRyYWNrZWRFbGVtZW50c0FyZUlkZW50aWNhbCgpfSxuLnByb3RvdHlwZS50cmFja2VkRWxlbWVudHNBcmVJZGVudGljYWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50SGVhZERldGFpbHMuZ2V0VHJhY2tlZEVsZW1lbnRTaWduYXR1cmUoKT09PXRoaXMubmV3SGVhZERldGFpbHMuZ2V0VHJhY2tlZEVsZW1lbnRTaWduYXR1cmUoKX0sbi5wcm90b3R5cGUuY29weU5ld0hlYWRTdHlsZXNoZWV0RWxlbWVudHM9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixvO2ZvcihuPXRoaXMuZ2V0TmV3SGVhZFN0eWxlc2hlZXRFbGVtZW50cygpLG89W10sZT0wLHI9bi5sZW5ndGg7cj5lO2UrKyl0PW5bZV0sby5wdXNoKGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodCkpO3JldHVybiBvfSxuLnByb3RvdHlwZS5jb3B5TmV3SGVhZFNjcmlwdEVsZW1lbnRzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4sbztmb3Iobj10aGlzLmdldE5ld0hlYWRTY3JpcHRFbGVtZW50cygpLG89W10sZT0wLHI9bi5sZW5ndGg7cj5lO2UrKyl0PW5bZV0sby5wdXNoKGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVTY3JpcHRFbGVtZW50KHQpKSk7cmV0dXJuIG99LG4ucHJvdG90eXBlLnJlbW92ZUN1cnJlbnRIZWFkUHJvdmlzaW9uYWxFbGVtZW50cz1mdW5jdGlvbigpe3ZhciB0LGUscixuLG87Zm9yKG49dGhpcy5nZXRDdXJyZW50SGVhZFByb3Zpc2lvbmFsRWxlbWVudHMoKSxvPVtdLGU9MCxyPW4ubGVuZ3RoO3I+ZTtlKyspdD1uW2VdLG8ucHVzaChkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHQpKTtyZXR1cm4gb30sbi5wcm90b3R5cGUuY29weU5ld0hlYWRQcm92aXNpb25hbEVsZW1lbnRzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4sbztmb3Iobj10aGlzLmdldE5ld0hlYWRQcm92aXNpb25hbEVsZW1lbnRzKCksbz1bXSxlPTAscj1uLmxlbmd0aDtyPmU7ZSsrKXQ9bltlXSxvLnB1c2goZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0KSk7cmV0dXJuIG99LG4ucHJvdG90eXBlLmltcG9ydEJvZHlQZXJtYW5lbnRFbGVtZW50cz1mdW5jdGlvbigpe3ZhciB0LGUscixuLG8saTtmb3Iobj10aGlzLmdldE5ld0JvZHlQZXJtYW5lbnRFbGVtZW50cygpLGk9W10sZT0wLHI9bi5sZW5ndGg7cj5lO2UrKylvPW5bZV0sKHQ9dGhpcy5maW5kQ3VycmVudEJvZHlQZXJtYW5lbnRFbGVtZW50KG8pKT9pLnB1c2goby5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0LG8pKTppLnB1c2godm9pZCAwKTtyZXR1cm4gaX0sbi5wcm90b3R5cGUuYWN0aXZhdGVCb2R5U2NyaXB0RWxlbWVudHM9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixvLGk7Zm9yKG49dGhpcy5nZXROZXdCb2R5U2NyaXB0RWxlbWVudHMoKSxpPVtdLGU9MCxyPW4ubGVuZ3RoO3I+ZTtlKyspbz1uW2VdLHQ9dGhpcy5jcmVhdGVTY3JpcHRFbGVtZW50KG8pLGkucHVzaChvLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHQsbykpO3JldHVybiBpfSxuLnByb3RvdHlwZS5hc3NpZ25OZXdCb2R5PWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmJvZHk9dGhpcy5uZXdCb2R5fSxuLnByb3RvdHlwZS5mb2N1c0ZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbnVsbCE9KHQ9dGhpcy5maW5kRmlyc3RBdXRvZm9jdXNhYmxlRWxlbWVudCgpKT90LmZvY3VzKCk6dm9pZCAwfSxuLnByb3RvdHlwZS5nZXROZXdIZWFkU3R5bGVzaGVldEVsZW1lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV3SGVhZERldGFpbHMuZ2V0U3R5bGVzaGVldEVsZW1lbnRzTm90SW5EZXRhaWxzKHRoaXMuY3VycmVudEhlYWREZXRhaWxzKX0sbi5wcm90b3R5cGUuZ2V0TmV3SGVhZFNjcmlwdEVsZW1lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV3SGVhZERldGFpbHMuZ2V0U2NyaXB0RWxlbWVudHNOb3RJbkRldGFpbHModGhpcy5jdXJyZW50SGVhZERldGFpbHMpfSxuLnByb3RvdHlwZS5nZXRDdXJyZW50SGVhZFByb3Zpc2lvbmFsRWxlbWVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50SGVhZERldGFpbHMuZ2V0UHJvdmlzaW9uYWxFbGVtZW50cygpfSxuLnByb3RvdHlwZS5nZXROZXdIZWFkUHJvdmlzaW9uYWxFbGVtZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5ld0hlYWREZXRhaWxzLmdldFByb3Zpc2lvbmFsRWxlbWVudHMoKX0sbi5wcm90b3R5cGUuZ2V0TmV3Qm9keVBlcm1hbmVudEVsZW1lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV3Qm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkXVtkYXRhLXR1cmJvbGlua3MtcGVybWFuZW50XVwiKX0sbi5wcm90b3R5cGUuZmluZEN1cnJlbnRCb2R5UGVybWFuZW50RWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKFwiI1wiK3QuaWQrXCJbZGF0YS10dXJib2xpbmtzLXBlcm1hbmVudF1cIil9LG4ucHJvdG90eXBlLmdldE5ld0JvZHlTY3JpcHRFbGVtZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5ld0JvZHkucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFwiKX0sbi5wcm90b3R5cGUuZmluZEZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKFwiW2F1dG9mb2N1c11cIil9LG59KGUuUmVuZGVyZXIpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fWZvcih2YXIgbyBpbiBlKXIuY2FsbChlLG8pJiYodFtvXT1lW29dKTtyZXR1cm4gbi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsdC5wcm90b3R5cGU9bmV3IG4sdC5fX3N1cGVyX189ZS5wcm90b3R5cGUsdH0scj17fS5oYXNPd25Qcm9wZXJ0eTtlLkVycm9yUmVuZGVyZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcih0KXt0aGlzLmh0bWw9dH1yZXR1cm4gdChyLGUpLHIucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZW5kZXJWaWV3KGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLnJlcGxhY2VEb2N1bWVudEhUTUwoKSxlLmFjdGl2YXRlQm9keVNjcmlwdEVsZW1lbnRzKCksdCgpfX0odGhpcykpfSxyLnByb3RvdHlwZS5yZXBsYWNlRG9jdW1lbnRIVE1MPWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUw9dGhpcy5odG1sfSxyLnByb3RvdHlwZS5hY3RpdmF0ZUJvZHlTY3JpcHRFbGVtZW50cz1mdW5jdGlvbigpe3ZhciB0LGUscixuLG8saTtmb3Iobj10aGlzLmdldFNjcmlwdEVsZW1lbnRzKCksaT1bXSxlPTAscj1uLmxlbmd0aDtyPmU7ZSsrKW89bltlXSx0PXRoaXMuY3JlYXRlU2NyaXB0RWxlbWVudChvKSxpLnB1c2goby5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0LG8pKTtyZXR1cm4gaX0sci5wcm90b3R5cGUuZ2V0U2NyaXB0RWxlbWVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRcIil9LHJ9KGUuUmVuZGVyZXIpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7ZS5WaWV3PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmRlbGVnYXRlPXQsdGhpcy5lbGVtZW50PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudH1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Um9vdExvY2F0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U25hcHNob3QoKS5nZXRSb290TG9jYXRpb24oKX0sdC5wcm90b3R5cGUuZ2V0RWxlbWVudEZvckFuY2hvcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRTbmFwc2hvdCgpLmdldEVsZW1lbnRGb3JBbmNob3IodCl9LHQucHJvdG90eXBlLmdldFNuYXBzaG90PWZ1bmN0aW9uKCl7cmV0dXJuIGUuU25hcHNob3QuZnJvbUVsZW1lbnQodGhpcy5lbGVtZW50KX0sdC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixvO3JldHVybiBvPXQuc25hcHNob3Qscj10LmVycm9yLG49dC5pc1ByZXZpZXcsdGhpcy5tYXJrQXNQcmV2aWV3KG4pLG51bGwhPW8/dGhpcy5yZW5kZXJTbmFwc2hvdChvLG4sZSk6dGhpcy5yZW5kZXJFcnJvcihyLGUpfSx0LnByb3RvdHlwZS5tYXJrQXNQcmV2aWV3PWZ1bmN0aW9uKHQpe3JldHVybiB0P3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvbGlua3MtcHJldmlld1wiLFwiXCIpOnRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvbGlua3MtcHJldmlld1wiKX0sdC5wcm90b3R5cGUucmVuZGVyU25hcHNob3Q9ZnVuY3Rpb24odCxyLG4pe3JldHVybiBlLlNuYXBzaG90UmVuZGVyZXIucmVuZGVyKHRoaXMuZGVsZWdhdGUsbix0aGlzLmdldFNuYXBzaG90KCksZS5TbmFwc2hvdC53cmFwKHQpLHIpfSx0LnByb3RvdHlwZS5yZW5kZXJFcnJvcj1mdW5jdGlvbih0LHIpe3JldHVybiBlLkVycm9yUmVuZGVyZXIucmVuZGVyKHRoaXMuZGVsZWdhdGUscix0KX0sdH0oKX0uY2FsbCh0aGlzKSxmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX07ZS5TY3JvbGxNYW5hZ2VyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLmRlbGVnYXRlPXIsdGhpcy5vblNjcm9sbD10KHRoaXMub25TY3JvbGwsdGhpcyksdGhpcy5vblNjcm9sbD1lLnRocm90dGxlKHRoaXMub25TY3JvbGwpfXJldHVybiByLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0ZWQ/dm9pZCAwOihhZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbCwhMSksdGhpcy5vblNjcm9sbCgpLHRoaXMuc3RhcnRlZD0hMCl9LHIucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydGVkPyhyZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbCwhMSksdGhpcy5zdGFydGVkPSExKTp2b2lkIDB9LHIucHJvdG90eXBlLnNjcm9sbFRvRWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdC5zY3JvbGxJbnRvVmlldygpfSxyLnByb3RvdHlwZS5zY3JvbGxUb1Bvc2l0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlLHI7cmV0dXJuIGU9dC54LHI9dC55LHdpbmRvdy5zY3JvbGxUbyhlLHIpfSxyLnByb3RvdHlwZS5vblNjcm9sbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy51cGRhdGVQb3NpdGlvbih7eDp3aW5kb3cucGFnZVhPZmZzZXQseTp3aW5kb3cucGFnZVlPZmZzZXR9KX0sci5wcm90b3R5cGUudXBkYXRlUG9zaXRpb249ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHRoaXMucG9zaXRpb249dCxudWxsIT0oZT10aGlzLmRlbGVnYXRlKT9lLnNjcm9sbFBvc2l0aW9uQ2hhbmdlZCh0aGlzLnBvc2l0aW9uKTp2b2lkIDB9LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXtlLlNuYXBzaG90Q2FjaGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuc2l6ZT10LHRoaXMua2V5cz1bXSx0aGlzLnNuYXBzaG90cz17fX12YXIgcjtyZXR1cm4gdC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXIodCksZSBpbiB0aGlzLnNuYXBzaG90c30sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3ZhciBlO2lmKHRoaXMuaGFzKHQpKXJldHVybiBlPXRoaXMucmVhZCh0KSx0aGlzLnRvdWNoKHQpLGV9LHQucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLndyaXRlKHQsZSksdGhpcy50b3VjaCh0KSxlfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXIodCksdGhpcy5zbmFwc2hvdHNbZV19LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIG49cih0KSx0aGlzLnNuYXBzaG90c1tuXT1lfSx0LnByb3RvdHlwZS50b3VjaD1mdW5jdGlvbih0KXt2YXIgZSxuO3JldHVybiBuPXIodCksZT10aGlzLmtleXMuaW5kZXhPZihuKSxlPi0xJiZ0aGlzLmtleXMuc3BsaWNlKGUsMSksdGhpcy5rZXlzLnVuc2hpZnQobiksdGhpcy50cmltKCl9LHQucHJvdG90eXBlLnRyaW09ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixvO2ZvcihuPXRoaXMua2V5cy5zcGxpY2UodGhpcy5zaXplKSxvPVtdLHQ9MCxyPW4ubGVuZ3RoO3I+dDt0KyspZT1uW3RdLG8ucHVzaChkZWxldGUgdGhpcy5zbmFwc2hvdHNbZV0pO3JldHVybiBvfSxyPWZ1bmN0aW9uKHQpe3JldHVybiBlLkxvY2F0aW9uLndyYXAodCkudG9DYWNoZUtleSgpfSx0fSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fTtlLlZpc2l0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyLG4sbyl7dGhpcy5jb250cm9sbGVyPXIsdGhpcy5hY3Rpb249byx0aGlzLnBlcmZvcm1TY3JvbGw9dCh0aGlzLnBlcmZvcm1TY3JvbGwsdGhpcyksdGhpcy5pZGVudGlmaWVyPWUudXVpZCgpLHRoaXMubG9jYXRpb249ZS5Mb2NhdGlvbi53cmFwKG4pLHRoaXMuYWRhcHRlcj10aGlzLmNvbnRyb2xsZXIuYWRhcHRlcix0aGlzLnN0YXRlPVwiaW5pdGlhbGl6ZWRcIix0aGlzLnRpbWluZ01ldHJpY3M9e319dmFyIG47cmV0dXJuIHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuXCJpbml0aWFsaXplZFwiPT09dGhpcy5zdGF0ZT8odGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoXCJ2aXNpdFN0YXJ0XCIpLHRoaXMuc3RhdGU9XCJzdGFydGVkXCIsdGhpcy5hZGFwdGVyLnZpc2l0U3RhcnRlZCh0aGlzKSk6dm9pZCAwfSxyLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm5cInN0YXJ0ZWRcIj09PXRoaXMuc3RhdGU/KG51bGwhPSh0PXRoaXMucmVxdWVzdCkmJnQuY2FuY2VsKCksdGhpcy5jYW5jZWxSZW5kZXIoKSx0aGlzLnN0YXRlPVwiY2FuY2VsZWRcIik6dm9pZCAwfSxyLnByb3RvdHlwZS5jb21wbGV0ZT1mdW5jdGlvbigpe3ZhciB0O3JldHVyblwic3RhcnRlZFwiPT09dGhpcy5zdGF0ZT8odGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoXCJ2aXNpdEVuZFwiKSx0aGlzLnN0YXRlPVwiY29tcGxldGVkXCIsXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0Q29tcGxldGVkJiZ0LnZpc2l0Q29tcGxldGVkKHRoaXMpLHRoaXMuY29udHJvbGxlci52aXNpdENvbXBsZXRlZCh0aGlzKSk6dm9pZCAwfSxyLnByb3RvdHlwZS5mYWlsPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuXCJzdGFydGVkXCI9PT10aGlzLnN0YXRlPyh0aGlzLnN0YXRlPVwiZmFpbGVkXCIsXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0RmFpbGVkP3QudmlzaXRGYWlsZWQodGhpcyk6dm9pZCAwKTp2b2lkIDB9LHIucHJvdG90eXBlLmNoYW5nZUhpc3Rvcnk9ZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiB0aGlzLmhpc3RvcnlDaGFuZ2VkP3ZvaWQgMDoodD10aGlzLmxvY2F0aW9uLmlzRXF1YWxUbyh0aGlzLnJlZmVycmVyKT9cInJlcGxhY2VcIjp0aGlzLmFjdGlvbixlPW4odCksdGhpcy5jb250cm9sbGVyW2VdKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpLHRoaXMuaGlzdG9yeUNoYW5nZWQ9ITApfSxyLnByb3RvdHlwZS5pc3N1ZVJlcXVlc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaG91bGRJc3N1ZVJlcXVlc3QoKSYmbnVsbD09dGhpcy5yZXF1ZXN0Pyh0aGlzLnByb2dyZXNzPTAsdGhpcy5yZXF1ZXN0PW5ldyBlLkh0dHBSZXF1ZXN0KHRoaXMsdGhpcy5sb2NhdGlvbix0aGlzLnJlZmVycmVyKSx0aGlzLnJlcXVlc3Quc2VuZCgpKTp2b2lkIDB9LHIucHJvdG90eXBlLmdldENhY2hlZFNuYXBzaG90PWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuISh0PXRoaXMuY29udHJvbGxlci5nZXRDYWNoZWRTbmFwc2hvdEZvckxvY2F0aW9uKHRoaXMubG9jYXRpb24pKXx8bnVsbCE9dGhpcy5sb2NhdGlvbi5hbmNob3ImJiF0Lmhhc0FuY2hvcih0aGlzLmxvY2F0aW9uLmFuY2hvcil8fFwicmVzdG9yZVwiIT09dGhpcy5hY3Rpb24mJiF0LmlzUHJldmlld2FibGUoKT92b2lkIDA6dH0sci5wcm90b3R5cGUuaGFzQ2FjaGVkU25hcHNob3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRDYWNoZWRTbmFwc2hvdCgpfSxyLnByb3RvdHlwZS5sb2FkQ2FjaGVkU25hcHNob3Q9ZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybihlPXRoaXMuZ2V0Q2FjaGVkU25hcHNob3QoKSk/KHQ9dGhpcy5zaG91bGRJc3N1ZVJlcXVlc3QoKSx0aGlzLnJlbmRlcihmdW5jdGlvbigpe3ZhciByO3JldHVybiB0aGlzLmNhY2hlU25hcHNob3QoKSx0aGlzLmNvbnRyb2xsZXIucmVuZGVyKHtzbmFwc2hvdDplLGlzUHJldmlldzp0fSx0aGlzLnBlcmZvcm1TY3JvbGwpLFwiZnVuY3Rpb25cIj09dHlwZW9mKHI9dGhpcy5hZGFwdGVyKS52aXNpdFJlbmRlcmVkJiZyLnZpc2l0UmVuZGVyZWQodGhpcyksdD92b2lkIDA6dGhpcy5jb21wbGV0ZSgpfSkpOnZvaWQgMH0sci5wcm90b3R5cGUubG9hZFJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMucmVzcG9uc2U/dGhpcy5yZW5kZXIoZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiB0aGlzLmNhY2hlU25hcHNob3QoKSx0aGlzLnJlcXVlc3QuZmFpbGVkPyh0aGlzLmNvbnRyb2xsZXIucmVuZGVyKHtlcnJvcjp0aGlzLnJlc3BvbnNlfSx0aGlzLnBlcmZvcm1TY3JvbGwpLFwiZnVuY3Rpb25cIj09dHlwZW9mKHQ9dGhpcy5hZGFwdGVyKS52aXNpdFJlbmRlcmVkJiZ0LnZpc2l0UmVuZGVyZWQodGhpcyksdGhpcy5mYWlsKCkpOih0aGlzLmNvbnRyb2xsZXIucmVuZGVyKHtzbmFwc2hvdDp0aGlzLnJlc3BvbnNlfSx0aGlzLnBlcmZvcm1TY3JvbGwpLFwiZnVuY3Rpb25cIj09dHlwZW9mKGU9dGhpcy5hZGFwdGVyKS52aXNpdFJlbmRlcmVkJiZlLnZpc2l0UmVuZGVyZWQodGhpcyksdGhpcy5jb21wbGV0ZSgpKX0pOnZvaWQgMH0sci5wcm90b3R5cGUuZm9sbG93UmVkaXJlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWRpcmVjdGVkVG9Mb2NhdGlvbiYmIXRoaXMuZm9sbG93ZWRSZWRpcmVjdD8odGhpcy5sb2NhdGlvbj10aGlzLnJlZGlyZWN0ZWRUb0xvY2F0aW9uLHRoaXMuY29udHJvbGxlci5yZXBsYWNlSGlzdG9yeVdpdGhMb2NhdGlvbkFuZFJlc3RvcmF0aW9uSWRlbnRpZmllcih0aGlzLnJlZGlyZWN0ZWRUb0xvY2F0aW9uLHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyKSx0aGlzLmZvbGxvd2VkUmVkaXJlY3Q9ITApOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdFN0YXJ0ZWQ9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gdGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoXCJyZXF1ZXN0U3RhcnRcIiksXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0UmVxdWVzdFN0YXJ0ZWQ/dC52aXNpdFJlcXVlc3RTdGFydGVkKHRoaXMpOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdFByb2dyZXNzZWQ9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHRoaXMucHJvZ3Jlc3M9dCxcImZ1bmN0aW9uXCI9PXR5cGVvZihlPXRoaXMuYWRhcHRlcikudmlzaXRSZXF1ZXN0UHJvZ3Jlc3NlZD9lLnZpc2l0UmVxdWVzdFByb2dyZXNzZWQodGhpcyk6dm9pZCAwfSxyLnByb3RvdHlwZS5yZXF1ZXN0Q29tcGxldGVkV2l0aFJlc3BvbnNlPWZ1bmN0aW9uKHQscil7cmV0dXJuIHRoaXMucmVzcG9uc2U9dCxudWxsIT1yJiYodGhpcy5yZWRpcmVjdGVkVG9Mb2NhdGlvbj1lLkxvY2F0aW9uLndyYXAocikpLHRoaXMuYWRhcHRlci52aXNpdFJlcXVlc3RDb21wbGV0ZWQodGhpcyl9LHIucHJvdG90eXBlLnJlcXVlc3RGYWlsZWRXaXRoU3RhdHVzQ29kZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnJlc3BvbnNlPWUsdGhpcy5hZGFwdGVyLnZpc2l0UmVxdWVzdEZhaWxlZFdpdGhTdGF0dXNDb2RlKHRoaXMsdCl9LHIucHJvdG90eXBlLnJlcXVlc3RGaW5pc2hlZD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0aGlzLnJlY29yZFRpbWluZ01ldHJpYyhcInJlcXVlc3RFbmRcIiksXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0UmVxdWVzdEZpbmlzaGVkP3QudmlzaXRSZXF1ZXN0RmluaXNoZWQodGhpcyk6dm9pZCAwfSxyLnByb3RvdHlwZS5wZXJmb3JtU2Nyb2xsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2Nyb2xsZWQ/dm9pZCAwOihcInJlc3RvcmVcIj09PXRoaXMuYWN0aW9uP3RoaXMuc2Nyb2xsVG9SZXN0b3JlZFBvc2l0aW9uKCl8fHRoaXMuc2Nyb2xsVG9Ub3AoKTp0aGlzLnNjcm9sbFRvQW5jaG9yKCl8fHRoaXMuc2Nyb2xsVG9Ub3AoKSx0aGlzLnNjcm9sbGVkPSEwKX0sci5wcm90b3R5cGUuc2Nyb2xsVG9SZXN0b3JlZFBvc2l0aW9uPWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gdD1udWxsIT0oZT10aGlzLnJlc3RvcmF0aW9uRGF0YSk/ZS5zY3JvbGxQb3NpdGlvbjp2b2lkIDAsbnVsbCE9dD8odGhpcy5jb250cm9sbGVyLnNjcm9sbFRvUG9zaXRpb24odCksITApOnZvaWQgMH0sci5wcm90b3R5cGUuc2Nyb2xsVG9BbmNob3I9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5sb2NhdGlvbi5hbmNob3I/KHRoaXMuY29udHJvbGxlci5zY3JvbGxUb0FuY2hvcih0aGlzLmxvY2F0aW9uLmFuY2hvciksITApOnZvaWQgMH0sci5wcm90b3R5cGUuc2Nyb2xsVG9Ub3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250cm9sbGVyLnNjcm9sbFRvUG9zaXRpb24oe3g6MCx5OjB9KX0sci5wcm90b3R5cGUucmVjb3JkVGltaW5nTWV0cmljPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBudWxsIT0oZT10aGlzLnRpbWluZ01ldHJpY3MpW3RdP2VbdF06ZVt0XT0obmV3IERhdGUpLmdldFRpbWUoKX0sci5wcm90b3R5cGUuZ2V0VGltaW5nTWV0cmljcz1mdW5jdGlvbigpe3JldHVybiBlLmNvcHlPYmplY3QodGhpcy50aW1pbmdNZXRyaWNzKX0sbj1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwicmVwbGFjZVwiOnJldHVyblwicmVwbGFjZUhpc3RvcnlXaXRoTG9jYXRpb25BbmRSZXN0b3JhdGlvbklkZW50aWZpZXJcIjtjYXNlXCJhZHZhbmNlXCI6Y2FzZVwicmVzdG9yZVwiOnJldHVyblwicHVzaEhpc3RvcnlXaXRoTG9jYXRpb25BbmRSZXN0b3JhdGlvbklkZW50aWZpZXJcIn19LHIucHJvdG90eXBlLnNob3VsZElzc3VlUmVxdWVzdD1mdW5jdGlvbigpe3JldHVyblwicmVzdG9yZVwiPT09dGhpcy5hY3Rpb24/IXRoaXMuaGFzQ2FjaGVkU25hcHNob3QoKTohMH0sci5wcm90b3R5cGUuY2FjaGVTbmFwc2hvdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNuYXBzaG90Q2FjaGVkP3ZvaWQgMDoodGhpcy5jb250cm9sbGVyLmNhY2hlU25hcHNob3QoKSx0aGlzLnNuYXBzaG90Q2FjaGVkPSEwKX0sci5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNhbmNlbFJlbmRlcigpLHRoaXMuZnJhbWU9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmZyYW1lPW51bGwsdC5jYWxsKGUpfX0odGhpcykpfSxyLnByb3RvdHlwZS5jYW5jZWxSZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mcmFtZT9jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lKTp2b2lkIDB9LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19O2UuQ29udHJvbGxlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHIoKXt0aGlzLmNsaWNrQnViYmxlZD10KHRoaXMuY2xpY2tCdWJibGVkLHRoaXMpLHRoaXMuY2xpY2tDYXB0dXJlZD10KHRoaXMuY2xpY2tDYXB0dXJlZCx0aGlzKSx0aGlzLnBhZ2VMb2FkZWQ9dCh0aGlzLnBhZ2VMb2FkZWQsdGhpcyksdGhpcy5oaXN0b3J5PW5ldyBlLkhpc3RvcnkodGhpcyksdGhpcy52aWV3PW5ldyBlLlZpZXcodGhpcyksdGhpcy5zY3JvbGxNYW5hZ2VyPW5ldyBlLlNjcm9sbE1hbmFnZXIodGhpcyksdGhpcy5yZXN0b3JhdGlvbkRhdGE9e30sdGhpcy5jbGVhckNhY2hlKCksdGhpcy5zZXRQcm9ncmVzc0JhckRlbGF5KDUwMCl9cmV0dXJuIHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIGUuc3VwcG9ydGVkJiYhdGhpcy5zdGFydGVkPyhhZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmNsaWNrQ2FwdHVyZWQsITApLGFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsdGhpcy5wYWdlTG9hZGVkLCExKSx0aGlzLnNjcm9sbE1hbmFnZXIuc3RhcnQoKSx0aGlzLnN0YXJ0SGlzdG9yeSgpLHRoaXMuc3RhcnRlZD0hMCx0aGlzLmVuYWJsZWQ9ITApOnZvaWQgMH0sci5wcm90b3R5cGUuZGlzYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWQ9ITF9LHIucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydGVkPyhyZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmNsaWNrQ2FwdHVyZWQsITApLHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsdGhpcy5wYWdlTG9hZGVkLCExKSx0aGlzLnNjcm9sbE1hbmFnZXIuc3RvcCgpLHRoaXMuc3RvcEhpc3RvcnkoKSx0aGlzLnN0YXJ0ZWQ9ITEpOnZvaWQgMH0sci5wcm90b3R5cGUuY2xlYXJDYWNoZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhY2hlPW5ldyBlLlNuYXBzaG90Q2FjaGUoMTApfSxyLnByb3RvdHlwZS52aXNpdD1mdW5jdGlvbih0LHIpe3ZhciBuLG87cmV0dXJuIG51bGw9PXImJihyPXt9KSx0PWUuTG9jYXRpb24ud3JhcCh0KSx0aGlzLmFwcGxpY2F0aW9uQWxsb3dzVmlzaXRpbmdMb2NhdGlvbih0KT90aGlzLmxvY2F0aW9uSXNWaXNpdGFibGUodCk/KG49bnVsbCE9KG89ci5hY3Rpb24pP286XCJhZHZhbmNlXCIsdGhpcy5hZGFwdGVyLnZpc2l0UHJvcG9zZWRUb0xvY2F0aW9uV2l0aEFjdGlvbih0LG4pKTp3aW5kb3cubG9jYXRpb249dDp2b2lkIDB9LHIucHJvdG90eXBlLnN0YXJ0VmlzaXRUb0xvY2F0aW9uV2l0aEFjdGlvbj1mdW5jdGlvbih0LHIsbil7dmFyIG87cmV0dXJuIGUuc3VwcG9ydGVkPyhvPXRoaXMuZ2V0UmVzdG9yYXRpb25EYXRhRm9ySWRlbnRpZmllcihuKSx0aGlzLnN0YXJ0VmlzaXQodCxyLHtyZXN0b3JhdGlvbkRhdGE6b30pKTp3aW5kb3cubG9jYXRpb249dH0sci5wcm90b3R5cGUuc2V0UHJvZ3Jlc3NCYXJEZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wcm9ncmVzc0JhckRlbGF5PXR9LHIucHJvdG90eXBlLnN0YXJ0SGlzdG9yeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2F0aW9uPWUuTG9jYXRpb24ud3JhcCh3aW5kb3cubG9jYXRpb24pLHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyPWUudXVpZCgpLHRoaXMuaGlzdG9yeS5zdGFydCgpLHRoaXMuaGlzdG9yeS5yZXBsYWNlKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpfSxyLnByb3RvdHlwZS5zdG9wSGlzdG9yeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpc3Rvcnkuc3RvcCgpfSxyLnByb3RvdHlwZS5wdXNoSGlzdG9yeVdpdGhMb2NhdGlvbkFuZFJlc3RvcmF0aW9uSWRlbnRpZmllcj1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcj1yLHRoaXMubG9jYXRpb249ZS5Mb2NhdGlvbi53cmFwKHQpLHRoaXMuaGlzdG9yeS5wdXNoKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpfSxyLnByb3RvdHlwZS5yZXBsYWNlSGlzdG9yeVdpdGhMb2NhdGlvbkFuZFJlc3RvcmF0aW9uSWRlbnRpZmllcj1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcj1yLHRoaXMubG9jYXRpb249ZS5Mb2NhdGlvbi53cmFwKHQpLHRoaXMuaGlzdG9yeS5yZXBsYWNlKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpfSxyLnByb3RvdHlwZS5oaXN0b3J5UG9wcGVkVG9Mb2NhdGlvbldpdGhSZXN0b3JhdGlvbklkZW50aWZpZXI9ZnVuY3Rpb24odCxyKXt2YXIgbjtyZXR1cm4gdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXI9cix0aGlzLmVuYWJsZWQ/KG49dGhpcy5nZXRSZXN0b3JhdGlvbkRhdGFGb3JJZGVudGlmaWVyKHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyKSx0aGlzLnN0YXJ0VmlzaXQodCxcInJlc3RvcmVcIix7cmVzdG9yYXRpb25JZGVudGlmaWVyOnRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyLHJlc3RvcmF0aW9uRGF0YTpuLGhpc3RvcnlDaGFuZ2VkOiEwfSksdGhpcy5sb2NhdGlvbj1lLkxvY2F0aW9uLndyYXAodCkpOnRoaXMuYWRhcHRlci5wYWdlSW52YWxpZGF0ZWQoKX0sci5wcm90b3R5cGUuZ2V0Q2FjaGVkU25hcHNob3RGb3JMb2NhdGlvbj1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT10aGlzLmNhY2hlLmdldCh0KSxlP2UuY2xvbmUoKTp2b2lkIDB9LHIucHJvdG90eXBlLnNob3VsZENhY2hlU25hcHNob3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFNuYXBzaG90KCkuaXNDYWNoZWFibGUoKX0sci5wcm90b3R5cGUuY2FjaGVTbmFwc2hvdD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0aGlzLnNob3VsZENhY2hlU25hcHNob3QoKT8odGhpcy5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZUNhY2hpbmdTbmFwc2hvdCgpLHQ9dGhpcy52aWV3LmdldFNuYXBzaG90KCksdGhpcy5jYWNoZS5wdXQodGhpcy5sYXN0UmVuZGVyZWRMb2NhdGlvbix0LmNsb25lKCkpKTp2b2lkIDB9LHIucHJvdG90eXBlLnNjcm9sbFRvQW5jaG9yPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybihlPXRoaXMudmlldy5nZXRFbGVtZW50Rm9yQW5jaG9yKHQpKT90aGlzLnNjcm9sbFRvRWxlbWVudChlKTp0aGlzLnNjcm9sbFRvUG9zaXRpb24oe3g6MCx5OjB9KX0sci5wcm90b3R5cGUuc2Nyb2xsVG9FbGVtZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNjcm9sbE1hbmFnZXIuc2Nyb2xsVG9FbGVtZW50KHQpfSxyLnByb3RvdHlwZS5zY3JvbGxUb1Bvc2l0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNjcm9sbE1hbmFnZXIuc2Nyb2xsVG9Qb3NpdGlvbih0KX0sci5wcm90b3R5cGUuc2Nyb2xsUG9zaXRpb25DaGFuZ2VkPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXRoaXMuZ2V0Q3VycmVudFJlc3RvcmF0aW9uRGF0YSgpLGUuc2Nyb2xsUG9zaXRpb249dH0sci5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudmlldy5yZW5kZXIodCxlKX0sci5wcm90b3R5cGUudmlld0ludmFsaWRhdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWRhcHRlci5wYWdlSW52YWxpZGF0ZWQoKX0sci5wcm90b3R5cGUudmlld1dpbGxSZW5kZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm90aWZ5QXBwbGljYXRpb25CZWZvcmVSZW5kZXIodCl9LHIucHJvdG90eXBlLnZpZXdSZW5kZXJlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxhc3RSZW5kZXJlZExvY2F0aW9uPXRoaXMuY3VycmVudFZpc2l0LmxvY2F0aW9uLHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlclJlbmRlcigpfSxyLnByb3RvdHlwZS5wYWdlTG9hZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFzdFJlbmRlcmVkTG9jYXRpb249dGhpcy5sb2NhdGlvbix0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJQYWdlTG9hZCgpfSxyLnByb3RvdHlwZS5jbGlja0NhcHR1cmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuY2xpY2tCdWJibGVkLCExKSxhZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmNsaWNrQnViYmxlZCwhMSl9LHIucHJvdG90eXBlLmNsaWNrQnViYmxlZD1mdW5jdGlvbih0KXt2YXIgZSxyLG47cmV0dXJuIHRoaXMuZW5hYmxlZCYmdGhpcy5jbGlja0V2ZW50SXNTaWduaWZpY2FudCh0KSYmKHI9dGhpcy5nZXRWaXNpdGFibGVMaW5rRm9yTm9kZSh0LnRhcmdldCkpJiYobj10aGlzLmdldFZpc2l0YWJsZUxvY2F0aW9uRm9yTGluayhyKSkmJnRoaXMuYXBwbGljYXRpb25BbGxvd3NGb2xsb3dpbmdMaW5rVG9Mb2NhdGlvbihyLG4pPyh0LnByZXZlbnREZWZhdWx0KCksZT10aGlzLmdldEFjdGlvbkZvckxpbmsociksXG50aGlzLnZpc2l0KG4se2FjdGlvbjplfSkpOnZvaWQgMH0sci5wcm90b3R5cGUuYXBwbGljYXRpb25BbGxvd3NGb2xsb3dpbmdMaW5rVG9Mb2NhdGlvbj1mdW5jdGlvbih0LGUpe3ZhciByO3JldHVybiByPXRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlckNsaWNraW5nTGlua1RvTG9jYXRpb24odCxlKSwhci5kZWZhdWx0UHJldmVudGVkfSxyLnByb3RvdHlwZS5hcHBsaWNhdGlvbkFsbG93c1Zpc2l0aW5nTG9jYXRpb249ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9dGhpcy5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZVZpc2l0aW5nTG9jYXRpb24odCksIWUuZGVmYXVsdFByZXZlbnRlZH0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25BZnRlckNsaWNraW5nTGlua1RvTG9jYXRpb249ZnVuY3Rpb24odCxyKXtyZXR1cm4gZS5kaXNwYXRjaChcInR1cmJvbGlua3M6Y2xpY2tcIix7dGFyZ2V0OnQsZGF0YTp7dXJsOnIuYWJzb2x1dGVVUkx9LGNhbmNlbGFibGU6ITB9KX0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25CZWZvcmVWaXNpdGluZ0xvY2F0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpiZWZvcmUtdmlzaXRcIix7ZGF0YTp7dXJsOnQuYWJzb2x1dGVVUkx9LGNhbmNlbGFibGU6ITB9KX0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25BZnRlclZpc2l0aW5nTG9jYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIGUuZGlzcGF0Y2goXCJ0dXJib2xpbmtzOnZpc2l0XCIse2RhdGE6e3VybDp0LmFic29sdXRlVVJMfX0pfSxyLnByb3RvdHlwZS5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZUNhY2hpbmdTbmFwc2hvdD1mdW5jdGlvbigpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpiZWZvcmUtY2FjaGVcIil9LHIucHJvdG90eXBlLm5vdGlmeUFwcGxpY2F0aW9uQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKHQpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpiZWZvcmUtcmVuZGVyXCIse2RhdGE6e25ld0JvZHk6dH19KX0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25BZnRlclJlbmRlcj1mdW5jdGlvbigpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpyZW5kZXJcIil9LHIucHJvdG90eXBlLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJQYWdlTG9hZD1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dCYmKHQ9e30pLGUuZGlzcGF0Y2goXCJ0dXJib2xpbmtzOmxvYWRcIix7ZGF0YTp7dXJsOnRoaXMubG9jYXRpb24uYWJzb2x1dGVVUkwsdGltaW5nOnR9fSl9LHIucHJvdG90eXBlLnN0YXJ0VmlzaXQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuO3JldHVybiBudWxsIT0obj10aGlzLmN1cnJlbnRWaXNpdCkmJm4uY2FuY2VsKCksdGhpcy5jdXJyZW50VmlzaXQ9dGhpcy5jcmVhdGVWaXNpdCh0LGUsciksdGhpcy5jdXJyZW50VmlzaXQuc3RhcnQoKSx0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJWaXNpdGluZ0xvY2F0aW9uKHQpfSxyLnByb3RvdHlwZS5jcmVhdGVWaXNpdD1mdW5jdGlvbih0LHIsbil7dmFyIG8saSxzLGEsdTtyZXR1cm4gaT1udWxsIT1uP246e30sYT1pLnJlc3RvcmF0aW9uSWRlbnRpZmllcixzPWkucmVzdG9yYXRpb25EYXRhLG89aS5oaXN0b3J5Q2hhbmdlZCx1PW5ldyBlLlZpc2l0KHRoaXMsdCxyKSx1LnJlc3RvcmF0aW9uSWRlbnRpZmllcj1udWxsIT1hP2E6ZS51dWlkKCksdS5yZXN0b3JhdGlvbkRhdGE9ZS5jb3B5T2JqZWN0KHMpLHUuaGlzdG9yeUNoYW5nZWQ9byx1LnJlZmVycmVyPXRoaXMubG9jYXRpb24sdX0sci5wcm90b3R5cGUudmlzaXRDb21wbGV0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlclBhZ2VMb2FkKHQuZ2V0VGltaW5nTWV0cmljcygpKX0sci5wcm90b3R5cGUuY2xpY2tFdmVudElzU2lnbmlmaWNhbnQ9ZnVuY3Rpb24odCl7cmV0dXJuISh0LmRlZmF1bHRQcmV2ZW50ZWR8fHQudGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlfHx0LndoaWNoPjF8fHQuYWx0S2V5fHx0LmN0cmxLZXl8fHQubWV0YUtleXx8dC5zaGlmdEtleSl9LHIucHJvdG90eXBlLmdldFZpc2l0YWJsZUxpbmtGb3JOb2RlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVJc1Zpc2l0YWJsZSh0KT9lLmNsb3Nlc3QodCxcImFbaHJlZl06bm90KFt0YXJnZXRdKTpub3QoW2Rvd25sb2FkXSlcIik6dm9pZCAwfSxyLnByb3RvdHlwZS5nZXRWaXNpdGFibGVMb2NhdGlvbkZvckxpbms9ZnVuY3Rpb24odCl7dmFyIHI7cmV0dXJuIHI9bmV3IGUuTG9jYXRpb24odC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSx0aGlzLmxvY2F0aW9uSXNWaXNpdGFibGUocik/cjp2b2lkIDB9LHIucHJvdG90eXBlLmdldEFjdGlvbkZvckxpbms9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIG51bGwhPShlPXQuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJib2xpbmtzLWFjdGlvblwiKSk/ZTpcImFkdmFuY2VcIn0sci5wcm90b3R5cGUubm9kZUlzVmlzaXRhYmxlPWZ1bmN0aW9uKHQpe3ZhciByO3JldHVybihyPWUuY2xvc2VzdCh0LFwiW2RhdGEtdHVyYm9saW5rc11cIikpP1wiZmFsc2VcIiE9PXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJib2xpbmtzXCIpOiEwfSxyLnByb3RvdHlwZS5sb2NhdGlvbklzVmlzaXRhYmxlPWZ1bmN0aW9uKHQpe3JldHVybiB0LmlzUHJlZml4ZWRCeSh0aGlzLnZpZXcuZ2V0Um9vdExvY2F0aW9uKCkpJiZ0LmlzSFRNTCgpfSxyLnByb3RvdHlwZS5nZXRDdXJyZW50UmVzdG9yYXRpb25EYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UmVzdG9yYXRpb25EYXRhRm9ySWRlbnRpZmllcih0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcil9LHIucHJvdG90eXBlLmdldFJlc3RvcmF0aW9uRGF0YUZvcklkZW50aWZpZXI9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIG51bGwhPShlPXRoaXMucmVzdG9yYXRpb25EYXRhKVt0XT9lW3RdOmVbdF09e319LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXshZnVuY3Rpb24oKXt2YXIgdCxlO2lmKCh0PWU9ZG9jdW1lbnQuY3VycmVudFNjcmlwdCkmJiFlLmhhc0F0dHJpYnV0ZShcImRhdGEtdHVyYm9saW5rcy1zdXBwcmVzcy13YXJuaW5nXCIpKWZvcig7dD10LnBhcmVudE5vZGU7KWlmKHQ9PT1kb2N1bWVudC5ib2R5KXJldHVybiBjb25zb2xlLndhcm4oXCJZb3UgYXJlIGxvYWRpbmcgVHVyYm9saW5rcyBmcm9tIGEgPHNjcmlwdD4gZWxlbWVudCBpbnNpZGUgdGhlIDxib2R5PiBlbGVtZW50LiBUaGlzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHlvdSBtZWFudCB0byBkbyFcXG5cXG5Mb2FkIHlvdXIgYXBwbGljYXRpb25cXHUyMDE5cyBKYXZhU2NyaXB0IGJ1bmRsZSBpbnNpZGUgdGhlIDxoZWFkPiBlbGVtZW50IGluc3RlYWQuIDxzY3JpcHQ+IGVsZW1lbnRzIGluIDxib2R5PiBhcmUgZXZhbHVhdGVkIHdpdGggZWFjaCBwYWdlIGNoYW5nZS5cXG5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdHVyYm9saW5rcy90dXJib2xpbmtzI3dvcmtpbmctd2l0aC1zY3JpcHQtZWxlbWVudHNcXG5cXG5cXHUyMDE0XFx1MjAxNFxcblN1cHByZXNzIHRoaXMgd2FybmluZyBieSBhZGRpbmcgYSBgZGF0YS10dXJib2xpbmtzLXN1cHByZXNzLXdhcm5pbmdgIGF0dHJpYnV0ZSB0bzogJXNcIixlLm91dGVySFRNTCl9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdCxyLG47ZS5zdGFydD1mdW5jdGlvbigpe3JldHVybiByKCk/KG51bGw9PWUuY29udHJvbGxlciYmKGUuY29udHJvbGxlcj10KCkpLGUuY29udHJvbGxlci5zdGFydCgpKTp2b2lkIDB9LHI9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09d2luZG93LlR1cmJvbGlua3MmJih3aW5kb3cuVHVyYm9saW5rcz1lKSxuKCl9LHQ9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gdD1uZXcgZS5Db250cm9sbGVyLHQuYWRhcHRlcj1uZXcgZS5Ccm93c2VyQWRhcHRlcih0KSx0fSxuPWZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5UdXJib2xpbmtzPT09ZX0sbigpJiZlLnN0YXJ0KCl9LmNhbGwodGhpcyl9KS5jYWxsKHRoaXMpLFwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWU6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoZSl9KS5jYWxsKHRoaXMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3R1cmJvbGlua3MvZGlzdC90dXJib2xpbmtzLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDciXSwic291cmNlUm9vdCI6IiJ9