/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 59);
/******/ })
/************************************************************************/
/******/ ({

/***/ 20:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
} ( function( $ ) {

$.ui = $.ui || {};

return $.ui.version = "1.12.1";

} ) );


/***/ }),

/***/ 28:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(24) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
} ( function( $ ) {
return $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

} ) );


/***/ }),

/***/ 29:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(24) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

return $.widget;

} ) );


/***/ }),

/***/ 59:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(60);


/***/ }),

/***/ 60:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.$ = window.jQuery = __webpack_require__(20);

// Datepicker
__webpack_require__(61);

// Timepicker
__webpack_require__(62);
__webpack_require__(65);

// Bootstrap
window.Popper = __webpack_require__(66);
__webpack_require__(68);
__webpack_require__(69);

// Metrics
__webpack_require__(70);

// Turbolinks
window.Turbolinks = __webpack_require__(71);

// https://stackoverflow.com/a/8407771/2957677
// Modified by /1549818 to support dot notation
(function ($) {
	$.fn.serializeObject = function () {
		var shouldValidate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		var self = this,
		    json = {},
		    push_counters = {},
		    patterns = {
			"validate": /^[a-zA-Z][a-zA-Z0-9_]*(?:[\[\.](?:\d*|[a-zA-Z0-9_]+)[\]]?)*$/,
			"key": /[a-zA-Z0-9_]+|(?=\[\])/g,
			"push": /^$/,
			"fixed": /^\d+$/,
			"named": /^[a-zA-Z0-9_]+$/
		},
		    isValid = true,
		    $fields = $(this).find('input, select, textarea').not('input[type=radio]:not(:checked)'); // filters out non-checked radio fields

		this.build = function (base, key, value) {
			base[key] = value;
			return base;
		};

		this.push_counter = function (key) {
			if (push_counters[key] === undefined) {
				push_counters[key] = 0;
			}

			return push_counters[key]++;
		};

		if (shouldValidate) {
			$('.invalid-feedback').remove();
			$('.is-valid, .is-invalid, .card-header.red-highlight, .card-header.green-highlight').removeClass('is-valid is-invalid red-highlight green-highlight');

			clearTimeout(validationTimeout);

			validationTimeout = setTimeout(function () {
				$('.is-valid, .is-invalid, .card-header.red-highlight, .card-header.green-highlight').removeClass('is-valid is-invalid red-highlight green-highlight');
				$('.invalid-feedback').fadeOut(250, function () {
					$(this).remove();
				});
			}, 15000);
		}

		$fields.not(':disabled').map(function () {
			// skip invalid keys
			if (!patterns.validate.test(this.name)) {
				return;
			}

			var k,
			    keys = this.name.match(patterns.key),
			    merge = this.value,
			    reverse_key = this.name,
			    validation_rules = this.attributes.hasOwnProperty('validation') ? this.attributes.validation.value : null;

			if (shouldValidate && validation_rules !== null) {
				var response = $(this).validate();

				if (isValid) {
					isValid = response;
				}
			}

			while ((k = keys.pop()) !== undefined) {

				// adjust reverse_key
				reverse_key = reverse_key.replace(new RegExp("\\[" + k + "\\]$"), '');

				// push
				if (k.match(patterns.push)) {
					merge = self.build({}, self.push_counter(reverse_key), merge);
				}

				// fixed or named
				else if (k.match(patterns.fixed) || k.match(patterns.named)) {
						merge = self.build({}, k, merge);
					}
			}

			json = $.extend(true, json, merge);
		});

		json.isValid = function () {
			return isValid;
		};

		if (shouldValidate) {
			$(this).find('.card:not(.existing) .is-valid').closest('.card').find('.card-header').addClass('green-highlight'); // highlight all cards green first
			$(this).find('.card:not(.existing) .is-invalid').closest('.card').find('.card-header').removeClass('green-highlight').addClass('red-highlight'); // highlight any cards with errors in them

			// open accordion with error
			if ($(this).find('.view-accordion.fa-chevron-down').first().closest('.card-header.green-highlight').length === 1) {
				$(this).find('.card-header.red-highlight .view-accordion').click();
			}
		}

		return json;
	};

	$.fn.validate = function () {
		var $this = $(this),
		    value = $this.val(),
		    validationRules = $this.attr('validation').split('|'),
		    failedRules = [];

		for (var _i = 0; _i < validationRules.length; _i++) {
			var rule = validationRules[_i];

			switch (rule) {
				case "nullable":
					if (value === null || value === '') {
						validationRules = []; // break out of for
					}

					break;
				case (rule.match(/required/) || {}).input:
					if (value === null || value === '') {
						if (rule.split(':').length === 1) {
							failedRules.push('This field is required.');
						} else {
							failedRules.push(rule.split(':')[1]); // custom message can be attached to required
						}

						validationRules = []; // break out of for
					}

					break;
				case "integer":
					if (value.length > 0 && (isNaN(parseInt(value)) || !isFinite(value))) {
						failedRules.push('This field must be an whole number.');
					}

					break;
				case (rule.match(/max:/) || {}).input:
					if (value.length > 0 && value.length > Number(rule.split(':')[1])) {
						failedRules.push('This field must have less than ' + (Number(rule.split(':')[1]) + 1) + ' characters.');
					}

					break;
				case (rule.match(/min:/) || {}).input:
					if (value.length < Number(rule.split(':')[1])) {
						failedRules.push('This field must have at least ' + rule.split(':')[1] + ' characters.');
					}

					break;
				case (rule.match(/in:/) || {}).input:
					if (value.length > 0 && rule.split(':')[1].split(',').indexOf(value) === -1) {
						failedRules.push('This field must contain one of the following: ' + rule.split(':')[1].split(',') + '.');
					}

					break;
				case (rule.match(/not:/) || {}).input:
					if (value === rule.split(':')[1].split(/'/)[1]) {
						failedRules.push('This field has an invalid value.');
					}

					break;
				case (rule.match(/requires:/) || {}).input:
					if ($this.closest('form').find('input[name="' + rule.split(':')[1] + '"]').val() === '') {
						failedRules.push('This field is required.');
					}

					break;
				case "email":
					if (!/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(value)) {
						failedRules.push('This field must be an email.');
					}

					break;
				case "phone":
					if (!/^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/im.test(value.replace(' ', ''))) {
						failedRules.push('This field must be a phone number.');
					}

					break;
			}
		}

		if ($this.is('select')) {
			// style support for bootstrap-select
			if ($this.hasClass('add-hardware-device')) {
				if ($this.closest('.affected-items-section').find('.affected-items').find('li[data-type="hardware"]').length === 0) {
					failedRules.push('Add at least one hardware device.');
				}
			}

			$this = $this.siblings('button.dropdown-toggle');
		}

		if (failedRules.length > 0) {
			$this.addClass('is-invalid');

			if (!$this.parent().is('.assigned-to-options')) {
				var $invalidFeedback = $('<div class="invalid-feedback">');

				for (var i = 0; i < failedRules.length; i++) {
					$invalidFeedback.append(failedRules[i] + (i >= 1 ? '<br />' : ''));
				}

				$this.closest('.form-group').append($invalidFeedback);
			}

			return false;
		}

		$this.addClass('is-valid');

		return true;
	};
})(jQuery);

/**
 * Resolve a dot notation path string through an object
 * From https://stackoverflow.com/a/22129960/1549818
 */
Object.resolve = function (path, obj) {
	return path.split('.').reduce(function (prev, curr) {
		return prev ? prev[curr] : undefined;
	}, obj || self);
};

/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// jscs:disable maximumLineLength
/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
/*!
 * jQuery UI Datepicker 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Datepicker
//>>group: Widgets
//>>description: Displays a calendar from an input or inline for selecting dates.
//>>docs: http://api.jqueryui.com/datepicker/
//>>demos: http://jqueryui.com/datepicker/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/datepicker.css
//>>css.theme: ../../themes/base/theme.css

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(20),
			__webpack_require__(24),
			__webpack_require__(28)
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

$.extend( $.ui, { datepicker: { version: "1.12.1" } } );

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {

		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {

			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[ "" ] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: [ "January","February","March","April","May","June",
			"July","August","September","October","November","December" ], // Names of months for drop-down and formatting
		monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
		dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
		dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
		dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend( this._defaults, this.regional[ "" ] );
	this.regional.en = $.extend( true, {}, this.regional[ "" ] );
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
}

$.extend( Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function( settings ) {
		datepicker_extendRemove( this._defaults, settings || {} );
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function( target, settings ) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = ( nodeName === "div" || nodeName === "span" );
		if ( !target.id ) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst( $( target ), inline );
		inst.settings = $.extend( {}, settings || {} );
		if ( nodeName === "input" ) {
			this._connectDatepicker( target, inst );
		} else if ( inline ) {
			this._inlineDatepicker( target, inst );
		}
	},

	/* Create a new instance object. */
	_newInst: function( target, inline ) {
		var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
		return { id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: ( !inline ? this.dpDiv : // presentation div
			datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function( target, inst ) {
		var input = $( target );
		inst.append = $( [] );
		inst.trigger = $( [] );
		if ( input.hasClass( this.markerClassName ) ) {
			return;
		}
		this._attachments( input, inst );
		input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
			on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
		this._autoSize( inst );
		$.data( target, "datepicker", inst );

		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function( input, inst ) {
		var showOn, buttonText, buttonImage,
			appendText = this._get( inst, "appendText" ),
			isRTL = this._get( inst, "isRTL" );

		if ( inst.append ) {
			inst.append.remove();
		}
		if ( appendText ) {
			inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
			input[ isRTL ? "before" : "after" ]( inst.append );
		}

		input.off( "focus", this._showDatepicker );

		if ( inst.trigger ) {
			inst.trigger.remove();
		}

		showOn = this._get( inst, "showOn" );
		if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
			input.on( "focus", this._showDatepicker );
		}
		if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
			buttonText = this._get( inst, "buttonText" );
			buttonImage = this._get( inst, "buttonImage" );
			inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
				$( "<img/>" ).addClass( this._triggerClass ).
					attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
				$( "<button type='button'></button>" ).addClass( this._triggerClass ).
					html( !buttonImage ? buttonText : $( "<img/>" ).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText } ) ) );
			input[ isRTL ? "before" : "after" ]( inst.trigger );
			inst.trigger.on( "click", function() {
				if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
					$.datepicker._hideDatepicker();
				} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker( input[ 0 ] );
				} else {
					$.datepicker._showDatepicker( input[ 0 ] );
				}
				return false;
			} );
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function( inst ) {
		if ( this._get( inst, "autoSize" ) && !inst.inline ) {
			var findMax, max, maxI, i,
				date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
				dateFormat = this._get( inst, "dateFormat" );

			if ( dateFormat.match( /[DM]/ ) ) {
				findMax = function( names ) {
					max = 0;
					maxI = 0;
					for ( i = 0; i < names.length; i++ ) {
						if ( names[ i ].length > max ) {
							max = names[ i ].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
					"monthNames" : "monthNamesShort" ) ) ) );
				date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
					"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
			}
			inst.input.attr( "size", this._formatDate( inst, date ).length );
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function( target, inst ) {
		var divSpan = $( target );
		if ( divSpan.hasClass( this.markerClassName ) ) {
			return;
		}
		divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
		$.data( target, "datepicker", inst );
		this._setDate( inst, this._getDefaultDate( inst ), true );
		this._updateDatepicker( inst );
		this._updateAlternate( inst );

		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}

		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function( input, date, onSelect, settings, pos ) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if ( !inst ) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $( "<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>" );
			this._dialogInput.on( "keydown", this._doKeyDown );
			$( "body" ).append( this._dialogInput );
			inst = this._dialogInst = this._newInst( this._dialogInput, false );
			inst.settings = {};
			$.data( this._dialogInput[ 0 ], "datepicker", inst );
		}
		datepicker_extendRemove( inst.settings, settings || {} );
		date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
		this._dialogInput.val( date );

		this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
		if ( !this._pos ) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
		}

		// Move input on screen for focus, but hidden behind dialog
		this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass( this._dialogClass );
		this._showDatepicker( this._dialogInput[ 0 ] );
		if ( $.blockUI ) {
			$.blockUI( this.dpDiv );
		}
		$.data( this._dialogInput[ 0 ], "datepicker", inst );
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function( target ) {
		var nodeName,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData( target, "datepicker" );
		if ( nodeName === "input" ) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass( this.markerClassName ).
				off( "focus", this._showDatepicker ).
				off( "keydown", this._doKeyDown ).
				off( "keypress", this._doKeyPress ).
				off( "keyup", this._doKeyUp );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			$target.removeClass( this.markerClassName ).empty();
		}

		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = false;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = false; } ).end().
				filter( "img" ).css( { opacity: "1.0", cursor: "" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().removeClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", false );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = true;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = true; } ).end().
				filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().addClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", true );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
		this._disabledInputs[ this._disabledInputs.length ] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function( target ) {
		if ( !target ) {
			return false;
		}
		for ( var i = 0; i < this._disabledInputs.length; i++ ) {
			if ( this._disabledInputs[ i ] === target ) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function( target ) {
		try {
			return $.data( target, "datepicker" );
		}
		catch ( err ) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function( target, name, value ) {
		var settings, date, minDate, maxDate,
			inst = this._getInst( target );

		if ( arguments.length === 2 && typeof name === "string" ) {
			return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
				( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
				this._get( inst, name ) ) : null ) );
		}

		settings = name || {};
		if ( typeof name === "string" ) {
			settings = {};
			settings[ name ] = value;
		}

		if ( inst ) {
			if ( this._curInst === inst ) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker( target, true );
			minDate = this._getMinMaxDate( inst, "min" );
			maxDate = this._getMinMaxDate( inst, "max" );
			datepicker_extendRemove( inst.settings, settings );

			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
				inst.settings.minDate = this._formatDate( inst, minDate );
			}
			if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
				inst.settings.maxDate = this._formatDate( inst, maxDate );
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker( target );
				} else {
					this._enableDatepicker( target );
				}
			}
			this._attachments( $( target ), inst );
			this._autoSize( inst );
			this._setDate( inst, date );
			this._updateAlternate( inst );
			this._updateDatepicker( inst );
		}
	},

	// Change method deprecated
	_changeDatepicker: function( target, name, value ) {
		this._optionDatepicker( target, name, value );
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function( target ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._updateDatepicker( inst );
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function( target, date ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._setDate( inst, date );
			this._updateDatepicker( inst );
			this._updateAlternate( inst );
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function( target, noDefault ) {
		var inst = this._getInst( target );
		if ( inst && !inst.inline ) {
			this._setDateFromField( inst, noDefault );
		}
		return ( inst ? this._getDate( inst ) : null );
	},

	/* Handle keystrokes. */
	_doKeyDown: function( event ) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst( event.target ),
			handled = true,
			isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );

		inst._keyEvent = true;
		if ( $.datepicker._datepickerShowing ) {
			switch ( event.keyCode ) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv );
						if ( sel[ 0 ] ) {
							$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
						}

						onSelect = $.datepicker._get( inst, "onSelect" );
						if ( onSelect ) {
							dateStr = $.datepicker._formatDate( inst );

							// Trigger custom callback
							onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							-$.datepicker._get( inst, "stepBigMonths" ) :
							-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							+$.datepicker._get( inst, "stepBigMonths" ) :
							+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // next month/year on page down/+ ctrl
				case 35: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._clearDate( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._gotoToday( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// -1 day on ctrl or command +left
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								-$.datepicker._get( inst, "stepBigMonths" ) :
								-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +left on Mac
						break;
				case 38: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, -7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// +1 day on ctrl or command +right
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								+$.datepicker._get( inst, "stepBigMonths" ) :
								+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +right
						break;
				case 40: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, +7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker( this );
		} else {
			handled = false;
		}

		if ( handled ) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function( event ) {
		var chars, chr,
			inst = $.datepicker._getInst( event.target );

		if ( $.datepicker._get( inst, "constrainInput" ) ) {
			chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
			chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
			return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function( event ) {
		var date,
			inst = $.datepicker._getInst( event.target );

		if ( inst.input.val() !== inst.lastVal ) {
			try {
				date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
					( inst.input ? inst.input.val() : null ),
					$.datepicker._getFormatConfig( inst ) );

				if ( date ) { // only if valid
					$.datepicker._setDateFromField( inst );
					$.datepicker._updateAlternate( inst );
					$.datepicker._updateDatepicker( inst );
				}
			}
			catch ( err ) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function( input ) {
		input = input.target || input;
		if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
			input = $( "input", input.parentNode )[ 0 ];
		}

		if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst( input );
		if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
			$.datepicker._curInst.dpDiv.stop( true, true );
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
			}
		}

		beforeShow = $.datepicker._get( inst, "beforeShow" );
		beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
		if ( beforeShowSettings === false ) {
			return;
		}
		datepicker_extendRemove( inst.settings, beforeShowSettings );

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField( inst );

		if ( $.datepicker._inDialog ) { // hide cursor
			input.value = "";
		}
		if ( !$.datepicker._pos ) { // position below input
			$.datepicker._pos = $.datepicker._findPos( input );
			$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$( input ).parents().each( function() {
			isFixed |= $( this ).css( "position" ) === "fixed";
			return !isFixed;
		} );

		offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
		$.datepicker._pos = null;

		//to avoid flashes on Firefox
		inst.dpDiv.empty();

		// determine sizing offscreen
		inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
		$.datepicker._updateDatepicker( inst );

		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset( inst, offset, isFixed );
		inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
			"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
			left: offset.left + "px", top: offset.top + "px" } );

		if ( !inst.inline ) {
			showAnim = $.datepicker._get( inst, "showAnim" );
			duration = $.datepicker._get( inst, "duration" );
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
			} else {
				inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.trigger( "focus" );
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function( inst ) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append( this._generateHTML( inst ) );
		this._attachHandlers( inst );

		var origyearshtml,
			numMonths = this._getNumberOfMonths( inst ),
			cols = numMonths[ 1 ],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
		if ( cols > 1 ) {
			inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
		}
		inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-multi" );
		inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-rtl" );

		if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.trigger( "focus" );
		}

		// Deffered render of the years select (to avoid flashes on Firefox)
		if ( inst.yearshtml ) {
			origyearshtml = inst.yearshtml;
			setTimeout( function() {

				//assure that inst.yearshtml didn't change.
				if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
					inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
				}
				origyearshtml = inst.yearshtml = null;
			}, 0 );
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function( inst, offset, isFixed ) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
			viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );

		offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
		offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
		offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;

		// Now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
			Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
		offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
			Math.abs( dpHeight + inputHeight ) : 0 );

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function( obj ) {
		var position,
			inst = this._getInst( obj ),
			isRTL = this._get( inst, "isRTL" );

		while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
			obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
		}

		position = $( obj ).offset();
		return [ position.left, position.top ];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function( input ) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
			return;
		}

		if ( this._datepickerShowing ) {
			showAnim = this._get( inst, "showAnim" );
			duration = this._get( inst, "duration" );
			postProcess = function() {
				$.datepicker._tidyDialog( inst );
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
			} else {
				inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
					( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
			}

			if ( !showAnim ) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get( inst, "onClose" );
			if ( onClose ) {
				onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
			}

			this._lastInput = null;
			if ( this._inDialog ) {
				this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
				if ( $.blockUI ) {
					$.unblockUI();
					$( "body" ).append( this.dpDiv );
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function( inst ) {
		inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function( event ) {
		if ( !$.datepicker._curInst ) {
			return;
		}

		var $target = $( event.target ),
			inst = $.datepicker._getInst( $target[ 0 ] );

		if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
				$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
				!$target.hasClass( $.datepicker.markerClassName ) &&
				!$target.closest( "." + $.datepicker._triggerClass ).length &&
				$.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
			( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function( id, offset, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}
		this._adjustInstDate( inst, offset +
			( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
			period );
		this._updateDatepicker( inst );
	},

	/* Action for current link. */
	_gotoToday: function( id ) {
		var date,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function( id, select, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
		inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
			parseInt( select.options[ select.selectedIndex ].value, 10 );

		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a day. */
	_selectDay: function( id, month, year, td ) {
		var inst,
			target = $( id );

		if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}

		inst = this._getInst( target[ 0 ] );
		inst.selectedDay = inst.currentDay = $( "a", td ).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate( id, this._formatDate( inst,
			inst.currentDay, inst.currentMonth, inst.currentYear ) );
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function( id ) {
		var target = $( id );
		this._selectDate( target, "" );
	},

	/* Update the input field with the selected date. */
	_selectDate: function( id, dateStr ) {
		var onSelect,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
		if ( inst.input ) {
			inst.input.val( dateStr );
		}
		this._updateAlternate( inst );

		onSelect = this._get( inst, "onSelect" );
		if ( onSelect ) {
			onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
		} else if ( inst.input ) {
			inst.input.trigger( "change" ); // fire the change event
		}

		if ( inst.inline ) {
			this._updateDatepicker( inst );
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[ 0 ];
			if ( typeof( inst.input[ 0 ] ) !== "object" ) {
				inst.input.trigger( "focus" ); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function( inst ) {
		var altFormat, date, dateStr,
			altField = this._get( inst, "altField" );

		if ( altField ) { // update alternate field too
			altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
			date = this._getDate( inst );
			dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
			$( altField ).val( dateStr );
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function( date ) {
		var day = date.getDay();
		return [ ( day > 0 && day < 6 ), "" ];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function( date ) {
		var time,
			checkDate = new Date( date.getTime() );

		// Find Thursday of this week starting on Monday
		checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );

		time = checkDate.getTime();
		checkDate.setMonth( 0 ); // Compare with Jan 1
		checkDate.setDate( 1 );
		return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function( format, value, settings ) {
		if ( format == null || value == null ) {
			throw "Invalid arguments";
		}

		value = ( typeof value === "object" ? value.toString() : value + "" );
		if ( value === "" ) {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
			shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Extract a number from the string value
			getNumber = function( match ) {
				var isDoubled = lookAhead( match ),
					size = ( match === "@" ? 14 : ( match === "!" ? 20 :
					( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
					minSize = ( match === "y" ? size : 1 ),
					digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
					num = value.substring( iValue ).match( digits );
				if ( !num ) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[ 0 ].length;
				return parseInt( num[ 0 ], 10 );
			},

			// Extract a name from the string value and convert to an index
			getName = function( match, shortNames, longNames ) {
				var index = -1,
					names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
						return [ [ k, v ] ];
					} ).sort( function( a, b ) {
						return -( a[ 1 ].length - b[ 1 ].length );
					} );

				$.each( names, function( i, pair ) {
					var name = pair[ 1 ];
					if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
						index = pair[ 0 ];
						iValue += name.length;
						return false;
					}
				} );
				if ( index !== -1 ) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},

			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d":
						day = getNumber( "d" );
						break;
					case "D":
						getName( "D", dayNamesShort, dayNames );
						break;
					case "o":
						doy = getNumber( "o" );
						break;
					case "m":
						month = getNumber( "m" );
						break;
					case "M":
						month = getName( "M", monthNamesShort, monthNames );
						break;
					case "y":
						year = getNumber( "y" );
						break;
					case "@":
						date = new Date( getNumber( "@" ) );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if ( lookAhead( "'" ) ) {
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if ( iValue < value.length ) {
			extra = value.substr( iValue );
			if ( !/^\s+/.test( extra ) ) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if ( year === -1 ) {
			year = new Date().getFullYear();
		} else if ( year < 100 ) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				( year <= shortYearCutoff ? 0 : -100 );
		}

		if ( doy > -1 ) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth( year, month - 1 );
				if ( day <= dim ) {
					break;
				}
				month++;
				day -= dim;
			} while ( true );
		}

		date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
		if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
		Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function( format, date, settings ) {
		if ( !date ) {
			return "";
		}

		var iFormat,
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Format a number, with leading zero if necessary
			formatNumber = function( match, value, len ) {
				var num = "" + value;
				if ( lookAhead( match ) ) {
					while ( num.length < len ) {
						num = "0" + num;
					}
				}
				return num;
			},

			// Format a name, short or long as requested
			formatName = function( match, value, shortNames, longNames ) {
				return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
			},
			output = "",
			literal = false;

		if ( date ) {
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						output += format.charAt( iFormat );
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d":
							output += formatNumber( "d", date.getDate(), 2 );
							break;
						case "D":
							output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
							break;
						case "o":
							output += formatNumber( "o",
								Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
							break;
						case "m":
							output += formatNumber( "m", date.getMonth() + 1, 2 );
							break;
						case "M":
							output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
							break;
						case "y":
							output += ( lookAhead( "y" ) ? date.getFullYear() :
								( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if ( lookAhead( "'" ) ) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt( iFormat );
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function( format ) {
		var iFormat,
			chars = "",
			literal = false,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					chars += format.charAt( iFormat );
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if ( lookAhead( "'" ) ) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt( iFormat );
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function( inst, name ) {
		return inst.settings[ name ] !== undefined ?
			inst.settings[ name ] : this._defaults[ name ];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function( inst, noDefault ) {
		if ( inst.input.val() === inst.lastVal ) {
			return;
		}

		var dateFormat = this._get( inst, "dateFormat" ),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate( inst ),
			date = defaultDate,
			settings = this._getFormatConfig( inst );

		try {
			date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
		} catch ( event ) {
			dates = ( noDefault ? "" : dates );
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = ( dates ? date.getDate() : 0 );
		inst.currentMonth = ( dates ? date.getMonth() : 0 );
		inst.currentYear = ( dates ? date.getFullYear() : 0 );
		this._adjustInstDate( inst );
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function( inst ) {
		return this._restrictMinMax( inst,
			this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function( inst, date, defaultDate ) {
		var offsetNumeric = function( offset ) {
				var date = new Date();
				date.setDate( date.getDate() + offset );
				return date;
			},
			offsetString = function( offset ) {
				try {
					return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
						offset, $.datepicker._getFormatConfig( inst ) );
				}
				catch ( e ) {

					// Ignore
				}

				var date = ( offset.toLowerCase().match( /^c/ ) ?
					$.datepicker._getDate( inst ) : null ) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec( offset );

				while ( matches ) {
					switch ( matches[ 2 ] || "d" ) {
						case "d" : case "D" :
							day += parseInt( matches[ 1 ], 10 ); break;
						case "w" : case "W" :
							day += parseInt( matches[ 1 ], 10 ) * 7; break;
						case "m" : case "M" :
							month += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
						case "y": case "Y" :
							year += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
					}
					matches = pattern.exec( offset );
				}
				return new Date( year, month, day );
			},
			newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
				( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );

		newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
		if ( newDate ) {
			newDate.setHours( 0 );
			newDate.setMinutes( 0 );
			newDate.setSeconds( 0 );
			newDate.setMilliseconds( 0 );
		}
		return this._daylightSavingAdjust( newDate );
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function( date ) {
		if ( !date ) {
			return null;
		}
		date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function( inst, date, noChange ) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
			this._notifyChange( inst );
		}
		this._adjustInstDate( inst );
		if ( inst.input ) {
			inst.input.val( clear ? "" : this._formatDate( inst ) );
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function( inst ) {
		var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
			this._daylightSavingAdjust( new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function( inst ) {
		var stepMonths = this._get( inst, "stepMonths" ),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find( "[data-handler]" ).map( function() {
			var handler = {
				prev: function() {
					$.datepicker._adjustDate( id, -stepMonths, "M" );
				},
				next: function() {
					$.datepicker._adjustDate( id, +stepMonths, "M" );
				},
				hide: function() {
					$.datepicker._hideDatepicker();
				},
				today: function() {
					$.datepicker._gotoToday( id );
				},
				selectDay: function() {
					$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
					return false;
				},
				selectMonth: function() {
					$.datepicker._selectMonthYear( id, this, "M" );
					return false;
				},
				selectYear: function() {
					$.datepicker._selectMonthYear( id, this, "Y" );
					return false;
				}
			};
			$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
		} );
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function( inst ) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
			isRTL = this._get( inst, "isRTL" ),
			showButtonPanel = this._get( inst, "showButtonPanel" ),
			hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
			navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
			numMonths = this._getNumberOfMonths( inst ),
			showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
			stepMonths = this._get( inst, "stepMonths" ),
			isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
			currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
				new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if ( drawMonth < 0 ) {
			drawMonth += 12;
			drawYear--;
		}
		if ( maxDate ) {
			maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
				maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
			maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
			while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
				drawMonth--;
				if ( drawMonth < 0 ) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get( inst, "prevText" );
		prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );

		nextText = this._get( inst, "nextText" );
		nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );

		currentText = this._get( inst, "currentText" );
		gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
		currentText = ( !navigationAsDateFormat ? currentText :
			this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );

		controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get( inst, "closeText" ) + "</button>" : "" );

		buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
			( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";

		firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
		firstDay = ( isNaN( firstDay ) ? 0 : firstDay );

		showWeek = this._get( inst, "showWeek" );
		dayNames = this._get( inst, "dayNames" );
		dayNamesMin = this._get( inst, "dayNamesMin" );
		monthNames = this._get( inst, "monthNames" );
		monthNamesShort = this._get( inst, "monthNamesShort" );
		beforeShowDay = this._get( inst, "beforeShowDay" );
		showOtherMonths = this._get( inst, "showOtherMonths" );
		selectOtherMonths = this._get( inst, "selectOtherMonths" );
		defaultDate = this._getDefaultDate( inst );
		html = "";

		for ( row = 0; row < numMonths[ 0 ]; row++ ) {
			group = "";
			this.maxRows = 4;
			for ( col = 0; col < numMonths[ 1 ]; col++ ) {
				selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
				cornerClass = " ui-corner-all";
				calender = "";
				if ( isMultiMonth ) {
					calender += "<div class='ui-datepicker-group";
					if ( numMonths[ 1 ] > 1 ) {
						switch ( col ) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
							case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
					( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
					this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
				for ( dow = 0; dow < 7; dow++ ) { // days of the week
					day = ( dow + firstDay ) % 7;
					thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
						"<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
				if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
					inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
				}
				leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
				curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
				numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
				for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
					calender += "<tr>";
					tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
					for ( dow = 0; dow < 7; dow++ ) { // create date picker days
						daySettings = ( beforeShowDay ?
							beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
						otherMonth = ( printDate.getMonth() !== drawMonth );
						unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
							( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
						tbody += "<td class='" +
							( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
							( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
							( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
							( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?

							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "" ) + // highlight selected day
							( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
							( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
							( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
							( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
							( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
							( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
							( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
							( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
							( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
						printDate.setDate( printDate.getDate() + 1 );
						printDate = this._daylightSavingAdjust( printDate );
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if ( drawMonth > 11 ) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
							( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort ) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get( inst, "changeMonth" ),
			changeYear = this._get( inst, "changeYear" ),
			showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// Month selection
		if ( secondary || !changeMonth ) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
		} else {
			inMinYear = ( minDate && minDate.getFullYear() === drawYear );
			inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++ ) {
				if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
					monthHtml += "<option value='" + month + "'" +
						( month === drawMonth ? " selected='selected'" : "" ) +
						">" + monthNamesShort[ month ] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if ( !showMonthAfterYear ) {
			html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
		}

		// Year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if ( secondary || !changeYear ) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {

				// determine range of years to display
				years = this._get( inst, "yearRange" ).split( ":" );
				thisYear = new Date().getFullYear();
				determineYear = function( value ) {
					var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
						( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
						parseInt( value, 10 ) ) );
					return ( isNaN( year ) ? thisYear : year );
				};
				year = determineYear( years[ 0 ] );
				endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
				year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
				endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for ( ; year <= endYear; year++ ) {
					inst.yearshtml += "<option value='" + year + "'" +
						( year === drawYear ? " selected='selected'" : "" ) +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get( inst, "yearSuffix" );
		if ( showMonthAfterYear ) {
			html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function( inst, offset, period ) {
		var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
			month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
			day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
			date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if ( period === "M" || period === "Y" ) {
			this._notifyChange( inst );
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function( inst, date ) {
		var minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			newDate = ( minDate && date < minDate ? minDate : date );
		return ( maxDate && newDate > maxDate ? maxDate : newDate );
	},

	/* Notify change of month/year. */
	_notifyChange: function( inst ) {
		var onChange = this._get( inst, "onChangeMonthYear" );
		if ( onChange ) {
			onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
				[ inst.selectedYear, inst.selectedMonth + 1, inst ] );
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function( inst ) {
		var numMonths = this._get( inst, "numberOfMonths" );
		return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function( inst, minMax ) {
		return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function( year, month ) {
		return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function( year, month ) {
		return new Date( year, month, 1 ).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function( inst, offset, curYear, curMonth ) {
		var numMonths = this._getNumberOfMonths( inst ),
			date = this._daylightSavingAdjust( new Date( curYear,
			curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );

		if ( offset < 0 ) {
			date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
		}
		return this._isInRange( inst, date );
	},

	/* Is the given date in the accepted range? */
	_isInRange: function( inst, date ) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			minYear = null,
			maxYear = null,
			years = this._get( inst, "yearRange" );
			if ( years ) {
				yearSplit = years.split( ":" );
				currentYear = new Date().getFullYear();
				minYear = parseInt( yearSplit[ 0 ], 10 );
				maxYear = parseInt( yearSplit[ 1 ], 10 );
				if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
					minYear += currentYear;
				}
				if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
					maxYear += currentYear;
				}
			}

		return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
			( !maxDate || date.getTime() <= maxDate.getTime() ) &&
			( !minYear || date.getFullYear() >= minYear ) &&
			( !maxYear || date.getFullYear() <= maxYear ) );
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function( inst ) {
		var shortYearCutoff = this._get( inst, "shortYearCutoff" );
		shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
		return { shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
			monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
	},

	/* Format the given date for display. */
	_formatDate: function( inst, day, month, year ) {
		if ( !day ) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = ( day ? ( typeof day === "object" ? day :
			this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
			this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
		return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
	}
} );

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover( dpDiv ) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.on( "mouseout", selector, function() {
			$( this ).removeClass( "ui-state-hover" );
			if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-prev-hover" );
			}
			if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-next-hover" );
			}
		} )
		.on( "mouseover", selector, datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
		$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
		$( this ).addClass( "ui-state-hover" );
		if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-prev-hover" );
		}
		if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-next-hover" );
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove( target, props ) {
	$.extend( target, props );
	for ( var name in props ) {
		if ( props[ name ] == null ) {
			target[ name ] = props[ name ];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function( options ) {

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if ( !$.datepicker.initialized ) {
		$( document ).on( "mousedown", $.datepicker._checkExternalClick );
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
		$( "body" ).append( $.datepicker.dpDiv );
	}

	var otherArgs = Array.prototype.slice.call( arguments, 1 );
	if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	return this.each( function() {
		typeof options === "string" ?
			$.datepicker[ "_" + options + "Datepicker" ].
				apply( $.datepicker, [ this ].concat( otherArgs ) ) :
			$.datepicker._attachDatepicker( this, options );
	} );
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.12.1";

return $.datepicker;

} ) );


/***/ }),

/***/ 62:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Slider 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slider
//>>group: Widgets
//>>description: Displays a flexible slider with ranges and accessibility via keyboard.
//>>docs: http://api.jqueryui.com/slider/
//>>demos: http://jqueryui.com/slider/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/slider.css
//>>css.theme: ../../themes/base/theme.css

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(20),
			__webpack_require__(63),
			__webpack_require__(28),
			__webpack_require__(24),
			__webpack_require__(29)
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

return $.widget( "ui.slider", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		classes: {
			"ui-slider": "ui-corner-all",
			"ui-slider-handle": "ui-corner-all",

			// Note: ui-widget-header isn't the most fittingly semantic framework class for this
			// element, but worked best visually with a variety of themes
			"ui-slider-range": "ui-corner-all ui-widget-header"
		},
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// Callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// Number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();
		this._calculateNewMax();

		this._addClass( "ui-slider ui-slider-" + this.orientation,
			"ui-widget ui-widget-content" );

		this._refresh();

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ),
			handle = "<span tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );

		this.handle = this.handles.eq( 0 );

		this.handles.each( function( i ) {
			$( this )
				.data( "ui-slider-handle-index", i )
				.attr( "tabIndex", 0 );
		} );
	},

	_createRange: function() {
		var options = this.options;

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[ 0 ], options.values[ 0 ] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice( 0 );
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div>" )
					.appendTo( this.element );

				this._addClass( this.range, "ui-slider-range" );
			} else {
				this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );

				// Handle range switching from true to min/max
				this.range.css( {
					"left": "",
					"bottom": ""
				} );
			}
			if ( options.range === "min" || options.range === "max" ) {
				this._addClass( this.range, "ui-slider-range-" + options.range );
			}
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each( function( i ) {
			var thisDistance = Math.abs( normValue - that.values( i ) );
			if ( ( distance > thisDistance ) ||
				( distance === thisDistance &&
					( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		} );

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		this._addClass( closestHandle, null, "ui-state-active" );
		closestHandle.trigger( "focus" );

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -
				( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +
				( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this._removeClass( this.handles, null, "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left -
				( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top -
				( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_uiHash: function( index, value, values ) {
		var uiHash = {
			handle: this.handles[ index ],
			handleIndex: index,
			value: value !== undefined ? value : this.value()
		};

		if ( this._hasMultipleValues() ) {
			uiHash.value = value !== undefined ? value : this.values( index );
			uiHash.values = values || this.values();
		}

		return uiHash;
	},

	_hasMultipleValues: function() {
		return this.options.values && this.options.values.length;
	},

	_start: function( event, index ) {
		return this._trigger( "start", event, this._uiHash( index ) );
	},

	_slide: function( event, index, newVal ) {
		var allowed, otherVal,
			currentValue = this.value(),
			newValues = this.values();

		if ( this._hasMultipleValues() ) {
			otherVal = this.values( index ? 0 : 1 );
			currentValue = this.values( index );

			if ( this.options.values.length === 2 && this.options.range === true ) {
				newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );
			}

			newValues[ index ] = newVal;
		}

		if ( newVal === currentValue ) {
			return;
		}

		allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );

		// A slide can be canceled by returning false from the slide callback
		if ( allowed === false ) {
			return;
		}

		if ( this._hasMultipleValues() ) {
			this.values( index, newVal );
		} else {
			this.value( newVal );
		}
	},

	_stop: function( event, index ) {
		this._trigger( "stop", event, this._uiHash( index ) );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;
			this._trigger( "change", event, this._uiHash( index ) );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this._hasMultipleValues() ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this._removeClass( "ui-slider-horizontal ui-slider-vertical" )
					._addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				if ( this.options.range ) {
					this._refreshRange( value );
				}

				// Reset positioning from previous orientation
				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();

				// Start from the last handle to prevent unreachable handles (#9046)
				for ( i = valsLength - 1; i >= 0; i-- ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "step":
			case "min":
			case "max":
				this._animateOff = true;
				this._calculateNewMax();
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this._hasMultipleValues() ) {

			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i += 1 ) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// Returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = ( val - this._valueMin() ) % step,
			alignValue = val - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed( 5 ) );
	},

	_calculateNewMax: function() {
		var max = this.options.max,
			min = this._valueMin(),
			step = this.options.step,
			aboveMin = Math.round( ( max - min ) / step ) * step;
		max = aboveMin + min;
		if ( max > this.options.max ) {

			//If max is not divisible by step, rounding off may increase its value
			max -= step;
		}
		this.max = parseFloat( max.toFixed( this._precision() ) );
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.max;
	},

	_refreshRange: function( orientation ) {
		if ( orientation === "vertical" ) {
			this.range.css( { "width": "", "left": "" } );
		}
		if ( orientation === "horizontal" ) {
			this.range.css( { "height": "", "bottom": "" } );
		}
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this._hasMultipleValues() ) {
			this.handles.each( function( i ) {
				valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -
					that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								left: valPercent + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								width: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								bottom: ( valPercent ) + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								height: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					}
				}
				lastValPercent = valPercent;
			} );
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						this._addClass( $( event.target ), null, "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this._hasMultipleValues() ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				this._removeClass( $( event.target ), null, "ui-state-active" );
			}
		}
	}
} );

} ) );


/***/ }),

/***/ 63:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(20),
			__webpack_require__(64),
			__webpack_require__(24),
			__webpack_require__(29)
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

var mouseHandled = false;
$( document ).on( "mouseup", function() {
	mouseHandled = false;
} );

return $.widget( "ui.mouse", {
	version: "1.12.1",
	options: {
		cancel: "input, textarea, button, select, option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.on( "mousedown." + this.widgetName, function( event ) {
				return that._mouseDown( event );
			} )
			.on( "click." + this.widgetName, function( event ) {
				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
					$.removeData( event.target, that.widgetName + ".preventClickEvent" );
					event.stopImmediatePropagation();
					return false;
				}
			} );

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off( "." + this.widgetName );
		if ( this._mouseMoveDelegate ) {
			this.document
				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );
		}
	},

	_mouseDown: function( event ) {

		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// We may have missed mouseup (out of window)
		( this._mouseStarted && this._mouseUp( event ) );

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = ( event.which === 1 ),

			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
				$( event.target ).closest( this.options.cancel ).length : false );
		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if ( !this.mouseDelayMet ) {
			this._mouseDelayTimer = setTimeout( function() {
				that.mouseDelayMet = true;
			}, this.options.delay );
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted = ( this._mouseStart( event ) !== false );
			if ( !this._mouseStarted ) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
			$.removeData( event.target, this.widgetName + ".preventClickEvent" );
		}

		// These delegates are required to keep context
		this._mouseMoveDelegate = function( event ) {
			return that._mouseMove( event );
		};
		this._mouseUpDelegate = function( event ) {
			return that._mouseUp( event );
		};

		this.document
			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function( event ) {

		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {

			// IE mouseup check - mouseup happened when mouse was out of window
			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
					!event.button ) {
				return this._mouseUp( event );

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {

				// Support: Safari <=8 - 9
				// Safari sets which to 0 if you press any of the following keys
				// during a drag (#14461)
				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
					this.ignoreMissingWhich = true;
				} else if ( !this.ignoreMissingWhich ) {
					return this._mouseUp( event );
				}
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if ( this._mouseStarted ) {
			this._mouseDrag( event );
			return event.preventDefault();
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted =
				( this._mouseStart( this._mouseDownEvent, event ) !== false );
			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
		}

		return !this._mouseStarted;
	},

	_mouseUp: function( event ) {
		this.document
			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if ( this._mouseStarted ) {
			this._mouseStarted = false;

			if ( event.target === this._mouseDownEvent.target ) {
				$.data( event.target, this.widgetName + ".preventClickEvent", true );
			}

			this._mouseStop( event );
		}

		if ( this._mouseDelayTimer ) {
			clearTimeout( this._mouseDelayTimer );
			delete this._mouseDelayTimer;
		}

		this.ignoreMissingWhich = false;
		mouseHandled = false;
		event.preventDefault();
	},

	_mouseDistanceMet: function( event ) {
		return ( Math.max(
				Math.abs( this._mouseDownEvent.pageX - event.pageX ),
				Math.abs( this._mouseDownEvent.pageY - event.pageY )
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function( /* event */ ) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function( /* event */ ) {},
	_mouseDrag: function( /* event */ ) {},
	_mouseStop: function( /* event */ ) {},
	_mouseCapture: function( /* event */ ) { return true; }
} );

} ) );


/***/ }),

/***/ 64:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(24) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {

		// Browser globals
		factory( jQuery );
	}
} ( function( $ ) {

// This file is deprecated
return $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
} ) );


/***/ }),

/***/ 65:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! jQuery Timepicker Addon - v1.6.3 - 2016-04-20
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2016 Trent Richardson; Licensed MIT */
(function ($) {

	/*
 * Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
 */
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
 * Extend jQueryUI, get it started with our version number
 */
	$.extend($.ui, {
		timepicker: {
			version: "1.6.3"
		}
	});

	/*
 * Timepicker manager.
 * Use the singleton instance of this class, $.timepicker, to interact with the time picker.
 * Settings for (groups of) time pickers are maintained in an instance object,
 * allowing multiple different settings on the same page.
 */
	var Timepicker = function Timepicker() {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			timeOnlyShowDate: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			maxTime: null,
			minTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			altRedirectFocus: true,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			oneLine: false,
			defaultValue: null,
			parse: 'strict',
			afterInject: null
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		maxTime: null,
		minTime: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour', 'minute', 'second', 'millisec', 'microsec'],
		support: {},
		control: null,

		/*
  * Override the default settings for all instances of the time picker.
  * @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
  * @return {Object} the manager object
  */
		setDefaults: function setDefaults(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
  * Create a new Timepicker instance
  */
		_newInst: function _newInst($input, opts) {
			var tp_inst = new Timepicker(),
			    inlineSettings = {},
			    fns = {},
			    overrides,
			    i;

			for (var attrName in this._defaults) {
				if (this._defaults.hasOwnProperty(attrName)) {
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

			overrides = {
				beforeShow: function beforeShow(input, dp_inst) {
					if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
						return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
					}
				},
				onChangeMonthYear: function onChangeMonthYear(year, month, dp_inst) {
					// Update the time as well : this prevents the time from disappearing from the $input field.
					// tp_inst._updateDateTime(dp_inst);
					if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
						tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
					}
				},
				onClose: function onClose(dateText, dp_inst) {
					if (tp_inst.timeDefined === true && $input.val() !== '') {
						tp_inst._updateDateTime(dp_inst);
					}
					if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
						tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
					}
				}
			};
			for (i in overrides) {
				if (overrides.hasOwnProperty(i)) {
					fns[i] = opts[i] || this._defaults[i] || null;
				}
			}

			tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
				evnts: fns,
				timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
			});
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(tp_inst._defaults.timeFormat + (tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : '') + (tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : ''));

			// controlType is string - key to our this._controls
			if (typeof tp_inst._defaults.controlType === 'string') {
				if (tp_inst._defaults.controlType === 'slider' && typeof $.ui.slider === 'undefined') {
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else {
					tp_inst.control = tp_inst._defaults.controlType;
				}

			// prep the timezone options
			var timezoneList = [-720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl = timezoneList.length,
			    tzi = 0,
			    tzv = null;
			if (tzl > 0 && _typeof(timezoneList[0]) !== 'object') {
				for (; tzi < tzl; tzi++) {
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : new Date().getTimezoneOffset() * -1;
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin : tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin : tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin : tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin : tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin : tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (tp_inst._defaults.altField) {
				tp_inst.$altInput = $(tp_inst._defaults.altField);
				if (tp_inst._defaults.altRedirectFocus === true) {
					tp_inst.$altInput.css({
						cursor: 'pointer'
					}).focus(function () {
						$input.trigger("focus");
					});
				}
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function () {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
  * add our sliders to the calendar
  */
		_addTimePicker: function _addTimePicker(dp_inst) {
			var currDT = $.trim(this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val());

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
			this._afterInject();
		},

		/*
  * parse the time string from input value or _setTime
  */
		_parseTime: function _parseTime(timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
  * Handle callback option after injecting timepicker
  */
		_afterInject: function _afterInject() {
			var o = this.inst.settings;
			if ($.isFunction(o.afterInject)) {
				o.afterInject.call(this);
			}
		},

		/*
  * generate and inject html for timepicker into ui datepicker
  */
		_injectTimePicker: function _injectTimePicker() {
			var $dp = this.inst.dpDiv,
			    o = this.inst.settings,
			    tp_inst = this,
			    litem = '',
			    uitem = '',
			    show = null,
			    max = {},
			    gridSize = {},
			    size = null,
			    i = 0,
			    l = 0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' ui_tpicker_unit_hide',
				    html = '<div class="ui-timepicker-div' + (o.isRTL ? ' ui-timepicker-rtl' : '') + (o.oneLine && o.controlType === 'select' ? ' ui-timepicker-oneLine' : '') + '"><dl>' + '<dt class="ui_tpicker_time_label' + (o.showTime ? '' : noDisplay) + '">' + o.timeText + '</dt>' + '<dd class="ui_tpicker_time ' + (o.showTime ? '' : noDisplay) + '"><input class="ui_tpicker_time_input" ' + (o.timeInput ? '' : 'disabled') + '/></dd>';

				// Create the markup
				for (i = 0, l = this.units.length; i < l; i++) {
					litem = this.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt(o[litem + 'Max'] - (o[litem + 'Max'] - o[litem + 'Min']) % o['step' + uitem], 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_' + litem + '_label' + (show ? '' : noDisplay) + '">' + o[litem + 'Text'] + '</dt>' + '<dd class="ui_tpicker_' + litem + (show ? '' : noDisplay) + '"><div class="ui_tpicker_' + litem + '_slider' + (show ? '' : noDisplay) + '"></div>';

					if (show && o[litem + 'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if (litem === 'hour') {
							for (var h = o[litem + 'Min']; h <= max[litem]; h += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm ? 'hht' : 'HH', { hour: h }, o);
								html += '<td data-for="' + litem + '">' + tmph + '</td>';
							}
						} else {
							for (var m = o[litem + 'Min']; m <= max[litem]; m += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="' + litem + '">' + (m < 10 ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}

				// Timezone
				var showTz = o.showTimezone !== null ? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label' + (showTz ? '' : noDisplay) + '">' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone' + (showTz ? '' : noDisplay) + '"></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}

				// add sliders, adjust grids, add events
				for (i = 0, l = tp_inst.units.length; i < l; i++) {
					litem = tp_inst.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// add the slider
					tp_inst[litem + '_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_' + litem + '_slider'), litem, tp_inst[litem], o[litem + 'Min'], max[litem], o['step' + uitem]);

					// adjust the grid and add click event
					if (show && o[litem + 'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem + 'Grid'] / (max[litem] - o[litem + 'Min']);
						$tp.find('.ui_tpicker_' + litem + ' table').css({
							width: size + "%",
							marginLeft: o.isRTL ? '0' : size / (-2 * gridSize[litem]) + "%",
							marginRight: o.isRTL ? size / (-2 * gridSize[litem]) + "%" : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function (e) {
							var $t = $(this),
							    h = $t.html(),
							    n = parseInt(h.replace(/[^0-9]/g), 10),
							    ap = h.replace(/[^apm]/ig),
							    f = $t.data('for'); // loses scope, so we use data-for

							if (f === 'hour') {
								if (ap.indexOf('p') !== -1 && n < 12) {
									n += 12;
								} else {
									if (ap.indexOf('a') !== -1 && n === 12) {
										n = 0;
									}
								}
							}

							tp_inst.control.value(tp_inst, tp_inst[f + '_slider'], litem, n);

							tp_inst._onTimeChange();
							tp_inst._onSelectHandler();
						}).css({
							cursor: 'pointer',
							width: 100 / gridSize[litem] + '%',
							textAlign: 'center',
							overflow: 'hidden'
						});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function (val, idx) {
					return $("<option />").val((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.value : val).text((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.label : val);
				}));
				if (typeof this.timezone !== "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12).getTimezoneOffset() * -1;
					if (local_timezone === this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof this.hour !== "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function () {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
					tp_inst._afterInject();
				});
				// End timezone options

				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time_input');
				this.$timeObj.change(function () {
					var timeFormat = tp_inst.inst.settings.timeFormat;
					var parsedTime = $.datepicker.parseTime(timeFormat, this.value);
					var update = new Date();
					if (parsedTime) {
						update.setHours(parsedTime.hour);
						update.setMinutes(parsedTime.minute);
						update.setSeconds(parsedTime.second);
						$.datepicker._setTime(tp_inst.inst, update);
					} else {
						this.value = tp_inst.formattedTime;
						this.blur();
					}
				});

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
					    rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;

					setTimeout(function () {
						// fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function () {
									var $g = $(this),
									    oldWidth = $g.outerWidth(),
									    oldMarginLeft = $g.css(rtl ? 'marginRight' : 'marginLeft').toString().replace('%', ''),
									    newWidth = oldWidth - sliderAccessWidth,
									    newMarginLeft = oldMarginLeft * newWidth / oldWidth + '%',
									    css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl ? 'marginRight' : 'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

				tp_inst._limitMinMaxDateTime(this.inst, true);
			}
		},

		/*
  * This function tries to limit the ability to go outside the
  * min/max date range
  */
		_limitMinMaxDateTime: function _limitMinMaxDateTime(dp_inst, adjustSliders) {
			var o = this._defaults,
			    dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
				    minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if (this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
				    maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (dp_inst.settings.minTime !== null) {
				var tempMinTime = new Date("01/01/1970 " + dp_inst.settings.minTime);
				if (this.hour < tempMinTime.getHours()) {
					this.hour = this._defaults.hourMin = tempMinTime.getHours();
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else if (this.hour === tempMinTime.getHours() && this.minute < tempMinTime.getMinutes()) {
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else {
					if (this._defaults.hourMin < tempMinTime.getHours()) {
						this._defaults.hourMin = tempMinTime.getHours();
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else if (this._defaults.hourMin === tempMinTime.getHours() === this.hour && this._defaults.minuteMin < tempMinTime.getMinutes()) {
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else {
						this._defaults.minuteMin = 0;
					}
				}
			}

			if (dp_inst.settings.maxTime !== null) {
				var tempMaxTime = new Date("01/01/1970 " + dp_inst.settings.maxTime);
				if (this.hour > tempMaxTime.getHours()) {
					this.hour = this._defaults.hourMax = tempMaxTime.getHours();
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else if (this.hour === tempMaxTime.getHours() && this.minute > tempMaxTime.getMinutes()) {
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else {
					if (this._defaults.hourMax > tempMaxTime.getHours()) {
						this._defaults.hourMax = tempMaxTime.getHours();
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else if (this._defaults.hourMax === tempMaxTime.getHours() === this.hour && this._defaults.minuteMax > tempMaxTime.getMinutes()) {
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else {
						this._defaults.minuteMax = 59;
					}
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10),
				    minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10),
				    secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10),
				    millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10),
				    microsecMax = parseInt(this._defaults.microsecMax - (this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec, 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax, step: this._defaults.stepHour });
					this.control.value(this, this.hour_slider, 'hour', this.hour - this.hour % this._defaults.stepHour);
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax, step: this._defaults.stepMinute });
					this.control.value(this, this.minute_slider, 'minute', this.minute - this.minute % this._defaults.stepMinute);
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax, step: this._defaults.stepSecond });
					this.control.value(this, this.second_slider, 'second', this.second - this.second % this._defaults.stepSecond);
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax, step: this._defaults.stepMillisec });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - this.millisec % this._defaults.stepMillisec);
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax, step: this._defaults.stepMicrosec });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - this.microsec % this._defaults.stepMicrosec);
				}
			}
		},

		/*
  * when a slider moves, set the internal time...
  * on time change is also called when the time is updated in the text field
  */
		_onTimeChange: function _onTimeChange() {
			if (!this._defaults.showTimepicker) {
				return;
			}
			var hour = this.hour_slider ? this.control.value(this, this.hour_slider, 'hour') : false,
			    minute = this.minute_slider ? this.control.value(this, this.minute_slider, 'minute') : false,
			    second = this.second_slider ? this.control.value(this, this.second_slider, 'second') : false,
			    millisec = this.millisec_slider ? this.control.value(this, this.millisec_slider, 'millisec') : false,
			    microsec = this.microsec_slider ? this.control.value(this, this.microsec_slider, 'microsec') : false,
			    timezone = this.timezone_select ? this.timezone_select.val() : false,
			    o = this._defaults,
			    pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
			    pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if ((typeof hour === 'undefined' ? 'undefined' : _typeof(hour)) === 'object') {
				hour = false;
			}
			if ((typeof minute === 'undefined' ? 'undefined' : _typeof(minute)) === 'object') {
				minute = false;
			}
			if ((typeof second === 'undefined' ? 'undefined' : _typeof(second)) === 'object') {
				second = false;
			}
			if ((typeof millisec === 'undefined' ? 'undefined' : _typeof(millisec)) === 'object') {
				millisec = false;
			}
			if ((typeof microsec === 'undefined' ? 'undefined' : _typeof(microsec)) === 'object') {
				microsec = false;
			}
			if ((typeof timezone === 'undefined' ? 'undefined' : _typeof(timezone)) === 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}
			if (timezone !== false) {
				timezone = timezone.toString();
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = hour !== parseInt(this.hour, 10) || // sliders should all be numeric
			minute !== parseInt(this.minute, 10) || second !== parseInt(this.second, 10) || millisec !== parseInt(this.millisec, 10) || microsec !== parseInt(this.microsec, 10) || this.ampm.length > 0 && hour < 12 !== ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1) || this.timezone !== null && timezone !== this.timezone.toString() // could be numeric or "EST" format, so use toString()
			;

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if (pickerTimeFormat === o.timeFormat) {
					this.$timeObj.val(this.formattedTime + pickerTimeSuffix);
				} else {
					this.$timeObj.val($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
				if (this.$timeObj[0].setSelectionRange) {
					var sPos = this.$timeObj[0].selectionStart;
					var ePos = this.$timeObj[0].selectionEnd;
					this.$timeObj[0].setSelectionRange(sPos, ePos);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
				//this.$input.focus(); // may automatically open the picker on setDate
			}
		},

		/*
  * call custom onSelect.
  * bind to sliders slidestop, and grid click.
  */
		_onSelectHandler: function _onSelectHandler() {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
  * update our input with the new date time..
  */
		_updateDateTime: function _updateDateTime(dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dtTmp = dp_inst.currentYear > 0 ? new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay),
			    dt = $.datepicker._daylightSavingAdjust(dtTmp),

			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
			dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
			    formatCfg = $.datepicker._getFormatConfig(dp_inst),
			    timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, dt === null ? new Date() : dt, formatCfg);
			var formattedDateTime = this.formattedDate;

			// if a slider was changed but datepicker doesn't have a value yet, set it
			if (dp_inst.lastVal === "") {
				dp_inst.currentYear = dp_inst.selectedYear;
				dp_inst.currentMonth = dp_inst.selectedMonth;
				dp_inst.currentDay = dp_inst.selectedDay;
			}

			/*
   * remove following lines to force every changes in date picker to change the input value
   * Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker.
   * If the user manually empty the value in the input field, the date picker will never change selected value.
   */
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === false) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable) || this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === true) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
				    altSeparator = this._defaults.altSeparator !== null ? this._defaults.altSeparator : this._defaults.separator,
				    altTimeSuffix = this._defaults.altTimeSuffix !== null ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;

				if (!this._defaults.timeOnly) {
					if (this._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, dt === null ? new Date() : dt, formatCfg);
					} else {
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime) {
						altFormattedDateTime += altSeparator;
					}
				}

				if (this._defaults.altTimeFormat !== null) {
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				} else {
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function _onFocus() {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
				    tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
  * Small abstraction to control types
  * We can add more, just be sure to follow the pattern: create, options, value
  */
		_controls: {
			// slider methods
			slider: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl ? val * -1 : val,
						min: rtl ? max * -1 : min,
						max: rtl ? min * -1 : max,
						step: step,
						slide: function slide(event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value);
							tp_inst._onTimeChange();
						},
						stop: function stop(event, ui) {
							tp_inst._onSelectHandler();
						}
					});
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					if (tp_inst._defaults.isRTL) {
						if (typeof opts === 'string') {
							if (opts === 'min' || opts === 'max') {
								if (val !== undefined) {
									return obj.slider(opts, val * -1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min,
						    max = opts.max;
						opts.min = opts.max = null;
						if (min !== undefined) {
							opts.max = min * -1;
						}
						if (max !== undefined) {
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if (typeof opts === 'string' && val !== undefined) {
						return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function value(tp_inst, obj, unit, val) {
					if (tp_inst._defaults.isRTL) {
						if (val !== undefined) {
							return obj.slider('value', val * -1);
						}
						return Math.abs(obj.slider('value'));
					}
					if (val !== undefined) {
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">',
					    format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for (var i = min; i <= max; i += step) {
						sel += '<option value="' + i + '"' + (i === val ? ' selected' : '') + '>';
						if (unit === 'hour') {
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig, '')), { hour: i }, tp_inst._defaults);
						} else if (unit === 'millisec' || unit === 'microsec' || i >= 10) {
							sel += i;
						} else {
							sel += '0' + i.toString();
						}
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function (e) {
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
						tp_inst._afterInject();
					});

					return obj;
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					var o = {},
					    $t = obj.children('select');
					if (typeof opts === 'string') {
						if (val === undefined) {
							return $t.data(opts);
						}
						o[opts] = val;
					} else {
						o = opts;
					}
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min >= 0 ? o.min : $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function value(tp_inst, obj, unit, val) {
					var $t = obj.children('select');
					if (val !== undefined) {
						return $t.val(val);
					}
					return $t.val();
				}
			} // end _controls

		} });

	$.fn.extend({
		/*
  * shorthand just to use timepicker.
  */
		timepicker: function timepicker(o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function () {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
  * extend timepicker to datepicker
  */
		datetimepicker: function datetimepicker(o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof o === 'string') {
				if (o === 'getDate' || o === 'option' && tmp_args.length === 2 && typeof tmp_args[1] === 'string') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function () {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function () {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
 * Public Utility to parse date and time
 */
	$.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRes.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
 * Public utility to parse time
 */
	$.datepicker.parseTime = function (timeFormat, timeString, options) {
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
		    iso8601 = timeFormat.replace(/\'.*?\'/g, '').indexOf('Z') !== -1;

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function strictParse(f, s, o) {

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function getPatternAmpm(amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function (val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function getFormatPositions(timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
				    orders = {
					h: -1,
					m: -1,
					s: -1,
					l: -1,
					c: -1,
					t: -1,
					z: -1
				};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] === -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
				var ml = match.length;
				switch (match.charAt(0).toLowerCase()) {
					case 'h':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'm':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 's':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'l':
						return '(\\d?\\d?\\d)';
					case 'c':
						return '(\\d?\\d?\\d)';
					case 'z':
						return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
					case 't':
						return getPatternAmpm(o.amNames, o.pmNames);
					default:
						// literal escaped in quotes
						return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) {
							return "\\" + m;
						}) + ')?';
				}
			}).replace(/\s/g, '\\s?') + o.timeSuffix + '$',
			    order = getFormatPositions(f),
			    ampm = '',
			    treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), $.map(o.amNames, function (x, i) {
							return x.toUpperCase();
						})) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm === 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm === 'AM' && treg[order.h] === '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm === 'PM' && treg[order.h] !== '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}

				return resTime;
			}
			return false;
		}; // end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function looseParse(f, s, o) {
			try {
				var d = new Date('2012-01-01 ' + s);
				if (isNaN(d.getTime())) {
					d = new Date('2012-01-01T' + s);
					if (isNaN(d.getTime())) {
						d = new Date('01/01/2012 ' + s);
						if (isNaN(d.getTime())) {
							throw "Unable to parse time with native Date: " + s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset() * -1
				};
			} catch (err) {
				try {
					return strictParse(f, s, o);
				} catch (err2) {
					$.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
				}
			}
			return false;
		}; // end looseParse

		if (typeof o.parse === "function") {
			return o.parse(timeFormat, timeString, o);
		}
		if (o.parse === 'loose') {
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/**
  * Public utility to format the time
  * @param {string} format format of the time
  * @param {Object} time Object not a Date for timezones
  * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
  * @returns {string} the formatted time
  */
	$.datepicker.formatTime = function (format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null
		}, time);

		var tmptime = format,
		    ampmName = options.amNames[0],
		    hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
			switch (match) {
				case 'HH':
					return ('0' + hour).slice(-2);
				case 'H':
					return hour;
				case 'hh':
					return ('0' + convert24to12(hour)).slice(-2);
				case 'h':
					return convert24to12(hour);
				case 'mm':
					return ('0' + time.minute).slice(-2);
				case 'm':
					return time.minute;
				case 'ss':
					return ('0' + time.second).slice(-2);
				case 's':
					return time.second;
				case 'l':
					return ('00' + time.millisec).slice(-3);
				case 'c':
					return ('00' + time.microsec).slice(-3);
				case 'z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, false);
				case 'Z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, true);
				case 'T':
					return ampmName.charAt(0).toUpperCase();
				case 'TT':
					return ampmName.toUpperCase();
				case 't':
					return ampmName.charAt(0).toLowerCase();
				case 'tt':
					return ampmName.toLowerCase();
				default:
					return match.replace(/'/g, "");
			}
		});

		return tmptime;
	};

	/*
 * the bad hack :/ override datepicker so it doesn't close on select
 // inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
 */
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function (id, dateStr) {
		var inst = this._getInst($(id)[0]),
		    tp_inst = this._get(inst, 'timepicker'),
		    was_inline;

		if (tp_inst && inst.settings.showTimepicker) {
			tp_inst._limitMinMaxDateTime(inst, true);
			was_inline = inst.inline;
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = was_inline;
			inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
 * second bad hack :/ override datepicker so it triggers an event when changing the input field
 * and does not redraw the datepicker on every selectDate event
 */
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function (inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input) {
			return;
		}

		if (typeof inst.stay_open !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
 * third bad hack :/ override datepicker so it allows spaces and colon in the input field
 */
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
				    tz = tp_inst._defaults.showTimezone !== null ? tp_inst._defaults.showTimezone : tp_inst.support.timezone,
				    dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
				    datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, '').replace(/TT/g, ampm ? 'APM' : '').replace(/Tt/g, ampm ? 'AaPpMm' : '').replace(/tT/g, ampm ? 'AaPpMm' : '').replace(/T/g, ampm ? 'AP' : '').replace(/tt/g, ampm ? 'apm' : '').replace(/t/g, ampm ? 'ap' : '') + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tz ? tp_inst._defaults.timezoneList.join('') : '') + tp_inst._defaults.amNames.join('') + tp_inst._defaults.pmNames.join('') + dateChars,
				    chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1;
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
 * Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
 * Update any alternate field to synchronise with the main field.
 */
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	$.datepicker._updateAlternate = function (inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var altField = tp_inst._defaults.altField;
			if (altField) {
				// update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
				    date = this._getDate(inst),
				    formatCfg = $.datepicker._getFormatConfig(inst),
				    altFormattedDateTime = '',
				    altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator,
				    altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
				    altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;

				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null) {
					if (tp_inst._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					} else {
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val(inst.input.val() ? altFormattedDateTime : "");
			}
		} else {
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
 * Override key up event to sync manual input changes.
 */
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
 * override "Today" button to also grab the time and set it to input field.
 */
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function (id) {
		var inst = this._getInst($(id)[0]);
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		if (!tp_inst) {
			return;
		}

		var tzoffset = $.timepicker.timezoneOffsetNumber(tp_inst.timezone);
		var now = new Date();
		now.setMinutes(now.getMinutes() + now.getTimezoneOffset() + parseInt(tzoffset, 10));
		this._setTime(inst, now);
		this._setDate(inst, now);
		tp_inst._onSelectHandler();
	};

	/*
 * Disable & enable the Time in the datetimepicker
 */
	$.datepicker._disableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = false;
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = true;
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create our own set time function
 */
	$.datepicker._setTime = function (inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times..
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create new public method to set only time, callable as $().datepicker('setTime', date)
 */
	$.datepicker._setTimeDatepicker = function (target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date === "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
					tp_date.setMicroseconds(date.getMicroseconds());
				}
				if (tp_date.toString() === 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}
	};

	/*
 * override setDate() to allow setting time too within Date object
 */
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function (target, _date) {
		var inst = this._getInst(target);
		var date = _date;
		if (!inst) {
			return;
		}

		if (typeof _date === 'string') {
			date = new Date(_date);
			if (!date.getTime()) {
				this._base_setDateDatepicker.apply(this, arguments);
				date = $(target).datepicker('getDate');
			}
		}

		var tp_inst = this._get(inst, 'timepicker');
		var tp_date;
		if (date instanceof Date) {
			tp_date = new Date(date.getTime());
			tp_date.setMicroseconds(date.getMicroseconds());
		} else {
			tp_date = date;
		}

		// This is important if you are using the timezone option, javascript's Date
		// object will only return the timezone offset for the current locale, so we
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if (tp_inst && tp_date) {
			// look out for DST if tz wasn't specified
			if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
				tp_inst.timezone = tp_date.getTimezoneOffset() * -1;
			}
			date = $.timepicker.timezoneAdjust(date, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()), tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, $.timepicker.timezoneOffsetString(-tp_date.getTimezoneOffset()), tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
 * override getDate() to allow getting time too within Date object
 */
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function (target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if (inst.lastVal === undefined) {
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);

			var currDT = null;

			if (tp_inst.$altInput && tp_inst._defaults.altFieldTimeOnly) {
				currDT = tp_inst.$input.val() + ' ' + tp_inst.$altInput.val();
			} else if (tp_inst.$input.get(0).tagName !== 'INPUT' && tp_inst.$altInput) {
				/**
     * in case the datetimepicker has been applied to a non-input tag for inline UI,
     * and the user has not configured the plugin to display only time in altInput,
     * pick current date time from the altInput (and hope for the best, for now, until "ER1" is applied)
     *
     * @todo ER1. Since altInput can have a totally difference format, convert it to standard format by reading input format from "altFormat" and "altTimeFormat" option values
     */
				currDT = tp_inst.$altInput.val();
			} else {
				currDT = tp_inst.$input.val();
			}

			if (date && tp_inst._parseTime(currDT, !inst.settings.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date
				// object will only return the timezone offset for the current locale, so we
				// adjust it accordingly.  If not using timezone option this won't matter..
				if (tp_inst.timezone != null) {
					// look out for DST if tz wasn't specified
					if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
						tp_inst.timezone = date.getTimezoneOffset() * -1;
					}
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()));
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
 * override parseDate() because UI 1.8.14 throws an error about "Extra characters"
 * An option in datapicker to ignore extra format characters would be nicer.
 */
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function (format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(':') - 2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
 * override formatDate to set date with time to the input
 */
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function (inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
 * override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
 */
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function (target, name, value) {
		var inst = this._getInst(target),
		    name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
			    max = null,
			    onselect = null,
			    overrides = tp_inst._defaults.evnts,
			    fns = {},
			    prop,
			    ret,
			    oldVal,
			    $target;
			if (typeof name === 'string') {
				// if min/max was set with the string
				if (name === 'minDate' || name === 'minDateTime') {
					min = value;
				} else if (name === 'maxDate' || name === 'maxDateTime') {
					max = value;
				} else if (name === 'onSelect') {
					onselect = value;
				} else if (overrides.hasOwnProperty(name)) {
					if (typeof value === 'undefined') {
						return overrides[name];
					}
					fns[name] = value;
					name_clone = {}; //empty results in exiting function after overrides updated
				}
			} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
				//if min/max was set with the JSON
				if (name.minDate) {
					min = name.minDate;
				} else if (name.minDateTime) {
					min = name.minDateTime;
				} else if (name.maxDate) {
					max = name.maxDate;
				} else if (name.maxDateTime) {
					max = name.maxDateTime;
				}
				for (prop in overrides) {
					if (overrides.hasOwnProperty(prop) && name[prop]) {
						fns[prop] = name[prop];
					}
				}
			}
			for (prop in fns) {
				if (fns.hasOwnProperty(prop)) {
					overrides[prop] = fns[prop];
					if (!name_clone) {
						name_clone = $.extend({}, name);
					}
					delete name_clone[prop];
				}
			}
			if (name_clone && isEmptyObject(name_clone)) {
				return;
			}
			if (min) {
				//if min was set
				if (min === 0) {
					min = new Date();
				} else {
					min = new Date(min);
				}
				tp_inst._defaults.minDate = min;
				tp_inst._defaults.minDateTime = min;
			} else if (max) {
				//if max was set
				if (max === 0) {
					max = new Date();
				} else {
					max = new Date(max);
				}
				tp_inst._defaults.maxDate = max;
				tp_inst._defaults.maxDateTime = max;
			} else if (onselect) {
				tp_inst._defaults.onSelect = onselect;
			}

			// Datepicker will override our date when we call _base_optionDatepicker when
			// calling minDate/maxDate, so we will first grab the value, call
			// _base_optionDatepicker, then set our value back.
			if (min || max) {
				$target = $(target);
				oldVal = $target.datetimepicker('getDate');
				ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
				$target.datetimepicker('setDate', oldVal);
				return ret;
			}
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};

	/*
 * jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
 * it will return false for all objects
 */
	var isEmptyObject = function isEmptyObject(obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/*
 * jQuery extend now ignores nulls!
 */
	var extendRemove = function extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
 * Determine by the time format which units are supported
 * Returns an object of booleans for each unit
 */
	var detectSupport = function detectSupport(timeFormat) {
		var tf = timeFormat.replace(/'.*?'/g, '').toLowerCase(),
		    // removes literals
		isIn = function isIn(f, t) {
			// does the format contain the token?
			return f.indexOf(t) !== -1 ? true : false;
		};
		return {
			hour: isIn(tf, 'h'),
			minute: isIn(tf, 'm'),
			second: isIn(tf, 's'),
			millisec: isIn(tf, 'l'),
			microsec: isIn(tf, 'c'),
			timezone: isIn(tf, 'z'),
			ampm: isIn(tf, 't') && isIn(timeFormat, 'h'),
			iso8601: isIn(timeFormat, 'Z')
		};
	};

	/*
 * Converts 24 hour format into 12 hour
 * Returns 12 hour without leading 0
 */
	var convert24to12 = function convert24to12(hour) {
		hour %= 12;

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	var computeEffectiveSetting = function computeEffectiveSetting(settings, property) {
		return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
	};

	/*
 * Splits datetime string into date and time substrings.
 * Throws exception when date can't be parsed
 * Returns {dateString: dateString, timeString: timeString}
 */
	var splitDateTime = function splitDateTime(dateTimeString, timeSettings) {
		// The idea is to get the number separator occurrences in datetime and the time format requested (since time has
		// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
		var separator = computeEffectiveSetting(timeSettings, 'separator'),
		    format = computeEffectiveSetting(timeSettings, 'timeFormat'),
		    timeParts = format.split(separator),
		    // how many occurrences of separator may be in our format?
		timePartsLen = timeParts.length,
		    allParts = dateTimeString.split(separator),
		    allPartsLen = allParts.length;

		if (allPartsLen > 1) {
			return {
				dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
				timeString: allParts.splice(0, timePartsLen).join(separator)
			};
		}

		return {
			dateString: dateTimeString,
			timeString: ''
		};
	};

	/*
 * Internal function to parse datetime interval
 * Returns: {date: Date, timeObj: Object}, where
 *   date - parsed date without time (type Date)
 *   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
 */
	var parseDateTimeInternal = function parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date, parts, parsedTime;

		parts = splitDateTime(dateTimeString, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings);

		if (parts.timeString === '') {
			return {
				date: date
			};
		}

		parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings);

		if (!parsedTime) {
			throw 'Wrong time format';
		}

		return {
			date: date,
			timeObj: parsedTime
		};
	};

	/*
 * Internal function to set timezone_select to the local timezone
 */
	var selectLocalTimezone = function selectLocalTimezone(tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = date || new Date();
			tp_inst.timezone_select.val(-now.getTimezoneOffset());
		}
	};

	/*
 * Create a Singleton Instance
 */
	$.timepicker = new Timepicker();

	/**
  * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
  * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
  * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
  * @return {string}
  */
	$.timepicker.timezoneOffsetString = function (tzMinutes, iso8601) {
		if (isNaN(tzMinutes) || tzMinutes > 840 || tzMinutes < -720) {
			return tzMinutes;
		}

		var off = tzMinutes,
		    minutes = off % 60,
		    hours = (off - minutes) / 60,
		    iso = iso8601 ? ':' : '',
		    tz = (off >= 0 ? '+' : '-') + ('0' + Math.abs(hours)).slice(-2) + iso + ('0' + Math.abs(minutes)).slice(-2);

		if (tz === '+00:00') {
			return 'Z';
		}
		return tz;
	};

	/**
  * Get the number in minutes that represents a timezone string
  * @param  {string} tzString formatted like "+0500", "-1245", "Z"
  * @return {number} the offset minutes or the original string if it doesn't match expectations
  */
	$.timepicker.timezoneOffsetNumber = function (tzString) {
		var normalized = tzString.toString().replace(':', ''); // excuse any iso8601, end up with "+1245"

		if (normalized.toUpperCase() === 'Z') {
			// if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if (!/^(\-|\+)\d{4}$/.test(normalized)) {
			// possibly a user defined tz, so just give it back
			return parseInt(tzString, 10);
		}

		return (normalized.substr(0, 1) === '-' ? -1 : 1) * ( // plus or minus
		parseInt(normalized.substr(1, 2), 10) * 60 + // hours (converted to minutes)
		parseInt(normalized.substr(3, 2), 10)); // minutes
	};

	/**
  * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
  * @param  {Date} date
  * @param  {string} fromTimezone formatted like "+0500", "-1245"
  * @param  {string} toTimezone formatted like "+0500", "-1245"
  * @return {Date}
  */
	$.timepicker.timezoneAdjust = function (date, fromTimezone, toTimezone) {
		var fromTz = $.timepicker.timezoneOffsetNumber(fromTimezone);
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if (!isNaN(toTz)) {
			date.setMinutes(date.getMinutes() + -fromTz - -toTz);
		}
		return date;
	};

	/**
  * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * n.b. The input value must be correctly formatted (reformatting is not supported)
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the timepicker() call
  * @return {jQuery}
  */
	$.timepicker.timeRange = function (startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
  * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @return {jQuery}
  */
	$.timepicker.datetimeRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
  * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.dateRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
  * Calls `method` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.handleRange = function (method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {}, // options for start picker
			end: {} // options for end picker
		}, options);

		// for the mean time this fixes an issue with calling getDate with timepicker()
		var timeOnly = false;
		if (method === 'timepicker') {
			timeOnly = true;
			method = 'datetimepicker';
		}

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
			    enddt = endTime[method]('getDate'),
			    changeddt = changed[method]('getDate');

			if (startdt !== null) {
				var minDate = new Date(startdt.getTime()),
				    maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if (options.minInterval > 0 && minDate > enddt) {
					// minInterval check
					endTime[method]('setDate', minDate);
				} else if (options.maxInterval > 0 && maxDate < enddt) {
					// max interval check
					endTime[method]('setDate', maxDate);
				} else if (startdt > enddt) {
					other[method]('setDate', changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if (date !== null && options.minInterval > 0) {
				if (option === 'minDate') {
					date.setMilliseconds(date.getMilliseconds() + options.minInterval);
				}
				if (option === 'maxDate') {
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}

			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}

		$.fn[method].call(startTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);

		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
  * Log error or data to the console during error or debugging
  * @param  {Object} err pass any type object to log to the console during error or debugging
  * @return {void}
  */
	$.timepicker.log = function () {
		// Older IE (9, maybe 10) throw error on accessing `window.console.log.apply`, so check first.
		if (window.console && window.console.log && window.console.log.apply) {
			window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
		}
	};

	/*
  * Add util object to allow access to private methods for testability.
  */
	$.timepicker._util = {
		_extendRemove: extendRemove,
		_isEmptyObject: isEmptyObject,
		_convert24to12: convert24to12,
		_detectSupport: detectSupport,
		_selectLocalTimezone: selectLocalTimezone,
		_computeEffectiveSetting: computeEffectiveSetting,
		_splitDateTime: splitDateTime,
		_parseDateTimeInternal: parseDateTimeInternal
	};

	/*
 * Microsecond support
 */
	if (!Date.prototype.getMicroseconds) {
		Date.prototype.microseconds = 0;
		Date.prototype.getMicroseconds = function () {
			return this.microseconds;
		};
		Date.prototype.setMicroseconds = function (m) {
			this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1000));
			this.microseconds = m % 1000;
			return this;
		};
	}

	/*
 * Keep up with the version
 */
	$.timepicker.version = "1.6.3";
})(window.jQuery);

/***/ }),

/***/ 66:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.11.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Popper = factory();
})(undefined, function () {
  'use strict';

  var nativeHints = ['native code', '[object MutationObserverConstructor]'];

  /**
   * Determine if a function is implemented natively (as opposed to a polyfill).
   * @method
   * @memberof Popper.Utils
   * @argument {Function | undefined} fn the function to check
   * @returns {Boolean}
   */
  var isNative = function isNative(fn) {
    return nativeHints.some(function (hint) {
      return (fn || '').toString().indexOf(hint) > -1;
    });
  };

  var isBrowser = typeof window !== 'undefined';
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }

  function microtaskDebounce(fn) {
    var scheduled = false;
    var i = 0;
    var elem = document.createElement('span');

    // MutationObserver provides a mechanism for scheduling microtasks, which
    // are scheduled *before* the next task. This gives us a way to debounce
    // a function but ensure it's called *before* the next paint.
    var observer = new MutationObserver(function () {
      fn();
      scheduled = false;
    });

    observer.observe(elem, { attributes: true });

    return function () {
      if (!scheduled) {
        scheduled = true;
        elem.setAttribute('x-index', i);
        i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8
      }
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  // It's common for MutationObserver polyfills to be seen in the wild, however
  // these rely on Mutation Events which only occur when an element is connected
  // to the DOM. The algorithm used in this module does not use a connected element,
  // and so we must ensure that a *native* MutationObserver is available.
  var supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);

  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */
  var debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {
      return window.document.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent(getParentNode(element));
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    // NOTE: 1 DOM access here
    var offsetParent = element && element.offsetParent;
    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return window.document.documentElement;
    }

    // .offsetParent will return the closest TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return window.document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = window.document.documentElement;
      var scrollingElement = window.document.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];
  }

  /**
   * Tells if you are running Internet Explorer 10
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean} isIE10
   */
  var isIE10 = undefined;

  var isIE10$1 = function isIE10$1() {
    if (isIE10 === undefined) {
      isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
    }
    return isIE10;
  };

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], html['client' + axis], html['offset' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
  }

  function getWindowSizes() {
    var body = window.document.body;
    var html = window.document.documentElement;
    var computedStyle = isIE10$1() && window.getComputedStyle(html);

    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    if (isIE10$1()) {
      try {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } catch (err) {}
    } else {
      rect = element.getBoundingClientRect();
    }

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');

      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var isIE10 = isIE10$1();
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = +styles.borderTopWidth.split('px')[0];
    var borderLeftWidth = +styles.borderLeftWidth.split('px')[0];

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = +styles.marginTop.split('px')[0];
      var marginLeft = +styles.marginLeft.split('px')[0];

      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var html = window.document.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = getScroll(html);
    var scrollLeft = getScroll(html, 'left');

    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };

    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    return isFixed(getParentNode(element));
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    // NOTE: 1 DOM access here
    var boundaries = { top: 0, left: 0 };
    var offsetParent = findCommonOffsetParent(popper, reference);

    // Handle viewport case
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(popper));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = window.document.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = window.document.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    boundaries.left += padding;
    boundaries.top += padding;
    boundaries.right -= padding;
    boundaries.bottom -= padding;

    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };

    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var commonOffsetParent = findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

    modifiersToRun.forEach(function (modifier) {
      if (modifier.function) {
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier.function || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);

        data = fn(data, modifier);
      }
    });

    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length - 1; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof window.document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroy the popper
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.left = '';
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? window : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    window.addEventListener('resize', state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    window.removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger onUpdate callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      window.cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if the arrow style has been computed, apply the arrow style
    if (data.offsets.arrow) {
      setStyles(data.arrowElement, data.offsets.arrow);
    }

    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: 'absolute' });

    return options;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
      position: popper.position
    };

    // floor sides to avoid blurry text
    var offsets = {
      left: Math.floor(popper.left),
      top: Math.floor(popper.top),
      bottom: Math.floor(popper.bottom),
      right: Math.floor(popper.right)
    };

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      top = -offsetParentRect.height + offsets.bottom;
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      left = -offsetParentRect.width + offsets.right;
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
      'x-placement': data.placement
    };

    // Update attributes and styles of `data`
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);

    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow(data, options) {
    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var side = isVertical ? 'top' : 'left';
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    var sideValue = center - getClientRect(data.offsets.popper)[side];

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = {};
    data.offsets.arrow[side] = Math.round(sideValue);
    data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node

    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-right` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);

      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

      // flip the variation if required
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : '');

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };

    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;

      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };

      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unitless, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the height.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * An scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper this makes sure the popper has always a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier, can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near eachothers
     * without leaving any gap between the two. Expecially useful when the arrow is
     * enabled and you want to assure it to point to its reference element.
     * It cares only about the first axis, you can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjuction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations).
       */
      behavior: 'flip',
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position,
       * the popper will never be placed outside of the defined boundaries
       * (except if keepTogether is enabled)
       */
      boundariesElement: 'viewport'
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define you own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: undefined
    }
  };

  /**
   * The `dataObject` is an object containing all the informations used by Popper.js
   * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overriden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass as 3rd argument an object with the same
   * structure of this object, example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults = {
    /**
     * Popper's placement
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Whether events (resize, scroll) are initially enabled
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated, this callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js
     * @prop {modifiers}
     */
    modifiers: modifiers
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */

  // Utils
  // Methods
  var Popper = function () {
    /**
     * Create a new Popper.js instance
     * @class Popper
     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper.
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference.jquery ? reference[0] : reference;
      this.popper = popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });

      // fire the first update to position the popper in the right place
      this.update();

      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedule an update, it will run on the next UI update available
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */

  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  return Popper;
});
//# sourceMappingURL=popper.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)))

/***/ }),

/***/ 67:
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Bootstrap v4.0.0-beta (https://getbootstrap.com)
 * Copyright 2011-2017 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
}

(function ($) {
  var version = $.fn.jquery.split(' ')[0].split('.');
  if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] >= 4) {
    throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
  }
})(jQuery);

(function () {
  var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Util = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Private TransitionEnd Helpers
     * ------------------------------------------------------------------------
     */

    var transition = false;

    var MAX_UID = 1000000;

    var TransitionEndEvent = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'

      // shoutout AngusCroll (https://goo.gl/pxwQGp)
    };function toType(obj) {
      return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
    }

    function isElement(obj) {
      return (obj[0] || obj).nodeType;
    }

    function getSpecialTransitionEndEvent() {
      return {
        bindType: transition.end,
        delegateType: transition.end,
        handle: function handle(event) {
          if ($(event.target).is(this)) {
            return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
          }
          return undefined;
        }
      };
    }

    function transitionEndTest() {
      if (window.QUnit) {
        return false;
      }

      var el = document.createElement('bootstrap');

      for (var name in TransitionEndEvent) {
        if (el.style[name] !== undefined) {
          return {
            end: TransitionEndEvent[name]
          };
        }
      }

      return false;
    }

    function transitionEndEmulator(duration) {
      var _this = this;

      var called = false;

      $(this).one(Util.TRANSITION_END, function () {
        called = true;
      });

      setTimeout(function () {
        if (!called) {
          Util.triggerTransitionEnd(_this);
        }
      }, duration);

      return this;
    }

    function setTransitionEndSupport() {
      transition = transitionEndTest();

      $.fn.emulateTransitionEnd = transitionEndEmulator;

      if (Util.supportsTransitionEnd()) {
        $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
      }
    }

    /**
     * --------------------------------------------------------------------------
     * Public Util Api
     * --------------------------------------------------------------------------
     */

    var Util = {

      TRANSITION_END: 'bsTransitionEnd',

      getUID: function getUID(prefix) {
        do {
          // eslint-disable-next-line no-bitwise
          prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
        } while (document.getElementById(prefix));
        return prefix;
      },
      getSelectorFromElement: function getSelectorFromElement(element) {
        var selector = element.getAttribute('data-target');
        if (!selector || selector === '#') {
          selector = element.getAttribute('href') || '';
        }

        try {
          var $selector = $(selector);
          return $selector.length > 0 ? selector : null;
        } catch (error) {
          return null;
        }
      },
      reflow: function reflow(element) {
        return element.offsetHeight;
      },
      triggerTransitionEnd: function triggerTransitionEnd(element) {
        $(element).trigger(transition.end);
      },
      supportsTransitionEnd: function supportsTransitionEnd() {
        return Boolean(transition);
      },
      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
        for (var property in configTypes) {
          if (configTypes.hasOwnProperty(property)) {
            var expectedTypes = configTypes[property];
            var value = config[property];
            var valueType = value && isElement(value) ? 'element' : toType(value);

            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new Error(componentName.toUpperCase() + ': ' + ('Option "' + property + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
            }
          }
        }
      }
    };

    setTransitionEndSupport();

    return Util;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Alert = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'alert';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.alert';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 150;

    var Selector = {
      DISMISS: '[data-dismiss="alert"]'
    };

    var Event = {
      CLOSE: 'close' + EVENT_KEY,
      CLOSED: 'closed' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      ALERT: 'alert',
      FADE: 'fade',
      SHOW: 'show'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Alert = function () {
      function Alert(element) {
        _classCallCheck(this, Alert);

        this._element = element;
      }

      // getters

      // public

      Alert.prototype.close = function close(element) {
        element = element || this._element;

        var rootElement = this._getRootElement(element);
        var customEvent = this._triggerCloseEvent(rootElement);

        if (customEvent.isDefaultPrevented()) {
          return;
        }

        this._removeElement(rootElement);
      };

      Alert.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        this._element = null;
      };

      // private

      Alert.prototype._getRootElement = function _getRootElement(element) {
        var selector = Util.getSelectorFromElement(element);
        var parent = false;

        if (selector) {
          parent = $(selector)[0];
        }

        if (!parent) {
          parent = $(element).closest('.' + ClassName.ALERT)[0];
        }

        return parent;
      };

      Alert.prototype._triggerCloseEvent = function _triggerCloseEvent(element) {
        var closeEvent = $.Event(Event.CLOSE);

        $(element).trigger(closeEvent);
        return closeEvent;
      };

      Alert.prototype._removeElement = function _removeElement(element) {
        var _this2 = this;

        $(element).removeClass(ClassName.SHOW);

        if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {
          this._destroyElement(element);
          return;
        }

        $(element).one(Util.TRANSITION_END, function (event) {
          return _this2._destroyElement(element, event);
        }).emulateTransitionEnd(TRANSITION_DURATION);
      };

      Alert.prototype._destroyElement = function _destroyElement(element) {
        $(element).detach().trigger(Event.CLOSED).remove();
      };

      // static

      Alert._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $element = $(this);
          var data = $element.data(DATA_KEY);

          if (!data) {
            data = new Alert(this);
            $element.data(DATA_KEY, data);
          }

          if (config === 'close') {
            data[config](this);
          }
        });
      };

      Alert._handleDismiss = function _handleDismiss(alertInstance) {
        return function (event) {
          if (event) {
            event.preventDefault();
          }

          alertInstance.close(this);
        };
      };

      _createClass(Alert, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }]);

      return Alert;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Alert._jQueryInterface;
    $.fn[NAME].Constructor = Alert;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Alert._jQueryInterface;
    };

    return Alert;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Button = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'button';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.button';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];

    var ClassName = {
      ACTIVE: 'active',
      BUTTON: 'btn',
      FOCUS: 'focus'
    };

    var Selector = {
      DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
      DATA_TOGGLE: '[data-toggle="buttons"]',
      INPUT: 'input',
      ACTIVE: '.active',
      BUTTON: '.btn'
    };

    var Event = {
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,
      FOCUS_BLUR_DATA_API: 'focus' + EVENT_KEY + DATA_API_KEY + ' ' + ('blur' + EVENT_KEY + DATA_API_KEY)

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Button = function () {
      function Button(element) {
        _classCallCheck(this, Button);

        this._element = element;
      }

      // getters

      // public

      Button.prototype.toggle = function toggle() {
        var triggerChangeEvent = true;
        var addAriaPressed = true;
        var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];

        if (rootElement) {
          var input = $(this._element).find(Selector.INPUT)[0];

          if (input) {
            if (input.type === 'radio') {
              if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {
                triggerChangeEvent = false;
              } else {
                var activeElement = $(rootElement).find(Selector.ACTIVE)[0];

                if (activeElement) {
                  $(activeElement).removeClass(ClassName.ACTIVE);
                }
              }
            }

            if (triggerChangeEvent) {
              if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
                return;
              }
              input.checked = !$(this._element).hasClass(ClassName.ACTIVE);
              $(input).trigger('change');
            }

            input.focus();
            addAriaPressed = false;
          }
        }

        if (addAriaPressed) {
          this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));
        }

        if (triggerChangeEvent) {
          $(this._element).toggleClass(ClassName.ACTIVE);
        }
      };

      Button.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        this._element = null;
      };

      // static

      Button._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);

          if (!data) {
            data = new Button(this);
            $(this).data(DATA_KEY, data);
          }

          if (config === 'toggle') {
            data[config]();
          }
        });
      };

      _createClass(Button, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }]);

      return Button;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
      event.preventDefault();

      var button = event.target;

      if (!$(button).hasClass(ClassName.BUTTON)) {
        button = $(button).closest(Selector.BUTTON);
      }

      Button._jQueryInterface.call($(button), 'toggle');
    }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
      var button = $(event.target).closest(Selector.BUTTON)[0];
      $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Button._jQueryInterface;
    $.fn[NAME].Constructor = Button;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Button._jQueryInterface;
    };

    return Button;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Carousel = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'carousel';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.carousel';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 600;
    var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key
    var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key
    var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

    var Default = {
      interval: 5000,
      keyboard: true,
      slide: false,
      pause: 'hover',
      wrap: true
    };

    var DefaultType = {
      interval: '(number|boolean)',
      keyboard: 'boolean',
      slide: '(boolean|string)',
      pause: '(string|boolean)',
      wrap: 'boolean'
    };

    var Direction = {
      NEXT: 'next',
      PREV: 'prev',
      LEFT: 'left',
      RIGHT: 'right'
    };

    var Event = {
      SLIDE: 'slide' + EVENT_KEY,
      SLID: 'slid' + EVENT_KEY,
      KEYDOWN: 'keydown' + EVENT_KEY,
      MOUSEENTER: 'mouseenter' + EVENT_KEY,
      MOUSELEAVE: 'mouseleave' + EVENT_KEY,
      TOUCHEND: 'touchend' + EVENT_KEY,
      LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      CAROUSEL: 'carousel',
      ACTIVE: 'active',
      SLIDE: 'slide',
      RIGHT: 'carousel-item-right',
      LEFT: 'carousel-item-left',
      NEXT: 'carousel-item-next',
      PREV: 'carousel-item-prev',
      ITEM: 'carousel-item'
    };

    var Selector = {
      ACTIVE: '.active',
      ACTIVE_ITEM: '.active.carousel-item',
      ITEM: '.carousel-item',
      NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
      INDICATORS: '.carousel-indicators',
      DATA_SLIDE: '[data-slide], [data-slide-to]',
      DATA_RIDE: '[data-ride="carousel"]'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Carousel = function () {
      function Carousel(element, config) {
        _classCallCheck(this, Carousel);

        this._items = null;
        this._interval = null;
        this._activeElement = null;

        this._isPaused = false;
        this._isSliding = false;

        this.touchTimeout = null;

        this._config = this._getConfig(config);
        this._element = $(element)[0];
        this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];

        this._addEventListeners();
      }

      // getters

      // public

      Carousel.prototype.next = function next() {
        if (!this._isSliding) {
          this._slide(Direction.NEXT);
        }
      };

      Carousel.prototype.nextWhenVisible = function nextWhenVisible() {
        // Don't call next when the page isn't visible
        if (!document.hidden) {
          this.next();
        }
      };

      Carousel.prototype.prev = function prev() {
        if (!this._isSliding) {
          this._slide(Direction.PREV);
        }
      };

      Carousel.prototype.pause = function pause(event) {
        if (!event) {
          this._isPaused = true;
        }

        if ($(this._element).find(Selector.NEXT_PREV)[0] && Util.supportsTransitionEnd()) {
          Util.triggerTransitionEnd(this._element);
          this.cycle(true);
        }

        clearInterval(this._interval);
        this._interval = null;
      };

      Carousel.prototype.cycle = function cycle(event) {
        if (!event) {
          this._isPaused = false;
        }

        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }

        if (this._config.interval && !this._isPaused) {
          this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
        }
      };

      Carousel.prototype.to = function to(index) {
        var _this3 = this;

        this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];

        var activeIndex = this._getItemIndex(this._activeElement);

        if (index > this._items.length - 1 || index < 0) {
          return;
        }

        if (this._isSliding) {
          $(this._element).one(Event.SLID, function () {
            return _this3.to(index);
          });
          return;
        }

        if (activeIndex === index) {
          this.pause();
          this.cycle();
          return;
        }

        var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

        this._slide(direction, this._items[index]);
      };

      Carousel.prototype.dispose = function dispose() {
        $(this._element).off(EVENT_KEY);
        $.removeData(this._element, DATA_KEY);

        this._items = null;
        this._config = null;
        this._element = null;
        this._interval = null;
        this._isPaused = null;
        this._isSliding = null;
        this._activeElement = null;
        this._indicatorsElement = null;
      };

      // private

      Carousel.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      Carousel.prototype._addEventListeners = function _addEventListeners() {
        var _this4 = this;

        if (this._config.keyboard) {
          $(this._element).on(Event.KEYDOWN, function (event) {
            return _this4._keydown(event);
          });
        }

        if (this._config.pause === 'hover') {
          $(this._element).on(Event.MOUSEENTER, function (event) {
            return _this4.pause(event);
          }).on(Event.MOUSELEAVE, function (event) {
            return _this4.cycle(event);
          });
          if ('ontouchstart' in document.documentElement) {
            // if it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
            $(this._element).on(Event.TOUCHEND, function () {
              _this4.pause();
              if (_this4.touchTimeout) {
                clearTimeout(_this4.touchTimeout);
              }
              _this4.touchTimeout = setTimeout(function (event) {
                return _this4.cycle(event);
              }, TOUCHEVENT_COMPAT_WAIT + _this4._config.interval);
            });
          }
        }
      };

      Carousel.prototype._keydown = function _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }

        switch (event.which) {
          case ARROW_LEFT_KEYCODE:
            event.preventDefault();
            this.prev();
            break;
          case ARROW_RIGHT_KEYCODE:
            event.preventDefault();
            this.next();
            break;
          default:
            return;
        }
      };

      Carousel.prototype._getItemIndex = function _getItemIndex(element) {
        this._items = $.makeArray($(element).parent().find(Selector.ITEM));
        return this._items.indexOf(element);
      };

      Carousel.prototype._getItemByDirection = function _getItemByDirection(direction, activeElement) {
        var isNextDirection = direction === Direction.NEXT;
        var isPrevDirection = direction === Direction.PREV;
        var activeIndex = this._getItemIndex(activeElement);
        var lastItemIndex = this._items.length - 1;
        var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

        if (isGoingToWrap && !this._config.wrap) {
          return activeElement;
        }

        var delta = direction === Direction.PREV ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this._items.length;

        return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
      };

      Carousel.prototype._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
        var targetIndex = this._getItemIndex(relatedTarget);
        var fromIndex = this._getItemIndex($(this._element).find(Selector.ACTIVE_ITEM)[0]);
        var slideEvent = $.Event(Event.SLIDE, {
          relatedTarget: relatedTarget,
          direction: eventDirectionName,
          from: fromIndex,
          to: targetIndex
        });

        $(this._element).trigger(slideEvent);

        return slideEvent;
      };

      Carousel.prototype._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
        if (this._indicatorsElement) {
          $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);

          var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

          if (nextIndicator) {
            $(nextIndicator).addClass(ClassName.ACTIVE);
          }
        }
      };

      Carousel.prototype._slide = function _slide(direction, element) {
        var _this5 = this;

        var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];
        var activeElementIndex = this._getItemIndex(activeElement);
        var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);
        var nextElementIndex = this._getItemIndex(nextElement);
        var isCycling = Boolean(this._interval);

        var directionalClassName = void 0;
        var orderClassName = void 0;
        var eventDirectionName = void 0;

        if (direction === Direction.NEXT) {
          directionalClassName = ClassName.LEFT;
          orderClassName = ClassName.NEXT;
          eventDirectionName = Direction.LEFT;
        } else {
          directionalClassName = ClassName.RIGHT;
          orderClassName = ClassName.PREV;
          eventDirectionName = Direction.RIGHT;
        }

        if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {
          this._isSliding = false;
          return;
        }

        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
        if (slideEvent.isDefaultPrevented()) {
          return;
        }

        if (!activeElement || !nextElement) {
          // some weirdness is happening, so we bail
          return;
        }

        this._isSliding = true;

        if (isCycling) {
          this.pause();
        }

        this._setActiveIndicatorElement(nextElement);

        var slidEvent = $.Event(Event.SLID, {
          relatedTarget: nextElement,
          direction: eventDirectionName,
          from: activeElementIndex,
          to: nextElementIndex
        });

        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.SLIDE)) {

          $(nextElement).addClass(orderClassName);

          Util.reflow(nextElement);

          $(activeElement).addClass(directionalClassName);
          $(nextElement).addClass(directionalClassName);

          $(activeElement).one(Util.TRANSITION_END, function () {
            $(nextElement).removeClass(directionalClassName + ' ' + orderClassName).addClass(ClassName.ACTIVE);

            $(activeElement).removeClass(ClassName.ACTIVE + ' ' + orderClassName + ' ' + directionalClassName);

            _this5._isSliding = false;

            setTimeout(function () {
              return $(_this5._element).trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          $(activeElement).removeClass(ClassName.ACTIVE);
          $(nextElement).addClass(ClassName.ACTIVE);

          this._isSliding = false;
          $(this._element).trigger(slidEvent);
        }

        if (isCycling) {
          this.cycle();
        }
      };

      // static

      Carousel._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = $.extend({}, Default, $(this).data());

          if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {
            $.extend(_config, config);
          }

          var action = typeof config === 'string' ? config : _config.slide;

          if (!data) {
            data = new Carousel(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'number') {
            data.to(config);
          } else if (typeof action === 'string') {
            if (data[action] === undefined) {
              throw new Error('No method named "' + action + '"');
            }
            data[action]();
          } else if (_config.interval) {
            data.pause();
            data.cycle();
          }
        });
      };

      Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
        var selector = Util.getSelectorFromElement(this);

        if (!selector) {
          return;
        }

        var target = $(selector)[0];

        if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {
          return;
        }

        var config = $.extend({}, $(target).data(), $(this).data());
        var slideIndex = this.getAttribute('data-slide-to');

        if (slideIndex) {
          config.interval = false;
        }

        Carousel._jQueryInterface.call($(target), config);

        if (slideIndex) {
          $(target).data(DATA_KEY).to(slideIndex);
        }

        event.preventDefault();
      };

      _createClass(Carousel, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return Carousel;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);

    $(window).on(Event.LOAD_DATA_API, function () {
      $(Selector.DATA_RIDE).each(function () {
        var $carousel = $(this);
        Carousel._jQueryInterface.call($carousel, $carousel.data());
      });
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Carousel._jQueryInterface;
    $.fn[NAME].Constructor = Carousel;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Carousel._jQueryInterface;
    };

    return Carousel;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Collapse = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'collapse';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.collapse';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 600;

    var Default = {
      toggle: true,
      parent: ''
    };

    var DefaultType = {
      toggle: 'boolean',
      parent: 'string'
    };

    var Event = {
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      SHOW: 'show',
      COLLAPSE: 'collapse',
      COLLAPSING: 'collapsing',
      COLLAPSED: 'collapsed'
    };

    var Dimension = {
      WIDTH: 'width',
      HEIGHT: 'height'
    };

    var Selector = {
      ACTIVES: '.show, .collapsing',
      DATA_TOGGLE: '[data-toggle="collapse"]'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Collapse = function () {
      function Collapse(element, config) {
        _classCallCheck(this, Collapse);

        this._isTransitioning = false;
        this._element = element;
        this._config = this._getConfig(config);
        this._triggerArray = $.makeArray($('[data-toggle="collapse"][href="#' + element.id + '"],' + ('[data-toggle="collapse"][data-target="#' + element.id + '"]')));
        var tabToggles = $(Selector.DATA_TOGGLE);
        for (var i = 0; i < tabToggles.length; i++) {
          var elem = tabToggles[i];
          var selector = Util.getSelectorFromElement(elem);
          if (selector !== null && $(selector).filter(element).length > 0) {
            this._triggerArray.push(elem);
          }
        }

        this._parent = this._config.parent ? this._getParent() : null;

        if (!this._config.parent) {
          this._addAriaAndCollapsedClass(this._element, this._triggerArray);
        }

        if (this._config.toggle) {
          this.toggle();
        }
      }

      // getters

      // public

      Collapse.prototype.toggle = function toggle() {
        if ($(this._element).hasClass(ClassName.SHOW)) {
          this.hide();
        } else {
          this.show();
        }
      };

      Collapse.prototype.show = function show() {
        var _this6 = this;

        if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {
          return;
        }

        var actives = void 0;
        var activesData = void 0;

        if (this._parent) {
          actives = $.makeArray($(this._parent).children().children(Selector.ACTIVES));
          if (!actives.length) {
            actives = null;
          }
        }

        if (actives) {
          activesData = $(actives).data(DATA_KEY);
          if (activesData && activesData._isTransitioning) {
            return;
          }
        }

        var startEvent = $.Event(Event.SHOW);
        $(this._element).trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
          return;
        }

        if (actives) {
          Collapse._jQueryInterface.call($(actives), 'hide');
          if (!activesData) {
            $(actives).data(DATA_KEY, null);
          }
        }

        var dimension = this._getDimension();

        $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);

        this._element.style[dimension] = 0;

        if (this._triggerArray.length) {
          $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
        }

        this.setTransitioning(true);

        var complete = function complete() {
          $(_this6._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);

          _this6._element.style[dimension] = '';

          _this6.setTransitioning(false);

          $(_this6._element).trigger(Event.SHOWN);
        };

        if (!Util.supportsTransitionEnd()) {
          complete();
          return;
        }

        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        var scrollSize = 'scroll' + capitalizedDimension;

        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);

        this._element.style[dimension] = this._element[scrollSize] + 'px';
      };

      Collapse.prototype.hide = function hide() {
        var _this7 = this;

        if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {
          return;
        }

        var startEvent = $.Event(Event.HIDE);
        $(this._element).trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
          return;
        }

        var dimension = this._getDimension();

        this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + 'px';

        Util.reflow(this._element);

        $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

        if (this._triggerArray.length) {
          for (var i = 0; i < this._triggerArray.length; i++) {
            var trigger = this._triggerArray[i];
            var selector = Util.getSelectorFromElement(trigger);
            if (selector !== null) {
              var $elem = $(selector);
              if (!$elem.hasClass(ClassName.SHOW)) {
                $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
              }
            }
          }
        }

        this.setTransitioning(true);

        var complete = function complete() {
          _this7.setTransitioning(false);
          $(_this7._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
        };

        this._element.style[dimension] = '';

        if (!Util.supportsTransitionEnd()) {
          complete();
          return;
        }

        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      };

      Collapse.prototype.setTransitioning = function setTransitioning(isTransitioning) {
        this._isTransitioning = isTransitioning;
      };

      Collapse.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);

        this._config = null;
        this._parent = null;
        this._element = null;
        this._triggerArray = null;
        this._isTransitioning = null;
      };

      // private

      Collapse.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);
        config.toggle = Boolean(config.toggle); // coerce string values
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      Collapse.prototype._getDimension = function _getDimension() {
        var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
        return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
      };

      Collapse.prototype._getParent = function _getParent() {
        var _this8 = this;

        var parent = $(this._config.parent)[0];
        var selector = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';

        $(parent).find(selector).each(function (i, element) {
          _this8._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
        });

        return parent;
      };

      Collapse.prototype._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
        if (element) {
          var isOpen = $(element).hasClass(ClassName.SHOW);

          if (triggerArray.length) {
            $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
          }
        }
      };

      // static

      Collapse._getTargetFromElement = function _getTargetFromElement(element) {
        var selector = Util.getSelectorFromElement(element);
        return selector ? $(selector)[0] : null;
      };

      Collapse._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data(DATA_KEY);
          var _config = $.extend({}, Default, $this.data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);

          if (!data && _config.toggle && /show|hide/.test(config)) {
            _config.toggle = false;
          }

          if (!data) {
            data = new Collapse(this, _config);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Collapse, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return Collapse;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      if (!/input|textarea/i.test(event.target.tagName)) {
        event.preventDefault();
      }

      var $trigger = $(this);
      var selector = Util.getSelectorFromElement(this);
      $(selector).each(function () {
        var $target = $(this);
        var data = $target.data(DATA_KEY);
        var config = data ? 'toggle' : $trigger.data();
        Collapse._jQueryInterface.call($target, config);
      });
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Collapse._jQueryInterface;
    $.fn[NAME].Constructor = Collapse;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Collapse._jQueryInterface;
    };

    return Collapse;
  }(jQuery);

  /* global Popper */

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Dropdown = function ($) {

    /**
     * Check for Popper dependency
     * Popper - https://popper.js.org
     */
    if (typeof Popper === 'undefined') {
      throw new Error('Bootstrap dropdown require Popper.js (https://popper.js.org)');
    }

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'dropdown';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.dropdown';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
    var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key
    var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key
    var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key
    var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key
    var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)
    var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + '|' + ARROW_DOWN_KEYCODE + '|' + ESCAPE_KEYCODE);

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      CLICK: 'click' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,
      KEYDOWN_DATA_API: 'keydown' + EVENT_KEY + DATA_API_KEY,
      KEYUP_DATA_API: 'keyup' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      DISABLED: 'disabled',
      SHOW: 'show',
      DROPUP: 'dropup',
      MENURIGHT: 'dropdown-menu-right',
      MENULEFT: 'dropdown-menu-left'
    };

    var Selector = {
      DATA_TOGGLE: '[data-toggle="dropdown"]',
      FORM_CHILD: '.dropdown form',
      MENU: '.dropdown-menu',
      NAVBAR_NAV: '.navbar-nav',
      VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled)'
    };

    var AttachmentMap = {
      TOP: 'top-start',
      TOPEND: 'top-end',
      BOTTOM: 'bottom-start',
      BOTTOMEND: 'bottom-end'
    };

    var Default = {
      placement: AttachmentMap.BOTTOM,
      offset: 0,
      flip: true
    };

    var DefaultType = {
      placement: 'string',
      offset: '(number|string)',
      flip: 'boolean'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Dropdown = function () {
      function Dropdown(element, config) {
        _classCallCheck(this, Dropdown);

        this._element = element;
        this._popper = null;
        this._config = this._getConfig(config);
        this._menu = this._getMenuElement();
        this._inNavbar = this._detectNavbar();

        this._addEventListeners();
      }

      // getters

      // public

      Dropdown.prototype.toggle = function toggle() {
        if (this._element.disabled || $(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this._element);
        var isActive = $(this._menu).hasClass(ClassName.SHOW);

        Dropdown._clearMenus();

        if (isActive) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = $.Event(Event.SHOW, relatedTarget);

        $(parent).trigger(showEvent);

        if (showEvent.isDefaultPrevented()) {
          return;
        }

        var element = this._element;
        // for dropup with alignment we use the parent as popper container
        if ($(parent).hasClass(ClassName.DROPUP)) {
          if ($(this._menu).hasClass(ClassName.MENULEFT) || $(this._menu).hasClass(ClassName.MENURIGHT)) {
            element = parent;
          }
        }
        this._popper = new Popper(element, this._menu, this._getPopperConfig());

        // if this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ('ontouchstart' in document.documentElement && !$(parent).closest(Selector.NAVBAR_NAV).length) {
          $('body').children().on('mouseover', null, $.noop);
        }

        this._element.focus();
        this._element.setAttribute('aria-expanded', true);

        $(this._menu).toggleClass(ClassName.SHOW);
        $(parent).toggleClass(ClassName.SHOW).trigger($.Event(Event.SHOWN, relatedTarget));
      };

      Dropdown.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        $(this._element).off(EVENT_KEY);
        this._element = null;
        this._menu = null;
        if (this._popper !== null) {
          this._popper.destroy();
        }
        this._popper = null;
      };

      Dropdown.prototype.update = function update() {
        this._inNavbar = this._detectNavbar();
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      };

      // private

      Dropdown.prototype._addEventListeners = function _addEventListeners() {
        var _this9 = this;

        $(this._element).on(Event.CLICK, function (event) {
          event.preventDefault();
          event.stopPropagation();
          _this9.toggle();
        });
      };

      Dropdown.prototype._getConfig = function _getConfig(config) {
        var elementData = $(this._element).data();
        if (elementData.placement !== undefined) {
          elementData.placement = AttachmentMap[elementData.placement.toUpperCase()];
        }

        config = $.extend({}, this.constructor.Default, $(this._element).data(), config);

        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);

        return config;
      };

      Dropdown.prototype._getMenuElement = function _getMenuElement() {
        if (!this._menu) {
          var parent = Dropdown._getParentFromElement(this._element);
          this._menu = $(parent).find(Selector.MENU)[0];
        }
        return this._menu;
      };

      Dropdown.prototype._getPlacement = function _getPlacement() {
        var $parentDropdown = $(this._element).parent();
        var placement = this._config.placement;

        // Handle dropup
        if ($parentDropdown.hasClass(ClassName.DROPUP) || this._config.placement === AttachmentMap.TOP) {
          placement = AttachmentMap.TOP;
          if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
            placement = AttachmentMap.TOPEND;
          }
        } else if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
          placement = AttachmentMap.BOTTOMEND;
        }
        return placement;
      };

      Dropdown.prototype._detectNavbar = function _detectNavbar() {
        return $(this._element).closest('.navbar').length > 0;
      };

      Dropdown.prototype._getPopperConfig = function _getPopperConfig() {
        var popperConfig = {
          placement: this._getPlacement(),
          modifiers: {
            offset: {
              offset: this._config.offset
            },
            flip: {
              enabled: this._config.flip
            }

            // Disable Popper.js for Dropdown in Navbar
          } };if (this._inNavbar) {
          popperConfig.modifiers.applyStyle = {
            enabled: !this._inNavbar
          };
        }
        return popperConfig;
      };

      // static

      Dropdown._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;

          if (!data) {
            data = new Dropdown(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      Dropdown._clearMenus = function _clearMenus(event) {
        if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
          return;
        }

        var toggles = $.makeArray($(Selector.DATA_TOGGLE));
        for (var i = 0; i < toggles.length; i++) {
          var parent = Dropdown._getParentFromElement(toggles[i]);
          var context = $(toggles[i]).data(DATA_KEY);
          var relatedTarget = {
            relatedTarget: toggles[i]
          };

          if (!context) {
            continue;
          }

          var dropdownMenu = context._menu;
          if (!$(parent).hasClass(ClassName.SHOW)) {
            continue;
          }

          if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
            continue;
          }

          var hideEvent = $.Event(Event.HIDE, relatedTarget);
          $(parent).trigger(hideEvent);
          if (hideEvent.isDefaultPrevented()) {
            continue;
          }

          // if this is a touch-enabled device we remove the extra
          // empty mouseover listeners we added for iOS support
          if ('ontouchstart' in document.documentElement) {
            $('body').children().off('mouseover', null, $.noop);
          }

          toggles[i].setAttribute('aria-expanded', 'false');

          $(dropdownMenu).removeClass(ClassName.SHOW);
          $(parent).removeClass(ClassName.SHOW).trigger($.Event(Event.HIDDEN, relatedTarget));
        }
      };

      Dropdown._getParentFromElement = function _getParentFromElement(element) {
        var parent = void 0;
        var selector = Util.getSelectorFromElement(element);

        if (selector) {
          parent = $(selector)[0];
        }

        return parent || element.parentNode;
      };

      Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
        if (!REGEXP_KEYDOWN.test(event.which) || /button/i.test(event.target.tagName) && event.which === SPACE_KEYCODE || /input|textarea/i.test(event.target.tagName)) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this);
        var isActive = $(parent).hasClass(ClassName.SHOW);

        if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {

          if (event.which === ESCAPE_KEYCODE) {
            var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];
            $(toggle).trigger('focus');
          }

          $(this).trigger('click');
          return;
        }

        var items = $(parent).find(Selector.VISIBLE_ITEMS).get();

        if (!items.length) {
          return;
        }

        var index = items.indexOf(event.target);

        if (event.which === ARROW_UP_KEYCODE && index > 0) {
          // up
          index--;
        }

        if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
          // down
          index++;
        }

        if (index < 0) {
          index = 0;
        }

        items[index].focus();
      };

      _createClass(Dropdown, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }, {
        key: 'DefaultType',
        get: function get() {
          return DefaultType;
        }
      }]);

      return Dropdown;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + ' ' + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();
      event.stopPropagation();
      Dropdown._jQueryInterface.call($(this), 'toggle');
    }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
      e.stopPropagation();
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Dropdown._jQueryInterface;
    $.fn[NAME].Constructor = Dropdown;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Dropdown._jQueryInterface;
    };

    return Dropdown;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Modal = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'modal';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.modal';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 300;
    var BACKDROP_TRANSITION_DURATION = 150;
    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

    var Default = {
      backdrop: true,
      keyboard: true,
      focus: true,
      show: true
    };

    var DefaultType = {
      backdrop: '(boolean|string)',
      keyboard: 'boolean',
      focus: 'boolean',
      show: 'boolean'
    };

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      FOCUSIN: 'focusin' + EVENT_KEY,
      RESIZE: 'resize' + EVENT_KEY,
      CLICK_DISMISS: 'click.dismiss' + EVENT_KEY,
      KEYDOWN_DISMISS: 'keydown.dismiss' + EVENT_KEY,
      MOUSEUP_DISMISS: 'mouseup.dismiss' + EVENT_KEY,
      MOUSEDOWN_DISMISS: 'mousedown.dismiss' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
      BACKDROP: 'modal-backdrop',
      OPEN: 'modal-open',
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      DIALOG: '.modal-dialog',
      DATA_TOGGLE: '[data-toggle="modal"]',
      DATA_DISMISS: '[data-dismiss="modal"]',
      FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
      NAVBAR_TOGGLER: '.navbar-toggler'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Modal = function () {
      function Modal(element, config) {
        _classCallCheck(this, Modal);

        this._config = this._getConfig(config);
        this._element = element;
        this._dialog = $(element).find(Selector.DIALOG)[0];
        this._backdrop = null;
        this._isShown = false;
        this._isBodyOverflowing = false;
        this._ignoreBackdropClick = false;
        this._originalBodyPadding = 0;
        this._scrollbarWidth = 0;
      }

      // getters

      // public

      Modal.prototype.toggle = function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      };

      Modal.prototype.show = function show(relatedTarget) {
        var _this10 = this;

        if (this._isTransitioning) {
          return;
        }

        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
          this._isTransitioning = true;
        }

        var showEvent = $.Event(Event.SHOW, {
          relatedTarget: relatedTarget
        });

        $(this._element).trigger(showEvent);

        if (this._isShown || showEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = true;

        this._checkScrollbar();
        this._setScrollbar();

        $(document.body).addClass(ClassName.OPEN);

        this._setEscapeEvent();
        this._setResizeEvent();

        $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
          return _this10.hide(event);
        });

        $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
          $(_this10._element).one(Event.MOUSEUP_DISMISS, function (event) {
            if ($(event.target).is(_this10._element)) {
              _this10._ignoreBackdropClick = true;
            }
          });
        });

        this._showBackdrop(function () {
          return _this10._showElement(relatedTarget);
        });
      };

      Modal.prototype.hide = function hide(event) {
        var _this11 = this;

        if (event) {
          event.preventDefault();
        }

        if (this._isTransitioning || !this._isShown) {
          return;
        }

        var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

        if (transition) {
          this._isTransitioning = true;
        }

        var hideEvent = $.Event(Event.HIDE);

        $(this._element).trigger(hideEvent);

        if (!this._isShown || hideEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = false;

        this._setEscapeEvent();
        this._setResizeEvent();

        $(document).off(Event.FOCUSIN);

        $(this._element).removeClass(ClassName.SHOW);

        $(this._element).off(Event.CLICK_DISMISS);
        $(this._dialog).off(Event.MOUSEDOWN_DISMISS);

        if (transition) {

          $(this._element).one(Util.TRANSITION_END, function (event) {
            return _this11._hideModal(event);
          }).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          this._hideModal();
        }
      };

      Modal.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);

        $(window, document, this._element, this._backdrop).off(EVENT_KEY);

        this._config = null;
        this._element = null;
        this._dialog = null;
        this._backdrop = null;
        this._isShown = null;
        this._isBodyOverflowing = null;
        this._ignoreBackdropClick = null;
        this._scrollbarWidth = null;
      };

      Modal.prototype.handleUpdate = function handleUpdate() {
        this._adjustDialog();
      };

      // private

      Modal.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      Modal.prototype._showElement = function _showElement(relatedTarget) {
        var _this12 = this;

        var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
          // don't move modals dom position
          document.body.appendChild(this._element);
        }

        this._element.style.display = 'block';
        this._element.removeAttribute('aria-hidden');
        this._element.scrollTop = 0;

        if (transition) {
          Util.reflow(this._element);
        }

        $(this._element).addClass(ClassName.SHOW);

        if (this._config.focus) {
          this._enforceFocus();
        }

        var shownEvent = $.Event(Event.SHOWN, {
          relatedTarget: relatedTarget
        });

        var transitionComplete = function transitionComplete() {
          if (_this12._config.focus) {
            _this12._element.focus();
          }
          _this12._isTransitioning = false;
          $(_this12._element).trigger(shownEvent);
        };

        if (transition) {
          $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          transitionComplete();
        }
      };

      Modal.prototype._enforceFocus = function _enforceFocus() {
        var _this13 = this;

        $(document).off(Event.FOCUSIN) // guard against infinite focus loop
        .on(Event.FOCUSIN, function (event) {
          if (document !== event.target && _this13._element !== event.target && !$(_this13._element).has(event.target).length) {
            _this13._element.focus();
          }
        });
      };

      Modal.prototype._setEscapeEvent = function _setEscapeEvent() {
        var _this14 = this;

        if (this._isShown && this._config.keyboard) {
          $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
            if (event.which === ESCAPE_KEYCODE) {
              event.preventDefault();
              _this14.hide();
            }
          });
        } else if (!this._isShown) {
          $(this._element).off(Event.KEYDOWN_DISMISS);
        }
      };

      Modal.prototype._setResizeEvent = function _setResizeEvent() {
        var _this15 = this;

        if (this._isShown) {
          $(window).on(Event.RESIZE, function (event) {
            return _this15.handleUpdate(event);
          });
        } else {
          $(window).off(Event.RESIZE);
        }
      };

      Modal.prototype._hideModal = function _hideModal() {
        var _this16 = this;

        this._element.style.display = 'none';
        this._element.setAttribute('aria-hidden', true);
        this._isTransitioning = false;
        this._showBackdrop(function () {
          $(document.body).removeClass(ClassName.OPEN);
          _this16._resetAdjustments();
          _this16._resetScrollbar();
          $(_this16._element).trigger(Event.HIDDEN);
        });
      };

      Modal.prototype._removeBackdrop = function _removeBackdrop() {
        if (this._backdrop) {
          $(this._backdrop).remove();
          this._backdrop = null;
        }
      };

      Modal.prototype._showBackdrop = function _showBackdrop(callback) {
        var _this17 = this;

        var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';

        if (this._isShown && this._config.backdrop) {
          var doAnimate = Util.supportsTransitionEnd() && animate;

          this._backdrop = document.createElement('div');
          this._backdrop.className = ClassName.BACKDROP;

          if (animate) {
            $(this._backdrop).addClass(animate);
          }

          $(this._backdrop).appendTo(document.body);

          $(this._element).on(Event.CLICK_DISMISS, function (event) {
            if (_this17._ignoreBackdropClick) {
              _this17._ignoreBackdropClick = false;
              return;
            }
            if (event.target !== event.currentTarget) {
              return;
            }
            if (_this17._config.backdrop === 'static') {
              _this17._element.focus();
            } else {
              _this17.hide();
            }
          });

          if (doAnimate) {
            Util.reflow(this._backdrop);
          }

          $(this._backdrop).addClass(ClassName.SHOW);

          if (!callback) {
            return;
          }

          if (!doAnimate) {
            callback();
            return;
          }

          $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
        } else if (!this._isShown && this._backdrop) {
          $(this._backdrop).removeClass(ClassName.SHOW);

          var callbackRemove = function callbackRemove() {
            _this17._removeBackdrop();
            if (callback) {
              callback();
            }
          };

          if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
            $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
          } else {
            callbackRemove();
          }
        } else if (callback) {
          callback();
        }
      };

      // ----------------------------------------------------------------------
      // the following methods are used to handle overflowing modals
      // todo (fat): these should probably be refactored out of modal.js
      // ----------------------------------------------------------------------

      Modal.prototype._adjustDialog = function _adjustDialog() {
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

        if (!this._isBodyOverflowing && isModalOverflowing) {
          this._element.style.paddingLeft = this._scrollbarWidth + 'px';
        }

        if (this._isBodyOverflowing && !isModalOverflowing) {
          this._element.style.paddingRight = this._scrollbarWidth + 'px';
        }
      };

      Modal.prototype._resetAdjustments = function _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
      };

      Modal.prototype._checkScrollbar = function _checkScrollbar() {
        this._isBodyOverflowing = document.body.clientWidth < window.innerWidth;
        this._scrollbarWidth = this._getScrollbarWidth();
      };

      Modal.prototype._setScrollbar = function _setScrollbar() {
        var _this18 = this;

        if (this._isBodyOverflowing) {
          // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
          //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set

          // Adjust fixed content padding
          $(Selector.FIXED_CONTENT).each(function (index, element) {
            var actualPadding = $(element)[0].style.paddingRight;
            var calculatedPadding = $(element).css('padding-right');
            $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this18._scrollbarWidth + 'px');
          });

          // Adjust navbar-toggler margin
          $(Selector.NAVBAR_TOGGLER).each(function (index, element) {
            var actualMargin = $(element)[0].style.marginRight;
            var calculatedMargin = $(element).css('margin-right');
            $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this18._scrollbarWidth + 'px');
          });

          // Adjust body padding
          var actualPadding = document.body.style.paddingRight;
          var calculatedPadding = $('body').css('padding-right');
          $('body').data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + 'px');
        }
      };

      Modal.prototype._resetScrollbar = function _resetScrollbar() {
        // Restore fixed content padding
        $(Selector.FIXED_CONTENT).each(function (index, element) {
          var padding = $(element).data('padding-right');
          if (typeof padding !== 'undefined') {
            $(element).css('padding-right', padding).removeData('padding-right');
          }
        });

        // Restore navbar-toggler margin
        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {
          var margin = $(element).data('margin-right');
          if (typeof margin !== 'undefined') {
            $(element).css('margin-right', margin).removeData('margin-right');
          }
        });

        // Restore body padding
        var padding = $('body').data('padding-right');
        if (typeof padding !== 'undefined') {
          $('body').css('padding-right', padding).removeData('padding-right');
        }
      };

      Modal.prototype._getScrollbarWidth = function _getScrollbarWidth() {
        // thx d.walsh
        var scrollDiv = document.createElement('div');
        scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      };

      // static

      Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = $.extend({}, Modal.Default, $(this).data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);

          if (!data) {
            data = new Modal(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config](relatedTarget);
          } else if (_config.show) {
            data.show(relatedTarget);
          }
        });
      };

      _createClass(Modal, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return Modal;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      var _this19 = this;

      var target = void 0;
      var selector = Util.getSelectorFromElement(this);

      if (selector) {
        target = $(selector)[0];
      }

      var config = $(target).data(DATA_KEY) ? 'toggle' : $.extend({}, $(target).data(), $(this).data());

      if (this.tagName === 'A' || this.tagName === 'AREA') {
        event.preventDefault();
      }

      var $target = $(target).one(Event.SHOW, function (showEvent) {
        if (showEvent.isDefaultPrevented()) {
          // only register focus restorer if modal will actually get shown
          return;
        }

        $target.one(Event.HIDDEN, function () {
          if ($(_this19).is(':visible')) {
            _this19.focus();
          }
        });
      });

      Modal._jQueryInterface.call($(target), config, this);
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Modal._jQueryInterface;
    $.fn[NAME].Constructor = Modal;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Modal._jQueryInterface;
    };

    return Modal;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var ScrollSpy = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'scrollspy';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.scrollspy';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];

    var Default = {
      offset: 10,
      method: 'auto',
      target: ''
    };

    var DefaultType = {
      offset: 'number',
      method: 'string',
      target: '(string|element)'
    };

    var Event = {
      ACTIVATE: 'activate' + EVENT_KEY,
      SCROLL: 'scroll' + EVENT_KEY,
      LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      DROPDOWN_ITEM: 'dropdown-item',
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active'
    };

    var Selector = {
      DATA_SPY: '[data-spy="scroll"]',
      ACTIVE: '.active',
      NAV_LIST_GROUP: '.nav, .list-group',
      NAV_LINKS: '.nav-link',
      LIST_ITEMS: '.list-group-item',
      DROPDOWN: '.dropdown',
      DROPDOWN_ITEMS: '.dropdown-item',
      DROPDOWN_TOGGLE: '.dropdown-toggle'
    };

    var OffsetMethod = {
      OFFSET: 'offset',
      POSITION: 'position'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var ScrollSpy = function () {
      function ScrollSpy(element, config) {
        var _this20 = this;

        _classCallCheck(this, ScrollSpy);

        this._element = element;
        this._scrollElement = element.tagName === 'BODY' ? window : element;
        this._config = this._getConfig(config);
        this._selector = this._config.target + ' ' + Selector.NAV_LINKS + ',' + (this._config.target + ' ' + Selector.LIST_ITEMS + ',') + (this._config.target + ' ' + Selector.DROPDOWN_ITEMS);
        this._offsets = [];
        this._targets = [];
        this._activeTarget = null;
        this._scrollHeight = 0;

        $(this._scrollElement).on(Event.SCROLL, function (event) {
          return _this20._process(event);
        });

        this.refresh();
        this._process();
      }

      // getters

      // public

      ScrollSpy.prototype.refresh = function refresh() {
        var _this21 = this;

        var autoMethod = this._scrollElement !== this._scrollElement.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;

        var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;

        var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;

        this._offsets = [];
        this._targets = [];

        this._scrollHeight = this._getScrollHeight();

        var targets = $.makeArray($(this._selector));

        targets.map(function (element) {
          var target = void 0;
          var targetSelector = Util.getSelectorFromElement(element);

          if (targetSelector) {
            target = $(targetSelector)[0];
          }

          if (target) {
            var targetBCR = target.getBoundingClientRect();
            if (targetBCR.width || targetBCR.height) {
              // todo (fat): remove sketch reliance on jQuery position/offset
              return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
            }
          }
          return null;
        }).filter(function (item) {
          return item;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).forEach(function (item) {
          _this21._offsets.push(item[0]);
          _this21._targets.push(item[1]);
        });
      };

      ScrollSpy.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        $(this._scrollElement).off(EVENT_KEY);

        this._element = null;
        this._scrollElement = null;
        this._config = null;
        this._selector = null;
        this._offsets = null;
        this._targets = null;
        this._activeTarget = null;
        this._scrollHeight = null;
      };

      // private

      ScrollSpy.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, Default, config);

        if (typeof config.target !== 'string') {
          var id = $(config.target).attr('id');
          if (!id) {
            id = Util.getUID(NAME);
            $(config.target).attr('id', id);
          }
          config.target = '#' + id;
        }

        Util.typeCheckConfig(NAME, config, DefaultType);

        return config;
      };

      ScrollSpy.prototype._getScrollTop = function _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
      };

      ScrollSpy.prototype._getScrollHeight = function _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      };

      ScrollSpy.prototype._getOffsetHeight = function _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
      };

      ScrollSpy.prototype._process = function _process() {
        var scrollTop = this._getScrollTop() + this._config.offset;
        var scrollHeight = this._getScrollHeight();
        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

        if (this._scrollHeight !== scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          var target = this._targets[this._targets.length - 1];

          if (this._activeTarget !== target) {
            this._activate(target);
          }
          return;
        }

        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
          this._activeTarget = null;
          this._clear();
          return;
        }

        for (var i = this._offsets.length; i--;) {
          var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (this._offsets[i + 1] === undefined || scrollTop < this._offsets[i + 1]);

          if (isActiveTarget) {
            this._activate(this._targets[i]);
          }
        }
      };

      ScrollSpy.prototype._activate = function _activate(target) {
        this._activeTarget = target;

        this._clear();

        var queries = this._selector.split(',');
        queries = queries.map(function (selector) {
          return selector + '[data-target="' + target + '"],' + (selector + '[href="' + target + '"]');
        });

        var $link = $(queries.join(','));

        if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
          $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
          $link.addClass(ClassName.ACTIVE);
        } else {
          // Set triggered link as active
          $link.addClass(ClassName.ACTIVE);
          // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ', ' + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE);
        }

        $(this._scrollElement).trigger(Event.ACTIVATE, {
          relatedTarget: target
        });
      };

      ScrollSpy.prototype._clear = function _clear() {
        $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
      };

      // static

      ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;

          if (!data) {
            data = new ScrollSpy(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(ScrollSpy, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }]);

      return ScrollSpy;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(window).on(Event.LOAD_DATA_API, function () {
      var scrollSpys = $.makeArray($(Selector.DATA_SPY));

      for (var i = scrollSpys.length; i--;) {
        var $spy = $(scrollSpys[i]);
        ScrollSpy._jQueryInterface.call($spy, $spy.data());
      }
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = ScrollSpy._jQueryInterface;
    $.fn[NAME].Constructor = ScrollSpy;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return ScrollSpy._jQueryInterface;
    };

    return ScrollSpy;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Tab = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'tab';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.tab';
    var EVENT_KEY = '.' + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 150;

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
    };

    var ClassName = {
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active',
      DISABLED: 'disabled',
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      DROPDOWN: '.dropdown',
      NAV_LIST_GROUP: '.nav, .list-group',
      ACTIVE: '.active',
      DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
      DROPDOWN_TOGGLE: '.dropdown-toggle',
      DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Tab = function () {
      function Tab(element) {
        _classCallCheck(this, Tab);

        this._element = element;
      }

      // getters

      // public

      Tab.prototype.show = function show() {
        var _this22 = this;

        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var target = void 0;
        var previous = void 0;
        var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];
        var selector = Util.getSelectorFromElement(this._element);

        if (listElement) {
          previous = $.makeArray($(listElement).find(Selector.ACTIVE));
          previous = previous[previous.length - 1];
        }

        var hideEvent = $.Event(Event.HIDE, {
          relatedTarget: this._element
        });

        var showEvent = $.Event(Event.SHOW, {
          relatedTarget: previous
        });

        if (previous) {
          $(previous).trigger(hideEvent);
        }

        $(this._element).trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
          return;
        }

        if (selector) {
          target = $(selector)[0];
        }

        this._activate(this._element, listElement);

        var complete = function complete() {
          var hiddenEvent = $.Event(Event.HIDDEN, {
            relatedTarget: _this22._element
          });

          var shownEvent = $.Event(Event.SHOWN, {
            relatedTarget: previous
          });

          $(previous).trigger(hiddenEvent);
          $(_this22._element).trigger(shownEvent);
        };

        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      };

      Tab.prototype.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        this._element = null;
      };

      // private

      Tab.prototype._activate = function _activate(element, container, callback) {
        var _this23 = this;

        var active = $(container).find(Selector.ACTIVE)[0];
        var isTransitioning = callback && Util.supportsTransitionEnd() && active && $(active).hasClass(ClassName.FADE);

        var complete = function complete() {
          return _this23._transitionComplete(element, active, isTransitioning, callback);
        };

        if (active && isTransitioning) {
          $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          complete();
        }

        if (active) {
          $(active).removeClass(ClassName.SHOW);
        }
      };

      Tab.prototype._transitionComplete = function _transitionComplete(element, active, isTransitioning, callback) {
        if (active) {
          $(active).removeClass(ClassName.ACTIVE);

          var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

          if (dropdownChild) {
            $(dropdownChild).removeClass(ClassName.ACTIVE);
          }

          active.setAttribute('aria-expanded', false);
        }

        $(element).addClass(ClassName.ACTIVE);
        element.setAttribute('aria-expanded', true);

        if (isTransitioning) {
          Util.reflow(element);
          $(element).addClass(ClassName.SHOW);
        } else {
          $(element).removeClass(ClassName.FADE);
        }

        if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {

          var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];
          if (dropdownElement) {
            $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
          }

          element.setAttribute('aria-expanded', true);
        }

        if (callback) {
          callback();
        }
      };

      // static

      Tab._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data(DATA_KEY);

          if (!data) {
            data = new Tab(this);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Tab, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }]);

      return Tab;
    }();

    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();
      Tab._jQueryInterface.call($(this), 'show');
    });

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Tab._jQueryInterface;
    $.fn[NAME].Constructor = Tab;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tab._jQueryInterface;
    };

    return Tab;
  }(jQuery);

  /* global Popper */

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Tooltip = function ($) {

    /**
     * Check for Popper dependency
     * Popper - https://popper.js.org
     */
    if (typeof Popper === 'undefined') {
      throw new Error('Bootstrap tooltips require Popper.js (https://popper.js.org)');
    }

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'tooltip';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.tooltip';
    var EVENT_KEY = '.' + DATA_KEY;
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var TRANSITION_DURATION = 150;
    var CLASS_PREFIX = 'bs-tooltip';
    var BSCLS_PREFIX_REGEX = new RegExp('(^|\\s)' + CLASS_PREFIX + '\\S+', 'g');

    var DefaultType = {
      animation: 'boolean',
      template: 'string',
      title: '(string|element|function)',
      trigger: 'string',
      delay: '(number|object)',
      html: 'boolean',
      selector: '(string|boolean)',
      placement: '(string|function)',
      offset: '(number|string)',
      container: '(string|element|boolean)',
      fallbackPlacement: '(string|array)'
    };

    var AttachmentMap = {
      AUTO: 'auto',
      TOP: 'top',
      RIGHT: 'right',
      BOTTOM: 'bottom',
      LEFT: 'left'
    };

    var Default = {
      animation: true,
      template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
      trigger: 'hover focus',
      title: '',
      delay: 0,
      html: false,
      selector: false,
      placement: 'top',
      offset: 0,
      container: false,
      fallbackPlacement: 'flip'
    };

    var HoverState = {
      SHOW: 'show',
      OUT: 'out'
    };

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      INSERTED: 'inserted' + EVENT_KEY,
      CLICK: 'click' + EVENT_KEY,
      FOCUSIN: 'focusin' + EVENT_KEY,
      FOCUSOUT: 'focusout' + EVENT_KEY,
      MOUSEENTER: 'mouseenter' + EVENT_KEY,
      MOUSELEAVE: 'mouseleave' + EVENT_KEY
    };

    var ClassName = {
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      TOOLTIP: '.tooltip',
      TOOLTIP_INNER: '.tooltip-inner',
      ARROW: '.arrow'
    };

    var Trigger = {
      HOVER: 'hover',
      FOCUS: 'focus',
      CLICK: 'click',
      MANUAL: 'manual'

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Tooltip = function () {
      function Tooltip(element, config) {
        _classCallCheck(this, Tooltip);

        // private
        this._isEnabled = true;
        this._timeout = 0;
        this._hoverState = '';
        this._activeTrigger = {};
        this._popper = null;

        // protected
        this.element = element;
        this.config = this._getConfig(config);
        this.tip = null;

        this._setListeners();
      }

      // getters

      // public

      Tooltip.prototype.enable = function enable() {
        this._isEnabled = true;
      };

      Tooltip.prototype.disable = function disable() {
        this._isEnabled = false;
      };

      Tooltip.prototype.toggleEnabled = function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      };

      Tooltip.prototype.toggle = function toggle(event) {
        if (event) {
          var dataKey = this.constructor.DATA_KEY;
          var context = $(event.currentTarget).data(dataKey);

          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $(event.currentTarget).data(dataKey, context);
          }

          context._activeTrigger.click = !context._activeTrigger.click;

          if (context._isWithActiveTrigger()) {
            context._enter(null, context);
          } else {
            context._leave(null, context);
          }
        } else {

          if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
            this._leave(null, this);
            return;
          }

          this._enter(null, this);
        }
      };

      Tooltip.prototype.dispose = function dispose() {
        clearTimeout(this._timeout);

        $.removeData(this.element, this.constructor.DATA_KEY);

        $(this.element).off(this.constructor.EVENT_KEY);
        $(this.element).closest('.modal').off('hide.bs.modal');

        if (this.tip) {
          $(this.tip).remove();
        }

        this._isEnabled = null;
        this._timeout = null;
        this._hoverState = null;
        this._activeTrigger = null;
        if (this._popper !== null) {
          this._popper.destroy();
        }
        this._popper = null;

        this.element = null;
        this.config = null;
        this.tip = null;
      };

      Tooltip.prototype.show = function show() {
        var _this24 = this;

        if ($(this.element).css('display') === 'none') {
          throw new Error('Please use show on visible elements');
        }

        var showEvent = $.Event(this.constructor.Event.SHOW);
        if (this.isWithContent() && this._isEnabled) {
          $(this.element).trigger(showEvent);

          var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);

          if (showEvent.isDefaultPrevented() || !isInTheDom) {
            return;
          }

          var tip = this.getTipElement();
          var tipId = Util.getUID(this.constructor.NAME);

          tip.setAttribute('id', tipId);
          this.element.setAttribute('aria-describedby', tipId);

          this.setContent();

          if (this.config.animation) {
            $(tip).addClass(ClassName.FADE);
          }

          var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

          var attachment = this._getAttachment(placement);
          this.addAttachmentClass(attachment);

          var container = this.config.container === false ? document.body : $(this.config.container);

          $(tip).data(this.constructor.DATA_KEY, this);

          if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
            $(tip).appendTo(container);
          }

          $(this.element).trigger(this.constructor.Event.INSERTED);

          this._popper = new Popper(this.element, tip, {
            placement: attachment,
            modifiers: {
              offset: {
                offset: this.config.offset
              },
              flip: {
                behavior: this.config.fallbackPlacement
              },
              arrow: {
                element: Selector.ARROW
              }
            },
            onCreate: function onCreate(data) {
              if (data.originalPlacement !== data.placement) {
                _this24._handlePopperPlacementChange(data);
              }
            },
            onUpdate: function onUpdate(data) {
              _this24._handlePopperPlacementChange(data);
            }
          });

          $(tip).addClass(ClassName.SHOW);

          // if this is a touch-enabled device we add extra
          // empty mouseover listeners to the body's immediate children;
          // only needed because of broken event delegation on iOS
          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
          if ('ontouchstart' in document.documentElement) {
            $('body').children().on('mouseover', null, $.noop);
          }

          var complete = function complete() {
            if (_this24.config.animation) {
              _this24._fixTransition();
            }
            var prevHoverState = _this24._hoverState;
            _this24._hoverState = null;

            $(_this24.element).trigger(_this24.constructor.Event.SHOWN);

            if (prevHoverState === HoverState.OUT) {
              _this24._leave(null, _this24);
            }
          };

          if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
            $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
          } else {
            complete();
          }
        }
      };

      Tooltip.prototype.hide = function hide(callback) {
        var _this25 = this;

        var tip = this.getTipElement();
        var hideEvent = $.Event(this.constructor.Event.HIDE);
        var complete = function complete() {
          if (_this25._hoverState !== HoverState.SHOW && tip.parentNode) {
            tip.parentNode.removeChild(tip);
          }

          _this25._cleanTipClass();
          _this25.element.removeAttribute('aria-describedby');
          $(_this25.element).trigger(_this25.constructor.Event.HIDDEN);
          if (_this25._popper !== null) {
            _this25._popper.destroy();
          }

          if (callback) {
            callback();
          }
        };

        $(this.element).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          return;
        }

        $(tip).removeClass(ClassName.SHOW);

        // if this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ('ontouchstart' in document.documentElement) {
          $('body').children().off('mouseover', null, $.noop);
        }

        this._activeTrigger[Trigger.CLICK] = false;
        this._activeTrigger[Trigger.FOCUS] = false;
        this._activeTrigger[Trigger.HOVER] = false;

        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {

          $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          complete();
        }

        this._hoverState = '';
      };

      Tooltip.prototype.update = function update() {
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      };

      // protected

      Tooltip.prototype.isWithContent = function isWithContent() {
        return Boolean(this.getTitle());
      };

      Tooltip.prototype.addAttachmentClass = function addAttachmentClass(attachment) {
        $(this.getTipElement()).addClass(CLASS_PREFIX + '-' + attachment);
      };

      Tooltip.prototype.getTipElement = function getTipElement() {
        return this.tip = this.tip || $(this.config.template)[0];
      };

      Tooltip.prototype.setContent = function setContent() {
        var $tip = $(this.getTipElement());
        this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
        $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);
      };

      Tooltip.prototype.setElementContent = function setElementContent($element, content) {
        var html = this.config.html;
        if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && (content.nodeType || content.jquery)) {
          // content is a DOM node or a jQuery
          if (html) {
            if (!$(content).parent().is($element)) {
              $element.empty().append(content);
            }
          } else {
            $element.text($(content).text());
          }
        } else {
          $element[html ? 'html' : 'text'](content);
        }
      };

      Tooltip.prototype.getTitle = function getTitle() {
        var title = this.element.getAttribute('data-original-title');

        if (!title) {
          title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
        }

        return title;
      };

      // private

      Tooltip.prototype._getAttachment = function _getAttachment(placement) {
        return AttachmentMap[placement.toUpperCase()];
      };

      Tooltip.prototype._setListeners = function _setListeners() {
        var _this26 = this;

        var triggers = this.config.trigger.split(' ');

        triggers.forEach(function (trigger) {
          if (trigger === 'click') {
            $(_this26.element).on(_this26.constructor.Event.CLICK, _this26.config.selector, function (event) {
              return _this26.toggle(event);
            });
          } else if (trigger !== Trigger.MANUAL) {
            var eventIn = trigger === Trigger.HOVER ? _this26.constructor.Event.MOUSEENTER : _this26.constructor.Event.FOCUSIN;
            var eventOut = trigger === Trigger.HOVER ? _this26.constructor.Event.MOUSELEAVE : _this26.constructor.Event.FOCUSOUT;

            $(_this26.element).on(eventIn, _this26.config.selector, function (event) {
              return _this26._enter(event);
            }).on(eventOut, _this26.config.selector, function (event) {
              return _this26._leave(event);
            });
          }

          $(_this26.element).closest('.modal').on('hide.bs.modal', function () {
            return _this26.hide();
          });
        });

        if (this.config.selector) {
          this.config = $.extend({}, this.config, {
            trigger: 'manual',
            selector: ''
          });
        } else {
          this._fixTitle();
        }
      };

      Tooltip.prototype._fixTitle = function _fixTitle() {
        var titleType = _typeof(this.element.getAttribute('data-original-title'));
        if (this.element.getAttribute('title') || titleType !== 'string') {
          this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
          this.element.setAttribute('title', '');
        }
      };

      Tooltip.prototype._enter = function _enter(event, context) {
        var dataKey = this.constructor.DATA_KEY;

        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
        }

        if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
          context._hoverState = HoverState.SHOW;
          return;
        }

        clearTimeout(context._timeout);

        context._hoverState = HoverState.SHOW;

        if (!context.config.delay || !context.config.delay.show) {
          context.show();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.SHOW) {
            context.show();
          }
        }, context.config.delay.show);
      };

      Tooltip.prototype._leave = function _leave(event, context) {
        var dataKey = this.constructor.DATA_KEY;

        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
        }

        if (context._isWithActiveTrigger()) {
          return;
        }

        clearTimeout(context._timeout);

        context._hoverState = HoverState.OUT;

        if (!context.config.delay || !context.config.delay.hide) {
          context.hide();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.OUT) {
            context.hide();
          }
        }, context.config.delay.hide);
      };

      Tooltip.prototype._isWithActiveTrigger = function _isWithActiveTrigger() {
        for (var trigger in this._activeTrigger) {
          if (this._activeTrigger[trigger]) {
            return true;
          }
        }

        return false;
      };

      Tooltip.prototype._getConfig = function _getConfig(config) {
        config = $.extend({}, this.constructor.Default, $(this.element).data(), config);

        if (config.delay && typeof config.delay === 'number') {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }

        if (config.title && typeof config.title === 'number') {
          config.title = config.title.toString();
        }

        if (config.content && typeof config.content === 'number') {
          config.content = config.content.toString();
        }

        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);

        return config;
      };

      Tooltip.prototype._getDelegateConfig = function _getDelegateConfig() {
        var config = {};

        if (this.config) {
          for (var key in this.config) {
            if (this.constructor.Default[key] !== this.config[key]) {
              config[key] = this.config[key];
            }
          }
        }

        return config;
      };

      Tooltip.prototype._cleanTipClass = function _cleanTipClass() {
        var $tip = $(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      };

      Tooltip.prototype._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
        this._cleanTipClass();
        this.addAttachmentClass(this._getAttachment(data.placement));
      };

      Tooltip.prototype._fixTransition = function _fixTransition() {
        var tip = this.getTipElement();
        var initConfigAnimation = this.config.animation;
        if (tip.getAttribute('x-placement') !== null) {
          return;
        }
        $(tip).removeClass(ClassName.FADE);
        this.config.animation = false;
        this.hide();
        this.show();
        this.config.animation = initConfigAnimation;
      };

      // static

      Tooltip._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;

          if (!data && /dispose|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Tooltip(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Tooltip, null, [{
        key: 'VERSION',
        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }, {
        key: 'NAME',
        get: function get() {
          return NAME;
        }
      }, {
        key: 'DATA_KEY',
        get: function get() {
          return DATA_KEY;
        }
      }, {
        key: 'Event',
        get: function get() {
          return Event;
        }
      }, {
        key: 'EVENT_KEY',
        get: function get() {
          return EVENT_KEY;
        }
      }, {
        key: 'DefaultType',
        get: function get() {
          return DefaultType;
        }
      }]);

      return Tooltip;
    }();

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Tooltip._jQueryInterface;
    $.fn[NAME].Constructor = Tooltip;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tooltip._jQueryInterface;
    };

    return Tooltip;
  }(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-beta): popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Popover = function ($) {

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'popover';
    var VERSION = '4.0.0-beta';
    var DATA_KEY = 'bs.popover';
    var EVENT_KEY = '.' + DATA_KEY;
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var CLASS_PREFIX = 'bs-popover';
    var BSCLS_PREFIX_REGEX = new RegExp('(^|\\s)' + CLASS_PREFIX + '\\S+', 'g');

    var Default = $.extend({}, Tooltip.Default, {
      placement: 'right',
      trigger: 'click',
      content: '',
      template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
    });

    var DefaultType = $.extend({}, Tooltip.DefaultType, {
      content: '(string|element|function)'
    });

    var ClassName = {
      FADE: 'fade',
      SHOW: 'show'
    };

    var Selector = {
      TITLE: '.popover-header',
      CONTENT: '.popover-body'
    };

    var Event = {
      HIDE: 'hide' + EVENT_KEY,
      HIDDEN: 'hidden' + EVENT_KEY,
      SHOW: 'show' + EVENT_KEY,
      SHOWN: 'shown' + EVENT_KEY,
      INSERTED: 'inserted' + EVENT_KEY,
      CLICK: 'click' + EVENT_KEY,
      FOCUSIN: 'focusin' + EVENT_KEY,
      FOCUSOUT: 'focusout' + EVENT_KEY,
      MOUSEENTER: 'mouseenter' + EVENT_KEY,
      MOUSELEAVE: 'mouseleave' + EVENT_KEY

      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };
    var Popover = function (_Tooltip) {
      _inherits(Popover, _Tooltip);

      function Popover() {
        _classCallCheck(this, Popover);

        return _possibleConstructorReturn(this, _Tooltip.apply(this, arguments));
      }

      // overrides

      Popover.prototype.isWithContent = function isWithContent() {
        return this.getTitle() || this._getContent();
      };

      Popover.prototype.addAttachmentClass = function addAttachmentClass(attachment) {
        $(this.getTipElement()).addClass(CLASS_PREFIX + '-' + attachment);
      };

      Popover.prototype.getTipElement = function getTipElement() {
        return this.tip = this.tip || $(this.config.template)[0];
      };

      Popover.prototype.setContent = function setContent() {
        var $tip = $(this.getTipElement());

        // we use append for html objects to maintain js events
        this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
        this.setElementContent($tip.find(Selector.CONTENT), this._getContent());

        $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);
      };

      // private

      Popover.prototype._getContent = function _getContent() {
        return this.element.getAttribute('data-content') || (typeof this.config.content === 'function' ? this.config.content.call(this.element) : this.config.content);
      };

      Popover.prototype._cleanTipClass = function _cleanTipClass() {
        var $tip = $(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      };

      // static

      Popover._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;

          if (!data && /destroy|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Popover(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };

      _createClass(Popover, null, [{
        key: 'VERSION',

        // getters

        get: function get() {
          return VERSION;
        }
      }, {
        key: 'Default',
        get: function get() {
          return Default;
        }
      }, {
        key: 'NAME',
        get: function get() {
          return NAME;
        }
      }, {
        key: 'DATA_KEY',
        get: function get() {
          return DATA_KEY;
        }
      }, {
        key: 'Event',
        get: function get() {
          return Event;
        }
      }, {
        key: 'EVENT_KEY',
        get: function get() {
          return EVENT_KEY;
        }
      }, {
        key: 'DefaultType',
        get: function get() {
          return DefaultType;
        }
      }]);

      return Popover;
    }(Tooltip);

    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Popover._jQueryInterface;
    $.fn[NAME].Constructor = Popover;
    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Popover._jQueryInterface;
    };

    return Popover;
  }(jQuery);
})();

/***/ }),

/***/ 69:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e, t) {
     true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (e) {
        return t(e);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = t(require("jquery")) : t(e.jQuery);
}(undefined, function (e) {
    !function (e) {
        "use strict";

        function t(t) {
            var i = [{
                re: /[\xC0-\xC6]/g,
                ch: "A"
            }, {
                re: /[\xE0-\xE6]/g,
                ch: "a"
            }, {
                re: /[\xC8-\xCB]/g,
                ch: "E"
            }, {
                re: /[\xE8-\xEB]/g,
                ch: "e"
            }, {
                re: /[\xCC-\xCF]/g,
                ch: "I"
            }, {
                re: /[\xEC-\xEF]/g,
                ch: "i"
            }, {
                re: /[\xD2-\xD6]/g,
                ch: "O"
            }, {
                re: /[\xF2-\xF6]/g,
                ch: "o"
            }, {
                re: /[\xD9-\xDC]/g,
                ch: "U"
            }, {
                re: /[\xF9-\xFC]/g,
                ch: "u"
            }, {
                re: /[\xC7-\xE7]/g,
                ch: "c"
            }, {
                re: /[\xD1]/g,
                ch: "N"
            }, {
                re: /[\xF1]/g,
                ch: "n"
            }];
            return e.each(i, function () {
                t = t ? t.replace(this.re, this.ch) : "";
            }), t;
        }

        function i(t) {
            var i = arguments,
                n = t;
            [].shift.apply(i);
            var s,
                o = this.each(function () {
                var t = e(this);
                if (t.is("select")) {
                    var o = t.data("selectpicker"),
                        a = "object" == (typeof n === "undefined" ? "undefined" : _typeof(n)) && n;
                    if (o) {
                        if (a) for (var l in a) {
                            a.hasOwnProperty(l) && (o.options[l] = a[l]);
                        }
                    } else {
                        var r = e.extend({}, h.DEFAULTS, e.fn.selectpicker.defaults || {}, t.data(), a);
                        r.template = e.extend({}, h.DEFAULTS.template, e.fn.selectpicker.defaults ? e.fn.selectpicker.defaults.template : {}, t.data().template, a.template), t.data("selectpicker", o = new h(this, r));
                    }
                    "string" == typeof n && (s = o[n] instanceof Function ? o[n].apply(o, i) : o.options[n]);
                }
            });
            return "undefined" != typeof s ? s : o;
        }
        String.prototype.includes || !function () {
            var e = {}.toString,
                t = function () {
                try {
                    var e = {},
                        t = Object.defineProperty,
                        i = t(e, e, e) && t;
                } catch (n) {}
                return i;
            }(),
                i = "".indexOf,
                n = function n(t) {
                if (null == this) throw new TypeError();
                var n = String(this);
                if (t && "[object RegExp]" == e.call(t)) throw new TypeError();
                var s = n.length,
                    o = String(t),
                    a = o.length,
                    l = arguments.length > 1 ? arguments[1] : void 0,
                    r = l ? Number(l) : 0;
                r != r && (r = 0);
                var d = Math.min(Math.max(r, 0), s);
                return a + d > s ? !1 : -1 != i.call(n, o, r);
            };
            t ? t(String.prototype, "includes", {
                value: n,
                configurable: !0,
                writable: !0
            }) : String.prototype.includes = n;
        }(), String.prototype.startsWith || !function () {
            var e = function () {
                try {
                    var e = {},
                        t = Object.defineProperty,
                        i = t(e, e, e) && t;
                } catch (n) {}
                return i;
            }(),
                t = {}.toString,
                i = function i(e) {
                if (null == this) throw new TypeError();
                var i = String(this);
                if (e && "[object RegExp]" == t.call(e)) throw new TypeError();
                var n = i.length,
                    s = String(e),
                    o = s.length,
                    a = arguments.length > 1 ? arguments[1] : void 0,
                    l = a ? Number(a) : 0;
                l != l && (l = 0);
                var r = Math.min(Math.max(l, 0), n);
                if (o + r > n) return !1;
                for (var d = -1; ++d < o;) {
                    if (i.charCodeAt(r + d) != s.charCodeAt(d)) return !1;
                }return !0;
            };
            e ? e(String.prototype, "startsWith", {
                value: i,
                configurable: !0,
                writable: !0
            }) : String.prototype.startsWith = i;
        }(), Object.keys || (Object.keys = function (e, t, i) {
            i = [];
            for (t in e) {
                i.hasOwnProperty.call(e, t) && i.push(t);
            }return i;
        });
        var n = {
            useDefault: !1,
            _set: e.valHooks.select.set
        };
        e.valHooks.select.set = function (t, i) {
            return i && !n.useDefault && e(t).data("selected", !0), n._set.apply(this, arguments);
        };
        var s = null;
        e.fn.triggerNative = function (e) {
            this[0];
            this.trigger(e);
        }, e.expr.pseudos.icontains = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.text()).toString().toUpperCase();
            return o.includes(n[3].toUpperCase());
        }, e.expr.pseudos.ibegins = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.text()).toString().toUpperCase();
            return o.startsWith(n[3].toUpperCase());
        }, e.expr.pseudos.aicontains = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.data("normalizedText") || s.text()).toString().toUpperCase();
            return o.includes(n[3].toUpperCase());
        }, e.expr.pseudos.aibegins = function (t, i, n) {
            var s = e(t).find("span.dropdown-item-inner"),
                o = (s.data("tokens") || s.data("normalizedText") || s.text()).toString().toUpperCase();
            return o.startsWith(n[3].toUpperCase());
        };
        var o = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        },
            a = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#x27;": "'",
            "&#x60;": "`"
        },
            l = function l(e) {
            var t = function t(_t) {
                return e[_t];
            },
                i = "(?:" + Object.keys(e).join("|") + ")",
                n = RegExp(i),
                s = RegExp(i, "g");
            return function (e) {
                return e = null == e ? "" : "" + e, n.test(e) ? e.replace(s, t) : e;
            };
        },
            r = l(o),
            d = l(a),
            h = function h(t, i) {
            n.useDefault || (e.valHooks.select.set = n._set, n.useDefault = !0), this.$element = e(t), this.$newElement = null, this.$button = null, this.$menu = null, this.$lis = null, this.options = i, null === this.options.title && (this.options.title = this.$element.attr("title"));
            var s = this.options.windowPadding;
            "number" == typeof s && (this.options.windowPadding = [s, s, s, s]), this.val = h.prototype.val, this.render = h.prototype.render, this.refresh = h.prototype.refresh, this.setStyle = h.prototype.setStyle, this.selectAll = h.prototype.selectAll, this.deselectAll = h.prototype.deselectAll, this.destroy = h.prototype.destroy, this.remove = h.prototype.remove, this.show = h.prototype.show, this.hide = h.prototype.hide, this.init();
        };
        h.VERSION = "1.12.2", h.DEFAULTS = {
            noneSelectedText: "Nothing selected",
            noneResultsText: "No results matched {0}",
            countSelectedText: function countSelectedText(e, t) {
                return 1 == e ? "{0} item selected" : "{0} items selected";
            },
            maxOptionsText: function maxOptionsText(e, t) {
                return [1 == e ? "Limit reached ({n} item max)" : "Limit reached ({n} items max)", 1 == t ? "Group limit reached ({n} item max)" : "Group limit reached ({n} items max)"];
            },
            selectAllText: "Select All",
            deselectAllText: "Deselect All",
            doneButton: !1,
            doneButtonText: "Close",
            multipleSeparator: ", ",
            styleBase: "btn",
            style: "btn-default btn-light",
            size: "auto",
            title: null,
            selectedTextFormat: "values",
            width: !1,
            container: !1,
            hideDisabled: !1,
            showSubtext: !1,
            showIcon: !0,
            showContent: !0,
            dropupAuto: !0,
            header: !1,
            liveSearch: !1,
            liveSearchPlaceholder: null,
            liveSearchNormalize: !1,
            liveSearchStyle: "contains",
            actionsBox: !1,
            iconBase: "fa",
            tickIcon: "fa-check",
            showTick: !1,
            template: {
                caret: '<span class="caret"></span>'
            },
            maxOptions: !1,
            mobile: !1,
            selectOnTab: !1,
            dropdownAlignRight: !1,
            windowPadding: 0
        }, h.prototype = {
            constructor: h,
            init: function init() {
                var t = this,
                    i = this.$element.attr("id");
                this.$element.addClass("bs-select-hidden"), this.liObj = {}, this.multiple = this.$element.prop("multiple"), this.autofocus = this.$element.prop("autofocus"), this.$newElement = this.createView(), this.$element.after(this.$newElement).appendTo(this.$newElement), this.$button = this.$newElement.children("button"), this.$menu = this.$newElement.children(".dropdown-menu"), this.$menuInner = this.$menu.children(".inner"), this.$searchbox = this.$menu.find("input"), this.$element.removeClass("bs-select-hidden"), this.options.dropdownAlignRight === !0 && this.$menu.addClass("dropdown-menu-right"), "undefined" != typeof i && (this.$button.attr("data-id", i), e('label[for="' + i + '"]').click(function (e) {
                    e.preventDefault(), t.$button.focus();
                })), this.checkDisabled(), this.clickListener(), this.options.liveSearch && this.liveSearchListener(), this.render(), this.setStyle(), this.setWidth(), this.options.container && this.selectPosition(), this.$menu.data("this", this), this.$newElement.data("this", this), this.options.mobile && this.mobile(), this.$newElement.on({
                    "hide.bs.dropdown": function hideBsDropdown(e) {
                        t.$menuInner.attr("aria-expanded", !1), t.$element.trigger("hide.bs.select", e);
                    },
                    "hidden.bs.dropdown": function hiddenBsDropdown(e) {
                        t.$element.trigger("hidden.bs.select", e);
                    },
                    "show.bs.dropdown": function showBsDropdown(e) {
                        t.$menuInner.attr("aria-expanded", !0), t.$element.trigger("show.bs.select", e);
                    },
                    "shown.bs.dropdown": function shownBsDropdown(e) {
                        t.$element.trigger("shown.bs.select", e);
                    }
                }), t.$element[0].hasAttribute("required") && this.$element.on("invalid", function () {
                    t.$button.addClass("bs-invalid").focus(), t.$element.on({
                        "focus.bs.select": function focusBsSelect() {
                            t.$button.focus(), t.$element.off("focus.bs.select");
                        },
                        "shown.bs.select": function shownBsSelect() {
                            t.$element.val(t.$element.val()).off("shown.bs.select");
                        },
                        "rendered.bs.select": function renderedBsSelect() {
                            this.validity.valid && t.$button.removeClass("bs-invalid"), t.$element.off("rendered.bs.select");
                        }
                    });
                }), setTimeout(function () {
                    t.$element.trigger("loaded.bs.select");
                });
            },
            createDropdown: function createDropdown() {
                var t = this.multiple || this.options.showTick ? " show-tick" : "",
                    i = this.$element.parent().hasClass("input-group") ? " input-group-btn" : "",
                    n = this.autofocus ? " autofocus" : "",
                    s = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + "</div>" : "",
                    o = this.options.liveSearch ? '<div class="bs-searchbox"><input type="text" class="form-control" autocomplete="off"' + (null === this.options.liveSearchPlaceholder ? "" : ' placeholder="' + r(this.options.liveSearchPlaceholder) + '"') + ' role="textbox" aria-label="Search"></div>' : "",
                    a = this.multiple && this.options.actionsBox ? '<div class="bs-actionsbox"><div class="btn-group btn-group-sm btn-block"><button type="button" class="actions-btn bs-select-all btn btn-default btn-light">' + this.options.selectAllText + '</button><button type="button" class="actions-btn bs-deselect-all btn btn-default btn-light">' + this.options.deselectAllText + "</button></div></div>" : "",
                    l = this.multiple && this.options.doneButton ? '<div class="bs-donebutton"><div class="btn-group btn-block"><button type="button" class="btn btn-sm btn-default btn-light">' + this.options.doneButtonText + "</button></div></div>" : "",
                    d = '<div class="btn-group bootstrap-select' + t + i + '"><button type="button" class="' + this.options.styleBase + ' dropdown-toggle" data-toggle="dropdown"' + n + ' role="button"><span class="filter-option pull-left"></span>&nbsp;<span class="bs-caret">' + this.options.template.caret + '</span></button><div class="dropdown-menu open" role="combobox">' + s + o + a + '<div class="dropdown-menu inner" role="listbox" aria-expanded="false"></div>' + l + "</div></div>";
                return e(d);
            },
            createView: function createView() {
                var e = this.createDropdown(),
                    t = this.createLi();
                return e.find("div.inner")[0].innerHTML = t, e;
            },
            reloadLi: function reloadLi() {
                var e = this.createLi();
                this.$menuInner[0].innerHTML = e;
            },
            createLi: function createLi() {
                var i = this,
                    n = [],
                    s = 0,
                    o = document.createElement("option"),
                    a = -1,
                    l = function l(e, t, i, n) {
                    return i = "dropdown-item " + (i || ""), "<a" + ("undefined" != typeof i && "" !== i ? ' class="' + i + '"' : "") + ("undefined" != typeof t && null !== t ? ' data-original-index="' + t + '"' : "") + ("undefined" != typeof n && null !== n ? 'data-optgroup="' + n + '"' : "") + ">" + e + "</a>";
                },
                    d = function d(n, s, o, a) {
                    return s = "dropdown-item-inner " + (s || ""), '<span tabindex="0"' + ("undefined" != typeof s ? ' class="' + s + '"' : "") + (o ? ' style="' + o + '"' : "") + (i.options.liveSearchNormalize ? ' data-normalized-text="' + t(r(e(n).html())) + '"' : "") + ("undefined" != typeof a || null !== a ? ' data-tokens="' + a + '"' : "") + ' role="option">' + n + '<span class="' + i.options.iconBase + " " + i.options.tickIcon + ' check-mark"></span></span>';
                };
                if (this.options.title && !this.multiple && (a--, !this.$element.find(".bs-title-option").length)) {
                    var h = this.$element[0];
                    o.className = "bs-title-option", o.innerHTML = this.options.title, o.value = "", h.insertBefore(o, h.firstChild);
                    var c = e(h.options[h.selectedIndex]);
                    void 0 === c.attr("selected") && void 0 === this.$element.data("selected") && (o.selected = !0);
                }
                var p = this.$element.find("option");
                return p.each(function (t) {
                    var o = e(this);
                    if (a++, !o.hasClass("bs-title-option")) {
                        var h,
                            c = this.className || "",
                            u = r(this.style.cssText),
                            f = o.data("content") ? o.data("content") : o.html(),
                            m = o.data("tokens") ? o.data("tokens") : null,
                            g = "undefined" != typeof o.data("subtext") ? '<small class="text-muted">' + o.data("subtext") + "</small>" : "",
                            b = "undefined" != typeof o.data("icon") ? '<span class="' + i.options.iconBase + " " + o.data("icon") + '"></span> ' : "",
                            v = o.parent(),
                            $ = "OPTGROUP" === v[0].tagName,
                            x = $ && v[0].disabled,
                            w = this.disabled || x;
                        if ("" !== b && w && (b = "<span>" + b + "</span>"), i.options.hideDisabled && (w && !$ || x)) return h = o.data("prevHiddenIndex"), o.next().data("prevHiddenIndex", void 0 !== h ? h : t), void a--;
                        if (o.data("content") || (f = b + '<span class="text">' + f + g + "</span>"), $ && o.data("divider") !== !0) {
                            if (i.options.hideDisabled && w) {
                                if (void 0 === v.data("allOptionsDisabled")) {
                                    var y = v.children();
                                    v.data("allOptionsDisabled", y.filter(":disabled").length === y.length);
                                }
                                if (v.data("allOptionsDisabled")) return void a--;
                            }
                            var C = " " + v[0].className || "";
                            if (0 === o.index()) {
                                s += 1;
                                var S = v[0].label,
                                    k = "undefined" != typeof v.data("subtext") ? '<small class="text-muted">' + v.data("subtext") + "</small>" : "",
                                    I = v.data("icon") ? '<span class="' + i.options.iconBase + " " + v.data("icon") + '"></span> ' : "";
                                S = I + '<span class="text">' + r(S) + k + "</span>", 0 !== t && n.length > 0 && (a++, n.push(l("", null, "divider", s + "div"))), a++, n.push(l(S, null, "dropdown-header" + C, s));
                            }
                            if (i.options.hideDisabled && w) return void a--;
                            n.push(l(d(f, "opt " + c + C, u, m), t, "", s));
                        } else if (o.data("divider") === !0) n.push(l("", t, "divider"));else if (o.data("hidden") === !0) h = o.data("prevHiddenIndex"), o.next().data("prevHiddenIndex", void 0 !== h ? h : t), n.push(l(d(f, c, u, m), t, "hidden is-hidden"));else {
                            var T = this.previousElementSibling && "OPTGROUP" === this.previousElementSibling.tagName;
                            if (!T && i.options.hideDisabled && (h = o.data("prevHiddenIndex"), void 0 !== h)) {
                                var E = p.eq(h)[0].previousElementSibling;
                                E && "OPTGROUP" === E.tagName && !E.disabled && (T = !0);
                            }
                            T && (a++, n.push(l("", null, "divider", s + "div"))), n.push(l(d(f, c, u, m), t));
                        }
                        i.liObj[t] = a;
                    }
                }), this.multiple || 0 !== this.$element.find("option:selected").length || this.options.title || this.$element.find("option").eq(0).prop("selected", !0).attr("selected", "selected"), n.join("");
            },
            findLis: function findLis() {
                return null == this.$lis && (this.$lis = this.$menu.find("a")), this.$lis;
            },
            render: function render(t) {
                var i,
                    n = this,
                    s = this.$element.find("option");
                t !== !1 && s.each(function (e) {
                    var t = n.findLis().eq(n.liObj[e]);
                    n.setDisabled(e, this.disabled || "OPTGROUP" === this.parentNode.tagName && this.parentNode.disabled, t), n.setSelected(e, this.selected, t);
                }), this.togglePlaceholder(), this.tabIndex();
                var o = s.map(function () {
                    if (this.selected) {
                        if (n.options.hideDisabled && (this.disabled || "OPTGROUP" === this.parentNode.tagName && this.parentNode.disabled)) return;
                        var t,
                            i = e(this),
                            s = i.data("icon") && n.options.showIcon ? '<i class="' + n.options.iconBase + " " + i.data("icon") + '"></i> ' : "";
                        return t = n.options.showSubtext && i.data("subtext") && !n.multiple ? ' <small class="text-muted">' + i.data("subtext") + "</small>" : "", "undefined" != typeof i.attr("title") ? i.attr("title") : i.data("content") && n.options.showContent ? i.data("content").toString() : s + i.html() + t;
                    }
                }).toArray(),
                    a = this.multiple ? o.join(this.options.multipleSeparator) : o[0];
                if (this.multiple && this.options.selectedTextFormat.indexOf("count") > -1) {
                    var l = this.options.selectedTextFormat.split(">");
                    if (l.length > 1 && o.length > l[1] || 1 == l.length && o.length >= 2) {
                        i = this.options.hideDisabled ? ", [disabled]" : "";
                        var r = s.not('[data-divider="true"], [data-hidden="true"]' + i).length,
                            h = "function" == typeof this.options.countSelectedText ? this.options.countSelectedText(o.length, r) : this.options.countSelectedText;
                        a = h.replace("{0}", o.length.toString()).replace("{1}", r.toString());
                    }
                }
                void 0 == this.options.title && (this.options.title = this.$element.attr("title")), "static" == this.options.selectedTextFormat && (a = this.options.title), a || (a = "undefined" != typeof this.options.title ? this.options.title : this.options.noneSelectedText), this.$button.attr("title", d(e.trim(a.replace(/<[^>]*>?/g, "")))), this.$button.children(".filter-option").html(a), this.$element.trigger("rendered.bs.select");
            },
            setStyle: function setStyle(e, t) {
                this.$element.attr("class") && this.$newElement.addClass(this.$element.attr("class").replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ""));
                var i = e ? e : this.options.style;
                "add" == t ? this.$button.addClass(i) : "remove" == t ? this.$button.removeClass(i) : (this.$button.removeClass(this.options.style), this.$button.addClass(i));
            },
            liHeight: function liHeight(t) {
                if (t || this.options.size !== !1 && !this.sizeInfo) {
                    var i = document.createElement("div"),
                        n = document.createElement("div"),
                        s = document.createElement("ul"),
                        o = document.createElement("a"),
                        a = document.createElement("a"),
                        l = document.createElement("span"),
                        r = document.createElement("span"),
                        d = this.options.header && this.$menu.find(".popover-title").length > 0 ? this.$menu.find(".popover-title")[0].cloneNode(!0) : null,
                        h = this.options.liveSearch ? document.createElement("div") : null,
                        c = this.options.actionsBox && this.multiple && this.$menu.find(".bs-actionsbox").length > 0 ? this.$menu.find(".bs-actionsbox")[0].cloneNode(!0) : null,
                        p = this.options.doneButton && this.multiple && this.$menu.find(".bs-donebutton").length > 0 ? this.$menu.find(".bs-donebutton")[0].cloneNode(!0) : null;
                    if (r.className = "text", i.className = this.$menu[0].parentNode.className + " show open", n.className = "dropdown-menu open show", s.className = "dropdown-menu inner", o.className = "divider", l.className = "dropdown-item-inner", r.appendChild(document.createTextNode("Inner text")), l.appendChild(r), a.appendChild(l), s.appendChild(a), s.appendChild(o), d && n.appendChild(d), h) {
                        var u = document.createElement("input");
                        h.className = "bs-searchbox", u.className = "form-control", h.appendChild(u), n.appendChild(h);
                    }
                    c && n.appendChild(c), n.appendChild(s), p && n.appendChild(p), i.appendChild(n), document.body.appendChild(i);
                    var f = l.offsetHeight,
                        m = d ? d.offsetHeight : 0,
                        g = h ? h.offsetHeight : 0,
                        b = c ? c.offsetHeight : 0,
                        v = p ? p.offsetHeight : 0,
                        $ = e(o).outerHeight(!0),
                        x = "function" == typeof getComputedStyle ? getComputedStyle(n) : !1,
                        w = x ? null : e(n),
                        y = {
                        vert: parseInt(x ? x.paddingTop : w.css("paddingTop")) + parseInt(x ? x.paddingBottom : w.css("paddingBottom")) + parseInt(x ? x.borderTopWidth : w.css("borderTopWidth")) + parseInt(x ? x.borderBottomWidth : w.css("borderBottomWidth")),
                        horiz: parseInt(x ? x.paddingLeft : w.css("paddingLeft")) + parseInt(x ? x.paddingRight : w.css("paddingRight")) + parseInt(x ? x.borderLeftWidth : w.css("borderLeftWidth")) + parseInt(x ? x.borderRightWidth : w.css("borderRightWidth"))
                    },
                        C = {
                        vert: y.vert + parseInt(x ? x.marginTop : w.css("marginTop")) + parseInt(x ? x.marginBottom : w.css("marginBottom")) + 2,
                        horiz: y.horiz + parseInt(x ? x.marginLeft : w.css("marginLeft")) + parseInt(x ? x.marginRight : w.css("marginRight")) + 2
                    };
                    document.body.removeChild(i), this.sizeInfo = {
                        liHeight: f,
                        headerHeight: m,
                        searchHeight: g,
                        actionsHeight: b,
                        doneButtonHeight: v,
                        dividerHeight: $,
                        menuPadding: y,
                        menuExtras: C
                    };
                }
            },
            setSize: function setSize() {
                if (this.findLis(), this.liHeight(), this.options.header && this.$menu.css("padding-top", 0), this.options.size !== !1) {
                    var t,
                        i,
                        n,
                        s,
                        o,
                        a,
                        l,
                        r,
                        d = this,
                        h = this.$menu,
                        c = this.$menuInner,
                        p = e(window),
                        u = this.$newElement[0].offsetHeight,
                        f = this.$newElement[0].offsetWidth,
                        m = this.sizeInfo.liHeight,
                        g = this.sizeInfo.headerHeight,
                        b = this.sizeInfo.searchHeight,
                        v = this.sizeInfo.actionsHeight,
                        $ = this.sizeInfo.doneButtonHeight,
                        x = this.sizeInfo.dividerHeight,
                        w = this.sizeInfo.menuPadding,
                        y = this.sizeInfo.menuExtras,
                        C = this.options.hideDisabled ? ".disabled" : "",
                        S = function S() {
                        var t,
                            i = d.$newElement.offset(),
                            n = e(d.options.container);
                        d.options.container && !n.is("body") ? (t = n.offset(), t.top += parseInt(n.css("borderTopWidth")), t.left += parseInt(n.css("borderLeftWidth"))) : t = {
                            top: 0,
                            left: 0
                        };
                        var s = d.options.windowPadding;
                        o = i.top - t.top - p.scrollTop(), a = p.height() - o - u - t.top - s[2], l = i.left - t.left - p.scrollLeft(), r = p.width() - l - f - t.left - s[1], o -= s[0], l -= s[3];
                    };
                    if (S(), "auto" === this.options.size) {
                        var k = function k() {
                            var p,
                                u = function u(t, i) {
                                return function (n) {
                                    return i ? n.classList ? n.classList.contains(t) : e(n).hasClass(t) : !(n.classList ? n.classList.contains(t) : e(n).hasClass(t));
                                };
                            },
                                x = d.$menuInner[0].getElementsByTagName("a"),
                                C = Array.prototype.filter ? Array.prototype.filter.call(x, u("hidden", !1)) : d.$lis.not(".hidden"),
                                k = Array.prototype.filter ? Array.prototype.filter.call(C, u("dropdown-header", !0)) : C.filter(".dropdown-header");
                            S(), t = a - y.vert, i = r - y.horiz, d.options.container ? (h.data("height") || h.data("height", h.height()), n = h.data("height"), h.data("width") || h.data("width", h.width()), s = h.data("width")) : (n = h.height(), s = h.width()), d.options.dropupAuto && d.$newElement.toggleClass("dropup", o > a && t - y.vert < n), d.$newElement.hasClass("dropup") && (t = o - y.vert), "auto" === d.options.dropdownAlignRight && h.toggleClass("dropdown-menu-right", l > r && i - y.horiz < s - f), p = C.length + k.length > 3 ? 3 * m + y.vert - 2 : 0, h.css({
                                "max-height": t + "px",
                                overflow: "hidden",
                                "min-height": p + g + b + v + $ + "px"
                            }), c.css({
                                "max-height": t - g - b - v - $ - w.vert + "px",
                                "overflow-y": "auto",
                                "min-height": Math.max(p - w.vert, 0) + "px"
                            });
                        };
                        k(), this.$searchbox.off("input.getSize propertychange.getSize").on("input.getSize propertychange.getSize", k), p.off("resize.getSize scroll.getSize").on("resize.getSize scroll.getSize", k);
                    } else if (this.options.size && "auto" != this.options.size && this.$lis.not(C).length > this.options.size) {
                        var I = this.$lis.not(".divider").not(C).children().slice(0, this.options.size).last().parent().index(),
                            T = this.$lis.slice(0, I + 1).filter(".divider").length;
                        t = m * this.options.size + T * x + w.vert, d.options.container ? (h.data("height") || h.data("height", h.height()), n = h.data("height")) : n = h.height(), d.options.dropupAuto && this.$newElement.toggleClass("dropup", o > a && t - y.vert < n), h.css({
                            "max-height": t + g + b + v + $ + "px",
                            overflow: "hidden",
                            "min-height": ""
                        }), c.css({
                            "max-height": t - w.vert + "px",
                            "overflow-y": "auto",
                            "min-height": ""
                        });
                    }
                }
            },
            setWidth: function setWidth() {
                if ("auto" === this.options.width) {
                    this.$menu.css("min-width", "0");
                    var e = this.$menu.parent().clone().appendTo("body"),
                        t = this.options.container ? this.$newElement.clone().appendTo("body") : e,
                        i = e.children(".dropdown-menu").outerWidth(),
                        n = t.css("width", "auto").children("button").outerWidth();
                    e.remove(), t.remove(), this.$newElement.css("width", Math.max(i, n) + "px");
                } else "fit" === this.options.width ? (this.$menu.css("min-width", ""), this.$newElement.css("width", "").addClass("fit-width")) : this.options.width ? (this.$menu.css("min-width", ""), this.$newElement.css("width", this.options.width)) : (this.$menu.css("min-width", ""), this.$newElement.css("width", ""));
                this.$newElement.hasClass("fit-width") && "fit" !== this.options.width && this.$newElement.removeClass("fit-width");
            },
            selectPosition: function selectPosition() {
                this.$bsContainer = e('<div class="bs-container" />');
                var t,
                    i,
                    n,
                    s = this,
                    o = e(this.options.container),
                    a = function a(e) {
                    s.$bsContainer.addClass(e.attr("class").replace(/form-control|fit-width/gi, "")).toggleClass("dropup", e.hasClass("dropup")), t = e.offset(), o.is("body") ? i = {
                        top: 0,
                        left: 0
                    } : (i = o.offset(), i.top += parseInt(o.css("borderTopWidth")) - o.scrollTop(), i.left += parseInt(o.css("borderLeftWidth")) - o.scrollLeft()), n = e.hasClass("dropup") ? 0 : e[0].offsetHeight, s.$bsContainer.css({
                        top: t.top - i.top + n,
                        left: t.left - i.left,
                        width: e[0].offsetWidth
                    });
                };
                this.$button.on("click", function () {
                    var t = e(this);
                    s.isDisabled() || (a(s.$newElement), s.$bsContainer.appendTo(s.options.container).toggleClass("open", !t.hasClass("open")).append(s.$menu));
                }), e(window).on("resize scroll", function () {
                    a(s.$newElement);
                }), this.$element.on("hide.bs.select", function () {
                    s.$menu.data("height", s.$menu.height()), s.$bsContainer.detach();
                });
            },
            setSelected: function setSelected(e, t, i) {
                i || (this.togglePlaceholder(), i = this.findLis().eq(this.liObj[e])), i.toggleClass("selected", t).find("span.dropdown-item-inner").attr("aria-selected", t);
            },
            setDisabled: function setDisabled(e, t, i) {
                i || (i = this.findLis().eq(this.liObj[e])), t ? i.addClass("disabled").children("span.dropdown-item-inner").attr("href", "#").attr("tabindex", -1).attr("aria-disabled", !0) : i.removeClass("disabled").children("span.dropdown-item-inner").removeAttr("href").attr("tabindex", 0).attr("aria-disabled", !1);
            },
            isDisabled: function isDisabled() {
                return this.$element[0].disabled;
            },
            checkDisabled: function checkDisabled() {
                var e = this;
                this.isDisabled() ? (this.$newElement.addClass("disabled"), this.$button.addClass("disabled").attr("tabindex", -1).attr("aria-disabled", !0)) : (this.$button.hasClass("disabled") && (this.$newElement.removeClass("disabled"), this.$button.removeClass("disabled").attr("aria-disabled", !1)), -1 != this.$button.attr("tabindex") || this.$element.data("tabindex") || this.$button.removeAttr("tabindex")), this.$button.click(function () {
                    return !e.isDisabled();
                });
            },
            togglePlaceholder: function togglePlaceholder() {
                var e = this.$element.val();
                this.$button.toggleClass("bs-placeholder", null === e || "" === e || e.constructor === Array && 0 === e.length);
            },
            tabIndex: function tabIndex() {
                this.$element.data("tabindex") !== this.$element.attr("tabindex") && -98 !== this.$element.attr("tabindex") && "-98" !== this.$element.attr("tabindex") && (this.$element.data("tabindex", this.$element.attr("tabindex")), this.$button.attr("tabindex", this.$element.data("tabindex"))), this.$element.attr("tabindex", -98);
            },
            clickListener: function clickListener() {
                var t = this,
                    i = e(document);
                i.data("spaceSelect", !1), this.$button.on("keyup", function (e) {
                    /(32)/.test(e.keyCode.toString(10)) && i.data("spaceSelect") && (e.preventDefault(), i.data("spaceSelect", !1));
                }), this.$button.on("click", function () {
                    t.setSize();
                }), this.$element.on("shown.bs.select", function () {
                    if (t.options.liveSearch || t.multiple) {
                        if (!t.multiple) {
                            var e = t.liObj[t.$element[0].selectedIndex];
                            if ("number" != typeof e || t.options.size === !1) return;
                            var i = t.$lis.eq(e)[0].offsetTop - t.$menuInner[0].offsetTop;
                            i = i - t.$menuInner[0].offsetHeight / 2 + t.sizeInfo.liHeight / 2, t.$menuInner[0].scrollTop = i;
                        }
                    } else t.$menuInner.find(".selected a").focus();
                }), this.$menuInner.on("click", "a span.dropdown-item-inner", function (i) {
                    var n = e(this),
                        o = n.parent().data("originalIndex"),
                        a = t.$element.val(),
                        l = t.$element.prop("selectedIndex"),
                        r = !0;
                    if (t.multiple && 1 !== t.options.maxOptions && i.stopPropagation(), i.preventDefault(), !t.isDisabled() && !n.parent().hasClass("disabled")) {
                        var d = t.$element.find("option"),
                            h = d.eq(o),
                            c = h.prop("selected"),
                            p = h.parent("optgroup"),
                            u = t.options.maxOptions,
                            f = p.data("maxOptions") || !1;
                        if (t.multiple) {
                            if (h.prop("selected", !c), t.setSelected(o, !c), n.blur(), u !== !1 || f !== !1) {
                                var m = u < d.filter(":selected").length,
                                    g = f < p.find("option:selected").length;
                                if (u && m || f && g) if (u && 1 == u) d.prop("selected", !1), h.prop("selected", !0), t.$menuInner.find(".selected").removeClass("selected"), t.setSelected(o, !0);else if (f && 1 == f) {
                                    p.find("option:selected").prop("selected", !1), h.prop("selected", !0);
                                    var b = n.parent().data("optgroup");
                                    t.$menuInner.find('[data-optgroup="' + b + '"]').removeClass("selected"), t.setSelected(o, !0);
                                } else {
                                    var v = "string" == typeof t.options.maxOptionsText ? [t.options.maxOptionsText, t.options.maxOptionsText] : t.options.maxOptionsText,
                                        $ = "function" == typeof v ? v(u, f) : v,
                                        x = $[0].replace("{n}", u),
                                        w = $[1].replace("{n}", f),
                                        y = e('<div class="notify"></div>');
                                    $[2] && (x = x.replace("{var}", $[2][u > 1 ? 0 : 1]), w = w.replace("{var}", $[2][f > 1 ? 0 : 1])), h.prop("selected", !1), t.$menu.append(y), u && m && (y.append(e("<div>" + x + "</div>")), r = !1, t.$element.trigger("maxReached.bs.select")), f && g && (y.append(e("<div>" + w + "</div>")), r = !1, t.$element.trigger("maxReachedGrp.bs.select")), setTimeout(function () {
                                        t.setSelected(o, !1);
                                    }, 10), y.delay(750).fadeOut(300, function () {
                                        e(this).remove();
                                    });
                                }
                            }
                        } else d.prop("selected", !1), h.prop("selected", !0), t.$menuInner.find(".selected").removeClass("selected").find("span.dropdown-item-inner").attr("aria-selected", !1), t.setSelected(o, !0);
                        !t.multiple || t.multiple && 1 === t.options.maxOptions ? t.$button.focus() : t.options.liveSearch && t.$searchbox.focus(), r && (a != t.$element.val() && t.multiple || l != t.$element.prop("selectedIndex") && !t.multiple) && (s = [o, h.prop("selected"), c], t.$element.triggerNative("change"));
                    }
                }), this.$menu.on("click", "a.disabled span.dropdown-item-inner , .popover-title, .popover-title :not(.close)", function (i) {
                    i.currentTarget == this && (i.preventDefault(), i.stopPropagation(), t.options.liveSearch && !e(i.target).hasClass("close") ? t.$searchbox.focus() : t.$button.focus());
                }), this.$menuInner.on("click", ".divider, .dropdown-header", function (e) {
                    e.preventDefault(), e.stopPropagation(), t.options.liveSearch ? t.$searchbox.focus() : t.$button.focus();
                }), this.$menu.on("click", ".popover-title .close", function () {
                    t.$button.click();
                }), this.$searchbox.on("click", function (e) {
                    e.stopPropagation();
                }), this.$menu.on("click", ".actions-btn", function (i) {
                    t.options.liveSearch ? t.$searchbox.focus() : t.$button.focus(), i.preventDefault(), i.stopPropagation(), e(this).hasClass("bs-select-all") ? t.selectAll() : t.deselectAll();
                }), this.$element.change(function () {
                    t.render(!1), t.$element.trigger("changed.bs.select", s), s = null;
                });
            },
            liveSearchListener: function liveSearchListener() {
                var i = this,
                    n = e('<li class="no-results"></li>');
                this.$button.on("click.dropdown.data-api", function () {
                    i.$menuInner.find(".active").removeClass("active"), i.$searchbox.val() && (i.$searchbox.val(""), i.$lis.not(".is-hidden").removeClass("hidden"), n.parent().length && n.remove()), i.multiple || i.$menuInner.find(".selected").addClass("active"), setTimeout(function () {
                        i.$searchbox.focus();
                    }, 10);
                }), this.$searchbox.on("click.dropdown.data-api focus.dropdown.data-api touchend.dropdown.data-api", function (e) {
                    e.stopPropagation();
                }), this.$searchbox.on("input propertychange", function () {
                    if (i.$lis.not(".is-hidden").removeClass("hidden"), i.$lis.filter(".active").removeClass("active"), n.remove(), i.$searchbox.val()) {
                        var s,
                            o = i.$lis.not(".is-hidden, .divider, .dropdown-header");
                        if (s = i.options.liveSearchNormalize ? o.not(":a" + i._searchStyle() + '("' + t(i.$searchbox.val()) + '")') : o.not(":" + i._searchStyle() + '("' + i.$searchbox.val() + '")'), s.length === o.length) n.html(i.options.noneResultsText.replace("{0}", '"' + r(i.$searchbox.val()) + '"')), i.$menuInner.append(n), i.$lis.addClass("hidden");else {
                            s.addClass("hidden");
                            var a,
                                l = i.$lis.not(".hidden");
                            l.each(function (t) {
                                var i = e(this);
                                i.hasClass("divider") ? void 0 === a ? i.addClass("hidden") : (a && a.addClass("hidden"), a = i) : i.hasClass("dropdown-header") && l.eq(t + 1).data("optgroup") !== i.data("optgroup") ? i.addClass("hidden") : a = null;
                            }), a && a.addClass("hidden"), o.not(".hidden").first().addClass("active"), i.$menuInner.scrollTop(0);
                        }
                    }
                });
            },
            _searchStyle: function _searchStyle() {
                var e = {
                    begins: "ibegins",
                    startsWith: "ibegins"
                };
                return e[this.options.liveSearchStyle] || "icontains";
            },
            val: function val(e) {
                return "undefined" != typeof e ? (this.$element.val(e), this.render(), this.$element) : this.$element.val();
            },
            changeAll: function changeAll(t) {
                if (this.multiple) {
                    "undefined" == typeof t && (t = !0), this.findLis();
                    var i = this.$element.find("option"),
                        n = this.$lis.not(".divider, .dropdown-header, .disabled, .hidden"),
                        s = n.length,
                        o = [];
                    if (t) {
                        if (n.filter(".selected").length === n.length) return;
                    } else if (0 === n.filter(".selected").length) return;
                    n.toggleClass("selected", t);
                    for (var a = 0; s > a; a++) {
                        var l = n[a].getAttribute("data-original-index");
                        o[o.length] = i.eq(l)[0];
                    }
                    e(o).prop("selected", t), this.render(!1), this.togglePlaceholder(), this.$element.triggerNative("change");
                }
            },
            selectAll: function selectAll() {
                return this.changeAll(!0);
            },
            deselectAll: function deselectAll() {
                return this.changeAll(!1);
            },
            toggle: function toggle(e) {
                e = e || window.event, e && e.stopPropagation(), this.$button.trigger("click");
            },
            keydown: function keydown(t) {
                var i,
                    n,
                    s,
                    o,
                    a = e(this),
                    l = a.is("input") ? a.parent().parent() : a.parent(),
                    r = l.data("this"),
                    d = ":not(.disabled, .hidden, .dropdown-header, .divider)",
                    h = {
                    32: " ",
                    48: "0",
                    49: "1",
                    50: "2",
                    51: "3",
                    52: "4",
                    53: "5",
                    54: "6",
                    55: "7",
                    56: "8",
                    57: "9",
                    59: ";",
                    65: "a",
                    66: "b",
                    67: "c",
                    68: "d",
                    69: "e",
                    70: "f",
                    71: "g",
                    72: "h",
                    73: "i",
                    74: "j",
                    75: "k",
                    76: "l",
                    77: "m",
                    78: "n",
                    79: "o",
                    80: "p",
                    81: "q",
                    82: "r",
                    83: "s",
                    84: "t",
                    85: "u",
                    86: "v",
                    87: "w",
                    88: "x",
                    89: "y",
                    90: "z",
                    96: "0",
                    97: "1",
                    98: "2",
                    99: "3",
                    100: "4",
                    101: "5",
                    102: "6",
                    103: "7",
                    104: "8",
                    105: "9"
                };
                if (o = r.$newElement.hasClass("open"), !o && (t.keyCode >= 48 && t.keyCode <= 57 || t.keyCode >= 96 && t.keyCode <= 105 || t.keyCode >= 65 && t.keyCode <= 90)) return r.options.container ? r.$button.trigger("click") : (r.setSize(), r.$menu.parent().addClass("open"), o = !0), void r.$searchbox.focus();
                if (r.options.liveSearch && /(^9$|27)/.test(t.keyCode.toString(10)) && o && (t.preventDefault(), t.stopPropagation(), r.$menuInner.click(), r.$button.focus()), /(38|40)/.test(t.keyCode.toString(10))) {
                    if (i = r.$lis.filter(d), !i.length) return;
                    n = r.options.liveSearch ? i.index(i.filter(".active")) : i.index(i.find("span.dropdown-item-inner").filter(":focus").parent()), s = r.$menuInner.data("prevIndex"), 38 == t.keyCode ? (!r.options.liveSearch && n != s || -1 == n || n--, 0 > n && (n += i.length)) : 40 == t.keyCode && ((r.options.liveSearch || n == s) && n++, n %= i.length), r.$menuInner.data("prevIndex", n), r.options.liveSearch ? (t.preventDefault(), a.hasClass("dropdown-toggle") || (i.removeClass("active").eq(n).addClass("active").children("span.dropdown-item-inner").focus(), a.focus())) : i.eq(n).children("span.dropdown-item-inner").focus();
                } else if (!a.is("input")) {
                    var c,
                        p,
                        u = [];
                    i = r.$lis.filter(d), i.each(function (i) {
                        e.trim(e(this).children("span.dropdown-item-inner").text().toLowerCase()).substring(0, 1) == h[t.keyCode] && u.push(i);
                    }), c = e(document).data("keycount"), c++, e(document).data("keycount", c), p = e.trim(e(":focus").text().toLowerCase()).substring(0, 1), p != h[t.keyCode] ? (c = 1, e(document).data("keycount", c)) : c >= u.length && (e(document).data("keycount", 0), c > u.length && (c = 1)), i.eq(u[c - 1]).children("span.dropdown-item-inner").focus();
                }
                if ((/(13|32)/.test(t.keyCode.toString(10)) || /(^9$)/.test(t.keyCode.toString(10)) && r.options.selectOnTab) && o) {
                    if (/(32)/.test(t.keyCode.toString(10)) || t.preventDefault(), r.options.liveSearch) /(32)/.test(t.keyCode.toString(10)) || (r.$menuInner.find(".active a").click(), a.focus());else {
                        var f = e(":focus");
                        f.click(), f.focus(), t.preventDefault(), e(document).data("spaceSelect", !0);
                    }
                    e(document).data("keycount", 0);
                }(/(^9$|27)/.test(t.keyCode.toString(10)) && o && (r.multiple || r.options.liveSearch) || /(27)/.test(t.keyCode.toString(10)) && !o) && (r.$menu.parent().removeClass("open"), r.options.container && r.$newElement.removeClass("open"), r.$button.focus());
            },
            mobile: function mobile() {
                this.$element.addClass("mobile-device");
            },
            refresh: function refresh() {
                this.$lis = null, this.liObj = {}, this.reloadLi(), this.render(), this.checkDisabled(), this.liHeight(!0), this.setStyle(), this.setWidth(), this.$lis && this.$searchbox.trigger("propertychange"), this.$element.trigger("refreshed.bs.select");
            },
            hide: function hide() {
                this.$newElement.hide();
            },
            show: function show() {
                this.$newElement.show();
            },
            remove: function remove() {
                this.$newElement.remove(), this.$element.remove();
            },
            destroy: function destroy() {
                this.$newElement.before(this.$element).remove(), this.$bsContainer ? this.$bsContainer.remove() : this.$menu.remove(), this.$element.off(".bs.select").removeData("selectpicker").removeClass("bs-select-hidden selectpicker");
            }
        };
        var c = e.fn.selectpicker;
        e.fn.selectpicker = i, e.fn.selectpicker.Constructor = h, e.fn.selectpicker.noConflict = function () {
            return e.fn.selectpicker = c, this;
        }, e(document).data("keycount", 0).on("keydown.bs.select", '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input', h.prototype.keydown).on("focusin.modal", '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input', function (e) {
            e.stopPropagation();
        }), e(window).on("load.bs.select.data-api", function () {
            e(".selectpicker").each(function () {
                var t = e(this);
                i.call(t, t.data());
            });
        });
    }(e);
});

/***/ }),

/***/ 70:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.0
 *
 * Copyright 2017 Nick Downie
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
(function (f) {
	if (( false ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
		module.exports = f();
	} else if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		var g;if (typeof window !== "undefined") {
			g = window;
		} else if (typeof global !== "undefined") {
			g = global;
		} else if (typeof self !== "undefined") {
			g = self;
		} else {
			g = this;
		}g.Chart = f();
	}
})(function () {
	var define, module, exports;return function e(t, n, r) {
		function s(o, u) {
			if (!n[o]) {
				if (!t[o]) {
					var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
				}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
					var n = t[o][1][e];return s(n ? n : e);
				}, l, l.exports, e, t, n, r);
			}return n[o].exports;
		}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
			s(r[o]);
		}return s;
	}({ 1: [function (require, module, exports) {}, {}], 2: [function (require, module, exports) {
			/* MIT license */
			var colorNames = require(6);

			module.exports = {
				getRgba: getRgba,
				getHsla: getHsla,
				getRgb: getRgb,
				getHsl: getHsl,
				getHwb: getHwb,
				getAlpha: getAlpha,

				hexString: hexString,
				rgbString: rgbString,
				rgbaString: rgbaString,
				percentString: percentString,
				percentaString: percentaString,
				hslString: hslString,
				hslaString: hslaString,
				hwbString: hwbString,
				keyword: keyword
			};

			function getRgba(string) {
				if (!string) {
					return;
				}
				var abbr = /^#([a-fA-F0-9]{3})$/i,
				    hex = /^#([a-fA-F0-9]{6})$/i,
				    rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
				    per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
				    keyword = /(\w+)/;

				var rgb = [0, 0, 0],
				    a = 1,
				    match = string.match(abbr);
				if (match) {
					match = match[1];
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = parseInt(match[i] + match[i], 16);
					}
				} else if (match = string.match(hex)) {
					match = match[1];
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
					}
				} else if (match = string.match(rgba)) {
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = parseInt(match[i + 1]);
					}
					a = parseFloat(match[4]);
				} else if (match = string.match(per)) {
					for (var i = 0; i < rgb.length; i++) {
						rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
					}
					a = parseFloat(match[4]);
				} else if (match = string.match(keyword)) {
					if (match[1] == "transparent") {
						return [0, 0, 0, 0];
					}
					rgb = colorNames[match[1]];
					if (!rgb) {
						return;
					}
				}

				for (var i = 0; i < rgb.length; i++) {
					rgb[i] = scale(rgb[i], 0, 255);
				}
				if (!a && a != 0) {
					a = 1;
				} else {
					a = scale(a, 0, 1);
				}
				rgb[3] = a;
				return rgb;
			}

			function getHsla(string) {
				if (!string) {
					return;
				}
				var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
				var match = string.match(hsl);
				if (match) {
					var alpha = parseFloat(match[4]);
					var h = scale(parseInt(match[1]), 0, 360),
					    s = scale(parseFloat(match[2]), 0, 100),
					    l = scale(parseFloat(match[3]), 0, 100),
					    a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
					return [h, s, l, a];
				}
			}

			function getHwb(string) {
				if (!string) {
					return;
				}
				var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
				var match = string.match(hwb);
				if (match) {
					var alpha = parseFloat(match[4]);
					var h = scale(parseInt(match[1]), 0, 360),
					    w = scale(parseFloat(match[2]), 0, 100),
					    b = scale(parseFloat(match[3]), 0, 100),
					    a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
					return [h, w, b, a];
				}
			}

			function getRgb(string) {
				var rgba = getRgba(string);
				return rgba && rgba.slice(0, 3);
			}

			function getHsl(string) {
				var hsla = getHsla(string);
				return hsla && hsla.slice(0, 3);
			}

			function getAlpha(string) {
				var vals = getRgba(string);
				if (vals) {
					return vals[3];
				} else if (vals = getHsla(string)) {
					return vals[3];
				} else if (vals = getHwb(string)) {
					return vals[3];
				}
			}

			// generators
			function hexString(rgb) {
				return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
			}

			function rgbString(rgba, alpha) {
				if (alpha < 1 || rgba[3] && rgba[3] < 1) {
					return rgbaString(rgba, alpha);
				}
				return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
			}

			function rgbaString(rgba, alpha) {
				if (alpha === undefined) {
					alpha = rgba[3] !== undefined ? rgba[3] : 1;
				}
				return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
			}

			function percentString(rgba, alpha) {
				if (alpha < 1 || rgba[3] && rgba[3] < 1) {
					return percentaString(rgba, alpha);
				}
				var r = Math.round(rgba[0] / 255 * 100),
				    g = Math.round(rgba[1] / 255 * 100),
				    b = Math.round(rgba[2] / 255 * 100);

				return "rgb(" + r + "%, " + g + "%, " + b + "%)";
			}

			function percentaString(rgba, alpha) {
				var r = Math.round(rgba[0] / 255 * 100),
				    g = Math.round(rgba[1] / 255 * 100),
				    b = Math.round(rgba[2] / 255 * 100);
				return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
			}

			function hslString(hsla, alpha) {
				if (alpha < 1 || hsla[3] && hsla[3] < 1) {
					return hslaString(hsla, alpha);
				}
				return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
			}

			function hslaString(hsla, alpha) {
				if (alpha === undefined) {
					alpha = hsla[3] !== undefined ? hsla[3] : 1;
				}
				return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
			}

			// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
			// (hwb have alpha optional & 1 is default value)
			function hwbString(hwb, alpha) {
				if (alpha === undefined) {
					alpha = hwb[3] !== undefined ? hwb[3] : 1;
				}
				return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
			}

			function keyword(rgb) {
				return reverseNames[rgb.slice(0, 3)];
			}

			// helpers
			function scale(num, min, max) {
				return Math.min(Math.max(min, num), max);
			}

			function hexDouble(num) {
				var str = num.toString(16).toUpperCase();
				return str.length < 2 ? "0" + str : str;
			}

			//create a list of reverse color names
			var reverseNames = {};
			for (var name in colorNames) {
				reverseNames[colorNames[name]] = name;
			}
		}, { "6": 6 }], 3: [function (require, module, exports) {
			/* MIT license */
			var convert = require(5);
			var string = require(2);

			var Color = function Color(obj) {
				if (obj instanceof Color) {
					return obj;
				}
				if (!(this instanceof Color)) {
					return new Color(obj);
				}

				this.valid = false;
				this.values = {
					rgb: [0, 0, 0],
					hsl: [0, 0, 0],
					hsv: [0, 0, 0],
					hwb: [0, 0, 0],
					cmyk: [0, 0, 0, 0],
					alpha: 1
				};

				// parse Color() argument
				var vals;
				if (typeof obj === 'string') {
					vals = string.getRgba(obj);
					if (vals) {
						this.setValues('rgb', vals);
					} else if (vals = string.getHsla(obj)) {
						this.setValues('hsl', vals);
					} else if (vals = string.getHwb(obj)) {
						this.setValues('hwb', vals);
					}
				} else if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object') {
					vals = obj;
					if (vals.r !== undefined || vals.red !== undefined) {
						this.setValues('rgb', vals);
					} else if (vals.l !== undefined || vals.lightness !== undefined) {
						this.setValues('hsl', vals);
					} else if (vals.v !== undefined || vals.value !== undefined) {
						this.setValues('hsv', vals);
					} else if (vals.w !== undefined || vals.whiteness !== undefined) {
						this.setValues('hwb', vals);
					} else if (vals.c !== undefined || vals.cyan !== undefined) {
						this.setValues('cmyk', vals);
					}
				}
			};

			Color.prototype = {
				isValid: function isValid() {
					return this.valid;
				},
				rgb: function rgb() {
					return this.setSpace('rgb', arguments);
				},
				hsl: function hsl() {
					return this.setSpace('hsl', arguments);
				},
				hsv: function hsv() {
					return this.setSpace('hsv', arguments);
				},
				hwb: function hwb() {
					return this.setSpace('hwb', arguments);
				},
				cmyk: function cmyk() {
					return this.setSpace('cmyk', arguments);
				},

				rgbArray: function rgbArray() {
					return this.values.rgb;
				},
				hslArray: function hslArray() {
					return this.values.hsl;
				},
				hsvArray: function hsvArray() {
					return this.values.hsv;
				},
				hwbArray: function hwbArray() {
					var values = this.values;
					if (values.alpha !== 1) {
						return values.hwb.concat([values.alpha]);
					}
					return values.hwb;
				},
				cmykArray: function cmykArray() {
					return this.values.cmyk;
				},
				rgbaArray: function rgbaArray() {
					var values = this.values;
					return values.rgb.concat([values.alpha]);
				},
				hslaArray: function hslaArray() {
					var values = this.values;
					return values.hsl.concat([values.alpha]);
				},
				alpha: function alpha(val) {
					if (val === undefined) {
						return this.values.alpha;
					}
					this.setValues('alpha', val);
					return this;
				},

				red: function red(val) {
					return this.setChannel('rgb', 0, val);
				},
				green: function green(val) {
					return this.setChannel('rgb', 1, val);
				},
				blue: function blue(val) {
					return this.setChannel('rgb', 2, val);
				},
				hue: function hue(val) {
					if (val) {
						val %= 360;
						val = val < 0 ? 360 + val : val;
					}
					return this.setChannel('hsl', 0, val);
				},
				saturation: function saturation(val) {
					return this.setChannel('hsl', 1, val);
				},
				lightness: function lightness(val) {
					return this.setChannel('hsl', 2, val);
				},
				saturationv: function saturationv(val) {
					return this.setChannel('hsv', 1, val);
				},
				whiteness: function whiteness(val) {
					return this.setChannel('hwb', 1, val);
				},
				blackness: function blackness(val) {
					return this.setChannel('hwb', 2, val);
				},
				value: function value(val) {
					return this.setChannel('hsv', 2, val);
				},
				cyan: function cyan(val) {
					return this.setChannel('cmyk', 0, val);
				},
				magenta: function magenta(val) {
					return this.setChannel('cmyk', 1, val);
				},
				yellow: function yellow(val) {
					return this.setChannel('cmyk', 2, val);
				},
				black: function black(val) {
					return this.setChannel('cmyk', 3, val);
				},

				hexString: function hexString() {
					return string.hexString(this.values.rgb);
				},
				rgbString: function rgbString() {
					return string.rgbString(this.values.rgb, this.values.alpha);
				},
				rgbaString: function rgbaString() {
					return string.rgbaString(this.values.rgb, this.values.alpha);
				},
				percentString: function percentString() {
					return string.percentString(this.values.rgb, this.values.alpha);
				},
				hslString: function hslString() {
					return string.hslString(this.values.hsl, this.values.alpha);
				},
				hslaString: function hslaString() {
					return string.hslaString(this.values.hsl, this.values.alpha);
				},
				hwbString: function hwbString() {
					return string.hwbString(this.values.hwb, this.values.alpha);
				},
				keyword: function keyword() {
					return string.keyword(this.values.rgb, this.values.alpha);
				},

				rgbNumber: function rgbNumber() {
					var rgb = this.values.rgb;
					return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
				},

				luminosity: function luminosity() {
					// http://www.w3.org/TR/WCAG20/#relativeluminancedef
					var rgb = this.values.rgb;
					var lum = [];
					for (var i = 0; i < rgb.length; i++) {
						var chan = rgb[i] / 255;
						lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
					}
					return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
				},

				contrast: function contrast(color2) {
					// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
					var lum1 = this.luminosity();
					var lum2 = color2.luminosity();
					if (lum1 > lum2) {
						return (lum1 + 0.05) / (lum2 + 0.05);
					}
					return (lum2 + 0.05) / (lum1 + 0.05);
				},

				level: function level(color2) {
					var contrastRatio = this.contrast(color2);
					if (contrastRatio >= 7.1) {
						return 'AAA';
					}

					return contrastRatio >= 4.5 ? 'AA' : '';
				},

				dark: function dark() {
					// YIQ equation from http://24ways.org/2010/calculating-color-contrast
					var rgb = this.values.rgb;
					var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
					return yiq < 128;
				},

				light: function light() {
					return !this.dark();
				},

				negate: function negate() {
					var rgb = [];
					for (var i = 0; i < 3; i++) {
						rgb[i] = 255 - this.values.rgb[i];
					}
					this.setValues('rgb', rgb);
					return this;
				},

				lighten: function lighten(ratio) {
					var hsl = this.values.hsl;
					hsl[2] += hsl[2] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				darken: function darken(ratio) {
					var hsl = this.values.hsl;
					hsl[2] -= hsl[2] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				saturate: function saturate(ratio) {
					var hsl = this.values.hsl;
					hsl[1] += hsl[1] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				desaturate: function desaturate(ratio) {
					var hsl = this.values.hsl;
					hsl[1] -= hsl[1] * ratio;
					this.setValues('hsl', hsl);
					return this;
				},

				whiten: function whiten(ratio) {
					var hwb = this.values.hwb;
					hwb[1] += hwb[1] * ratio;
					this.setValues('hwb', hwb);
					return this;
				},

				blacken: function blacken(ratio) {
					var hwb = this.values.hwb;
					hwb[2] += hwb[2] * ratio;
					this.setValues('hwb', hwb);
					return this;
				},

				greyscale: function greyscale() {
					var rgb = this.values.rgb;
					// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
					var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
					this.setValues('rgb', [val, val, val]);
					return this;
				},

				clearer: function clearer(ratio) {
					var alpha = this.values.alpha;
					this.setValues('alpha', alpha - alpha * ratio);
					return this;
				},

				opaquer: function opaquer(ratio) {
					var alpha = this.values.alpha;
					this.setValues('alpha', alpha + alpha * ratio);
					return this;
				},

				rotate: function rotate(degrees) {
					var hsl = this.values.hsl;
					var hue = (hsl[0] + degrees) % 360;
					hsl[0] = hue < 0 ? 360 + hue : hue;
					this.setValues('hsl', hsl);
					return this;
				},

				/**
     * Ported from sass implementation in C
     * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
     */
				mix: function mix(mixinColor, weight) {
					var color1 = this;
					var color2 = mixinColor;
					var p = weight === undefined ? 0.5 : weight;

					var w = 2 * p - 1;
					var a = color1.alpha() - color2.alpha();

					var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
					var w2 = 1 - w1;

					return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
				},

				toJSON: function toJSON() {
					return this.rgb();
				},

				clone: function clone() {
					// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
					// making the final build way to big to embed in Chart.js. So let's do it manually,
					// assuming that values to clone are 1 dimension arrays containing only numbers,
					// except 'alpha' which is a number.
					var result = new Color();
					var source = this.values;
					var target = result.values;
					var value, type;

					for (var prop in source) {
						if (source.hasOwnProperty(prop)) {
							value = source[prop];
							type = {}.toString.call(value);
							if (type === '[object Array]') {
								target[prop] = value.slice(0);
							} else if (type === '[object Number]') {
								target[prop] = value;
							} else {
								console.error('unexpected color value:', value);
							}
						}
					}

					return result;
				}
			};

			Color.prototype.spaces = {
				rgb: ['red', 'green', 'blue'],
				hsl: ['hue', 'saturation', 'lightness'],
				hsv: ['hue', 'saturation', 'value'],
				hwb: ['hue', 'whiteness', 'blackness'],
				cmyk: ['cyan', 'magenta', 'yellow', 'black']
			};

			Color.prototype.maxes = {
				rgb: [255, 255, 255],
				hsl: [360, 100, 100],
				hsv: [360, 100, 100],
				hwb: [360, 100, 100],
				cmyk: [100, 100, 100, 100]
			};

			Color.prototype.getValues = function (space) {
				var values = this.values;
				var vals = {};

				for (var i = 0; i < space.length; i++) {
					vals[space.charAt(i)] = values[space][i];
				}

				if (values.alpha !== 1) {
					vals.a = values.alpha;
				}

				// {r: 255, g: 255, b: 255, a: 0.4}
				return vals;
			};

			Color.prototype.setValues = function (space, vals) {
				var values = this.values;
				var spaces = this.spaces;
				var maxes = this.maxes;
				var alpha = 1;
				var i;

				this.valid = true;

				if (space === 'alpha') {
					alpha = vals;
				} else if (vals.length) {
					// [10, 10, 10]
					values[space] = vals.slice(0, space.length);
					alpha = vals[space.length];
				} else if (vals[space.charAt(0)] !== undefined) {
					// {r: 10, g: 10, b: 10}
					for (i = 0; i < space.length; i++) {
						values[space][i] = vals[space.charAt(i)];
					}

					alpha = vals.a;
				} else if (vals[spaces[space][0]] !== undefined) {
					// {red: 10, green: 10, blue: 10}
					var chans = spaces[space];

					for (i = 0; i < space.length; i++) {
						values[space][i] = vals[chans[i]];
					}

					alpha = vals.alpha;
				}

				values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

				if (space === 'alpha') {
					return false;
				}

				var capped;

				// cap values of the space prior converting all values
				for (i = 0; i < space.length; i++) {
					capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
					values[space][i] = Math.round(capped);
				}

				// convert to all the other color spaces
				for (var sname in spaces) {
					if (sname !== space) {
						values[sname] = convert[space][sname](values[space]);
					}
				}

				return true;
			};

			Color.prototype.setSpace = function (space, args) {
				var vals = args[0];

				if (vals === undefined) {
					// color.rgb()
					return this.getValues(space);
				}

				// color.rgb(10, 10, 10)
				if (typeof vals === 'number') {
					vals = Array.prototype.slice.call(args);
				}

				this.setValues(space, vals);
				return this;
			};

			Color.prototype.setChannel = function (space, index, val) {
				var svalues = this.values[space];
				if (val === undefined) {
					// color.red()
					return svalues[index];
				} else if (val === svalues[index]) {
					// color.red(color.red())
					return this;
				}

				// color.red(100)
				svalues[index] = val;
				this.setValues(space, svalues);

				return this;
			};

			if (typeof window !== 'undefined') {
				window.Color = Color;
			}

			module.exports = Color;
		}, { "2": 2, "5": 5 }], 4: [function (require, module, exports) {
			/* MIT license */

			module.exports = {
				rgb2hsl: rgb2hsl,
				rgb2hsv: rgb2hsv,
				rgb2hwb: rgb2hwb,
				rgb2cmyk: rgb2cmyk,
				rgb2keyword: rgb2keyword,
				rgb2xyz: rgb2xyz,
				rgb2lab: rgb2lab,
				rgb2lch: rgb2lch,

				hsl2rgb: hsl2rgb,
				hsl2hsv: hsl2hsv,
				hsl2hwb: hsl2hwb,
				hsl2cmyk: hsl2cmyk,
				hsl2keyword: hsl2keyword,

				hsv2rgb: hsv2rgb,
				hsv2hsl: hsv2hsl,
				hsv2hwb: hsv2hwb,
				hsv2cmyk: hsv2cmyk,
				hsv2keyword: hsv2keyword,

				hwb2rgb: hwb2rgb,
				hwb2hsl: hwb2hsl,
				hwb2hsv: hwb2hsv,
				hwb2cmyk: hwb2cmyk,
				hwb2keyword: hwb2keyword,

				cmyk2rgb: cmyk2rgb,
				cmyk2hsl: cmyk2hsl,
				cmyk2hsv: cmyk2hsv,
				cmyk2hwb: cmyk2hwb,
				cmyk2keyword: cmyk2keyword,

				keyword2rgb: keyword2rgb,
				keyword2hsl: keyword2hsl,
				keyword2hsv: keyword2hsv,
				keyword2hwb: keyword2hwb,
				keyword2cmyk: keyword2cmyk,
				keyword2lab: keyword2lab,
				keyword2xyz: keyword2xyz,

				xyz2rgb: xyz2rgb,
				xyz2lab: xyz2lab,
				xyz2lch: xyz2lch,

				lab2xyz: lab2xyz,
				lab2rgb: lab2rgb,
				lab2lch: lab2lch,

				lch2lab: lch2lab,
				lch2xyz: lch2xyz,
				lch2rgb: lch2rgb
			};

			function rgb2hsl(rgb) {
				var r = rgb[0] / 255,
				    g = rgb[1] / 255,
				    b = rgb[2] / 255,
				    min = Math.min(r, g, b),
				    max = Math.max(r, g, b),
				    delta = max - min,
				    h,
				    s,
				    l;

				if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;

				h = Math.min(h * 60, 360);

				if (h < 0) h += 360;

				l = (min + max) / 2;

				if (max == min) s = 0;else if (l <= 0.5) s = delta / (max + min);else s = delta / (2 - max - min);

				return [h, s * 100, l * 100];
			}

			function rgb2hsv(rgb) {
				var r = rgb[0],
				    g = rgb[1],
				    b = rgb[2],
				    min = Math.min(r, g, b),
				    max = Math.max(r, g, b),
				    delta = max - min,
				    h,
				    s,
				    v;

				if (max == 0) s = 0;else s = delta / max * 1000 / 10;

				if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;

				h = Math.min(h * 60, 360);

				if (h < 0) h += 360;

				v = max / 255 * 1000 / 10;

				return [h, s, v];
			}

			function rgb2hwb(rgb) {
				var r = rgb[0],
				    g = rgb[1],
				    b = rgb[2],
				    h = rgb2hsl(rgb)[0],
				    w = 1 / 255 * Math.min(r, Math.min(g, b)),
				    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

				return [h, w * 100, b * 100];
			}

			function rgb2cmyk(rgb) {
				var r = rgb[0] / 255,
				    g = rgb[1] / 255,
				    b = rgb[2] / 255,
				    c,
				    m,
				    y,
				    k;

				k = Math.min(1 - r, 1 - g, 1 - b);
				c = (1 - r - k) / (1 - k) || 0;
				m = (1 - g - k) / (1 - k) || 0;
				y = (1 - b - k) / (1 - k) || 0;
				return [c * 100, m * 100, y * 100, k * 100];
			}

			function rgb2keyword(rgb) {
				return reverseKeywords[JSON.stringify(rgb)];
			}

			function rgb2xyz(rgb) {
				var r = rgb[0] / 255,
				    g = rgb[1] / 255,
				    b = rgb[2] / 255;

				// assume sRGB
				r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
				g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
				b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

				var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
				var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
				var z = r * 0.0193 + g * 0.1192 + b * 0.9505;

				return [x * 100, y * 100, z * 100];
			}

			function rgb2lab(rgb) {
				var xyz = rgb2xyz(rgb),
				    x = xyz[0],
				    y = xyz[1],
				    z = xyz[2],
				    l,
				    a,
				    b;

				x /= 95.047;
				y /= 100;
				z /= 108.883;

				x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
				y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
				z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

				l = 116 * y - 16;
				a = 500 * (x - y);
				b = 200 * (y - z);

				return [l, a, b];
			}

			function rgb2lch(args) {
				return lab2lch(rgb2lab(args));
			}

			function hsl2rgb(hsl) {
				var h = hsl[0] / 360,
				    s = hsl[1] / 100,
				    l = hsl[2] / 100,
				    t1,
				    t2,
				    t3,
				    rgb,
				    val;

				if (s == 0) {
					val = l * 255;
					return [val, val, val];
				}

				if (l < 0.5) t2 = l * (1 + s);else t2 = l + s - l * s;
				t1 = 2 * l - t2;

				rgb = [0, 0, 0];
				for (var i = 0; i < 3; i++) {
					t3 = h + 1 / 3 * -(i - 1);
					t3 < 0 && t3++;
					t3 > 1 && t3--;

					if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;else if (2 * t3 < 1) val = t2;else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;else val = t1;

					rgb[i] = val * 255;
				}

				return rgb;
			}

			function hsl2hsv(hsl) {
				var h = hsl[0],
				    s = hsl[1] / 100,
				    l = hsl[2] / 100,
				    sv,
				    v;

				if (l === 0) {
					// no need to do calc on black
					// also avoids divide by 0 error
					return [0, 0, 0];
				}

				l *= 2;
				s *= l <= 1 ? l : 2 - l;
				v = (l + s) / 2;
				sv = 2 * s / (l + s);
				return [h, sv * 100, v * 100];
			}

			function hsl2hwb(args) {
				return rgb2hwb(hsl2rgb(args));
			}

			function hsl2cmyk(args) {
				return rgb2cmyk(hsl2rgb(args));
			}

			function hsl2keyword(args) {
				return rgb2keyword(hsl2rgb(args));
			}

			function hsv2rgb(hsv) {
				var h = hsv[0] / 60,
				    s = hsv[1] / 100,
				    v = hsv[2] / 100,
				    hi = Math.floor(h) % 6;

				var f = h - Math.floor(h),
				    p = 255 * v * (1 - s),
				    q = 255 * v * (1 - s * f),
				    t = 255 * v * (1 - s * (1 - f)),
				    v = 255 * v;

				switch (hi) {
					case 0:
						return [v, t, p];
					case 1:
						return [q, v, p];
					case 2:
						return [p, v, t];
					case 3:
						return [p, q, v];
					case 4:
						return [t, p, v];
					case 5:
						return [v, p, q];
				}
			}

			function hsv2hsl(hsv) {
				var h = hsv[0],
				    s = hsv[1] / 100,
				    v = hsv[2] / 100,
				    sl,
				    l;

				l = (2 - s) * v;
				sl = s * v;
				sl /= l <= 1 ? l : 2 - l;
				sl = sl || 0;
				l /= 2;
				return [h, sl * 100, l * 100];
			}

			function hsv2hwb(args) {
				return rgb2hwb(hsv2rgb(args));
			}

			function hsv2cmyk(args) {
				return rgb2cmyk(hsv2rgb(args));
			}

			function hsv2keyword(args) {
				return rgb2keyword(hsv2rgb(args));
			}

			// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
			function hwb2rgb(hwb) {
				var h = hwb[0] / 360,
				    wh = hwb[1] / 100,
				    bl = hwb[2] / 100,
				    ratio = wh + bl,
				    i,
				    v,
				    f,
				    n;

				// wh + bl cant be > 1
				if (ratio > 1) {
					wh /= ratio;
					bl /= ratio;
				}

				i = Math.floor(6 * h);
				v = 1 - bl;
				f = 6 * h - i;
				if ((i & 0x01) != 0) {
					f = 1 - f;
				}
				n = wh + f * (v - wh); // linear interpolation

				switch (i) {
					default:
					case 6:
					case 0:
						r = v;g = n;b = wh;break;
					case 1:
						r = n;g = v;b = wh;break;
					case 2:
						r = wh;g = v;b = n;break;
					case 3:
						r = wh;g = n;b = v;break;
					case 4:
						r = n;g = wh;b = v;break;
					case 5:
						r = v;g = wh;b = n;break;
				}

				return [r * 255, g * 255, b * 255];
			}

			function hwb2hsl(args) {
				return rgb2hsl(hwb2rgb(args));
			}

			function hwb2hsv(args) {
				return rgb2hsv(hwb2rgb(args));
			}

			function hwb2cmyk(args) {
				return rgb2cmyk(hwb2rgb(args));
			}

			function hwb2keyword(args) {
				return rgb2keyword(hwb2rgb(args));
			}

			function cmyk2rgb(cmyk) {
				var c = cmyk[0] / 100,
				    m = cmyk[1] / 100,
				    y = cmyk[2] / 100,
				    k = cmyk[3] / 100,
				    r,
				    g,
				    b;

				r = 1 - Math.min(1, c * (1 - k) + k);
				g = 1 - Math.min(1, m * (1 - k) + k);
				b = 1 - Math.min(1, y * (1 - k) + k);
				return [r * 255, g * 255, b * 255];
			}

			function cmyk2hsl(args) {
				return rgb2hsl(cmyk2rgb(args));
			}

			function cmyk2hsv(args) {
				return rgb2hsv(cmyk2rgb(args));
			}

			function cmyk2hwb(args) {
				return rgb2hwb(cmyk2rgb(args));
			}

			function cmyk2keyword(args) {
				return rgb2keyword(cmyk2rgb(args));
			}

			function xyz2rgb(xyz) {
				var x = xyz[0] / 100,
				    y = xyz[1] / 100,
				    z = xyz[2] / 100,
				    r,
				    g,
				    b;

				r = x * 3.2406 + y * -1.5372 + z * -0.4986;
				g = x * -0.9689 + y * 1.8758 + z * 0.0415;
				b = x * 0.0557 + y * -0.2040 + z * 1.0570;

				// assume sRGB
				r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;

				g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;

				b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;

				r = Math.min(Math.max(0, r), 1);
				g = Math.min(Math.max(0, g), 1);
				b = Math.min(Math.max(0, b), 1);

				return [r * 255, g * 255, b * 255];
			}

			function xyz2lab(xyz) {
				var x = xyz[0],
				    y = xyz[1],
				    z = xyz[2],
				    l,
				    a,
				    b;

				x /= 95.047;
				y /= 100;
				z /= 108.883;

				x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
				y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
				z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

				l = 116 * y - 16;
				a = 500 * (x - y);
				b = 200 * (y - z);

				return [l, a, b];
			}

			function xyz2lch(args) {
				return lab2lch(xyz2lab(args));
			}

			function lab2xyz(lab) {
				var l = lab[0],
				    a = lab[1],
				    b = lab[2],
				    x,
				    y,
				    z,
				    y2;

				if (l <= 8) {
					y = l * 100 / 903.3;
					y2 = 7.787 * (y / 100) + 16 / 116;
				} else {
					y = 100 * Math.pow((l + 16) / 116, 3);
					y2 = Math.pow(y / 100, 1 / 3);
				}

				x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);

				z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);

				return [x, y, z];
			}

			function lab2lch(lab) {
				var l = lab[0],
				    a = lab[1],
				    b = lab[2],
				    hr,
				    h,
				    c;

				hr = Math.atan2(b, a);
				h = hr * 360 / 2 / Math.PI;
				if (h < 0) {
					h += 360;
				}
				c = Math.sqrt(a * a + b * b);
				return [l, c, h];
			}

			function lab2rgb(args) {
				return xyz2rgb(lab2xyz(args));
			}

			function lch2lab(lch) {
				var l = lch[0],
				    c = lch[1],
				    h = lch[2],
				    a,
				    b,
				    hr;

				hr = h / 360 * 2 * Math.PI;
				a = c * Math.cos(hr);
				b = c * Math.sin(hr);
				return [l, a, b];
			}

			function lch2xyz(args) {
				return lab2xyz(lch2lab(args));
			}

			function lch2rgb(args) {
				return lab2rgb(lch2lab(args));
			}

			function keyword2rgb(keyword) {
				return cssKeywords[keyword];
			}

			function keyword2hsl(args) {
				return rgb2hsl(keyword2rgb(args));
			}

			function keyword2hsv(args) {
				return rgb2hsv(keyword2rgb(args));
			}

			function keyword2hwb(args) {
				return rgb2hwb(keyword2rgb(args));
			}

			function keyword2cmyk(args) {
				return rgb2cmyk(keyword2rgb(args));
			}

			function keyword2lab(args) {
				return rgb2lab(keyword2rgb(args));
			}

			function keyword2xyz(args) {
				return rgb2xyz(keyword2rgb(args));
			}

			var cssKeywords = {
				aliceblue: [240, 248, 255],
				antiquewhite: [250, 235, 215],
				aqua: [0, 255, 255],
				aquamarine: [127, 255, 212],
				azure: [240, 255, 255],
				beige: [245, 245, 220],
				bisque: [255, 228, 196],
				black: [0, 0, 0],
				blanchedalmond: [255, 235, 205],
				blue: [0, 0, 255],
				blueviolet: [138, 43, 226],
				brown: [165, 42, 42],
				burlywood: [222, 184, 135],
				cadetblue: [95, 158, 160],
				chartreuse: [127, 255, 0],
				chocolate: [210, 105, 30],
				coral: [255, 127, 80],
				cornflowerblue: [100, 149, 237],
				cornsilk: [255, 248, 220],
				crimson: [220, 20, 60],
				cyan: [0, 255, 255],
				darkblue: [0, 0, 139],
				darkcyan: [0, 139, 139],
				darkgoldenrod: [184, 134, 11],
				darkgray: [169, 169, 169],
				darkgreen: [0, 100, 0],
				darkgrey: [169, 169, 169],
				darkkhaki: [189, 183, 107],
				darkmagenta: [139, 0, 139],
				darkolivegreen: [85, 107, 47],
				darkorange: [255, 140, 0],
				darkorchid: [153, 50, 204],
				darkred: [139, 0, 0],
				darksalmon: [233, 150, 122],
				darkseagreen: [143, 188, 143],
				darkslateblue: [72, 61, 139],
				darkslategray: [47, 79, 79],
				darkslategrey: [47, 79, 79],
				darkturquoise: [0, 206, 209],
				darkviolet: [148, 0, 211],
				deeppink: [255, 20, 147],
				deepskyblue: [0, 191, 255],
				dimgray: [105, 105, 105],
				dimgrey: [105, 105, 105],
				dodgerblue: [30, 144, 255],
				firebrick: [178, 34, 34],
				floralwhite: [255, 250, 240],
				forestgreen: [34, 139, 34],
				fuchsia: [255, 0, 255],
				gainsboro: [220, 220, 220],
				ghostwhite: [248, 248, 255],
				gold: [255, 215, 0],
				goldenrod: [218, 165, 32],
				gray: [128, 128, 128],
				green: [0, 128, 0],
				greenyellow: [173, 255, 47],
				grey: [128, 128, 128],
				honeydew: [240, 255, 240],
				hotpink: [255, 105, 180],
				indianred: [205, 92, 92],
				indigo: [75, 0, 130],
				ivory: [255, 255, 240],
				khaki: [240, 230, 140],
				lavender: [230, 230, 250],
				lavenderblush: [255, 240, 245],
				lawngreen: [124, 252, 0],
				lemonchiffon: [255, 250, 205],
				lightblue: [173, 216, 230],
				lightcoral: [240, 128, 128],
				lightcyan: [224, 255, 255],
				lightgoldenrodyellow: [250, 250, 210],
				lightgray: [211, 211, 211],
				lightgreen: [144, 238, 144],
				lightgrey: [211, 211, 211],
				lightpink: [255, 182, 193],
				lightsalmon: [255, 160, 122],
				lightseagreen: [32, 178, 170],
				lightskyblue: [135, 206, 250],
				lightslategray: [119, 136, 153],
				lightslategrey: [119, 136, 153],
				lightsteelblue: [176, 196, 222],
				lightyellow: [255, 255, 224],
				lime: [0, 255, 0],
				limegreen: [50, 205, 50],
				linen: [250, 240, 230],
				magenta: [255, 0, 255],
				maroon: [128, 0, 0],
				mediumaquamarine: [102, 205, 170],
				mediumblue: [0, 0, 205],
				mediumorchid: [186, 85, 211],
				mediumpurple: [147, 112, 219],
				mediumseagreen: [60, 179, 113],
				mediumslateblue: [123, 104, 238],
				mediumspringgreen: [0, 250, 154],
				mediumturquoise: [72, 209, 204],
				mediumvioletred: [199, 21, 133],
				midnightblue: [25, 25, 112],
				mintcream: [245, 255, 250],
				mistyrose: [255, 228, 225],
				moccasin: [255, 228, 181],
				navajowhite: [255, 222, 173],
				navy: [0, 0, 128],
				oldlace: [253, 245, 230],
				olive: [128, 128, 0],
				olivedrab: [107, 142, 35],
				orange: [255, 165, 0],
				orangered: [255, 69, 0],
				orchid: [218, 112, 214],
				palegoldenrod: [238, 232, 170],
				palegreen: [152, 251, 152],
				paleturquoise: [175, 238, 238],
				palevioletred: [219, 112, 147],
				papayawhip: [255, 239, 213],
				peachpuff: [255, 218, 185],
				peru: [205, 133, 63],
				pink: [255, 192, 203],
				plum: [221, 160, 221],
				powderblue: [176, 224, 230],
				purple: [128, 0, 128],
				rebeccapurple: [102, 51, 153],
				red: [255, 0, 0],
				rosybrown: [188, 143, 143],
				royalblue: [65, 105, 225],
				saddlebrown: [139, 69, 19],
				salmon: [250, 128, 114],
				sandybrown: [244, 164, 96],
				seagreen: [46, 139, 87],
				seashell: [255, 245, 238],
				sienna: [160, 82, 45],
				silver: [192, 192, 192],
				skyblue: [135, 206, 235],
				slateblue: [106, 90, 205],
				slategray: [112, 128, 144],
				slategrey: [112, 128, 144],
				snow: [255, 250, 250],
				springgreen: [0, 255, 127],
				steelblue: [70, 130, 180],
				tan: [210, 180, 140],
				teal: [0, 128, 128],
				thistle: [216, 191, 216],
				tomato: [255, 99, 71],
				turquoise: [64, 224, 208],
				violet: [238, 130, 238],
				wheat: [245, 222, 179],
				white: [255, 255, 255],
				whitesmoke: [245, 245, 245],
				yellow: [255, 255, 0],
				yellowgreen: [154, 205, 50]
			};

			var reverseKeywords = {};
			for (var key in cssKeywords) {
				reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
			}
		}, {}], 5: [function (require, module, exports) {
			var conversions = require(4);

			var convert = function convert() {
				return new Converter();
			};

			for (var func in conversions) {
				// export Raw versions
				convert[func + "Raw"] = function (func) {
					// accept array or plain args
					return function (arg) {
						if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
						return conversions[func](arg);
					};
				}(func);

				var pair = /(\w+)2(\w+)/.exec(func),
				    from = pair[1],
				    to = pair[2];

				// export rgb2hsl and ["rgb"]["hsl"]
				convert[from] = convert[from] || {};

				convert[from][to] = convert[func] = function (func) {
					return function (arg) {
						if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);

						var val = conversions[func](arg);
						if (typeof val == "string" || val === undefined) return val; // keyword

						for (var i = 0; i < val.length; i++) {
							val[i] = Math.round(val[i]);
						}return val;
					};
				}(func);
			}

			/* Converter does lazy conversion and caching */
			var Converter = function Converter() {
				this.convs = {};
			};

			/* Either get the values for a space or
     set the values for a space, depending on args */
			Converter.prototype.routeSpace = function (space, args) {
				var values = args[0];
				if (values === undefined) {
					// color.rgb()
					return this.getValues(space);
				}
				// color.rgb(10, 10, 10)
				if (typeof values == "number") {
					values = Array.prototype.slice.call(args);
				}

				return this.setValues(space, values);
			};

			/* Set the values for a space, invalidating cache */
			Converter.prototype.setValues = function (space, values) {
				this.space = space;
				this.convs = {};
				this.convs[space] = values;
				return this;
			};

			/* Get the values for a space. If there's already
     a conversion for the space, fetch it, otherwise
     compute it */
			Converter.prototype.getValues = function (space) {
				var vals = this.convs[space];
				if (!vals) {
					var fspace = this.space,
					    from = this.convs[fspace];
					vals = convert[fspace][space](from);

					this.convs[space] = vals;
				}
				return vals;
			};

			["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
				Converter.prototype[space] = function (vals) {
					return this.routeSpace(space, arguments);
				};
			});

			module.exports = convert;
		}, { "4": 4 }], 6: [function (require, module, exports) {
			'use strict';

			module.exports = {
				"aliceblue": [240, 248, 255],
				"antiquewhite": [250, 235, 215],
				"aqua": [0, 255, 255],
				"aquamarine": [127, 255, 212],
				"azure": [240, 255, 255],
				"beige": [245, 245, 220],
				"bisque": [255, 228, 196],
				"black": [0, 0, 0],
				"blanchedalmond": [255, 235, 205],
				"blue": [0, 0, 255],
				"blueviolet": [138, 43, 226],
				"brown": [165, 42, 42],
				"burlywood": [222, 184, 135],
				"cadetblue": [95, 158, 160],
				"chartreuse": [127, 255, 0],
				"chocolate": [210, 105, 30],
				"coral": [255, 127, 80],
				"cornflowerblue": [100, 149, 237],
				"cornsilk": [255, 248, 220],
				"crimson": [220, 20, 60],
				"cyan": [0, 255, 255],
				"darkblue": [0, 0, 139],
				"darkcyan": [0, 139, 139],
				"darkgoldenrod": [184, 134, 11],
				"darkgray": [169, 169, 169],
				"darkgreen": [0, 100, 0],
				"darkgrey": [169, 169, 169],
				"darkkhaki": [189, 183, 107],
				"darkmagenta": [139, 0, 139],
				"darkolivegreen": [85, 107, 47],
				"darkorange": [255, 140, 0],
				"darkorchid": [153, 50, 204],
				"darkred": [139, 0, 0],
				"darksalmon": [233, 150, 122],
				"darkseagreen": [143, 188, 143],
				"darkslateblue": [72, 61, 139],
				"darkslategray": [47, 79, 79],
				"darkslategrey": [47, 79, 79],
				"darkturquoise": [0, 206, 209],
				"darkviolet": [148, 0, 211],
				"deeppink": [255, 20, 147],
				"deepskyblue": [0, 191, 255],
				"dimgray": [105, 105, 105],
				"dimgrey": [105, 105, 105],
				"dodgerblue": [30, 144, 255],
				"firebrick": [178, 34, 34],
				"floralwhite": [255, 250, 240],
				"forestgreen": [34, 139, 34],
				"fuchsia": [255, 0, 255],
				"gainsboro": [220, 220, 220],
				"ghostwhite": [248, 248, 255],
				"gold": [255, 215, 0],
				"goldenrod": [218, 165, 32],
				"gray": [128, 128, 128],
				"green": [0, 128, 0],
				"greenyellow": [173, 255, 47],
				"grey": [128, 128, 128],
				"honeydew": [240, 255, 240],
				"hotpink": [255, 105, 180],
				"indianred": [205, 92, 92],
				"indigo": [75, 0, 130],
				"ivory": [255, 255, 240],
				"khaki": [240, 230, 140],
				"lavender": [230, 230, 250],
				"lavenderblush": [255, 240, 245],
				"lawngreen": [124, 252, 0],
				"lemonchiffon": [255, 250, 205],
				"lightblue": [173, 216, 230],
				"lightcoral": [240, 128, 128],
				"lightcyan": [224, 255, 255],
				"lightgoldenrodyellow": [250, 250, 210],
				"lightgray": [211, 211, 211],
				"lightgreen": [144, 238, 144],
				"lightgrey": [211, 211, 211],
				"lightpink": [255, 182, 193],
				"lightsalmon": [255, 160, 122],
				"lightseagreen": [32, 178, 170],
				"lightskyblue": [135, 206, 250],
				"lightslategray": [119, 136, 153],
				"lightslategrey": [119, 136, 153],
				"lightsteelblue": [176, 196, 222],
				"lightyellow": [255, 255, 224],
				"lime": [0, 255, 0],
				"limegreen": [50, 205, 50],
				"linen": [250, 240, 230],
				"magenta": [255, 0, 255],
				"maroon": [128, 0, 0],
				"mediumaquamarine": [102, 205, 170],
				"mediumblue": [0, 0, 205],
				"mediumorchid": [186, 85, 211],
				"mediumpurple": [147, 112, 219],
				"mediumseagreen": [60, 179, 113],
				"mediumslateblue": [123, 104, 238],
				"mediumspringgreen": [0, 250, 154],
				"mediumturquoise": [72, 209, 204],
				"mediumvioletred": [199, 21, 133],
				"midnightblue": [25, 25, 112],
				"mintcream": [245, 255, 250],
				"mistyrose": [255, 228, 225],
				"moccasin": [255, 228, 181],
				"navajowhite": [255, 222, 173],
				"navy": [0, 0, 128],
				"oldlace": [253, 245, 230],
				"olive": [128, 128, 0],
				"olivedrab": [107, 142, 35],
				"orange": [255, 165, 0],
				"orangered": [255, 69, 0],
				"orchid": [218, 112, 214],
				"palegoldenrod": [238, 232, 170],
				"palegreen": [152, 251, 152],
				"paleturquoise": [175, 238, 238],
				"palevioletred": [219, 112, 147],
				"papayawhip": [255, 239, 213],
				"peachpuff": [255, 218, 185],
				"peru": [205, 133, 63],
				"pink": [255, 192, 203],
				"plum": [221, 160, 221],
				"powderblue": [176, 224, 230],
				"purple": [128, 0, 128],
				"rebeccapurple": [102, 51, 153],
				"red": [255, 0, 0],
				"rosybrown": [188, 143, 143],
				"royalblue": [65, 105, 225],
				"saddlebrown": [139, 69, 19],
				"salmon": [250, 128, 114],
				"sandybrown": [244, 164, 96],
				"seagreen": [46, 139, 87],
				"seashell": [255, 245, 238],
				"sienna": [160, 82, 45],
				"silver": [192, 192, 192],
				"skyblue": [135, 206, 235],
				"slateblue": [106, 90, 205],
				"slategray": [112, 128, 144],
				"slategrey": [112, 128, 144],
				"snow": [255, 250, 250],
				"springgreen": [0, 255, 127],
				"steelblue": [70, 130, 180],
				"tan": [210, 180, 140],
				"teal": [0, 128, 128],
				"thistle": [216, 191, 216],
				"tomato": [255, 99, 71],
				"turquoise": [64, 224, 208],
				"violet": [238, 130, 238],
				"wheat": [245, 222, 179],
				"white": [255, 255, 255],
				"whitesmoke": [245, 245, 245],
				"yellow": [255, 255, 0],
				"yellowgreen": [154, 205, 50]
			};
		}, {}], 7: [function (require, module, exports) {
			/**
    * @namespace Chart
    */
			var Chart = require(29)();

			Chart.helpers = require(45);

			// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
			require(27)(Chart);

			Chart.defaults = require(25);
			Chart.Element = require(26);
			Chart.elements = require(40);
			Chart.Interaction = require(28);
			Chart.platform = require(48);

			require(31)(Chart);
			require(22)(Chart);
			require(23)(Chart);
			require(24)(Chart);
			require(30)(Chart);
			require(33)(Chart);
			require(32)(Chart);
			require(35)(Chart);

			require(54)(Chart);
			require(52)(Chart);
			require(53)(Chart);
			require(55)(Chart);
			require(56)(Chart);
			require(57)(Chart);

			// Controllers must be loaded after elements
			// See Chart.core.datasetController.dataElementType
			require(15)(Chart);
			require(16)(Chart);
			require(17)(Chart);
			require(18)(Chart);
			require(19)(Chart);
			require(20)(Chart);
			require(21)(Chart);

			require(8)(Chart);
			require(9)(Chart);
			require(10)(Chart);
			require(11)(Chart);
			require(12)(Chart);
			require(13)(Chart);
			require(14)(Chart);

			// Loading built-it plugins
			var plugins = [];

			plugins.push(require(49)(Chart), require(50)(Chart), require(51)(Chart));

			Chart.plugins.register(plugins);

			Chart.platform.initialize();

			module.exports = Chart;
			if (typeof window !== 'undefined') {
				window.Chart = Chart;
			}

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.canvas instead.
    * @namespace Chart.canvasHelpers
    * @deprecated since version 2.6.0
    * @todo remove at version 3
    * @private
    */
			Chart.canvasHelpers = Chart.helpers.canvas;
		}, { "10": 10, "11": 11, "12": 12, "13": 13, "14": 14, "15": 15, "16": 16, "17": 17, "18": 18, "19": 19, "20": 20, "21": 21, "22": 22, "23": 23, "24": 24, "25": 25, "26": 26, "27": 27, "28": 28, "29": 29, "30": 30, "31": 31, "32": 32, "33": 33, "35": 35, "40": 40, "45": 45, "48": 48, "49": 49, "50": 50, "51": 51, "52": 52, "53": 53, "54": 54, "55": 55, "56": 56, "57": 57, "8": 8, "9": 9 }], 8: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Bar = function (context, config) {
					config.type = 'bar';

					return new Chart(context, config);
				};
			};
		}, {}], 9: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Bubble = function (context, config) {
					config.type = 'bubble';
					return new Chart(context, config);
				};
			};
		}, {}], 10: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Doughnut = function (context, config) {
					config.type = 'doughnut';

					return new Chart(context, config);
				};
			};
		}, {}], 11: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Line = function (context, config) {
					config.type = 'line';

					return new Chart(context, config);
				};
			};
		}, {}], 12: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.PolarArea = function (context, config) {
					config.type = 'polarArea';

					return new Chart(context, config);
				};
			};
		}, {}], 13: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				Chart.Radar = function (context, config) {
					config.type = 'radar';

					return new Chart(context, config);
				};
			};
		}, {}], 14: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {
				Chart.Scatter = function (context, config) {
					config.type = 'scatter';
					return new Chart(context, config);
				};
			};
		}, {}], 15: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('bar', {
				hover: {
					mode: 'label'
				},

				scales: {
					xAxes: [{
						type: 'category',

						// Specific to Bar Controller
						categoryPercentage: 0.8,
						barPercentage: 0.9,

						// offset settings
						offset: true,

						// grid line settings
						gridLines: {
							offsetGridLines: true
						}
					}],

					yAxes: [{
						type: 'linear'
					}]
				}
			});

			defaults._set('horizontalBar', {
				hover: {
					mode: 'index',
					axis: 'y'
				},

				scales: {
					xAxes: [{
						type: 'linear',
						position: 'bottom'
					}],

					yAxes: [{
						position: 'left',
						type: 'category',

						// Specific to Horizontal Bar Controller
						categoryPercentage: 0.8,
						barPercentage: 0.9,

						// offset settings
						offset: true,

						// grid line settings
						gridLines: {
							offsetGridLines: true
						}
					}]
				},

				elements: {
					rectangle: {
						borderSkipped: 'left'
					}
				},

				tooltips: {
					callbacks: {
						title: function title(item, data) {
							// Pick first xLabel for now
							var title = '';

							if (item.length > 0) {
								if (item[0].yLabel) {
									title = item[0].yLabel;
								} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
									title = data.labels[item[0].index];
								}
							}

							return title;
						},

						label: function label(item, data) {
							var datasetLabel = data.datasets[item.datasetIndex].label || '';
							return datasetLabel + ': ' + item.xLabel;
						}
					},
					mode: 'index',
					axis: 'y'
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.bar = Chart.DatasetController.extend({

					dataElementType: elements.Rectangle,

					initialize: function initialize() {
						var me = this;
						var meta;

						Chart.DatasetController.prototype.initialize.apply(me, arguments);

						meta = me.getMeta();
						meta.stack = me.getDataset().stack;
						meta.bar = true;
					},

					update: function update(reset) {
						var me = this;
						var rects = me.getMeta().data;
						var i, ilen;

						me._ruler = me.getRuler();

						for (i = 0, ilen = rects.length; i < ilen; ++i) {
							me.updateElement(rects[i], i, reset);
						}
					},

					updateElement: function updateElement(rectangle, index, reset) {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var dataset = me.getDataset();
						var custom = rectangle.custom || {};
						var rectangleOptions = chart.options.elements.rectangle;

						rectangle._xScale = me.getScaleForId(meta.xAxisID);
						rectangle._yScale = me.getScaleForId(meta.yAxisID);
						rectangle._datasetIndex = me.index;
						rectangle._index = index;

						rectangle._model = {
							datasetLabel: dataset.label,
							label: chart.data.labels[index],
							borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
							backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
							borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
							borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
						};

						me.updateElementGeometry(rectangle, index, reset);

						rectangle.pivot();
					},

					/**
      * @private
      */
					updateElementGeometry: function updateElementGeometry(rectangle, index, reset) {
						var me = this;
						var model = rectangle._model;
						var vscale = me.getValueScale();
						var base = vscale.getBasePixel();
						var horizontal = vscale.isHorizontal();
						var ruler = me._ruler || me.getRuler();
						var vpixels = me.calculateBarValuePixels(me.index, index);
						var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

						model.horizontal = horizontal;
						model.base = reset ? base : vpixels.base;
						model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
						model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
						model.height = horizontal ? ipixels.size : undefined;
						model.width = horizontal ? undefined : ipixels.size;
					},

					/**
      * @private
      */
					getValueScaleId: function getValueScaleId() {
						return this.getMeta().yAxisID;
					},

					/**
      * @private
      */
					getIndexScaleId: function getIndexScaleId() {
						return this.getMeta().xAxisID;
					},

					/**
      * @private
      */
					getValueScale: function getValueScale() {
						return this.getScaleForId(this.getValueScaleId());
					},

					/**
      * @private
      */
					getIndexScale: function getIndexScale() {
						return this.getScaleForId(this.getIndexScaleId());
					},

					/**
      * Returns the effective number of stacks based on groups and bar visibility.
      * @private
      */
					getStackCount: function getStackCount(last) {
						var me = this;
						var chart = me.chart;
						var scale = me.getIndexScale();
						var stacked = scale.options.stacked;
						var ilen = last === undefined ? chart.data.datasets.length : last + 1;
						var stacks = [];
						var i, meta;

						for (i = 0; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
								stacks.push(meta.stack);
							}
						}

						return stacks.length;
					},

					/**
      * Returns the stack index for the given dataset based on groups and bar visibility.
      * @private
      */
					getStackIndex: function getStackIndex(datasetIndex) {
						return this.getStackCount(datasetIndex) - 1;
					},

					/**
      * @private
      */
					getRuler: function getRuler() {
						var me = this;
						var scale = me.getIndexScale();
						var stackCount = me.getStackCount();
						var datasetIndex = me.index;
						var pixels = [];
						var isHorizontal = scale.isHorizontal();
						var start = isHorizontal ? scale.left : scale.top;
						var end = start + (isHorizontal ? scale.width : scale.height);
						var i, ilen;

						for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
							pixels.push(scale.getPixelForValue(null, i, datasetIndex));
						}

						return {
							pixels: pixels,
							start: start,
							end: end,
							stackCount: stackCount,
							scale: scale
						};
					},

					/**
      * Note: pixel values are not clamped to the scale area.
      * @private
      */
					calculateBarValuePixels: function calculateBarValuePixels(datasetIndex, index) {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var scale = me.getValueScale();
						var datasets = chart.data.datasets;
						var value = scale.getRightValue(datasets[datasetIndex].data[index]);
						var stacked = scale.options.stacked;
						var stack = meta.stack;
						var start = 0;
						var i, imeta, ivalue, base, head, size;

						if (stacked || stacked === undefined && stack !== undefined) {
							for (i = 0; i < datasetIndex; ++i) {
								imeta = chart.getDatasetMeta(i);

								if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {

									ivalue = scale.getRightValue(datasets[i].data[index]);
									if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
										start += ivalue;
									}
								}
							}
						}

						base = scale.getPixelForValue(start);
						head = scale.getPixelForValue(start + value);
						size = (head - base) / 2;

						return {
							size: size,
							base: base,
							head: head,
							center: head + size / 2
						};
					},

					/**
      * @private
      */
					calculateBarIndexPixels: function calculateBarIndexPixels(datasetIndex, index, ruler) {
						var me = this;
						var options = ruler.scale.options;
						var stackIndex = me.getStackIndex(datasetIndex);
						var pixels = ruler.pixels;
						var base = pixels[index];
						var length = pixels.length;
						var start = ruler.start;
						var end = ruler.end;
						var leftSampleSize, rightSampleSize, leftCategorySize, rightCategorySize, fullBarSize, size;

						if (length === 1) {
							leftSampleSize = base > start ? base - start : end - base;
							rightSampleSize = base < end ? end - base : base - start;
						} else {
							if (index > 0) {
								leftSampleSize = (base - pixels[index - 1]) / 2;
								if (index === length - 1) {
									rightSampleSize = leftSampleSize;
								}
							}
							if (index < length - 1) {
								rightSampleSize = (pixels[index + 1] - base) / 2;
								if (index === 0) {
									leftSampleSize = rightSampleSize;
								}
							}
						}

						leftCategorySize = leftSampleSize * options.categoryPercentage;
						rightCategorySize = rightSampleSize * options.categoryPercentage;
						fullBarSize = (leftCategorySize + rightCategorySize) / ruler.stackCount;
						size = fullBarSize * options.barPercentage;

						size = Math.min(helpers.valueOrDefault(options.barThickness, size), helpers.valueOrDefault(options.maxBarThickness, Infinity));

						base -= leftCategorySize;
						base += fullBarSize * stackIndex;
						base += (fullBarSize - size) / 2;

						return {
							size: size,
							base: base,
							head: base + size,
							center: base + size / 2
						};
					},

					draw: function draw() {
						var me = this;
						var chart = me.chart;
						var scale = me.getValueScale();
						var rects = me.getMeta().data;
						var dataset = me.getDataset();
						var ilen = rects.length;
						var i = 0;

						helpers.canvas.clipArea(chart.ctx, chart.chartArea);

						for (; i < ilen; ++i) {
							if (!isNaN(scale.getRightValue(dataset.data[i]))) {
								rects[i].draw();
							}
						}

						helpers.canvas.unclipArea(chart.ctx);
					},

					setHoverStyle: function setHoverStyle(rectangle) {
						var dataset = this.chart.data.datasets[rectangle._datasetIndex];
						var index = rectangle._index;
						var custom = rectangle.custom || {};
						var model = rectangle._model;

						model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
					},

					removeHoverStyle: function removeHoverStyle(rectangle) {
						var dataset = this.chart.data.datasets[rectangle._datasetIndex];
						var index = rectangle._index;
						var custom = rectangle.custom || {};
						var model = rectangle._model;
						var rectangleElementOptions = this.chart.options.elements.rectangle;

						model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
						model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
						model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
					}
				});

				Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
					/**
      * @private
      */
					getValueScaleId: function getValueScaleId() {
						return this.getMeta().xAxisID;
					},

					/**
      * @private
      */
					getIndexScaleId: function getIndexScaleId() {
						return this.getMeta().yAxisID;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 16: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('bubble', {
				hover: {
					mode: 'single'
				},

				scales: {
					xAxes: [{
						type: 'linear', // bubble should probably use a linear scale by default
						position: 'bottom',
						id: 'x-axis-0' // need an ID so datasets can reference the scale
					}],
					yAxes: [{
						type: 'linear',
						position: 'left',
						id: 'y-axis-0'
					}]
				},

				tooltips: {
					callbacks: {
						title: function title() {
							// Title doesn't make sense for scatter since we format the data as a point
							return '';
						},
						label: function label(item, data) {
							var datasetLabel = data.datasets[item.datasetIndex].label || '';
							var dataPoint = data.datasets[item.datasetIndex].data[item.index];
							return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
						}
					}
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.bubble = Chart.DatasetController.extend({
					/**
      * @protected
      */
					dataElementType: elements.Point,

					/**
      * @protected
      */
					update: function update(reset) {
						var me = this;
						var meta = me.getMeta();
						var points = meta.data;

						// Update Points
						helpers.each(points, function (point, index) {
							me.updateElement(point, index, reset);
						});
					},

					/**
      * @protected
      */
					updateElement: function updateElement(point, index, reset) {
						var me = this;
						var meta = me.getMeta();
						var custom = point.custom || {};
						var xScale = me.getScaleForId(meta.xAxisID);
						var yScale = me.getScaleForId(meta.yAxisID);
						var options = me._resolveElementOptions(point, index);
						var data = me.getDataset().data[index];
						var dsIndex = me.index;

						var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue((typeof data === "undefined" ? "undefined" : _typeof(data)) === 'object' ? data : NaN, index, dsIndex);
						var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

						point._xScale = xScale;
						point._yScale = yScale;
						point._options = options;
						point._datasetIndex = dsIndex;
						point._index = index;
						point._model = {
							backgroundColor: options.backgroundColor,
							borderColor: options.borderColor,
							borderWidth: options.borderWidth,
							hitRadius: options.hitRadius,
							pointStyle: options.pointStyle,
							radius: reset ? 0 : options.radius,
							skip: custom.skip || isNaN(x) || isNaN(y),
							x: x,
							y: y
						};

						point.pivot();
					},

					/**
      * @protected
      */
					setHoverStyle: function setHoverStyle(point) {
						var model = point._model;
						var options = point._options;

						model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
						model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
						model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
						model.radius = options.radius + options.hoverRadius;
					},

					/**
      * @protected
      */
					removeHoverStyle: function removeHoverStyle(point) {
						var model = point._model;
						var options = point._options;

						model.backgroundColor = options.backgroundColor;
						model.borderColor = options.borderColor;
						model.borderWidth = options.borderWidth;
						model.radius = options.radius;
					},

					/**
      * @private
      */
					_resolveElementOptions: function _resolveElementOptions(point, index) {
						var me = this;
						var chart = me.chart;
						var datasets = chart.data.datasets;
						var dataset = datasets[me.index];
						var custom = point.custom || {};
						var options = chart.options.elements.point;
						var resolve = helpers.options.resolve;
						var data = dataset.data[index];
						var values = {};
						var i, ilen, key;

						// Scriptable options
						var context = {
							chart: chart,
							dataIndex: index,
							dataset: dataset,
							datasetIndex: me.index
						};

						var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle'];

						for (i = 0, ilen = keys.length; i < ilen; ++i) {
							key = keys[i];
							values[key] = resolve([custom[key], dataset[key], options[key]], context, index);
						}

						// Custom radius resolution
						values.radius = resolve([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);

						return values;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 17: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('doughnut', {
				animation: {
					// Boolean - Whether we animate the rotation of the Doughnut
					animateRotate: true,
					// Boolean - Whether we animate scaling the Doughnut from the centre
					animateScale: false
				},
				hover: {
					mode: 'single'
				},
				legendCallback: function legendCallback(chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');

					var data = chart.data;
					var datasets = data.datasets;
					var labels = data.labels;

					if (datasets.length) {
						for (var i = 0; i < datasets[0].data.length; ++i) {
							text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
							if (labels[i]) {
								text.push(labels[i]);
							}
							text.push('</li>');
						}
					}

					text.push('</ul>');
					return text.join('');
				},
				legend: {
					labels: {
						generateLabels: function generateLabels(chart) {
							var data = chart.data;
							if (data.labels.length && data.datasets.length) {
								return data.labels.map(function (label, i) {
									var meta = chart.getDatasetMeta(0);
									var ds = data.datasets[0];
									var arc = meta.data[i];
									var custom = arc && arc.custom || {};
									var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
									var arcOpts = chart.options.elements.arc;
									var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
									var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
									var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

									return {
										text: label,
										fillStyle: fill,
										strokeStyle: stroke,
										lineWidth: bw,
										hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

										// Extra data used for toggling the correct item
										index: i
									};
								});
							}
							return [];
						}
					},

					onClick: function onClick(e, legendItem) {
						var index = legendItem.index;
						var chart = this.chart;
						var i, ilen, meta;

						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							// toggle visibility of index if exists
							if (meta.data[index]) {
								meta.data[index].hidden = !meta.data[index].hidden;
							}
						}

						chart.update();
					}
				},

				// The percentage of the chart that we cut out of the middle.
				cutoutPercentage: 50,

				// The rotation of the chart, where the first data arc begins.
				rotation: Math.PI * -0.5,

				// The total circumference of the chart.
				circumference: Math.PI * 2.0,

				// Need to override these to give a nice default
				tooltips: {
					callbacks: {
						title: function title() {
							return '';
						},
						label: function label(tooltipItem, data) {
							var dataLabel = data.labels[tooltipItem.index];
							var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

							if (helpers.isArray(dataLabel)) {
								// show value on first line of multiline label
								// need to clone because we are changing the value
								dataLabel = dataLabel.slice();
								dataLabel[0] += value;
							} else {
								dataLabel += value;
							}

							return dataLabel;
						}
					}
				}
			});

			defaults._set('pie', helpers.clone(defaults.doughnut));
			defaults._set('pie', {
				cutoutPercentage: 0
			});

			module.exports = function (Chart) {

				Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

					dataElementType: elements.Arc,

					linkScales: helpers.noop,

					// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
					getRingIndex: function getRingIndex(datasetIndex) {
						var ringIndex = 0;

						for (var j = 0; j < datasetIndex; ++j) {
							if (this.chart.isDatasetVisible(j)) {
								++ringIndex;
							}
						}

						return ringIndex;
					},

					update: function update(reset) {
						var me = this;
						var chart = me.chart;
						var chartArea = chart.chartArea;
						var opts = chart.options;
						var arcOpts = opts.elements.arc;
						var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
						var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
						var minSize = Math.min(availableWidth, availableHeight);
						var offset = { x: 0, y: 0 };
						var meta = me.getMeta();
						var cutoutPercentage = opts.cutoutPercentage;
						var circumference = opts.circumference;

						// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
						if (circumference < Math.PI * 2.0) {
							var startAngle = opts.rotation % (Math.PI * 2.0);
							startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
							var endAngle = startAngle + circumference;
							var start = { x: Math.cos(startAngle), y: Math.sin(startAngle) };
							var end = { x: Math.cos(endAngle), y: Math.sin(endAngle) };
							var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
							var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
							var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
							var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
							var cutout = cutoutPercentage / 100.0;
							var min = { x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout)) };
							var max = { x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout)) };
							var size = { width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5 };
							minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
							offset = { x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5 };
						}

						chart.borderWidth = me.getMaxBorderWidth(meta.data);
						chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
						chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
						chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
						chart.offsetX = offset.x * chart.outerRadius;
						chart.offsetY = offset.y * chart.outerRadius;

						meta.total = me.calculateTotal();

						me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
						me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

						helpers.each(meta.data, function (arc, index) {
							me.updateElement(arc, index, reset);
						});
					},

					updateElement: function updateElement(arc, index, reset) {
						var me = this;
						var chart = me.chart;
						var chartArea = chart.chartArea;
						var opts = chart.options;
						var animationOpts = opts.animation;
						var centerX = (chartArea.left + chartArea.right) / 2;
						var centerY = (chartArea.top + chartArea.bottom) / 2;
						var startAngle = opts.rotation; // non reset case handled later
						var endAngle = opts.rotation; // non reset case handled later
						var dataset = me.getDataset();
						var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
						var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
						var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

						helpers.extend(arc, {
							// Utility
							_datasetIndex: me.index,
							_index: index,

							// Desired view properties
							_model: {
								x: centerX + chart.offsetX,
								y: centerY + chart.offsetY,
								startAngle: startAngle,
								endAngle: endAngle,
								circumference: circumference,
								outerRadius: outerRadius,
								innerRadius: innerRadius,
								label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
							}
						});

						var model = arc._model;
						// Resets the visual styles
						this.removeHoverStyle(arc);

						// Set correct angles if not resetting
						if (!reset || !animationOpts.animateRotate) {
							if (index === 0) {
								model.startAngle = opts.rotation;
							} else {
								model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
							}

							model.endAngle = model.startAngle + model.circumference;
						}

						arc.pivot();
					},

					removeHoverStyle: function removeHoverStyle(arc) {
						Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
					},

					calculateTotal: function calculateTotal() {
						var dataset = this.getDataset();
						var meta = this.getMeta();
						var total = 0;
						var value;

						helpers.each(meta.data, function (element, index) {
							value = dataset.data[index];
							if (!isNaN(value) && !element.hidden) {
								total += Math.abs(value);
							}
						});

						/* if (total === 0) {
      	total = NaN;
      }*/

						return total;
					},

					calculateCircumference: function calculateCircumference(value) {
						var total = this.getMeta().total;
						if (total > 0 && !isNaN(value)) {
							return Math.PI * 2.0 * (value / total);
						}
						return 0;
					},

					// gets the max border or hover width to properly scale pie charts
					getMaxBorderWidth: function getMaxBorderWidth(arcs) {
						var max = 0;
						var index = this.index;
						var length = arcs.length;
						var borderWidth;
						var hoverWidth;

						for (var i = 0; i < length; i++) {
							borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
							hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

							max = borderWidth > max ? borderWidth : max;
							max = hoverWidth > max ? hoverWidth : max;
						}
						return max;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 18: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('line', {
				showLines: true,
				spanGaps: false,

				hover: {
					mode: 'label'
				},

				scales: {
					xAxes: [{
						type: 'category',
						id: 'x-axis-0'
					}],
					yAxes: [{
						type: 'linear',
						id: 'y-axis-0'
					}]
				}
			});

			module.exports = function (Chart) {

				function lineEnabled(dataset, options) {
					return helpers.valueOrDefault(dataset.showLine, options.showLines);
				}

				Chart.controllers.line = Chart.DatasetController.extend({

					datasetElementType: elements.Line,

					dataElementType: elements.Point,

					update: function update(reset) {
						var me = this;
						var meta = me.getMeta();
						var line = meta.dataset;
						var points = meta.data || [];
						var options = me.chart.options;
						var lineElementOptions = options.elements.line;
						var scale = me.getScaleForId(meta.yAxisID);
						var i, ilen, custom;
						var dataset = me.getDataset();
						var showLine = lineEnabled(dataset, options);

						// Update Line
						if (showLine) {
							custom = line.custom || {};

							// Compatibility: If the properties are defined with only the old name, use those values
							if (dataset.tension !== undefined && dataset.lineTension === undefined) {
								dataset.lineTension = dataset.tension;
							}

							// Utility
							line._scale = scale;
							line._datasetIndex = me.index;
							// Data
							line._children = points;
							// Model
							line._model = {
								// Appearance
								// The default behavior of lines is to break at null values, according
								// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
								// This option gives lines the ability to span gaps
								spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
								tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
								backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
								borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
								borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
								borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
								borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
								borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
								borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
								fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
								steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
								cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)
							};

							line.pivot();
						}

						// Update Points
						for (i = 0, ilen = points.length; i < ilen; ++i) {
							me.updateElement(points[i], i, reset);
						}

						if (showLine && line._model.tension !== 0) {
							me.updateBezierControlPoints();
						}

						// Now pivot the point for animation
						for (i = 0, ilen = points.length; i < ilen; ++i) {
							points[i].pivot();
						}
					},

					getPointBackgroundColor: function getPointBackgroundColor(point, index) {
						var backgroundColor = this.chart.options.elements.point.backgroundColor;
						var dataset = this.getDataset();
						var custom = point.custom || {};

						if (custom.backgroundColor) {
							backgroundColor = custom.backgroundColor;
						} else if (dataset.pointBackgroundColor) {
							backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
						} else if (dataset.backgroundColor) {
							backgroundColor = dataset.backgroundColor;
						}

						return backgroundColor;
					},

					getPointBorderColor: function getPointBorderColor(point, index) {
						var borderColor = this.chart.options.elements.point.borderColor;
						var dataset = this.getDataset();
						var custom = point.custom || {};

						if (custom.borderColor) {
							borderColor = custom.borderColor;
						} else if (dataset.pointBorderColor) {
							borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
						} else if (dataset.borderColor) {
							borderColor = dataset.borderColor;
						}

						return borderColor;
					},

					getPointBorderWidth: function getPointBorderWidth(point, index) {
						var borderWidth = this.chart.options.elements.point.borderWidth;
						var dataset = this.getDataset();
						var custom = point.custom || {};

						if (!isNaN(custom.borderWidth)) {
							borderWidth = custom.borderWidth;
						} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
							borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
						} else if (!isNaN(dataset.borderWidth)) {
							borderWidth = dataset.borderWidth;
						}

						return borderWidth;
					},

					updateElement: function updateElement(point, index, reset) {
						var me = this;
						var meta = me.getMeta();
						var custom = point.custom || {};
						var dataset = me.getDataset();
						var datasetIndex = me.index;
						var value = dataset.data[index];
						var yScale = me.getScaleForId(meta.yAxisID);
						var xScale = me.getScaleForId(meta.xAxisID);
						var pointOptions = me.chart.options.elements.point;
						var x, y;

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
							dataset.pointRadius = dataset.radius;
						}
						if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
							dataset.pointHitRadius = dataset.hitRadius;
						}

						x = xScale.getPixelForValue((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' ? value : NaN, index, datasetIndex);
						y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

						// Utility
						point._xScale = xScale;
						point._yScale = yScale;
						point._datasetIndex = datasetIndex;
						point._index = index;

						// Desired view properties
						point._model = {
							x: x,
							y: y,
							skip: custom.skip || isNaN(x) || isNaN(y),
							// Appearance
							radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
							pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
							backgroundColor: me.getPointBackgroundColor(point, index),
							borderColor: me.getPointBorderColor(point, index),
							borderWidth: me.getPointBorderWidth(point, index),
							tension: meta.dataset._model ? meta.dataset._model.tension : 0,
							steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
							// Tooltip
							hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
						};
					},

					calculatePointY: function calculatePointY(value, index, datasetIndex) {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var yScale = me.getScaleForId(meta.yAxisID);
						var sumPos = 0;
						var sumNeg = 0;
						var i, ds, dsMeta;

						if (yScale.options.stacked) {
							for (i = 0; i < datasetIndex; i++) {
								ds = chart.data.datasets[i];
								dsMeta = chart.getDatasetMeta(i);
								if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
									var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
									if (stackedRightValue < 0) {
										sumNeg += stackedRightValue || 0;
									} else {
										sumPos += stackedRightValue || 0;
									}
								}
							}

							var rightValue = Number(yScale.getRightValue(value));
							if (rightValue < 0) {
								return yScale.getPixelForValue(sumNeg + rightValue);
							}
							return yScale.getPixelForValue(sumPos + rightValue);
						}

						return yScale.getPixelForValue(value);
					},

					updateBezierControlPoints: function updateBezierControlPoints() {
						var me = this;
						var meta = me.getMeta();
						var area = me.chart.chartArea;
						var points = meta.data || [];
						var i, ilen, point, model, controlPoints;

						// Only consider points that are drawn in case the spanGaps option is used
						if (meta.dataset._model.spanGaps) {
							points = points.filter(function (pt) {
								return !pt._model.skip;
							});
						}

						function capControlPoint(pt, min, max) {
							return Math.max(Math.min(pt, max), min);
						}

						if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
							helpers.splineCurveMonotone(points);
						} else {
							for (i = 0, ilen = points.length; i < ilen; ++i) {
								point = points[i];
								model = point._model;
								controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);
								model.controlPointPreviousX = controlPoints.previous.x;
								model.controlPointPreviousY = controlPoints.previous.y;
								model.controlPointNextX = controlPoints.next.x;
								model.controlPointNextY = controlPoints.next.y;
							}
						}

						if (me.chart.options.elements.line.capBezierPoints) {
							for (i = 0, ilen = points.length; i < ilen; ++i) {
								model = points[i]._model;
								model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
								model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
								model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
								model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
							}
						}
					},

					draw: function draw() {
						var me = this;
						var chart = me.chart;
						var meta = me.getMeta();
						var points = meta.data || [];
						var area = chart.chartArea;
						var ilen = points.length;
						var i = 0;

						helpers.canvas.clipArea(chart.ctx, area);

						if (lineEnabled(me.getDataset(), chart.options)) {
							meta.dataset.draw();
						}

						helpers.canvas.unclipArea(chart.ctx);

						// Draw the points
						for (; i < ilen; ++i) {
							points[i].draw(area);
						}
					},

					setHoverStyle: function setHoverStyle(point) {
						// Point
						var dataset = this.chart.data.datasets[point._datasetIndex];
						var index = point._index;
						var custom = point.custom || {};
						var model = point._model;

						model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
						model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
					},

					removeHoverStyle: function removeHoverStyle(point) {
						var me = this;
						var dataset = me.chart.data.datasets[point._datasetIndex];
						var index = point._index;
						var custom = point.custom || {};
						var model = point._model;

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
							dataset.pointRadius = dataset.radius;
						}

						model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
						model.backgroundColor = me.getPointBackgroundColor(point, index);
						model.borderColor = me.getPointBorderColor(point, index);
						model.borderWidth = me.getPointBorderWidth(point, index);
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 19: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('polarArea', {
				scale: {
					type: 'radialLinear',
					angleLines: {
						display: false
					},
					gridLines: {
						circular: true
					},
					pointLabels: {
						display: false
					},
					ticks: {
						beginAtZero: true
					}
				},

				// Boolean - Whether to animate the rotation of the chart
				animation: {
					animateRotate: true,
					animateScale: true
				},

				startAngle: -0.5 * Math.PI,
				legendCallback: function legendCallback(chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');

					var data = chart.data;
					var datasets = data.datasets;
					var labels = data.labels;

					if (datasets.length) {
						for (var i = 0; i < datasets[0].data.length; ++i) {
							text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
							if (labels[i]) {
								text.push(labels[i]);
							}
							text.push('</li>');
						}
					}

					text.push('</ul>');
					return text.join('');
				},
				legend: {
					labels: {
						generateLabels: function generateLabels(chart) {
							var data = chart.data;
							if (data.labels.length && data.datasets.length) {
								return data.labels.map(function (label, i) {
									var meta = chart.getDatasetMeta(0);
									var ds = data.datasets[0];
									var arc = meta.data[i];
									var custom = arc.custom || {};
									var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
									var arcOpts = chart.options.elements.arc;
									var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
									var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
									var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

									return {
										text: label,
										fillStyle: fill,
										strokeStyle: stroke,
										lineWidth: bw,
										hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

										// Extra data used for toggling the correct item
										index: i
									};
								});
							}
							return [];
						}
					},

					onClick: function onClick(e, legendItem) {
						var index = legendItem.index;
						var chart = this.chart;
						var i, ilen, meta;

						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							meta.data[index].hidden = !meta.data[index].hidden;
						}

						chart.update();
					}
				},

				// Need to override these to give a nice default
				tooltips: {
					callbacks: {
						title: function title() {
							return '';
						},
						label: function label(item, data) {
							return data.labels[item.index] + ': ' + item.yLabel;
						}
					}
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.polarArea = Chart.DatasetController.extend({

					dataElementType: elements.Arc,

					linkScales: helpers.noop,

					update: function update(reset) {
						var me = this;
						var chart = me.chart;
						var chartArea = chart.chartArea;
						var meta = me.getMeta();
						var opts = chart.options;
						var arcOpts = opts.elements.arc;
						var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
						chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
						chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
						chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

						me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
						me.innerRadius = me.outerRadius - chart.radiusLength;

						meta.count = me.countVisibleElements();

						helpers.each(meta.data, function (arc, index) {
							me.updateElement(arc, index, reset);
						});
					},

					updateElement: function updateElement(arc, index, reset) {
						var me = this;
						var chart = me.chart;
						var dataset = me.getDataset();
						var opts = chart.options;
						var animationOpts = opts.animation;
						var scale = chart.scale;
						var labels = chart.data.labels;

						var circumference = me.calculateCircumference(dataset.data[index]);
						var centerX = scale.xCenter;
						var centerY = scale.yCenter;

						// If there is NaN data before us, we need to calculate the starting angle correctly.
						// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
						var visibleCount = 0;
						var meta = me.getMeta();
						for (var i = 0; i < index; ++i) {
							if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
								++visibleCount;
							}
						}

						// var negHalfPI = -0.5 * Math.PI;
						var datasetStartAngle = opts.startAngle;
						var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
						var startAngle = datasetStartAngle + circumference * visibleCount;
						var endAngle = startAngle + (arc.hidden ? 0 : circumference);

						var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

						helpers.extend(arc, {
							// Utility
							_datasetIndex: me.index,
							_index: index,
							_scale: scale,

							// Desired view properties
							_model: {
								x: centerX,
								y: centerY,
								innerRadius: 0,
								outerRadius: reset ? resetRadius : distance,
								startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
								endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
								label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
							}
						});

						// Apply border and fill style
						me.removeHoverStyle(arc);

						arc.pivot();
					},

					removeHoverStyle: function removeHoverStyle(arc) {
						Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
					},

					countVisibleElements: function countVisibleElements() {
						var dataset = this.getDataset();
						var meta = this.getMeta();
						var count = 0;

						helpers.each(meta.data, function (element, index) {
							if (!isNaN(dataset.data[index]) && !element.hidden) {
								count++;
							}
						});

						return count;
					},

					calculateCircumference: function calculateCircumference(value) {
						var count = this.getMeta().count;
						if (count > 0 && !isNaN(value)) {
							return 2 * Math.PI / count;
						}
						return 0;
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 20: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('radar', {
				scale: {
					type: 'radialLinear'
				},
				elements: {
					line: {
						tension: 0 // no bezier in radar
					}
				}
			});

			module.exports = function (Chart) {

				Chart.controllers.radar = Chart.DatasetController.extend({

					datasetElementType: elements.Line,

					dataElementType: elements.Point,

					linkScales: helpers.noop,

					update: function update(reset) {
						var me = this;
						var meta = me.getMeta();
						var line = meta.dataset;
						var points = meta.data;
						var custom = line.custom || {};
						var dataset = me.getDataset();
						var lineElementOptions = me.chart.options.elements.line;
						var scale = me.chart.scale;

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.tension !== undefined && dataset.lineTension === undefined) {
							dataset.lineTension = dataset.tension;
						}

						helpers.extend(meta.dataset, {
							// Utility
							_datasetIndex: me.index,
							_scale: scale,
							// Data
							_children: points,
							_loop: true,
							// Model
							_model: {
								// Appearance
								tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
								backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
								borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
								borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
								fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
								borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
								borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
								borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
								borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle
							}
						});

						meta.dataset.pivot();

						// Update Points
						helpers.each(points, function (point, index) {
							me.updateElement(point, index, reset);
						}, me);

						// Update bezier control points
						me.updateBezierControlPoints();
					},
					updateElement: function updateElement(point, index, reset) {
						var me = this;
						var custom = point.custom || {};
						var dataset = me.getDataset();
						var scale = me.chart.scale;
						var pointElementOptions = me.chart.options.elements.point;
						var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

						// Compatibility: If the properties are defined with only the old name, use those values
						if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
							dataset.pointRadius = dataset.radius;
						}
						if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
							dataset.pointHitRadius = dataset.hitRadius;
						}

						helpers.extend(point, {
							// Utility
							_datasetIndex: me.index,
							_index: index,
							_scale: scale,

							// Desired view properties
							_model: {
								x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
								y: reset ? scale.yCenter : pointPosition.y,

								// Appearance
								tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
								radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
								backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
								borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
								borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
								pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

								// Tooltip
								hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
							}
						});

						point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);
					},
					updateBezierControlPoints: function updateBezierControlPoints() {
						var chartArea = this.chart.chartArea;
						var meta = this.getMeta();

						helpers.each(meta.data, function (point, index) {
							var model = point._model;
							var controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension);

							// Prevent the bezier going outside of the bounds of the graph
							model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
							model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

							model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
							model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

							// Now pivot the point for animation
							point.pivot();
						});
					},

					setHoverStyle: function setHoverStyle(point) {
						// Point
						var dataset = this.chart.data.datasets[point._datasetIndex];
						var custom = point.custom || {};
						var index = point._index;
						var model = point._model;

						model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
						model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
					},

					removeHoverStyle: function removeHoverStyle(point) {
						var dataset = this.chart.data.datasets[point._datasetIndex];
						var custom = point.custom || {};
						var index = point._index;
						var model = point._model;
						var pointElementOptions = this.chart.options.elements.point;

						model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
						model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
						model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
						model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
					}
				});
			};
		}, { "25": 25, "40": 40, "45": 45 }], 21: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);

			defaults._set('scatter', {
				hover: {
					mode: 'single'
				},

				scales: {
					xAxes: [{
						id: 'x-axis-1', // need an ID so datasets can reference the scale
						type: 'linear', // scatter should not use a category axis
						position: 'bottom'
					}],
					yAxes: [{
						id: 'y-axis-1',
						type: 'linear',
						position: 'left'
					}]
				},

				showLines: false,

				tooltips: {
					callbacks: {
						title: function title() {
							return ''; // doesn't make sense for scatter since data are formatted as a point
						},
						label: function label(item) {
							return '(' + item.xLabel + ', ' + item.yLabel + ')';
						}
					}
				}
			});

			module.exports = function (Chart) {

				// Scatter charts use line controllers
				Chart.controllers.scatter = Chart.controllers.line;
			};
		}, { "25": 25 }], 22: [function (require, module, exports) {
			/* global window: false */
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				animation: {
					duration: 1000,
					easing: 'easeOutQuart',
					onProgress: helpers.noop,
					onComplete: helpers.noop
				}
			});

			module.exports = function (Chart) {

				Chart.Animation = Element.extend({
					chart: null, // the animation associated chart instance
					currentStep: 0, // the current animation step
					numSteps: 60, // default number of steps
					easing: '', // the easing to use for this animation
					render: null, // render function used by the animation service

					onAnimationProgress: null, // user specified callback to fire on each step of the animation
					onAnimationComplete: null // user specified callback to fire when the animation finishes
				});

				Chart.animationService = {
					frameDuration: 17,
					animations: [],
					dropFrames: 0,
					request: null,

					/**
      * @param {Chart} chart - The chart to animate.
      * @param {Chart.Animation} animation - The animation that we will animate.
      * @param {Number} duration - The animation duration in ms.
      * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
      */
					addAnimation: function addAnimation(chart, animation, duration, lazy) {
						var animations = this.animations;
						var i, ilen;

						animation.chart = chart;

						if (!lazy) {
							chart.animating = true;
						}

						for (i = 0, ilen = animations.length; i < ilen; ++i) {
							if (animations[i].chart === chart) {
								animations[i] = animation;
								return;
							}
						}

						animations.push(animation);

						// If there are no animations queued, manually kickstart a digest, for lack of a better word
						if (animations.length === 1) {
							this.requestAnimationFrame();
						}
					},

					cancelAnimation: function cancelAnimation(chart) {
						var index = helpers.findIndex(this.animations, function (animation) {
							return animation.chart === chart;
						});

						if (index !== -1) {
							this.animations.splice(index, 1);
							chart.animating = false;
						}
					},

					requestAnimationFrame: function requestAnimationFrame() {
						var me = this;
						if (me.request === null) {
							// Skip animation frame requests until the active one is executed.
							// This can happen when processing mouse events, e.g. 'mousemove'
							// and 'mouseout' events will trigger multiple renders.
							me.request = helpers.requestAnimFrame.call(window, function () {
								me.request = null;
								me.startDigest();
							});
						}
					},

					/**
      * @private
      */
					startDigest: function startDigest() {
						var me = this;
						var startTime = Date.now();
						var framesToDrop = 0;

						if (me.dropFrames > 1) {
							framesToDrop = Math.floor(me.dropFrames);
							me.dropFrames = me.dropFrames % 1;
						}

						me.advance(1 + framesToDrop);

						var endTime = Date.now();

						me.dropFrames += (endTime - startTime) / me.frameDuration;

						// Do we have more stuff to animate?
						if (me.animations.length > 0) {
							me.requestAnimationFrame();
						}
					},

					/**
      * @private
      */
					advance: function advance(count) {
						var animations = this.animations;
						var animation, chart;
						var i = 0;

						while (i < animations.length) {
							animation = animations[i];
							chart = animation.chart;

							animation.currentStep = (animation.currentStep || 0) + count;
							animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

							helpers.callback(animation.render, [chart, animation], chart);
							helpers.callback(animation.onAnimationProgress, [animation], chart);

							if (animation.currentStep >= animation.numSteps) {
								helpers.callback(animation.onAnimationComplete, [animation], chart);
								chart.animating = false;
								animations.splice(i, 1);
							} else {
								++i;
							}
						}
					}
				};

				/**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */
				Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
					get: function get() {
						return this;
					}
				});

				/**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */
				Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
					get: function get() {
						return this.chart;
					},
					set: function set(value) {
						this.chart = value;
					}
				});
			};
		}, { "25": 25, "26": 26, "45": 45 }], 23: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);
			var Interaction = require(28);
			var platform = require(48);

			module.exports = function (Chart) {
				var plugins = Chart.plugins;

				// Create a dictionary of chart types, to allow for extension of existing types
				Chart.types = {};

				// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
				// Destroy method on the chart will remove the instance of the chart from this reference.
				Chart.instances = {};

				// Controllers available for dataset visualization eg. bar, line, slice, etc.
				Chart.controllers = {};

				/**
     * Initializes the given config with global and chart default values.
     */
				function initConfig(config) {
					config = config || {};

					// Do NOT use configMerge() for the data object because this method merges arrays
					// and so would change references to labels and datasets, preventing data updates.
					var data = config.data = config.data || {};
					data.datasets = data.datasets || [];
					data.labels = data.labels || [];

					config.options = helpers.configMerge(defaults.global, defaults[config.type], config.options || {});

					return config;
				}

				/**
     * Updates the config of the chart
     * @param chart {Chart} chart to update the options for
     */
				function updateConfig(chart) {
					var newOptions = chart.options;

					// Update Scale(s) with options
					if (newOptions.scale) {
						chart.scale.options = newOptions.scale;
					} else if (newOptions.scales) {
						newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {
							chart.scales[scaleOptions.id].options = scaleOptions;
						});
					}

					// Tooltip
					chart.tooltip._options = newOptions.tooltips;
				}

				function positionIsHorizontal(position) {
					return position === 'top' || position === 'bottom';
				}

				helpers.extend(Chart.prototype, /** @lends Chart */{
					/**
      * @private
      */
					construct: function construct(item, config) {
						var me = this;

						config = initConfig(config);

						var context = platform.acquireContext(item, config);
						var canvas = context && context.canvas;
						var height = canvas && canvas.height;
						var width = canvas && canvas.width;

						me.id = helpers.uid();
						me.ctx = context;
						me.canvas = canvas;
						me.config = config;
						me.width = width;
						me.height = height;
						me.aspectRatio = height ? width / height : null;
						me.options = config.options;
						me._bufferedRender = false;

						/**
       * Provided for backward compatibility, Chart and Chart.Controller have been merged,
       * the "instance" still need to be defined since it might be called from plugins.
       * @prop Chart#chart
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */
						me.chart = me;
						me.controller = me; // chart.chart.controller #inception

						// Add the chart instance to the global namespace
						Chart.instances[me.id] = me;

						// Define alias to the config data: `chart.data === chart.config.data`
						Object.defineProperty(me, 'data', {
							get: function get() {
								return me.config.data;
							},
							set: function set(value) {
								me.config.data = value;
							}
						});

						if (!context || !canvas) {
							// The given item is not a compatible context2d element, let's return before finalizing
							// the chart initialization but after setting basic chart / controller properties that
							// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
							// https://github.com/chartjs/Chart.js/issues/2807
							console.error("Failed to create chart: can't acquire context from the given item");
							return;
						}

						me.initialize();
						me.update();
					},

					/**
      * @private
      */
					initialize: function initialize() {
						var me = this;

						// Before init plugin notification
						plugins.notify(me, 'beforeInit');

						helpers.retinaScale(me, me.options.devicePixelRatio);

						me.bindEvents();

						if (me.options.responsive) {
							// Initial resize before chart draws (must be silent to preserve initial animations).
							me.resize(true);
						}

						// Make sure scales have IDs and are built before we build any controllers.
						me.ensureScalesHaveIDs();
						me.buildScales();
						me.initToolTip();

						// After init plugin notification
						plugins.notify(me, 'afterInit');

						return me;
					},

					clear: function clear() {
						helpers.canvas.clear(this);
						return this;
					},

					stop: function stop() {
						// Stops any current animation loop occurring
						Chart.animationService.cancelAnimation(this);
						return this;
					},

					resize: function resize(silent) {
						var me = this;
						var options = me.options;
						var canvas = me.canvas;
						var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;

						// the canvas render width and height will be casted to integers so make sure that
						// the canvas display style uses the same integer values to avoid blurring effect.

						// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased
						var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
						var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

						if (me.width === newWidth && me.height === newHeight) {
							return;
						}

						canvas.width = me.width = newWidth;
						canvas.height = me.height = newHeight;
						canvas.style.width = newWidth + 'px';
						canvas.style.height = newHeight + 'px';

						helpers.retinaScale(me, options.devicePixelRatio);

						if (!silent) {
							// Notify any plugins about the resize
							var newSize = { width: newWidth, height: newHeight };
							plugins.notify(me, 'resize', [newSize]);

							// Notify of resize
							if (me.options.onResize) {
								me.options.onResize(me, newSize);
							}

							me.stop();
							me.update(me.options.responsiveAnimationDuration);
						}
					},

					ensureScalesHaveIDs: function ensureScalesHaveIDs() {
						var options = this.options;
						var scalesOptions = options.scales || {};
						var scaleOptions = options.scale;

						helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
							xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
						});

						helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
							yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
						});

						if (scaleOptions) {
							scaleOptions.id = scaleOptions.id || 'scale';
						}
					},

					/**
      * Builds a map of scale ID to scale object for future lookup.
      */
					buildScales: function buildScales() {
						var me = this;
						var options = me.options;
						var scales = me.scales = {};
						var items = [];

						if (options.scales) {
							items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
								return { options: xAxisOptions, dtype: 'category', dposition: 'bottom' };
							}), (options.scales.yAxes || []).map(function (yAxisOptions) {
								return { options: yAxisOptions, dtype: 'linear', dposition: 'left' };
							}));
						}

						if (options.scale) {
							items.push({
								options: options.scale,
								dtype: 'radialLinear',
								isDefault: true,
								dposition: 'chartArea'
							});
						}

						helpers.each(items, function (item) {
							var scaleOptions = item.options;
							var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
							var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
							if (!scaleClass) {
								return;
							}

							if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
								scaleOptions.position = item.dposition;
							}

							var scale = new scaleClass({
								id: scaleOptions.id,
								options: scaleOptions,
								ctx: me.ctx,
								chart: me
							});

							scales[scale.id] = scale;
							scale.mergeTicksOptions();

							// TODO(SB): I think we should be able to remove this custom case (options.scale)
							// and consider it as a regular scale part of the "scales"" map only! This would
							// make the logic easier and remove some useless? custom code.
							if (item.isDefault) {
								me.scale = scale;
							}
						});

						Chart.scaleService.addScalesToLayout(this);
					},

					buildOrUpdateControllers: function buildOrUpdateControllers() {
						var me = this;
						var types = [];
						var newControllers = [];

						helpers.each(me.data.datasets, function (dataset, datasetIndex) {
							var meta = me.getDatasetMeta(datasetIndex);
							var type = dataset.type || me.config.type;

							if (meta.type && meta.type !== type) {
								me.destroyDatasetMeta(datasetIndex);
								meta = me.getDatasetMeta(datasetIndex);
							}
							meta.type = type;

							types.push(meta.type);

							if (meta.controller) {
								meta.controller.updateIndex(datasetIndex);
							} else {
								var ControllerClass = Chart.controllers[meta.type];
								if (ControllerClass === undefined) {
									throw new Error('"' + meta.type + '" is not a chart type.');
								}

								meta.controller = new ControllerClass(me, datasetIndex);
								newControllers.push(meta.controller);
							}
						}, me);

						return newControllers;
					},

					/**
      * Reset the elements of all datasets
      * @private
      */
					resetElements: function resetElements() {
						var me = this;
						helpers.each(me.data.datasets, function (dataset, datasetIndex) {
							me.getDatasetMeta(datasetIndex).controller.reset();
						}, me);
					},

					/**
     * Resets the chart back to it's state before the initial animation
     */
					reset: function reset() {
						this.resetElements();
						this.tooltip.initialize();
					},

					update: function update(config) {
						var me = this;

						if (!config || (typeof config === "undefined" ? "undefined" : _typeof(config)) !== 'object') {
							// backwards compatibility
							config = {
								duration: config,
								lazy: arguments[1]
							};
						}

						updateConfig(me);

						if (plugins.notify(me, 'beforeUpdate') === false) {
							return;
						}

						// In case the entire data object changed
						me.tooltip._data = me.data;

						// Make sure dataset controllers are updated and new controllers are reset
						var newControllers = me.buildOrUpdateControllers();

						// Make sure all dataset controllers have correct meta data counts
						helpers.each(me.data.datasets, function (dataset, datasetIndex) {
							me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
						}, me);

						me.updateLayout();

						// Can only reset the new controllers after the scales have been updated
						helpers.each(newControllers, function (controller) {
							controller.reset();
						});

						me.updateDatasets();

						// Do this before render so that any plugins that need final scale updates can use it
						plugins.notify(me, 'afterUpdate');

						if (me._bufferedRender) {
							me._bufferedRequest = {
								duration: config.duration,
								easing: config.easing,
								lazy: config.lazy
							};
						} else {
							me.render(config);
						}
					},

					/**
      * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
      * hook, in which case, plugins will not be called on `afterLayout`.
      * @private
      */
					updateLayout: function updateLayout() {
						var me = this;

						if (plugins.notify(me, 'beforeLayout') === false) {
							return;
						}

						Chart.layoutService.update(this, this.width, this.height);

						/**
       * Provided for backward compatibility, use `afterLayout` instead.
       * @method IPlugin#afterScaleUpdate
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */
						plugins.notify(me, 'afterScaleUpdate');
						plugins.notify(me, 'afterLayout');
					},

					/**
      * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
      * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
      * @private
      */
					updateDatasets: function updateDatasets() {
						var me = this;

						if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
							return;
						}

						for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
							me.updateDataset(i);
						}

						plugins.notify(me, 'afterDatasetsUpdate');
					},

					/**
      * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
      * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
      * @private
      */
					updateDataset: function updateDataset(index) {
						var me = this;
						var meta = me.getDatasetMeta(index);
						var args = {
							meta: meta,
							index: index
						};

						if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
							return;
						}

						meta.controller.update();

						plugins.notify(me, 'afterDatasetUpdate', [args]);
					},

					render: function render(config) {
						var me = this;

						if (!config || (typeof config === "undefined" ? "undefined" : _typeof(config)) !== 'object') {
							// backwards compatibility
							config = {
								duration: config,
								lazy: arguments[1]
							};
						}

						var duration = config.duration;
						var lazy = config.lazy;

						if (plugins.notify(me, 'beforeRender') === false) {
							return;
						}

						var animationOptions = me.options.animation;
						var onComplete = function onComplete(animation) {
							plugins.notify(me, 'afterRender');
							helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
						};

						if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {
							var animation = new Chart.Animation({
								numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
								easing: config.easing || animationOptions.easing,

								render: function render(chart, animationObject) {
									var easingFunction = helpers.easing.effects[animationObject.easing];
									var currentStep = animationObject.currentStep;
									var stepDecimal = currentStep / animationObject.numSteps;

									chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
								},

								onAnimationProgress: animationOptions.onProgress,
								onAnimationComplete: onComplete
							});

							Chart.animationService.addAnimation(me, animation, duration, lazy);
						} else {
							me.draw();

							// See https://github.com/chartjs/Chart.js/issues/3781
							onComplete(new Chart.Animation({ numSteps: 0, chart: me }));
						}

						return me;
					},

					draw: function draw(easingValue) {
						var me = this;

						me.clear();

						if (helpers.isNullOrUndef(easingValue)) {
							easingValue = 1;
						}

						me.transition(easingValue);

						if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
							return;
						}

						// Draw all the scales
						helpers.each(me.boxes, function (box) {
							box.draw(me.chartArea);
						}, me);

						if (me.scale) {
							me.scale.draw();
						}

						me.drawDatasets(easingValue);

						// Finally draw the tooltip
						me.tooltip.draw();

						plugins.notify(me, 'afterDraw', [easingValue]);
					},

					/**
      * @private
      */
					transition: function transition(easingValue) {
						var me = this;

						for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
							if (me.isDatasetVisible(i)) {
								me.getDatasetMeta(i).controller.transition(easingValue);
							}
						}

						me.tooltip.transition(easingValue);
					},

					/**
      * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
      * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
      * @private
      */
					drawDatasets: function drawDatasets(easingValue) {
						var me = this;

						if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
							return;
						}

						// Draw datasets reversed to support proper line stacking
						for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
							if (me.isDatasetVisible(i)) {
								me.drawDataset(i, easingValue);
							}
						}

						plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
					},

					/**
      * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
      * hook, in which case, plugins will not be called on `afterDatasetDraw`.
      * @private
      */
					drawDataset: function drawDataset(index, easingValue) {
						var me = this;
						var meta = me.getDatasetMeta(index);
						var args = {
							meta: meta,
							index: index,
							easingValue: easingValue
						};

						if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
							return;
						}

						meta.controller.draw(easingValue);

						plugins.notify(me, 'afterDatasetDraw', [args]);
					},

					// Get the single element that was clicked on
					// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
					getElementAtEvent: function getElementAtEvent(e) {
						return Interaction.modes.single(this, e);
					},

					getElementsAtEvent: function getElementsAtEvent(e) {
						return Interaction.modes.label(this, e, { intersect: true });
					},

					getElementsAtXAxis: function getElementsAtXAxis(e) {
						return Interaction.modes['x-axis'](this, e, { intersect: true });
					},

					getElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {
						var method = Interaction.modes[mode];
						if (typeof method === 'function') {
							return method(this, e, options);
						}

						return [];
					},

					getDatasetAtEvent: function getDatasetAtEvent(e) {
						return Interaction.modes.dataset(this, e, { intersect: true });
					},

					getDatasetMeta: function getDatasetMeta(datasetIndex) {
						var me = this;
						var dataset = me.data.datasets[datasetIndex];
						if (!dataset._meta) {
							dataset._meta = {};
						}

						var meta = dataset._meta[me.id];
						if (!meta) {
							meta = dataset._meta[me.id] = {
								type: null,
								data: [],
								dataset: null,
								controller: null,
								hidden: null, // See isDatasetVisible() comment
								xAxisID: null,
								yAxisID: null
							};
						}

						return meta;
					},

					getVisibleDatasetCount: function getVisibleDatasetCount() {
						var count = 0;
						for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
							if (this.isDatasetVisible(i)) {
								count++;
							}
						}
						return count;
					},

					isDatasetVisible: function isDatasetVisible(datasetIndex) {
						var meta = this.getDatasetMeta(datasetIndex);

						// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
						// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
						return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
					},

					generateLegend: function generateLegend() {
						return this.options.legendCallback(this);
					},

					/**
      * @private
      */
					destroyDatasetMeta: function destroyDatasetMeta(datasetIndex) {
						var id = this.id;
						var dataset = this.data.datasets[datasetIndex];
						var meta = dataset._meta && dataset._meta[id];

						if (meta) {
							meta.controller.destroy();
							delete dataset._meta[id];
						}
					},

					destroy: function destroy() {
						var me = this;
						var canvas = me.canvas;
						var i, ilen;

						me.stop();

						// dataset controllers need to cleanup associated data
						for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
							me.destroyDatasetMeta(i);
						}

						if (canvas) {
							me.unbindEvents();
							helpers.canvas.clear(me);
							platform.releaseContext(me.ctx);
							me.canvas = null;
							me.ctx = null;
						}

						plugins.notify(me, 'destroy');

						delete Chart.instances[me.id];
					},

					toBase64Image: function toBase64Image() {
						return this.canvas.toDataURL.apply(this.canvas, arguments);
					},

					initToolTip: function initToolTip() {
						var me = this;
						me.tooltip = new Chart.Tooltip({
							_chart: me,
							_chartInstance: me, // deprecated, backward compatibility
							_data: me.data,
							_options: me.options.tooltips
						}, me);
					},

					/**
      * @private
      */
					bindEvents: function bindEvents() {
						var me = this;
						var listeners = me._listeners = {};
						var listener = function listener() {
							me.eventHandler.apply(me, arguments);
						};

						helpers.each(me.options.events, function (type) {
							platform.addEventListener(me, type, listener);
							listeners[type] = listener;
						});

						// Elements used to detect size change should not be injected for non responsive charts.
						// See https://github.com/chartjs/Chart.js/issues/2210
						if (me.options.responsive) {
							listener = function listener() {
								me.resize();
							};

							platform.addEventListener(me, 'resize', listener);
							listeners.resize = listener;
						}
					},

					/**
      * @private
      */
					unbindEvents: function unbindEvents() {
						var me = this;
						var listeners = me._listeners;
						if (!listeners) {
							return;
						}

						delete me._listeners;
						helpers.each(listeners, function (listener, type) {
							platform.removeEventListener(me, type, listener);
						});
					},

					updateHoverStyle: function updateHoverStyle(elements, mode, enabled) {
						var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
						var element, i, ilen;

						for (i = 0, ilen = elements.length; i < ilen; ++i) {
							element = elements[i];
							if (element) {
								this.getDatasetMeta(element._datasetIndex).controller[method](element);
							}
						}
					},

					/**
      * @private
      */
					eventHandler: function eventHandler(e) {
						var me = this;
						var tooltip = me.tooltip;

						if (plugins.notify(me, 'beforeEvent', [e]) === false) {
							return;
						}

						// Buffer any update calls so that renders do not occur
						me._bufferedRender = true;
						me._bufferedRequest = null;

						var changed = me.handleEvent(e);
						changed |= tooltip && tooltip.handleEvent(e);

						plugins.notify(me, 'afterEvent', [e]);

						var bufferedRequest = me._bufferedRequest;
						if (bufferedRequest) {
							// If we have an update that was triggered, we need to do a normal render
							me.render(bufferedRequest);
						} else if (changed && !me.animating) {
							// If entering, leaving, or changing elements, animate the change via pivot
							me.stop();

							// We only need to render at this point. Updating will cause scales to be
							// recomputed generating flicker & using more memory than necessary.
							me.render(me.options.hover.animationDuration, true);
						}

						me._bufferedRender = false;
						me._bufferedRequest = null;

						return me;
					},

					/**
      * Handle an event
      * @private
      * @param {IEvent} event the event to handle
      * @return {Boolean} true if the chart needs to re-render
      */
					handleEvent: function handleEvent(e) {
						var me = this;
						var options = me.options || {};
						var hoverOptions = options.hover;
						var changed = false;

						me.lastActive = me.lastActive || [];

						// Find Active Elements for hover and tooltips
						if (e.type === 'mouseout') {
							me.active = [];
						} else {
							me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
						}

						// Invoke onHover hook
						// Need to call with native event here to not break backwards compatibility
						helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

						if (e.type === 'mouseup' || e.type === 'click') {
							if (options.onClick) {
								// Use e.native here for backwards compatibility
								options.onClick.call(me, e.native, me.active);
							}
						}

						// Remove styling for last active (even if it may still be active)
						if (me.lastActive.length) {
							me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
						}

						// Built in hover styling
						if (me.active.length && hoverOptions.mode) {
							me.updateHoverStyle(me.active, hoverOptions.mode, true);
						}

						changed = !helpers.arrayEquals(me.active, me.lastActive);

						// Remember Last Actives
						me.lastActive = me.active;

						return changed;
					}
				});

				/**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */
				Chart.Controller = Chart;
			};
		}, { "25": 25, "28": 28, "45": 45, "48": 48 }], 24: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			module.exports = function (Chart) {

				var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

				/**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */
				function listenArrayEvents(array, listener) {
					if (array._chartjs) {
						array._chartjs.listeners.push(listener);
						return;
					}

					Object.defineProperty(array, '_chartjs', {
						configurable: true,
						enumerable: false,
						value: {
							listeners: [listener]
						}
					});

					arrayEvents.forEach(function (key) {
						var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
						var base = array[key];

						Object.defineProperty(array, key, {
							configurable: true,
							enumerable: false,
							value: function value() {
								var args = Array.prototype.slice.call(arguments);
								var res = base.apply(this, args);

								helpers.each(array._chartjs.listeners, function (object) {
									if (typeof object[method] === 'function') {
										object[method].apply(object, args);
									}
								});

								return res;
							}
						});
					});
				}

				/**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */
				function unlistenArrayEvents(array, listener) {
					var stub = array._chartjs;
					if (!stub) {
						return;
					}

					var listeners = stub.listeners;
					var index = listeners.indexOf(listener);
					if (index !== -1) {
						listeners.splice(index, 1);
					}

					if (listeners.length > 0) {
						return;
					}

					arrayEvents.forEach(function (key) {
						delete array[key];
					});

					delete array._chartjs;
				}

				// Base class for all dataset controllers (line, bar, etc)
				Chart.DatasetController = function (chart, datasetIndex) {
					this.initialize(chart, datasetIndex);
				};

				helpers.extend(Chart.DatasetController.prototype, {

					/**
      * Element type used to generate a meta dataset (e.g. Chart.element.Line).
      * @type {Chart.core.element}
      */
					datasetElementType: null,

					/**
      * Element type used to generate a meta data (e.g. Chart.element.Point).
      * @type {Chart.core.element}
      */
					dataElementType: null,

					initialize: function initialize(chart, datasetIndex) {
						var me = this;
						me.chart = chart;
						me.index = datasetIndex;
						me.linkScales();
						me.addElements();
					},

					updateIndex: function updateIndex(datasetIndex) {
						this.index = datasetIndex;
					},

					linkScales: function linkScales() {
						var me = this;
						var meta = me.getMeta();
						var dataset = me.getDataset();

						if (meta.xAxisID === null) {
							meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
						}
						if (meta.yAxisID === null) {
							meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
						}
					},

					getDataset: function getDataset() {
						return this.chart.data.datasets[this.index];
					},

					getMeta: function getMeta() {
						return this.chart.getDatasetMeta(this.index);
					},

					getScaleForId: function getScaleForId(scaleID) {
						return this.chart.scales[scaleID];
					},

					reset: function reset() {
						this.update(true);
					},

					/**
      * @private
      */
					destroy: function destroy() {
						if (this._data) {
							unlistenArrayEvents(this._data, this);
						}
					},

					createMetaDataset: function createMetaDataset() {
						var me = this;
						var type = me.datasetElementType;
						return type && new type({
							_chart: me.chart,
							_datasetIndex: me.index
						});
					},

					createMetaData: function createMetaData(index) {
						var me = this;
						var type = me.dataElementType;
						return type && new type({
							_chart: me.chart,
							_datasetIndex: me.index,
							_index: index
						});
					},

					addElements: function addElements() {
						var me = this;
						var meta = me.getMeta();
						var data = me.getDataset().data || [];
						var metaData = meta.data;
						var i, ilen;

						for (i = 0, ilen = data.length; i < ilen; ++i) {
							metaData[i] = metaData[i] || me.createMetaData(i);
						}

						meta.dataset = meta.dataset || me.createMetaDataset();
					},

					addElementAndReset: function addElementAndReset(index) {
						var element = this.createMetaData(index);
						this.getMeta().data.splice(index, 0, element);
						this.updateElement(element, index, true);
					},

					buildOrUpdateElements: function buildOrUpdateElements() {
						var me = this;
						var dataset = me.getDataset();
						var data = dataset.data || (dataset.data = []);

						// In order to correctly handle data addition/deletion animation (an thus simulate
						// real-time charts), we need to monitor these data modifications and synchronize
						// the internal meta data accordingly.
						if (me._data !== data) {
							if (me._data) {
								// This case happens when the user replaced the data array instance.
								unlistenArrayEvents(me._data, me);
							}

							listenArrayEvents(data, me);
							me._data = data;
						}

						// Re-sync meta data in case the user replaced the data array or if we missed
						// any updates and so make sure that we handle number of datapoints changing.
						me.resyncElements();
					},

					update: helpers.noop,

					transition: function transition(easingValue) {
						var meta = this.getMeta();
						var elements = meta.data || [];
						var ilen = elements.length;
						var i = 0;

						for (; i < ilen; ++i) {
							elements[i].transition(easingValue);
						}

						if (meta.dataset) {
							meta.dataset.transition(easingValue);
						}
					},

					draw: function draw() {
						var meta = this.getMeta();
						var elements = meta.data || [];
						var ilen = elements.length;
						var i = 0;

						if (meta.dataset) {
							meta.dataset.draw();
						}

						for (; i < ilen; ++i) {
							elements[i].draw();
						}
					},

					removeHoverStyle: function removeHoverStyle(element, elementOpts) {
						var dataset = this.chart.data.datasets[element._datasetIndex];
						var index = element._index;
						var custom = element.custom || {};
						var valueOrDefault = helpers.valueAtIndexOrDefault;
						var model = element._model;

						model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
						model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
						model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
					},

					setHoverStyle: function setHoverStyle(element) {
						var dataset = this.chart.data.datasets[element._datasetIndex];
						var index = element._index;
						var custom = element.custom || {};
						var valueOrDefault = helpers.valueAtIndexOrDefault;
						var getHoverColor = helpers.getHoverColor;
						var model = element._model;

						model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
						model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
						model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
					},

					/**
      * @private
      */
					resyncElements: function resyncElements() {
						var me = this;
						var meta = me.getMeta();
						var data = me.getDataset().data;
						var numMeta = meta.data.length;
						var numData = data.length;

						if (numData < numMeta) {
							meta.data.splice(numData, numMeta - numData);
						} else if (numData > numMeta) {
							me.insertElements(numMeta, numData - numMeta);
						}
					},

					/**
      * @private
      */
					insertElements: function insertElements(start, count) {
						for (var i = 0; i < count; ++i) {
							this.addElementAndReset(start + i);
						}
					},

					/**
      * @private
      */
					onDataPush: function onDataPush() {
						this.insertElements(this.getDataset().data.length - 1, arguments.length);
					},

					/**
      * @private
      */
					onDataPop: function onDataPop() {
						this.getMeta().data.pop();
					},

					/**
      * @private
      */
					onDataShift: function onDataShift() {
						this.getMeta().data.shift();
					},

					/**
      * @private
      */
					onDataSplice: function onDataSplice(start, count) {
						this.getMeta().data.splice(start, count);
						this.insertElements(start, arguments.length - 2);
					},

					/**
      * @private
      */
					onDataUnshift: function onDataUnshift() {
						this.insertElements(0, arguments.length);
					}
				});

				Chart.DatasetController.extend = helpers.inherits;
			};
		}, { "45": 45 }], 25: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			module.exports = {
				/**
     * @private
     */
				_set: function _set(scope, values) {
					return helpers.merge(this[scope] || (this[scope] = {}), values);
				}
			};
		}, { "45": 45 }], 26: [function (require, module, exports) {
			'use strict';

			var color = require(3);
			var helpers = require(45);

			function interpolate(start, view, model, ease) {
				var keys = Object.keys(model);
				var i, ilen, key, actual, origin, target, type, c0, c1;

				for (i = 0, ilen = keys.length; i < ilen; ++i) {
					key = keys[i];

					target = model[key];

					// if a value is added to the model after pivot() has been called, the view
					// doesn't contain it, so let's initialize the view to the target value.
					if (!view.hasOwnProperty(key)) {
						view[key] = target;
					}

					actual = view[key];

					if (actual === target || key[0] === '_') {
						continue;
					}

					if (!start.hasOwnProperty(key)) {
						start[key] = actual;
					}

					origin = start[key];

					type = typeof target === "undefined" ? "undefined" : _typeof(target);

					if (type === (typeof origin === "undefined" ? "undefined" : _typeof(origin))) {
						if (type === 'string') {
							c0 = color(origin);
							if (c0.valid) {
								c1 = color(target);
								if (c1.valid) {
									view[key] = c1.mix(c0, ease).rgbString();
									continue;
								}
							}
						} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
							view[key] = origin + (target - origin) * ease;
							continue;
						}
					}

					view[key] = target;
				}
			}

			var Element = function Element(configuration) {
				helpers.extend(this, configuration);
				this.initialize.apply(this, arguments);
			};

			helpers.extend(Element.prototype, {

				initialize: function initialize() {
					this.hidden = false;
				},

				pivot: function pivot() {
					var me = this;
					if (!me._view) {
						me._view = helpers.clone(me._model);
					}
					me._start = {};
					return me;
				},

				transition: function transition(ease) {
					var me = this;
					var model = me._model;
					var start = me._start;
					var view = me._view;

					// No animation -> No Transition
					if (!model || ease === 1) {
						me._view = model;
						me._start = null;
						return me;
					}

					if (!view) {
						view = me._view = {};
					}

					if (!start) {
						start = me._start = {};
					}

					interpolate(start, view, model, ease);

					return me;
				},

				tooltipPosition: function tooltipPosition() {
					return {
						x: this._model.x,
						y: this._model.y
					};
				},

				hasValue: function hasValue() {
					return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
				}
			});

			Element.extend = helpers.inherits;

			module.exports = Element;
		}, { "3": 3, "45": 45 }], 27: [function (require, module, exports) {
			/* global window: false */
			/* global document: false */
			'use strict';

			var color = require(3);
			var defaults = require(25);
			var helpers = require(45);

			module.exports = function (Chart) {

				// -- Basic js utility methods

				helpers.extend = function (base) {
					var setFn = function setFn(value, key) {
						base[key] = value;
					};
					for (var i = 1, ilen = arguments.length; i < ilen; i++) {
						helpers.each(arguments[i], setFn);
					}
					return base;
				};

				helpers.configMerge = function () /* objects ... */{
					return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
						merger: function merger(key, target, source, options) {
							var tval = target[key] || {};
							var sval = source[key];

							if (key === 'scales') {
								// scale config merging is complex. Add our own function here for that
								target[key] = helpers.scaleMerge(tval, sval);
							} else if (key === 'scale') {
								// used in polar area & radar charts since there is only one scale
								target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
							} else {
								helpers._merger(key, target, source, options);
							}
						}
					});
				};

				helpers.scaleMerge = function () /* objects ... */{
					return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
						merger: function merger(key, target, source, options) {
							if (key === 'xAxes' || key === 'yAxes') {
								var slen = source[key].length;
								var i, type, scale;

								if (!target[key]) {
									target[key] = [];
								}

								for (i = 0; i < slen; ++i) {
									scale = source[key][i];
									type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

									if (i >= target[key].length) {
										target[key].push({});
									}

									if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
										// new/untyped scale or type changed: let's apply the new defaults
										// then merge source scale to correctly overwrite the defaults.
										helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
									} else {
										// scales type are the same
										helpers.merge(target[key][i], scale);
									}
								}
							} else {
								helpers._merger(key, target, source, options);
							}
						}
					});
				};

				helpers.where = function (collection, filterCallback) {
					if (helpers.isArray(collection) && Array.prototype.filter) {
						return collection.filter(filterCallback);
					}
					var filtered = [];

					helpers.each(collection, function (item) {
						if (filterCallback(item)) {
							filtered.push(item);
						}
					});

					return filtered;
				};
				helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
					return array.findIndex(callback, scope);
				} : function (array, callback, scope) {
					scope = scope === undefined ? array : scope;
					for (var i = 0, ilen = array.length; i < ilen; ++i) {
						if (callback.call(scope, array[i], i, array)) {
							return i;
						}
					}
					return -1;
				};
				helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
					// Default to start of the array
					if (helpers.isNullOrUndef(startIndex)) {
						startIndex = -1;
					}
					for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
						var currentItem = arrayToSearch[i];
						if (filterCallback(currentItem)) {
							return currentItem;
						}
					}
				};
				helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
					// Default to end of the array
					if (helpers.isNullOrUndef(startIndex)) {
						startIndex = arrayToSearch.length;
					}
					for (var i = startIndex - 1; i >= 0; i--) {
						var currentItem = arrayToSearch[i];
						if (filterCallback(currentItem)) {
							return currentItem;
						}
					}
				};
				helpers.inherits = function (extensions) {
					// Basic javascript inheritance based on the model created in Backbone.js
					var me = this;
					var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
						return me.apply(this, arguments);
					};

					var Surrogate = function Surrogate() {
						this.constructor = ChartElement;
					};
					Surrogate.prototype = me.prototype;
					ChartElement.prototype = new Surrogate();

					ChartElement.extend = helpers.inherits;

					if (extensions) {
						helpers.extend(ChartElement.prototype, extensions);
					}

					ChartElement.__super__ = me.prototype;

					return ChartElement;
				};
				// -- Math methods
				helpers.isNumber = function (n) {
					return !isNaN(parseFloat(n)) && isFinite(n);
				};
				helpers.almostEquals = function (x, y, epsilon) {
					return Math.abs(x - y) < epsilon;
				};
				helpers.almostWhole = function (x, epsilon) {
					var rounded = Math.round(x);
					return rounded - epsilon < x && rounded + epsilon > x;
				};
				helpers.max = function (array) {
					return array.reduce(function (max, value) {
						if (!isNaN(value)) {
							return Math.max(max, value);
						}
						return max;
					}, Number.NEGATIVE_INFINITY);
				};
				helpers.min = function (array) {
					return array.reduce(function (min, value) {
						if (!isNaN(value)) {
							return Math.min(min, value);
						}
						return min;
					}, Number.POSITIVE_INFINITY);
				};
				helpers.sign = Math.sign ? function (x) {
					return Math.sign(x);
				} : function (x) {
					x = +x; // convert to a number
					if (x === 0 || isNaN(x)) {
						return x;
					}
					return x > 0 ? 1 : -1;
				};
				helpers.log10 = Math.log10 ? function (x) {
					return Math.log10(x);
				} : function (x) {
					return Math.log(x) / Math.LN10;
				};
				helpers.toRadians = function (degrees) {
					return degrees * (Math.PI / 180);
				};
				helpers.toDegrees = function (radians) {
					return radians * (180 / Math.PI);
				};
				// Gets the angle from vertical upright to the point about a centre.
				helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
					var distanceFromXCenter = anglePoint.x - centrePoint.x;
					var distanceFromYCenter = anglePoint.y - centrePoint.y;
					var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

					var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

					if (angle < -0.5 * Math.PI) {
						angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
					}

					return {
						angle: angle,
						distance: radialDistanceFromCenter
					};
				};
				helpers.distanceBetweenPoints = function (pt1, pt2) {
					return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
				};
				helpers.aliasPixel = function (pixelWidth) {
					return pixelWidth % 2 === 0 ? 0 : 0.5;
				};
				helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
					// Props to Rob Spencer at scaled innovation for his post on splining between points
					// http://scaledinnovation.com/analytics/splines/aboutSplines.html

					// This function must also respect "skipped" points

					var previous = firstPoint.skip ? middlePoint : firstPoint;
					var current = middlePoint;
					var next = afterPoint.skip ? middlePoint : afterPoint;

					var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
					var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

					var s01 = d01 / (d01 + d12);
					var s12 = d12 / (d01 + d12);

					// If all points are the same, s01 & s02 will be inf
					s01 = isNaN(s01) ? 0 : s01;
					s12 = isNaN(s12) ? 0 : s12;

					var fa = t * s01; // scaling factor for triangle Ta
					var fb = t * s12;

					return {
						previous: {
							x: current.x - fa * (next.x - previous.x),
							y: current.y - fa * (next.y - previous.y)
						},
						next: {
							x: current.x + fb * (next.x - previous.x),
							y: current.y + fb * (next.y - previous.y)
						}
					};
				};
				helpers.EPSILON = Number.EPSILON || 1e-14;
				helpers.splineCurveMonotone = function (points) {
					// This function calculates Bézier control points in a similar way than |splineCurve|,
					// but preserves monotonicity of the provided data and ensures no local extremums are added
					// between the dataset discrete points due to the interpolation.
					// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

					var pointsWithTangents = (points || []).map(function (point) {
						return {
							model: point._model,
							deltaK: 0,
							mK: 0
						};
					});

					// Calculate slopes (deltaK) and initialize tangents (mK)
					var pointsLen = pointsWithTangents.length;
					var i, pointBefore, pointCurrent, pointAfter;
					for (i = 0; i < pointsLen; ++i) {
						pointCurrent = pointsWithTangents[i];
						if (pointCurrent.model.skip) {
							continue;
						}

						pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
						pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
						if (pointAfter && !pointAfter.model.skip) {
							var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;

							// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
							pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
						}

						if (!pointBefore || pointBefore.model.skip) {
							pointCurrent.mK = pointCurrent.deltaK;
						} else if (!pointAfter || pointAfter.model.skip) {
							pointCurrent.mK = pointBefore.deltaK;
						} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
							pointCurrent.mK = 0;
						} else {
							pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
						}
					}

					// Adjust tangents to ensure monotonic properties
					var alphaK, betaK, tauK, squaredMagnitude;
					for (i = 0; i < pointsLen - 1; ++i) {
						pointCurrent = pointsWithTangents[i];
						pointAfter = pointsWithTangents[i + 1];
						if (pointCurrent.model.skip || pointAfter.model.skip) {
							continue;
						}

						if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
							pointCurrent.mK = pointAfter.mK = 0;
							continue;
						}

						alphaK = pointCurrent.mK / pointCurrent.deltaK;
						betaK = pointAfter.mK / pointCurrent.deltaK;
						squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
						if (squaredMagnitude <= 9) {
							continue;
						}

						tauK = 3 / Math.sqrt(squaredMagnitude);
						pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
						pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
					}

					// Compute control points
					var deltaX;
					for (i = 0; i < pointsLen; ++i) {
						pointCurrent = pointsWithTangents[i];
						if (pointCurrent.model.skip) {
							continue;
						}

						pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
						pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
						if (pointBefore && !pointBefore.model.skip) {
							deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
							pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
							pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
						}
						if (pointAfter && !pointAfter.model.skip) {
							deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
							pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
							pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
						}
					}
				};
				helpers.nextItem = function (collection, index, loop) {
					if (loop) {
						return index >= collection.length - 1 ? collection[0] : collection[index + 1];
					}
					return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
				};
				helpers.previousItem = function (collection, index, loop) {
					if (loop) {
						return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
					}
					return index <= 0 ? collection[0] : collection[index - 1];
				};
				// Implementation of the nice number algorithm used in determining where axis labels will go
				helpers.niceNum = function (range, round) {
					var exponent = Math.floor(helpers.log10(range));
					var fraction = range / Math.pow(10, exponent);
					var niceFraction;

					if (round) {
						if (fraction < 1.5) {
							niceFraction = 1;
						} else if (fraction < 3) {
							niceFraction = 2;
						} else if (fraction < 7) {
							niceFraction = 5;
						} else {
							niceFraction = 10;
						}
					} else if (fraction <= 1.0) {
						niceFraction = 1;
					} else if (fraction <= 2) {
						niceFraction = 2;
					} else if (fraction <= 5) {
						niceFraction = 5;
					} else {
						niceFraction = 10;
					}

					return niceFraction * Math.pow(10, exponent);
				};
				// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
				helpers.requestAnimFrame = function () {
					if (typeof window === 'undefined') {
						return function (callback) {
							callback();
						};
					}
					return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
						return window.setTimeout(callback, 1000 / 60);
					};
				}();
				// -- DOM methods
				helpers.getRelativePosition = function (evt, chart) {
					var mouseX, mouseY;
					var e = evt.originalEvent || evt;
					var canvas = evt.currentTarget || evt.srcElement;
					var boundingRect = canvas.getBoundingClientRect();

					var touches = e.touches;
					if (touches && touches.length > 0) {
						mouseX = touches[0].clientX;
						mouseY = touches[0].clientY;
					} else {
						mouseX = e.clientX;
						mouseY = e.clientY;
					}

					// Scale mouse coordinates into canvas coordinates
					// by following the pattern laid out by 'jerryj' in the comments of
					// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
					var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
					var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
					var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
					var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
					var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
					var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

					// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
					// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
					mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
					mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);

					return {
						x: mouseX,
						y: mouseY
					};
				};

				// Private helper function to convert max-width/max-height values that may be percentages into a number
				function parseMaxStyle(styleValue, node, parentProperty) {
					var valueInPixels;
					if (typeof styleValue === 'string') {
						valueInPixels = parseInt(styleValue, 10);

						if (styleValue.indexOf('%') !== -1) {
							// percentage * size in dimension
							valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
						}
					} else {
						valueInPixels = styleValue;
					}

					return valueInPixels;
				}

				/**
     * Returns if the given value contains an effective constraint.
     * @private
     */
				function isConstrainedValue(value) {
					return value !== undefined && value !== null && value !== 'none';
				}

				// Private helper to get a constraint dimension
				// @param domNode : the node to check the constraint on
				// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
				// @param percentageProperty : property of parent to use when calculating width as a percentage
				// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
				function getConstraintDimension(domNode, maxStyle, percentageProperty) {
					var view = document.defaultView;
					var parentNode = domNode.parentNode;
					var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
					var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
					var hasCNode = isConstrainedValue(constrainedNode);
					var hasCContainer = isConstrainedValue(constrainedContainer);
					var infinity = Number.POSITIVE_INFINITY;

					if (hasCNode || hasCContainer) {
						return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
					}

					return 'none';
				}
				// returns Number or undefined if no constraint
				helpers.getConstraintWidth = function (domNode) {
					return getConstraintDimension(domNode, 'max-width', 'clientWidth');
				};
				// returns Number or undefined if no constraint
				helpers.getConstraintHeight = function (domNode) {
					return getConstraintDimension(domNode, 'max-height', 'clientHeight');
				};
				helpers.getMaximumWidth = function (domNode) {
					var container = domNode.parentNode;
					if (!container) {
						return domNode.clientWidth;
					}

					var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
					var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
					var w = container.clientWidth - paddingLeft - paddingRight;
					var cw = helpers.getConstraintWidth(domNode);
					return isNaN(cw) ? w : Math.min(w, cw);
				};
				helpers.getMaximumHeight = function (domNode) {
					var container = domNode.parentNode;
					if (!container) {
						return domNode.clientHeight;
					}

					var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
					var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
					var h = container.clientHeight - paddingTop - paddingBottom;
					var ch = helpers.getConstraintHeight(domNode);
					return isNaN(ch) ? h : Math.min(h, ch);
				};
				helpers.getStyle = function (el, property) {
					return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
				};
				helpers.retinaScale = function (chart, forceRatio) {
					var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
					if (pixelRatio === 1) {
						return;
					}

					var canvas = chart.canvas;
					var height = chart.height;
					var width = chart.width;

					canvas.height = height * pixelRatio;
					canvas.width = width * pixelRatio;
					chart.ctx.scale(pixelRatio, pixelRatio);

					// If no style has been set on the canvas, the render size is used as display size,
					// making the chart visually bigger, so let's enforce it to the "correct" values.
					// See https://github.com/chartjs/Chart.js/issues/3575
					canvas.style.height = height + 'px';
					canvas.style.width = width + 'px';
				};
				// -- Canvas methods
				helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
					return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
				};
				helpers.longestText = function (ctx, font, arrayOfThings, cache) {
					cache = cache || {};
					var data = cache.data = cache.data || {};
					var gc = cache.garbageCollect = cache.garbageCollect || [];

					if (cache.font !== font) {
						data = cache.data = {};
						gc = cache.garbageCollect = [];
						cache.font = font;
					}

					ctx.font = font;
					var longest = 0;
					helpers.each(arrayOfThings, function (thing) {
						// Undefined strings and arrays should not be measured
						if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
							longest = helpers.measureText(ctx, data, gc, longest, thing);
						} else if (helpers.isArray(thing)) {
							// if it is an array lets measure each element
							// to do maybe simplify this function a bit so we can do this more recursively?
							helpers.each(thing, function (nestedThing) {
								// Undefined strings and arrays should not be measured
								if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
									longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
								}
							});
						}
					});

					var gcLen = gc.length / 2;
					if (gcLen > arrayOfThings.length) {
						for (var i = 0; i < gcLen; i++) {
							delete data[gc[i]];
						}
						gc.splice(0, gcLen);
					}
					return longest;
				};
				helpers.measureText = function (ctx, data, gc, longest, string) {
					var textWidth = data[string];
					if (!textWidth) {
						textWidth = data[string] = ctx.measureText(string).width;
						gc.push(string);
					}
					if (textWidth > longest) {
						longest = textWidth;
					}
					return longest;
				};
				helpers.numberOfLabelLines = function (arrayOfThings) {
					var numberOfLines = 1;
					helpers.each(arrayOfThings, function (thing) {
						if (helpers.isArray(thing)) {
							if (thing.length > numberOfLines) {
								numberOfLines = thing.length;
							}
						}
					});
					return numberOfLines;
				};

				helpers.color = !color ? function (value) {
					console.error('Color.js not found!');
					return value;
				} : function (value) {
					/* global CanvasGradient */
					if (value instanceof CanvasGradient) {
						value = defaults.global.defaultColor;
					}

					return color(value);
				};

				helpers.getHoverColor = function (colorValue) {
					/* global CanvasPattern */
					return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
				};
			};
		}, { "25": 25, "3": 3, "45": 45 }], 28: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			/**
    * Helper function to get relative position for an event
    * @param {Event|IEvent} event - The event to get the position for
    * @param {Chart} chart - The chart
    * @returns {Point} the event position
    */
			function getRelativePosition(e, chart) {
				if (e.native) {
					return {
						x: e.x,
						y: e.y
					};
				}

				return helpers.getRelativePosition(e, chart);
			}

			/**
    * Helper function to traverse all of the visible elements in the chart
    * @param chart {chart} the chart
    * @param handler {Function} the callback to execute for each visible item
    */
			function parseVisibleItems(chart, handler) {
				var datasets = chart.data.datasets;
				var meta, i, j, ilen, jlen;

				for (i = 0, ilen = datasets.length; i < ilen; ++i) {
					if (!chart.isDatasetVisible(i)) {
						continue;
					}

					meta = chart.getDatasetMeta(i);
					for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
						var element = meta.data[j];
						if (!element._view.skip) {
							handler(element);
						}
					}
				}
			}

			/**
    * Helper function to get the items that intersect the event position
    * @param items {ChartElement[]} elements to filter
    * @param position {Point} the point to be nearest to
    * @return {ChartElement[]} the nearest items
    */
			function getIntersectItems(chart, position) {
				var elements = [];

				parseVisibleItems(chart, function (element) {
					if (element.inRange(position.x, position.y)) {
						elements.push(element);
					}
				});

				return elements;
			}

			/**
    * Helper function to get the items nearest to the event position considering all visible items in teh chart
    * @param chart {Chart} the chart to look at elements from
    * @param position {Point} the point to be nearest to
    * @param intersect {Boolean} if true, only consider items that intersect the position
    * @param distanceMetric {Function} function to provide the distance between points
    * @return {ChartElement[]} the nearest items
    */
			function getNearestItems(chart, position, intersect, distanceMetric) {
				var minDistance = Number.POSITIVE_INFINITY;
				var nearestItems = [];

				parseVisibleItems(chart, function (element) {
					if (intersect && !element.inRange(position.x, position.y)) {
						return;
					}

					var center = element.getCenterPoint();
					var distance = distanceMetric(position, center);

					if (distance < minDistance) {
						nearestItems = [element];
						minDistance = distance;
					} else if (distance === minDistance) {
						// Can have multiple items at the same distance in which case we sort by size
						nearestItems.push(element);
					}
				});

				return nearestItems;
			}

			/**
    * Get a distance metric function for two points based on the
    * axis mode setting
    * @param {String} axis the axis mode. x|y|xy
    */
			function getDistanceMetricForAxis(axis) {
				var useX = axis.indexOf('x') !== -1;
				var useY = axis.indexOf('y') !== -1;

				return function (pt1, pt2) {
					var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
					var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
					return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
				};
			}

			function indexMode(chart, e, options) {
				var position = getRelativePosition(e, chart);
				// Default axis for index mode is 'x' to match old behaviour
				options.axis = options.axis || 'x';
				var distanceMetric = getDistanceMetricForAxis(options.axis);
				var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
				var elements = [];

				if (!items.length) {
					return [];
				}

				chart.data.datasets.forEach(function (dataset, datasetIndex) {
					if (chart.isDatasetVisible(datasetIndex)) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var element = meta.data[items[0]._index];

						// don't count items that are skipped (null data)
						if (element && !element._view.skip) {
							elements.push(element);
						}
					}
				});

				return elements;
			}

			/**
    * @interface IInteractionOptions
    */
			/**
    * If true, only consider items that intersect the point
    * @name IInterfaceOptions#boolean
    * @type Boolean
    */

			/**
    * Contains interaction related functions
    * @namespace Chart.Interaction
    */
			module.exports = {
				// Helper function for different modes
				modes: {
					single: function single(chart, e) {
						var position = getRelativePosition(e, chart);
						var elements = [];

						parseVisibleItems(chart, function (element) {
							if (element.inRange(position.x, position.y)) {
								elements.push(element);
								return elements;
							}
						});

						return elements.slice(0, 1);
					},

					/**
      * @function Chart.Interaction.modes.label
      * @deprecated since version 2.4.0
      * @todo remove at version 3
      * @private
      */
					label: indexMode,

					/**
      * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
      * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
      * @function Chart.Interaction.modes.index
      * @since v2.4.0
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use during interaction
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					index: indexMode,

					/**
      * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
      * If the options.intersect is false, we find the nearest item and return the items in that dataset
      * @function Chart.Interaction.modes.dataset
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use during interaction
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					dataset: function dataset(chart, e, options) {
						var position = getRelativePosition(e, chart);
						options.axis = options.axis || 'xy';
						var distanceMetric = getDistanceMetricForAxis(options.axis);
						var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

						if (items.length > 0) {
							items = chart.getDatasetMeta(items[0]._datasetIndex).data;
						}

						return items;
					},

					/**
      * @function Chart.Interaction.modes.x-axis
      * @deprecated since version 2.4.0. Use index mode and intersect == true
      * @todo remove at version 3
      * @private
      */
					'x-axis': function xAxis(chart, e) {
						return indexMode(chart, e, { intersect: true });
					},

					/**
      * Point mode returns all elements that hit test based on the event position
      * of the event
      * @function Chart.Interaction.modes.intersect
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					point: function point(chart, e) {
						var position = getRelativePosition(e, chart);
						return getIntersectItems(chart, position);
					},

					/**
      * nearest mode returns the element closest to the point
      * @function Chart.Interaction.modes.intersect
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					nearest: function nearest(chart, e, options) {
						var position = getRelativePosition(e, chart);
						options.axis = options.axis || 'xy';
						var distanceMetric = getDistanceMetricForAxis(options.axis);
						var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

						// We have multiple items at the same distance from the event. Now sort by smallest
						if (nearestItems.length > 1) {
							nearestItems.sort(function (a, b) {
								var sizeA = a.getArea();
								var sizeB = b.getArea();
								var ret = sizeA - sizeB;

								if (ret === 0) {
									// if equal sort by dataset index
									ret = a._datasetIndex - b._datasetIndex;
								}

								return ret;
							});
						}

						// Return only 1 item
						return nearestItems.slice(0, 1);
					},

					/**
      * x mode returns the elements that hit-test at the current x coordinate
      * @function Chart.Interaction.modes.x
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					x: function x(chart, e, options) {
						var position = getRelativePosition(e, chart);
						var items = [];
						var intersectsItem = false;

						parseVisibleItems(chart, function (element) {
							if (element.inXRange(position.x)) {
								items.push(element);
							}

							if (element.inRange(position.x, position.y)) {
								intersectsItem = true;
							}
						});

						// If we want to trigger on an intersect and we don't have any items
						// that intersect the position, return nothing
						if (options.intersect && !intersectsItem) {
							items = [];
						}
						return items;
					},

					/**
      * y mode returns the elements that hit-test at the current y coordinate
      * @function Chart.Interaction.modes.y
      * @param chart {chart} the chart we are returning items from
      * @param e {Event} the event we are find things at
      * @param options {IInteractionOptions} options to use
      * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
      */
					y: function y(chart, e, options) {
						var position = getRelativePosition(e, chart);
						var items = [];
						var intersectsItem = false;

						parseVisibleItems(chart, function (element) {
							if (element.inYRange(position.y)) {
								items.push(element);
							}

							if (element.inRange(position.x, position.y)) {
								intersectsItem = true;
							}
						});

						// If we want to trigger on an intersect and we don't have any items
						// that intersect the position, return nothing
						if (options.intersect && !intersectsItem) {
							items = [];
						}
						return items;
					}
				}
			};
		}, { "45": 45 }], 29: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);

			defaults._set('global', {
				responsive: true,
				responsiveAnimationDuration: 0,
				maintainAspectRatio: true,
				events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
				hover: {
					onHover: null,
					mode: 'nearest',
					intersect: true,
					animationDuration: 400
				},
				onClick: null,
				defaultColor: 'rgba(0,0,0,0.1)',
				defaultFontColor: '#666',
				defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
				defaultFontSize: 12,
				defaultFontStyle: 'normal',
				showLines: true,

				// Element defaults defined in element extensions
				elements: {},

				// Layout options such as padding
				layout: {
					padding: {
						top: 0,
						right: 0,
						bottom: 0,
						left: 0
					}
				}
			});

			module.exports = function () {

				// Occupy the global variable of Chart, and create a simple base class
				var Chart = function Chart(item, config) {
					this.construct(item, config);
					return this;
				};

				Chart.Chart = Chart;

				return Chart;
			};
		}, { "25": 25 }], 30: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			module.exports = function (Chart) {

				function filterByPosition(array, position) {
					return helpers.where(array, function (v) {
						return v.position === position;
					});
				}

				function sortByWeight(array, reverse) {
					array.forEach(function (v, i) {
						v._tmpIndex_ = i;
						return v;
					});
					array.sort(function (a, b) {
						var v0 = reverse ? b : a;
						var v1 = reverse ? a : b;
						return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
					});
					array.forEach(function (v) {
						delete v._tmpIndex_;
					});
				}

				/**
     * @interface ILayoutItem
     * @prop {String} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {Function} update - Takes two parameters: width and height. Returns size of item
     * @prop {Function} getPadding -  Returns an object with padding on the edges
     * @prop {Number} width - Width of item. Must be valid after update()
     * @prop {Number} height - Height of item. Must be valid after update()
     * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */

				// The layout service is very self explanatory.  It's responsible for the layout within a chart.
				// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
				// It is this service's responsibility of carrying out that layout.
				Chart.layoutService = {
					defaults: {},

					/**
      * Register a box to a chart.
      * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
      * @param {Chart} chart - the chart to use
      * @param {ILayoutItem} item - the item to add to be layed out
      */
					addBox: function addBox(chart, item) {
						if (!chart.boxes) {
							chart.boxes = [];
						}

						// initialize item with default values
						item.fullWidth = item.fullWidth || false;
						item.position = item.position || 'top';
						item.weight = item.weight || 0;

						chart.boxes.push(item);
					},

					/**
      * Remove a layoutItem from a chart
      * @param {Chart} chart - the chart to remove the box from
      * @param {Object} layoutItem - the item to remove from the layout
      */
					removeBox: function removeBox(chart, layoutItem) {
						var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
						if (index !== -1) {
							chart.boxes.splice(index, 1);
						}
					},

					/**
      * Sets (or updates) options on the given `item`.
      * @param {Chart} chart - the chart in which the item lives (or will be added to)
      * @param {Object} item - the item to configure with the given options
      * @param {Object} options - the new item options.
      */
					configure: function configure(chart, item, options) {
						var props = ['fullWidth', 'position', 'weight'];
						var ilen = props.length;
						var i = 0;
						var prop;

						for (; i < ilen; ++i) {
							prop = props[i];
							if (options.hasOwnProperty(prop)) {
								item[prop] = options[prop];
							}
						}
					},

					/**
      * Fits boxes of the given chart into the given size by having each box measure itself
      * then running a fitting algorithm
      * @param {Chart} chart - the chart
      * @param {Number} width - the width to fit into
      * @param {Number} height - the height to fit into
      */
					update: function update(chart, width, height) {
						if (!chart) {
							return;
						}

						var layoutOptions = chart.options.layout || {};
						var padding = helpers.options.toPadding(layoutOptions.padding);
						var leftPadding = padding.left;
						var rightPadding = padding.right;
						var topPadding = padding.top;
						var bottomPadding = padding.bottom;

						var leftBoxes = filterByPosition(chart.boxes, 'left');
						var rightBoxes = filterByPosition(chart.boxes, 'right');
						var topBoxes = filterByPosition(chart.boxes, 'top');
						var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
						var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

						// Sort boxes by weight. A higher weight is further away from the chart area
						sortByWeight(leftBoxes, true);
						sortByWeight(rightBoxes, false);
						sortByWeight(topBoxes, true);
						sortByWeight(bottomBoxes, false);

						// Essentially we now have any number of boxes on each of the 4 sides.
						// Our canvas looks like the following.
						// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
						// B1 is the bottom axis
						// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
						// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
						// an error will be thrown.
						//
						// |----------------------------------------------------|
						// |                  T1 (Full Width)                   |
						// |----------------------------------------------------|
						// |    |    |                 T2                  |    |
						// |    |----|-------------------------------------|----|
						// |    |    | C1 |                           | C2 |    |
						// |    |    |----|                           |----|    |
						// |    |    |                                     |    |
						// | L1 | L2 |           ChartArea (C0)            | R1 |
						// |    |    |                                     |    |
						// |    |    |----|                           |----|    |
						// |    |    | C3 |                           | C4 |    |
						// |    |----|-------------------------------------|----|
						// |    |    |                 B1                  |    |
						// |----------------------------------------------------|
						// |                  B2 (Full Width)                   |
						// |----------------------------------------------------|
						//
						// What we do to find the best sizing, we do the following
						// 1. Determine the minimum size of the chart area.
						// 2. Split the remaining width equally between each vertical axis
						// 3. Split the remaining height equally between each horizontal axis
						// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
						// 5. Adjust the sizes of each axis based on it's minimum reported size.
						// 6. Refit each axis
						// 7. Position each axis in the final location
						// 8. Tell the chart the final location of the chart area
						// 9. Tell any axes that overlay the chart area the positions of the chart area

						// Step 1
						var chartWidth = width - leftPadding - rightPadding;
						var chartHeight = height - topPadding - bottomPadding;
						var chartAreaWidth = chartWidth / 2; // min 50%
						var chartAreaHeight = chartHeight / 2; // min 50%

						// Step 2
						var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

						// Step 3
						var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

						// Step 4
						var maxChartAreaWidth = chartWidth;
						var maxChartAreaHeight = chartHeight;
						var minBoxSizes = [];

						function getMinimumBoxSize(box) {
							var minSize;
							var isHorizontal = box.isHorizontal();

							if (isHorizontal) {
								minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
								maxChartAreaHeight -= minSize.height;
							} else {
								minSize = box.update(verticalBoxWidth, chartAreaHeight);
								maxChartAreaWidth -= minSize.width;
							}

							minBoxSizes.push({
								horizontal: isHorizontal,
								minSize: minSize,
								box: box
							});
						}

						helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

						// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
						var maxHorizontalLeftPadding = 0;
						var maxHorizontalRightPadding = 0;
						var maxVerticalTopPadding = 0;
						var maxVerticalBottomPadding = 0;

						helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {
							if (horizontalBox.getPadding) {
								var boxPadding = horizontalBox.getPadding();
								maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
								maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
							}
						});

						helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {
							if (verticalBox.getPadding) {
								var boxPadding = verticalBox.getPadding();
								maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
								maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
							}
						});

						// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
						// be if the axes are drawn at their minimum sizes.
						// Steps 5 & 6
						var totalLeftBoxesWidth = leftPadding;
						var totalRightBoxesWidth = rightPadding;
						var totalTopBoxesHeight = topPadding;
						var totalBottomBoxesHeight = bottomPadding;

						// Function to fit a box
						function fitBox(box) {
							var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
								return minBox.box === box;
							});

							if (minBoxSize) {
								if (box.isHorizontal()) {
									var scaleMargin = {
										left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
										right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
										top: 0,
										bottom: 0
									};

									// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
									// on the margin. Sometimes they need to increase in size slightly
									box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
								} else {
									box.update(minBoxSize.minSize.width, maxChartAreaHeight);
								}
							}
						}

						// Update, and calculate the left and right margins for the horizontal boxes
						helpers.each(leftBoxes.concat(rightBoxes), fitBox);

						helpers.each(leftBoxes, function (box) {
							totalLeftBoxesWidth += box.width;
						});

						helpers.each(rightBoxes, function (box) {
							totalRightBoxesWidth += box.width;
						});

						// Set the Left and Right margins for the horizontal boxes
						helpers.each(topBoxes.concat(bottomBoxes), fitBox);

						// Figure out how much margin is on the top and bottom of the vertical boxes
						helpers.each(topBoxes, function (box) {
							totalTopBoxesHeight += box.height;
						});

						helpers.each(bottomBoxes, function (box) {
							totalBottomBoxesHeight += box.height;
						});

						function finalFitVerticalBox(box) {
							var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
								return minSize.box === box;
							});

							var scaleMargin = {
								left: 0,
								right: 0,
								top: totalTopBoxesHeight,
								bottom: totalBottomBoxesHeight
							};

							if (minBoxSize) {
								box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
							}
						}

						// Let the left layout know the final margin
						helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

						// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
						totalLeftBoxesWidth = leftPadding;
						totalRightBoxesWidth = rightPadding;
						totalTopBoxesHeight = topPadding;
						totalBottomBoxesHeight = bottomPadding;

						helpers.each(leftBoxes, function (box) {
							totalLeftBoxesWidth += box.width;
						});

						helpers.each(rightBoxes, function (box) {
							totalRightBoxesWidth += box.width;
						});

						helpers.each(topBoxes, function (box) {
							totalTopBoxesHeight += box.height;
						});
						helpers.each(bottomBoxes, function (box) {
							totalBottomBoxesHeight += box.height;
						});

						// We may be adding some padding to account for rotated x axis labels
						var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
						totalLeftBoxesWidth += leftPaddingAddition;
						totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

						var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
						totalTopBoxesHeight += topPaddingAddition;
						totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

						// Figure out if our chart area changed. This would occur if the dataset layout label rotation
						// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
						// without calling `fit` again
						var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
						var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

						if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
							helpers.each(leftBoxes, function (box) {
								box.height = newMaxChartAreaHeight;
							});

							helpers.each(rightBoxes, function (box) {
								box.height = newMaxChartAreaHeight;
							});

							helpers.each(topBoxes, function (box) {
								if (!box.fullWidth) {
									box.width = newMaxChartAreaWidth;
								}
							});

							helpers.each(bottomBoxes, function (box) {
								if (!box.fullWidth) {
									box.width = newMaxChartAreaWidth;
								}
							});

							maxChartAreaHeight = newMaxChartAreaHeight;
							maxChartAreaWidth = newMaxChartAreaWidth;
						}

						// Step 7 - Position the boxes
						var left = leftPadding + leftPaddingAddition;
						var top = topPadding + topPaddingAddition;

						function placeBox(box) {
							if (box.isHorizontal()) {
								box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
								box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
								box.top = top;
								box.bottom = top + box.height;

								// Move to next point
								top = box.bottom;
							} else {

								box.left = left;
								box.right = left + box.width;
								box.top = totalTopBoxesHeight;
								box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

								// Move to next point
								left = box.right;
							}
						}

						helpers.each(leftBoxes.concat(topBoxes), placeBox);

						// Account for chart width and height
						left += maxChartAreaWidth;
						top += maxChartAreaHeight;

						helpers.each(rightBoxes, placeBox);
						helpers.each(bottomBoxes, placeBox);

						// Step 8
						chart.chartArea = {
							left: totalLeftBoxesWidth,
							top: totalTopBoxesHeight,
							right: totalLeftBoxesWidth + maxChartAreaWidth,
							bottom: totalTopBoxesHeight + maxChartAreaHeight
						};

						// Step 9
						helpers.each(chartAreaBoxes, function (box) {
							box.left = chart.chartArea.left;
							box.top = chart.chartArea.top;
							box.right = chart.chartArea.right;
							box.bottom = chart.chartArea.bottom;

							box.update(maxChartAreaWidth, maxChartAreaHeight);
						});
					}
				};
			};
		}, { "45": 45 }], 31: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				plugins: {}
			});

			module.exports = function (Chart) {

				/**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */
				Chart.plugins = {
					/**
      * Globally registered plugins.
      * @private
      */
					_plugins: [],

					/**
      * This identifier is used to invalidate the descriptors cache attached to each chart
      * when a global plugin is registered or unregistered. In this case, the cache ID is
      * incremented and descriptors are regenerated during following API calls.
      * @private
      */
					_cacheId: 0,

					/**
      * Registers the given plugin(s) if not already registered.
      * @param {Array|Object} plugins plugin instance(s).
      */
					register: function register(plugins) {
						var p = this._plugins;
						[].concat(plugins).forEach(function (plugin) {
							if (p.indexOf(plugin) === -1) {
								p.push(plugin);
							}
						});

						this._cacheId++;
					},

					/**
      * Unregisters the given plugin(s) only if registered.
      * @param {Array|Object} plugins plugin instance(s).
      */
					unregister: function unregister(plugins) {
						var p = this._plugins;
						[].concat(plugins).forEach(function (plugin) {
							var idx = p.indexOf(plugin);
							if (idx !== -1) {
								p.splice(idx, 1);
							}
						});

						this._cacheId++;
					},

					/**
      * Remove all registered plugins.
      * @since 2.1.5
      */
					clear: function clear() {
						this._plugins = [];
						this._cacheId++;
					},

					/**
      * Returns the number of registered plugins?
      * @returns {Number}
      * @since 2.1.5
      */
					count: function count() {
						return this._plugins.length;
					},

					/**
      * Returns all registered plugin instances.
      * @returns {Array} array of plugin objects.
      * @since 2.1.5
      */
					getAll: function getAll() {
						return this._plugins;
					},

					/**
      * Calls enabled plugins for `chart` on the specified hook and with the given args.
      * This method immediately returns as soon as a plugin explicitly returns false. The
      * returned value can be used, for instance, to interrupt the current action.
      * @param {Object} chart - The chart instance for which plugins should be called.
      * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
      * @param {Array} [args] - Extra arguments to apply to the hook call.
      * @returns {Boolean} false if any of the plugins return false, else returns true.
      */
					notify: function notify(chart, hook, args) {
						var descriptors = this.descriptors(chart);
						var ilen = descriptors.length;
						var i, descriptor, plugin, params, method;

						for (i = 0; i < ilen; ++i) {
							descriptor = descriptors[i];
							plugin = descriptor.plugin;
							method = plugin[hook];
							if (typeof method === 'function') {
								params = [chart].concat(args || []);
								params.push(descriptor.options);
								if (method.apply(plugin, params) === false) {
									return false;
								}
							}
						}

						return true;
					},

					/**
      * Returns descriptors of enabled plugins for the given chart.
      * @returns {Array} [{ plugin, options }]
      * @private
      */
					descriptors: function descriptors(chart) {
						var cache = chart._plugins || (chart._plugins = {});
						if (cache.id === this._cacheId) {
							return cache.descriptors;
						}

						var plugins = [];
						var descriptors = [];
						var config = chart && chart.config || {};
						var options = config.options && config.options.plugins || {};

						this._plugins.concat(config.plugins || []).forEach(function (plugin) {
							var idx = plugins.indexOf(plugin);
							if (idx !== -1) {
								return;
							}

							var id = plugin.id;
							var opts = options[id];
							if (opts === false) {
								return;
							}

							if (opts === true) {
								opts = helpers.clone(defaults.global.plugins[id]);
							}

							plugins.push(plugin);
							descriptors.push({
								plugin: plugin,
								options: opts || {}
							});
						});

						cache.descriptors = descriptors;
						cache.id = this._cacheId;
						return descriptors;
					}
				};

				/**
     * Plugin extension hooks.
     * @interface IPlugin
     * @since 2.1.0
     */
				/**
     * @method IPlugin#beforeInit
     * @desc Called before initializing `chart`.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#afterInit
     * @desc Called after `chart` has been initialized and before the first update.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeUpdate
     * @desc Called before updating `chart`. If any plugin returns `false`, the update
     * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart update.
     */
				/**
     * @method IPlugin#afterUpdate
     * @desc Called after `chart` has been updated and before rendering. Note that this
     * hook will not be called if the chart update has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDatasetsUpdate
    	 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
     * the datasets update is cancelled until another `update` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} false to cancel the datasets update.
     * @since version 2.1.5
     */
				/**
     * @method IPlugin#afterDatasetsUpdate
     * @desc Called after the `chart` datasets have been updated. Note that this hook
     * will not be called if the datasets update has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @since version 2.1.5
     */
				/**
     * @method IPlugin#beforeDatasetUpdate
    	 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
     * returns `false`, the datasets update is cancelled until another `update` is triggered.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart datasets drawing.
     */
				/**
     * @method IPlugin#afterDatasetUpdate
    	 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
     * that this hook will not be called if the datasets update has been previously cancelled.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeLayout
     * @desc Called before laying out `chart`. If any plugin returns `false`,
     * the layout update is cancelled until another `update` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart layout.
     */
				/**
     * @method IPlugin#afterLayout
     * @desc Called after the `chart` has been layed out. Note that this hook will not
     * be called if the layout update has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeRender
     * @desc Called before rendering `chart`. If any plugin returns `false`,
     * the rendering is cancelled until another `render` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart rendering.
     */
				/**
     * @method IPlugin#afterRender
     * @desc Called after the `chart` has been fully rendered (and animation completed). Note
     * that this hook will not be called if the rendering has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDraw
     * @desc Called before drawing `chart` at every animation frame specified by the given
     * easing value. If any plugin returns `false`, the frame drawing is cancelled until
     * another `render` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart drawing.
     */
				/**
     * @method IPlugin#afterDraw
     * @desc Called after the `chart` has been drawn for the specific easing value. Note
     * that this hook will not be called if the drawing has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDatasetsDraw
    	 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
     * the datasets drawing is cancelled until another `render` is triggered.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart datasets drawing.
     */
				/**
     * @method IPlugin#afterDatasetsDraw
     * @desc Called after the `chart` datasets have been drawn. Note that this hook
     * will not be called if the datasets drawing has been previously cancelled.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeDatasetDraw
    	 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
     * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
     * is cancelled until another `render` is triggered.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     * @returns {Boolean} `false` to cancel the chart datasets drawing.
     */
				/**
     * @method IPlugin#afterDatasetDraw
    	 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
     * (datasets are drawn in the reverse order). Note that this hook will not be called
     * if the datasets drawing has been previously cancelled.
     * @param {Chart} chart - The chart instance.
     * @param {Object} args - The call arguments.
     * @param {Number} args.index - The dataset index.
     * @param {Object} args.meta - The dataset metadata.
     * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#beforeEvent
    	 * @desc Called before processing the specified `event`. If any plugin returns `false`,
     * the event will be discarded.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {IEvent} event - The event object.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#afterEvent
     * @desc Called after the `event` has been consumed. Note that this hook
     * will not be called if the `event` has been previously discarded.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {IEvent} event - The event object.
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#resize
     * @desc Called after the chart as been resized.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
     * @param {Object} options - The plugin options.
     */
				/**
     * @method IPlugin#destroy
     * @desc Called after the chart as been destroyed.
     * @param {Chart.Controller} chart - The chart instance.
     * @param {Object} options - The plugin options.
     */

				/**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */
				Chart.pluginService = Chart.plugins;

				/**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */
				Chart.PluginBase = Element.extend({});
			};
		}, { "25": 25, "26": 26, "45": 45 }], 32: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);
			var Ticks = require(34);

			defaults._set('scale', {
				display: true,
				position: 'left',
				offset: false,

				// grid line settings
				gridLines: {
					display: true,
					color: 'rgba(0, 0, 0, 0.1)',
					lineWidth: 1,
					drawBorder: true,
					drawOnChartArea: true,
					drawTicks: true,
					tickMarkLength: 10,
					zeroLineWidth: 1,
					zeroLineColor: 'rgba(0,0,0,0.25)',
					zeroLineBorderDash: [],
					zeroLineBorderDashOffset: 0.0,
					offsetGridLines: false,
					borderDash: [],
					borderDashOffset: 0.0
				},

				// scale label
				scaleLabel: {
					// display property
					display: false,

					// actual label
					labelString: '',

					// line height
					lineHeight: 1.2,

					// top/bottom padding
					padding: {
						top: 4,
						bottom: 4
					}
				},

				// label settings
				ticks: {
					beginAtZero: false,
					minRotation: 0,
					maxRotation: 50,
					mirror: false,
					padding: 0,
					reverse: false,
					display: true,
					autoSkip: true,
					autoSkipPadding: 0,
					labelOffset: 0,
					// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
					callback: Ticks.formatters.values,
					minor: {},
					major: {}
				}
			});

			function labelsFromTicks(ticks) {
				var labels = [];
				var i, ilen;

				for (i = 0, ilen = ticks.length; i < ilen; ++i) {
					labels.push(ticks[i].label);
				}

				return labels;
			}

			function getLineValue(scale, index, offsetGridLines) {
				var lineValue = scale.getPixelForTick(index);

				if (offsetGridLines) {
					if (index === 0) {
						lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
					} else {
						lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
					}
				}
				return lineValue;
			}

			module.exports = function (Chart) {

				function computeTextSize(context, tick, font) {
					return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;
				}

				function parseFontOptions(options) {
					var valueOrDefault = helpers.valueOrDefault;
					var globalDefaults = defaults.global;
					var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
					var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
					var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

					return {
						size: size,
						style: style,
						family: family,
						font: helpers.fontString(size, style, family)
					};
				}

				function parseLineHeight(options) {
					return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
				}

				Chart.Scale = Element.extend({
					/**
      * Get the padding needed for the scale
      * @method getPadding
      * @private
      * @returns {Padding} the necessary padding
      */
					getPadding: function getPadding() {
						var me = this;
						return {
							left: me.paddingLeft || 0,
							top: me.paddingTop || 0,
							right: me.paddingRight || 0,
							bottom: me.paddingBottom || 0
						};
					},

					/**
      * Returns the scale tick objects ({label, major})
      * @since 2.7
      */
					getTicks: function getTicks() {
						return this._ticks;
					},

					// These methods are ordered by lifecyle. Utilities then follow.
					// Any function defined here is inherited by all scale types.
					// Any function can be extended by the scale type

					mergeTicksOptions: function mergeTicksOptions() {
						var ticks = this.options.ticks;
						if (ticks.minor === false) {
							ticks.minor = {
								display: false
							};
						}
						if (ticks.major === false) {
							ticks.major = {
								display: false
							};
						}
						for (var key in ticks) {
							if (key !== 'major' && key !== 'minor') {
								if (typeof ticks.minor[key] === 'undefined') {
									ticks.minor[key] = ticks[key];
								}
								if (typeof ticks.major[key] === 'undefined') {
									ticks.major[key] = ticks[key];
								}
							}
						}
					},
					beforeUpdate: function beforeUpdate() {
						helpers.callback(this.options.beforeUpdate, [this]);
					},
					update: function update(maxWidth, maxHeight, margins) {
						var me = this;
						var i, ilen, labels, label, ticks, tick;

						// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
						me.beforeUpdate();

						// Absorb the master measurements
						me.maxWidth = maxWidth;
						me.maxHeight = maxHeight;
						me.margins = helpers.extend({
							left: 0,
							right: 0,
							top: 0,
							bottom: 0
						}, margins);
						me.longestTextCache = me.longestTextCache || {};

						// Dimensions
						me.beforeSetDimensions();
						me.setDimensions();
						me.afterSetDimensions();

						// Data min/max
						me.beforeDataLimits();
						me.determineDataLimits();
						me.afterDataLimits();

						// Ticks - `this.ticks` is now DEPRECATED!
						// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
						// and must not be accessed directly from outside this class. `this.ticks` being
						// around for long time and not marked as private, we can't change its structure
						// without unexpected breaking changes. If you need to access the scale ticks,
						// use scale.getTicks() instead.

						me.beforeBuildTicks();

						// New implementations should return an array of objects but for BACKWARD COMPAT,
						// we still support no return (`this.ticks` internally set by calling this method).
						ticks = me.buildTicks() || [];

						me.afterBuildTicks();

						me.beforeTickToLabelConversion();

						// New implementations should return the formatted tick labels but for BACKWARD
						// COMPAT, we still support no return (`this.ticks` internally changed by calling
						// this method and supposed to contain only string values).
						labels = me.convertTicksToLabels(ticks) || me.ticks;

						me.afterTickToLabelConversion();

						me.ticks = labels; // BACKWARD COMPATIBILITY

						// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

						// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
						for (i = 0, ilen = labels.length; i < ilen; ++i) {
							label = labels[i];
							tick = ticks[i];
							if (!tick) {
								ticks.push(tick = {
									label: label,
									major: false
								});
							} else {
								tick.label = label;
							}
						}

						me._ticks = ticks;

						// Tick Rotation
						me.beforeCalculateTickRotation();
						me.calculateTickRotation();
						me.afterCalculateTickRotation();
						// Fit
						me.beforeFit();
						me.fit();
						me.afterFit();
						//
						me.afterUpdate();

						return me.minSize;
					},
					afterUpdate: function afterUpdate() {
						helpers.callback(this.options.afterUpdate, [this]);
					},

					//

					beforeSetDimensions: function beforeSetDimensions() {
						helpers.callback(this.options.beforeSetDimensions, [this]);
					},
					setDimensions: function setDimensions() {
						var me = this;
						// Set the unconstrained dimension before label rotation
						if (me.isHorizontal()) {
							// Reset position before calculating rotation
							me.width = me.maxWidth;
							me.left = 0;
							me.right = me.width;
						} else {
							me.height = me.maxHeight;

							// Reset position before calculating rotation
							me.top = 0;
							me.bottom = me.height;
						}

						// Reset padding
						me.paddingLeft = 0;
						me.paddingTop = 0;
						me.paddingRight = 0;
						me.paddingBottom = 0;
					},
					afterSetDimensions: function afterSetDimensions() {
						helpers.callback(this.options.afterSetDimensions, [this]);
					},

					// Data limits
					beforeDataLimits: function beforeDataLimits() {
						helpers.callback(this.options.beforeDataLimits, [this]);
					},
					determineDataLimits: helpers.noop,
					afterDataLimits: function afterDataLimits() {
						helpers.callback(this.options.afterDataLimits, [this]);
					},

					//
					beforeBuildTicks: function beforeBuildTicks() {
						helpers.callback(this.options.beforeBuildTicks, [this]);
					},
					buildTicks: helpers.noop,
					afterBuildTicks: function afterBuildTicks() {
						helpers.callback(this.options.afterBuildTicks, [this]);
					},

					beforeTickToLabelConversion: function beforeTickToLabelConversion() {
						helpers.callback(this.options.beforeTickToLabelConversion, [this]);
					},
					convertTicksToLabels: function convertTicksToLabels() {
						var me = this;
						// Convert ticks to strings
						var tickOpts = me.options.ticks;
						me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
					},
					afterTickToLabelConversion: function afterTickToLabelConversion() {
						helpers.callback(this.options.afterTickToLabelConversion, [this]);
					},

					//

					beforeCalculateTickRotation: function beforeCalculateTickRotation() {
						helpers.callback(this.options.beforeCalculateTickRotation, [this]);
					},
					calculateTickRotation: function calculateTickRotation() {
						var me = this;
						var context = me.ctx;
						var tickOpts = me.options.ticks;
						var labels = labelsFromTicks(me._ticks);

						// Get the width of each grid by calculating the difference
						// between x offsets between 0 and 1.
						var tickFont = parseFontOptions(tickOpts);
						context.font = tickFont.font;

						var labelRotation = tickOpts.minRotation || 0;

						if (labels.length && me.options.display && me.isHorizontal()) {
							var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
							var labelWidth = originalLabelWidth;
							var cosRotation, sinRotation;

							// Allow 3 pixels x2 padding either side for label readability
							var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

							// Max label rotation can be set or default to 90 - also act as a loop counter
							while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
								var angleRadians = helpers.toRadians(labelRotation);
								cosRotation = Math.cos(angleRadians);
								sinRotation = Math.sin(angleRadians);

								if (sinRotation * originalLabelWidth > me.maxHeight) {
									// go back one step
									labelRotation--;
									break;
								}

								labelRotation++;
								labelWidth = cosRotation * originalLabelWidth;
							}
						}

						me.labelRotation = labelRotation;
					},
					afterCalculateTickRotation: function afterCalculateTickRotation() {
						helpers.callback(this.options.afterCalculateTickRotation, [this]);
					},

					//

					beforeFit: function beforeFit() {
						helpers.callback(this.options.beforeFit, [this]);
					},
					fit: function fit() {
						var me = this;
						// Reset
						var minSize = me.minSize = {
							width: 0,
							height: 0
						};

						var labels = labelsFromTicks(me._ticks);

						var opts = me.options;
						var tickOpts = opts.ticks;
						var scaleLabelOpts = opts.scaleLabel;
						var gridLineOpts = opts.gridLines;
						var display = opts.display;
						var isHorizontal = me.isHorizontal();

						var tickFont = parseFontOptions(tickOpts);
						var tickMarkLength = opts.gridLines.tickMarkLength;

						// Width
						if (isHorizontal) {
							// subtract the margins to line up with the chartArea if we are a full width scale
							minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
						} else {
							minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
						}

						// height
						if (isHorizontal) {
							minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
						} else {
							minSize.height = me.maxHeight; // fill all the height
						}

						// Are we showing a title for the scale?
						if (scaleLabelOpts.display && display) {
							var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
							var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
							var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

							if (isHorizontal) {
								minSize.height += deltaHeight;
							} else {
								minSize.width += deltaHeight;
							}
						}

						// Don't bother fitting the ticks if we are not showing them
						if (tickOpts.display && display) {
							var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
							var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
							var lineSpace = tickFont.size * 0.5;
							var tickPadding = me.options.ticks.padding;

							if (isHorizontal) {
								// A horizontal axis is more constrained by the height.
								me.longestLabelWidth = largestTextWidth;

								var angleRadians = helpers.toRadians(me.labelRotation);
								var cosRotation = Math.cos(angleRadians);
								var sinRotation = Math.sin(angleRadians);

								// TODO - improve this calculation
								var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace; // padding

								minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

								me.ctx.font = tickFont.font;
								var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
								var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

								// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
								// which means that the right padding is dominated by the font height
								if (me.labelRotation !== 0) {
									me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges
									me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;
								} else {
									me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
									me.paddingRight = lastLabelWidth / 2 + 3;
								}
							} else {
								// A vertical axis is more constrained by the width. Labels are the
								// dominant factor here, so get that length first and account for padding
								if (tickOpts.mirror) {
									largestTextWidth = 0;
								} else {
									// use lineSpace for consistency with horizontal axis
									// tickPadding is not implemented for horizontal
									largestTextWidth += tickPadding + lineSpace;
								}

								minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

								me.paddingTop = tickFont.size / 2;
								me.paddingBottom = tickFont.size / 2;
							}
						}

						me.handleMargins();

						me.width = minSize.width;
						me.height = minSize.height;
					},

					/**
      * Handle margins and padding interactions
      * @private
      */
					handleMargins: function handleMargins() {
						var me = this;
						if (me.margins) {
							me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
							me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
							me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
							me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
						}
					},

					afterFit: function afterFit() {
						helpers.callback(this.options.afterFit, [this]);
					},

					// Shared Methods
					isHorizontal: function isHorizontal() {
						return this.options.position === 'top' || this.options.position === 'bottom';
					},
					isFullWidth: function isFullWidth() {
						return this.options.fullWidth;
					},

					// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
					getRightValue: function getRightValue(rawValue) {
						// Null and undefined values first
						if (helpers.isNullOrUndef(rawValue)) {
							return NaN;
						}
						// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
						if (typeof rawValue === 'number' && !isFinite(rawValue)) {
							return NaN;
						}
						// If it is in fact an object, dive in one more level
						if (rawValue) {
							if (this.isHorizontal()) {
								if (rawValue.x !== undefined) {
									return this.getRightValue(rawValue.x);
								}
							} else if (rawValue.y !== undefined) {
								return this.getRightValue(rawValue.y);
							}
						}

						// Value is good, return it
						return rawValue;
					},

					// Used to get the value to display in the tooltip for the data at the given index
					// function getLabelForIndex(index, datasetIndex)
					getLabelForIndex: helpers.noop,

					// Used to get data value locations.  Value can either be an index or a numerical value
					getPixelForValue: helpers.noop,

					// Used to get the data value from a given pixel. This is the inverse of getPixelForValue
					getValueForPixel: helpers.noop,

					// Used for tick location, should
					getPixelForTick: function getPixelForTick(index) {
						var me = this;
						var offset = me.options.offset;
						if (me.isHorizontal()) {
							var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
							var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
							var pixel = tickWidth * index + me.paddingLeft;

							if (offset) {
								pixel += tickWidth / 2;
							}

							var finalVal = me.left + Math.round(pixel);
							finalVal += me.isFullWidth() ? me.margins.left : 0;
							return finalVal;
						}
						var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
						return me.top + index * (innerHeight / (me._ticks.length - 1));
					},

					// Utility for getting the pixel location of a percentage of scale
					getPixelForDecimal: function getPixelForDecimal(decimal) {
						var me = this;
						if (me.isHorizontal()) {
							var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
							var valueOffset = innerWidth * decimal + me.paddingLeft;

							var finalVal = me.left + Math.round(valueOffset);
							finalVal += me.isFullWidth() ? me.margins.left : 0;
							return finalVal;
						}
						return me.top + decimal * me.height;
					},

					getBasePixel: function getBasePixel() {
						return this.getPixelForValue(this.getBaseValue());
					},

					getBaseValue: function getBaseValue() {
						var me = this;
						var min = me.min;
						var max = me.max;

						return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
					},

					/**
      * Returns a subset of ticks to be plotted to avoid overlapping labels.
      * @private
      */
					_autoSkip: function _autoSkip(ticks) {
						var skipRatio;
						var me = this;
						var isHorizontal = me.isHorizontal();
						var optionTicks = me.options.ticks.minor;
						var tickCount = ticks.length;
						var labelRotationRadians = helpers.toRadians(me.labelRotation);
						var cosRotation = Math.cos(labelRotationRadians);
						var longestRotatedLabel = me.longestLabelWidth * cosRotation;
						var result = [];
						var i, tick, shouldSkip;

						// figure out the maximum number of gridlines to show
						var maxTicks;
						if (optionTicks.maxTicksLimit) {
							maxTicks = optionTicks.maxTicksLimit;
						}

						if (isHorizontal) {
							skipRatio = false;

							if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {
								skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));
							}

							// if they defined a max number of optionTicks,
							// increase skipRatio until that number is met
							if (maxTicks && tickCount > maxTicks) {
								skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
							}
						}

						for (i = 0; i < tickCount; i++) {
							tick = ticks[i];

							// Since we always show the last tick,we need may need to hide the last shown one before
							shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;
							if (shouldSkip && i !== tickCount - 1 || helpers.isNullOrUndef(tick.label)) {
								// leave tick in place but make sure it's not displayed (#4635)
								delete tick.label;
							}
							result.push(tick);
						}
						return result;
					},

					// Actually draw the scale on the canvas
					// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
					draw: function draw(chartArea) {
						var me = this;
						var options = me.options;
						if (!options.display) {
							return;
						}

						var context = me.ctx;
						var globalDefaults = defaults.global;
						var optionTicks = options.ticks.minor;
						var optionMajorTicks = options.ticks.major || optionTicks;
						var gridLines = options.gridLines;
						var scaleLabel = options.scaleLabel;

						var isRotated = me.labelRotation !== 0;
						var isHorizontal = me.isHorizontal();

						var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
						var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
						var tickFont = parseFontOptions(optionTicks);
						var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
						var majorTickFont = parseFontOptions(optionMajorTicks);

						var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

						var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
						var scaleLabelFont = parseFontOptions(scaleLabel);
						var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
						var labelRotationRadians = helpers.toRadians(me.labelRotation);

						var itemsToDraw = [];

						var xTickStart = options.position === 'right' ? me.left : me.right - tl;
						var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
						var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
						var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;

						helpers.each(ticks, function (tick, index) {
							// autoskipper skipped this tick (#4635)
							if (tick.label === undefined) {
								return;
							}

							var label = tick.label;
							var lineWidth, lineColor, borderDash, borderDashOffset;
							if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
								// Draw the first index specially
								lineWidth = gridLines.zeroLineWidth;
								lineColor = gridLines.zeroLineColor;
								borderDash = gridLines.zeroLineBorderDash;
								borderDashOffset = gridLines.zeroLineBorderDashOffset;
							} else {
								lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
								lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
								borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
								borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
							}

							// Common properties
							var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
							var textAlign = 'middle';
							var textBaseline = 'middle';
							var tickPadding = optionTicks.padding;

							if (isHorizontal) {
								var labelYOffset = tl + tickPadding;

								if (options.position === 'bottom') {
									// bottom
									textBaseline = !isRotated ? 'top' : 'middle';
									textAlign = !isRotated ? 'center' : 'right';
									labelY = me.top + labelYOffset;
								} else {
									// top
									textBaseline = !isRotated ? 'bottom' : 'middle';
									textAlign = !isRotated ? 'center' : 'left';
									labelY = me.bottom - labelYOffset;
								}

								var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
								if (xLineValue < me.left) {
									lineColor = 'rgba(0,0,0,0)';
								}
								xLineValue += helpers.aliasPixel(lineWidth);

								labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

								tx1 = tx2 = x1 = x2 = xLineValue;
								ty1 = yTickStart;
								ty2 = yTickEnd;
								y1 = chartArea.top;
								y2 = chartArea.bottom;
							} else {
								var isLeft = options.position === 'left';
								var labelXOffset;

								if (optionTicks.mirror) {
									textAlign = isLeft ? 'left' : 'right';
									labelXOffset = tickPadding;
								} else {
									textAlign = isLeft ? 'right' : 'left';
									labelXOffset = tl + tickPadding;
								}

								labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

								var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
								if (yLineValue < me.top) {
									lineColor = 'rgba(0,0,0,0)';
								}
								yLineValue += helpers.aliasPixel(lineWidth);

								labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

								tx1 = xTickStart;
								tx2 = xTickEnd;
								x1 = chartArea.left;
								x2 = chartArea.right;
								ty1 = ty2 = y1 = y2 = yLineValue;
							}

							itemsToDraw.push({
								tx1: tx1,
								ty1: ty1,
								tx2: tx2,
								ty2: ty2,
								x1: x1,
								y1: y1,
								x2: x2,
								y2: y2,
								labelX: labelX,
								labelY: labelY,
								glWidth: lineWidth,
								glColor: lineColor,
								glBorderDash: borderDash,
								glBorderDashOffset: borderDashOffset,
								rotation: -1 * labelRotationRadians,
								label: label,
								major: tick.major,
								textBaseline: textBaseline,
								textAlign: textAlign
							});
						});

						// Draw all of the tick labels, tick marks, and grid lines at the correct places
						helpers.each(itemsToDraw, function (itemToDraw) {
							if (gridLines.display) {
								context.save();
								context.lineWidth = itemToDraw.glWidth;
								context.strokeStyle = itemToDraw.glColor;
								if (context.setLineDash) {
									context.setLineDash(itemToDraw.glBorderDash);
									context.lineDashOffset = itemToDraw.glBorderDashOffset;
								}

								context.beginPath();

								if (gridLines.drawTicks) {
									context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
									context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
								}

								if (gridLines.drawOnChartArea) {
									context.moveTo(itemToDraw.x1, itemToDraw.y1);
									context.lineTo(itemToDraw.x2, itemToDraw.y2);
								}

								context.stroke();
								context.restore();
							}

							if (optionTicks.display) {
								// Make sure we draw text in the correct color and font
								context.save();
								context.translate(itemToDraw.labelX, itemToDraw.labelY);
								context.rotate(itemToDraw.rotation);
								context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
								context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
								context.textBaseline = itemToDraw.textBaseline;
								context.textAlign = itemToDraw.textAlign;

								var label = itemToDraw.label;
								if (helpers.isArray(label)) {
									for (var i = 0, y = 0; i < label.length; ++i) {
										// We just make sure the multiline element is a string here..
										context.fillText('' + label[i], 0, y);
										// apply same lineSpacing as calculated @ L#320
										y += tickFont.size * 1.5;
									}
								} else {
									context.fillText(label, 0, 0);
								}
								context.restore();
							}
						});

						if (scaleLabel.display) {
							// Draw the scale label
							var scaleLabelX;
							var scaleLabelY;
							var rotation = 0;
							var halfLineHeight = parseLineHeight(scaleLabel) / 2;

							if (isHorizontal) {
								scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width
								scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
							} else {
								var isLeft = options.position === 'left';
								scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
								scaleLabelY = me.top + (me.bottom - me.top) / 2;
								rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
							}

							context.save();
							context.translate(scaleLabelX, scaleLabelY);
							context.rotate(rotation);
							context.textAlign = 'center';
							context.textBaseline = 'middle';
							context.fillStyle = scaleLabelFontColor; // render in correct colour
							context.font = scaleLabelFont.font;
							context.fillText(scaleLabel.labelString, 0, 0);
							context.restore();
						}

						if (gridLines.drawBorder) {
							// Draw the line at the edge of the axis
							context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
							context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
							var x1 = me.left;
							var x2 = me.right;
							var y1 = me.top;
							var y2 = me.bottom;

							var aliasPixel = helpers.aliasPixel(context.lineWidth);
							if (isHorizontal) {
								y1 = y2 = options.position === 'top' ? me.bottom : me.top;
								y1 += aliasPixel;
								y2 += aliasPixel;
							} else {
								x1 = x2 = options.position === 'left' ? me.right : me.left;
								x1 += aliasPixel;
								x2 += aliasPixel;
							}

							context.beginPath();
							context.moveTo(x1, y1);
							context.lineTo(x2, y2);
							context.stroke();
						}
					}
				});
			};
		}, { "25": 25, "26": 26, "34": 34, "45": 45 }], 33: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);

			module.exports = function (Chart) {

				Chart.scaleService = {
					// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
					// use the new chart options to grab the correct scale
					constructors: {},
					// Use a registration function so that we can move to an ES6 map when we no longer need to support
					// old browsers

					// Scale config defaults
					defaults: {},
					registerScaleType: function registerScaleType(type, scaleConstructor, scaleDefaults) {
						this.constructors[type] = scaleConstructor;
						this.defaults[type] = helpers.clone(scaleDefaults);
					},
					getScaleConstructor: function getScaleConstructor(type) {
						return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
					},
					getScaleDefaults: function getScaleDefaults(type) {
						// Return the scale defaults merged with the global settings so that we always use the latest ones
						return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
					},
					updateScaleDefaults: function updateScaleDefaults(type, additions) {
						var me = this;
						if (me.defaults.hasOwnProperty(type)) {
							me.defaults[type] = helpers.extend(me.defaults[type], additions);
						}
					},
					addScalesToLayout: function addScalesToLayout(chart) {
						// Adds each scale to the chart.boxes array to be sized accordingly
						helpers.each(chart.scales, function (scale) {
							// Set ILayoutItem parameters for backwards compatibility
							scale.fullWidth = scale.options.fullWidth;
							scale.position = scale.options.position;
							scale.weight = scale.options.weight;
							Chart.layoutService.addBox(chart, scale);
						});
					}
				};
			};
		}, { "25": 25, "45": 45 }], 34: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);

			/**
    * Namespace to hold static tick generation functions
    * @namespace Chart.Ticks
    */
			module.exports = {
				/**
     * Namespace to hold generators for different types of ticks
     * @namespace Chart.Ticks.generators
     */
				generators: {
					/**
      * Interface for the options provided to the numeric tick generator
      * @interface INumericTickGenerationOptions
      */
					/**
      * The maximum number of ticks to display
      * @name INumericTickGenerationOptions#maxTicks
      * @type Number
      */
					/**
      * The distance between each tick.
      * @name INumericTickGenerationOptions#stepSize
      * @type Number
      * @optional
      */
					/**
      * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
      * @name INumericTickGenerationOptions#min
      * @type Number
      * @optional
      */
					/**
      * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
      * @name INumericTickGenerationOptions#max
      * @type Number
      * @optional
      */

					/**
      * Generate a set of linear ticks
      * @method Chart.Ticks.generators.linear
      * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
      * @param dataRange {IRange} the range of the data
      * @returns {Array<Number>} array of tick values
      */
					linear: function linear(generationOptions, dataRange) {
						var ticks = [];
						// To get a "nice" value for the tick spacing, we will use the appropriately named
						// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
						// for details.

						var spacing;
						if (generationOptions.stepSize && generationOptions.stepSize > 0) {
							spacing = generationOptions.stepSize;
						} else {
							var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
							spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
						}
						var niceMin = Math.floor(dataRange.min / spacing) * spacing;
						var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

						// If min, max and stepSize is set and they make an evenly spaced scale use it.
						if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
							// If very close to our whole number, use it.
							if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
								niceMin = generationOptions.min;
								niceMax = generationOptions.max;
							}
						}

						var numSpaces = (niceMax - niceMin) / spacing;
						// If very close to our rounded value, use it.
						if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
							numSpaces = Math.round(numSpaces);
						} else {
							numSpaces = Math.ceil(numSpaces);
						}

						// Put the values into the ticks array
						ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
						for (var j = 1; j < numSpaces; ++j) {
							ticks.push(niceMin + j * spacing);
						}
						ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

						return ticks;
					},

					/**
      * Generate a set of logarithmic ticks
      * @method Chart.Ticks.generators.logarithmic
      * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
      * @param dataRange {IRange} the range of the data
      * @returns {Array<Number>} array of tick values
      */
					logarithmic: function logarithmic(generationOptions, dataRange) {
						var ticks = [];
						var valueOrDefault = helpers.valueOrDefault;

						// Figure out what the max number of ticks we can support it is based on the size of
						// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
						// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
						// the graph
						var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

						var endExp = Math.floor(helpers.log10(dataRange.max));
						var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
						var exp, significand;

						if (tickVal === 0) {
							exp = Math.floor(helpers.log10(dataRange.minNotZero));
							significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

							ticks.push(tickVal);
							tickVal = significand * Math.pow(10, exp);
						} else {
							exp = Math.floor(helpers.log10(tickVal));
							significand = Math.floor(tickVal / Math.pow(10, exp));
						}

						do {
							ticks.push(tickVal);

							++significand;
							if (significand === 10) {
								significand = 1;
								++exp;
							}

							tickVal = significand * Math.pow(10, exp);
						} while (exp < endExp || exp === endExp && significand < endSignificand);

						var lastTick = valueOrDefault(generationOptions.max, tickVal);
						ticks.push(lastTick);

						return ticks;
					}
				},

				/**
     * Namespace to hold formatters for different types of ticks
     * @namespace Chart.Ticks.formatters
     */
				formatters: {
					/**
      * Formatter for value labels
      * @method Chart.Ticks.formatters.values
      * @param value the value to display
      * @return {String|Array} the label to display
      */
					values: function values(value) {
						return helpers.isArray(value) ? value : '' + value;
					},

					/**
      * Formatter for linear numeric ticks
      * @method Chart.Ticks.formatters.linear
      * @param tickValue {Number} the value to be formatted
      * @param index {Number} the position of the tickValue parameter in the ticks array
      * @param ticks {Array<Number>} the list of ticks being converted
      * @return {String} string representation of the tickValue parameter
      */
					linear: function linear(tickValue, index, ticks) {
						// If we have lots of ticks, don't use the ones
						var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

						// If we have a number like 2.5 as the delta, figure out how many decimal places we need
						if (Math.abs(delta) > 1) {
							if (tickValue !== Math.floor(tickValue)) {
								// not an integer
								delta = tickValue - Math.floor(tickValue);
							}
						}

						var logDelta = helpers.log10(Math.abs(delta));
						var tickString = '';

						if (tickValue !== 0) {
							var numDecimal = -1 * Math.floor(logDelta);
							numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
							tickString = tickValue.toFixed(numDecimal);
						} else {
							tickString = '0'; // never show decimal places for 0
						}

						return tickString;
					},

					logarithmic: function logarithmic(tickValue, index, ticks) {
						var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));

						if (tickValue === 0) {
							return '0';
						} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
							return tickValue.toExponential();
						}
						return '';
					}
				}
			};
		}, { "45": 45 }], 35: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				tooltips: {
					enabled: true,
					custom: null,
					mode: 'nearest',
					position: 'average',
					intersect: true,
					backgroundColor: 'rgba(0,0,0,0.8)',
					titleFontStyle: 'bold',
					titleSpacing: 2,
					titleMarginBottom: 6,
					titleFontColor: '#fff',
					titleAlign: 'left',
					bodySpacing: 2,
					bodyFontColor: '#fff',
					bodyAlign: 'left',
					footerFontStyle: 'bold',
					footerSpacing: 2,
					footerMarginTop: 6,
					footerFontColor: '#fff',
					footerAlign: 'left',
					yPadding: 6,
					xPadding: 6,
					caretPadding: 2,
					caretSize: 5,
					cornerRadius: 6,
					multiKeyBackground: '#fff',
					displayColors: true,
					borderColor: 'rgba(0,0,0,0)',
					borderWidth: 0,
					callbacks: {
						// Args are: (tooltipItems, data)
						beforeTitle: helpers.noop,
						title: function title(tooltipItems, data) {
							// Pick first xLabel for now
							var title = '';
							var labels = data.labels;
							var labelCount = labels ? labels.length : 0;

							if (tooltipItems.length > 0) {
								var item = tooltipItems[0];

								if (item.xLabel) {
									title = item.xLabel;
								} else if (labelCount > 0 && item.index < labelCount) {
									title = labels[item.index];
								}
							}

							return title;
						},
						afterTitle: helpers.noop,

						// Args are: (tooltipItems, data)
						beforeBody: helpers.noop,

						// Args are: (tooltipItem, data)
						beforeLabel: helpers.noop,
						label: function label(tooltipItem, data) {
							var label = data.datasets[tooltipItem.datasetIndex].label || '';

							if (label) {
								label += ': ';
							}
							label += tooltipItem.yLabel;
							return label;
						},
						labelColor: function labelColor(tooltipItem, chart) {
							var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
							var activeElement = meta.data[tooltipItem.index];
							var view = activeElement._view;
							return {
								borderColor: view.borderColor,
								backgroundColor: view.backgroundColor
							};
						},
						labelTextColor: function labelTextColor() {
							return this._options.bodyFontColor;
						},
						afterLabel: helpers.noop,

						// Args are: (tooltipItems, data)
						afterBody: helpers.noop,

						// Args are: (tooltipItems, data)
						beforeFooter: helpers.noop,
						footer: helpers.noop,
						afterFooter: helpers.noop
					}
				}
			});

			module.exports = function (Chart) {

				/**
    	 * Helper method to merge the opacity into a color
    	 */
				function mergeOpacity(colorString, opacity) {
					var color = helpers.color(colorString);
					return color.alpha(opacity * color.alpha()).rgbaString();
				}

				// Helper to push or concat based on if the 2nd parameter is an array or not
				function pushOrConcat(base, toPush) {
					if (toPush) {
						if (helpers.isArray(toPush)) {
							// base = base.concat(toPush);
							Array.prototype.push.apply(base, toPush);
						} else {
							base.push(toPush);
						}
					}

					return base;
				}

				// Private helper to create a tooltip item model
				// @param element : the chart element (point, arc, bar) to create the tooltip item for
				// @return : new tooltip item
				function createTooltipItem(element) {
					var xScale = element._xScale;
					var yScale = element._yScale || element._scale; // handle radar || polarArea charts
					var index = element._index;
					var datasetIndex = element._datasetIndex;

					return {
						xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
						yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
						index: index,
						datasetIndex: datasetIndex,
						x: element._model.x,
						y: element._model.y
					};
				}

				/**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {Object} the tooltip options
     */
				function getBaseModel(tooltipOpts) {
					var globalDefaults = defaults.global;
					var valueOrDefault = helpers.valueOrDefault;

					return {
						// Positioning
						xPadding: tooltipOpts.xPadding,
						yPadding: tooltipOpts.yPadding,
						xAlign: tooltipOpts.xAlign,
						yAlign: tooltipOpts.yAlign,

						// Body
						bodyFontColor: tooltipOpts.bodyFontColor,
						_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
						_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
						_bodyAlign: tooltipOpts.bodyAlign,
						bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
						bodySpacing: tooltipOpts.bodySpacing,

						// Title
						titleFontColor: tooltipOpts.titleFontColor,
						_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
						_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
						titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
						_titleAlign: tooltipOpts.titleAlign,
						titleSpacing: tooltipOpts.titleSpacing,
						titleMarginBottom: tooltipOpts.titleMarginBottom,

						// Footer
						footerFontColor: tooltipOpts.footerFontColor,
						_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
						_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
						footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
						_footerAlign: tooltipOpts.footerAlign,
						footerSpacing: tooltipOpts.footerSpacing,
						footerMarginTop: tooltipOpts.footerMarginTop,

						// Appearance
						caretSize: tooltipOpts.caretSize,
						cornerRadius: tooltipOpts.cornerRadius,
						backgroundColor: tooltipOpts.backgroundColor,
						opacity: 0,
						legendColorBackground: tooltipOpts.multiKeyBackground,
						displayColors: tooltipOpts.displayColors,
						borderColor: tooltipOpts.borderColor,
						borderWidth: tooltipOpts.borderWidth
					};
				}

				/**
     * Get the size of the tooltip
     */
				function getTooltipSize(tooltip, model) {
					var ctx = tooltip._chart.ctx;

					var height = model.yPadding * 2; // Tooltip Padding
					var width = 0;

					// Count of all lines in the body
					var body = model.body;
					var combinedBodyLength = body.reduce(function (count, bodyItem) {
						return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
					}, 0);
					combinedBodyLength += model.beforeBody.length + model.afterBody.length;

					var titleLineCount = model.title.length;
					var footerLineCount = model.footer.length;
					var titleFontSize = model.titleFontSize;
					var bodyFontSize = model.bodyFontSize;
					var footerFontSize = model.footerFontSize;

					height += titleLineCount * titleFontSize; // Title Lines
					height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
					height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
					height += combinedBodyLength * bodyFontSize; // Body Lines
					height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
					height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
					height += footerLineCount * footerFontSize; // Footer Lines
					height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

					// Title width
					var widthPadding = 0;
					var maxLineWidth = function maxLineWidth(line) {
						width = Math.max(width, ctx.measureText(line).width + widthPadding);
					};

					ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
					helpers.each(model.title, maxLineWidth);

					// Body width
					ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
					helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

					// Body lines may include some extra width due to the color box
					widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
					helpers.each(body, function (bodyItem) {
						helpers.each(bodyItem.before, maxLineWidth);
						helpers.each(bodyItem.lines, maxLineWidth);
						helpers.each(bodyItem.after, maxLineWidth);
					});

					// Reset back to 0
					widthPadding = 0;

					// Footer width
					ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
					helpers.each(model.footer, maxLineWidth);

					// Add padding
					width += 2 * model.xPadding;

					return {
						width: width,
						height: height
					};
				}

				/**
     * Helper to get the alignment of a tooltip given the size
     */
				function determineAlignment(tooltip, size) {
					var model = tooltip._model;
					var chart = tooltip._chart;
					var chartArea = tooltip._chart.chartArea;
					var xAlign = 'center';
					var yAlign = 'center';

					if (model.y < size.height) {
						yAlign = 'top';
					} else if (model.y > chart.height - size.height) {
						yAlign = 'bottom';
					}

					var lf, rf; // functions to determine left, right alignment
					var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
					var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
					var midX = (chartArea.left + chartArea.right) / 2;
					var midY = (chartArea.top + chartArea.bottom) / 2;

					if (yAlign === 'center') {
						lf = function lf(x) {
							return x <= midX;
						};
						rf = function rf(x) {
							return x > midX;
						};
					} else {
						lf = function lf(x) {
							return x <= size.width / 2;
						};
						rf = function rf(x) {
							return x >= chart.width - size.width / 2;
						};
					}

					olf = function olf(x) {
						return x + size.width > chart.width;
					};
					orf = function orf(x) {
						return x - size.width < 0;
					};
					yf = function yf(y) {
						return y <= midY ? 'top' : 'bottom';
					};

					if (lf(model.x)) {
						xAlign = 'left';

						// Is tooltip too wide and goes over the right side of the chart.?
						if (olf(model.x)) {
							xAlign = 'center';
							yAlign = yf(model.y);
						}
					} else if (rf(model.x)) {
						xAlign = 'right';

						// Is tooltip too wide and goes outside left edge of canvas?
						if (orf(model.x)) {
							xAlign = 'center';
							yAlign = yf(model.y);
						}
					}

					var opts = tooltip._options;
					return {
						xAlign: opts.xAlign ? opts.xAlign : xAlign,
						yAlign: opts.yAlign ? opts.yAlign : yAlign
					};
				}

				/**
     * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */
				function getBackgroundPoint(vm, size, alignment) {
					// Background Position
					var x = vm.x;
					var y = vm.y;

					var caretSize = vm.caretSize;
					var caretPadding = vm.caretPadding;
					var cornerRadius = vm.cornerRadius;
					var xAlign = alignment.xAlign;
					var yAlign = alignment.yAlign;
					var paddingAndSize = caretSize + caretPadding;
					var radiusAndPadding = cornerRadius + caretPadding;

					if (xAlign === 'right') {
						x -= size.width;
					} else if (xAlign === 'center') {
						x -= size.width / 2;
					}

					if (yAlign === 'top') {
						y += paddingAndSize;
					} else if (yAlign === 'bottom') {
						y -= size.height + paddingAndSize;
					} else {
						y -= size.height / 2;
					}

					if (yAlign === 'center') {
						if (xAlign === 'left') {
							x += paddingAndSize;
						} else if (xAlign === 'right') {
							x -= paddingAndSize;
						}
					} else if (xAlign === 'left') {
						x -= radiusAndPadding;
					} else if (xAlign === 'right') {
						x += radiusAndPadding;
					}

					return {
						x: x,
						y: y
					};
				}

				Chart.Tooltip = Element.extend({
					initialize: function initialize() {
						this._model = getBaseModel(this._options);
					},

					// Get the title
					// Args are: (tooltipItem, data)
					getTitle: function getTitle() {
						var me = this;
						var opts = me._options;
						var callbacks = opts.callbacks;

						var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
						var title = callbacks.title.apply(me, arguments);
						var afterTitle = callbacks.afterTitle.apply(me, arguments);

						var lines = [];
						lines = pushOrConcat(lines, beforeTitle);
						lines = pushOrConcat(lines, title);
						lines = pushOrConcat(lines, afterTitle);

						return lines;
					},

					// Args are: (tooltipItem, data)
					getBeforeBody: function getBeforeBody() {
						var lines = this._options.callbacks.beforeBody.apply(this, arguments);
						return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
					},

					// Args are: (tooltipItem, data)
					getBody: function getBody(tooltipItems, data) {
						var me = this;
						var callbacks = me._options.callbacks;
						var bodyItems = [];

						helpers.each(tooltipItems, function (tooltipItem) {
							var bodyItem = {
								before: [],
								lines: [],
								after: []
							};
							pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
							pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
							pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

							bodyItems.push(bodyItem);
						});

						return bodyItems;
					},

					// Args are: (tooltipItem, data)
					getAfterBody: function getAfterBody() {
						var lines = this._options.callbacks.afterBody.apply(this, arguments);
						return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
					},

					// Get the footer and beforeFooter and afterFooter lines
					// Args are: (tooltipItem, data)
					getFooter: function getFooter() {
						var me = this;
						var callbacks = me._options.callbacks;

						var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
						var footer = callbacks.footer.apply(me, arguments);
						var afterFooter = callbacks.afterFooter.apply(me, arguments);

						var lines = [];
						lines = pushOrConcat(lines, beforeFooter);
						lines = pushOrConcat(lines, footer);
						lines = pushOrConcat(lines, afterFooter);

						return lines;
					},

					update: function update(changed) {
						var me = this;
						var opts = me._options;

						// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
						// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
						// which breaks any animations.
						var existingModel = me._model;
						var model = me._model = getBaseModel(opts);
						var active = me._active;

						var data = me._data;

						// In the case where active.length === 0 we need to keep these at existing values for good animations
						var alignment = {
							xAlign: existingModel.xAlign,
							yAlign: existingModel.yAlign
						};
						var backgroundPoint = {
							x: existingModel.x,
							y: existingModel.y
						};
						var tooltipSize = {
							width: existingModel.width,
							height: existingModel.height
						};
						var tooltipPosition = {
							x: existingModel.caretX,
							y: existingModel.caretY
						};

						var i, len;

						if (active.length) {
							model.opacity = 1;

							var labelColors = [];
							var labelTextColors = [];
							tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);

							var tooltipItems = [];
							for (i = 0, len = active.length; i < len; ++i) {
								tooltipItems.push(createTooltipItem(active[i]));
							}

							// If the user provided a filter function, use it to modify the tooltip items
							if (opts.filter) {
								tooltipItems = tooltipItems.filter(function (a) {
									return opts.filter(a, data);
								});
							}

							// If the user provided a sorting function, use it to modify the tooltip items
							if (opts.itemSort) {
								tooltipItems = tooltipItems.sort(function (a, b) {
									return opts.itemSort(a, b, data);
								});
							}

							// Determine colors for boxes
							helpers.each(tooltipItems, function (tooltipItem) {
								labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
								labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
							});

							// Build the Text Lines
							model.title = me.getTitle(tooltipItems, data);
							model.beforeBody = me.getBeforeBody(tooltipItems, data);
							model.body = me.getBody(tooltipItems, data);
							model.afterBody = me.getAfterBody(tooltipItems, data);
							model.footer = me.getFooter(tooltipItems, data);

							// Initial positioning and colors
							model.x = Math.round(tooltipPosition.x);
							model.y = Math.round(tooltipPosition.y);
							model.caretPadding = opts.caretPadding;
							model.labelColors = labelColors;
							model.labelTextColors = labelTextColors;

							// data points
							model.dataPoints = tooltipItems;

							// We need to determine alignment of the tooltip
							tooltipSize = getTooltipSize(this, model);
							alignment = determineAlignment(this, tooltipSize);
							// Final Size and Position
							backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
						} else {
							model.opacity = 0;
						}

						model.xAlign = alignment.xAlign;
						model.yAlign = alignment.yAlign;
						model.x = backgroundPoint.x;
						model.y = backgroundPoint.y;
						model.width = tooltipSize.width;
						model.height = tooltipSize.height;

						// Point where the caret on the tooltip points to
						model.caretX = tooltipPosition.x;
						model.caretY = tooltipPosition.y;

						me._model = model;

						if (changed && opts.custom) {
							opts.custom.call(me, model);
						}

						return me;
					},
					drawCaret: function drawCaret(tooltipPoint, size) {
						var ctx = this._chart.ctx;
						var vm = this._view;
						var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

						ctx.lineTo(caretPosition.x1, caretPosition.y1);
						ctx.lineTo(caretPosition.x2, caretPosition.y2);
						ctx.lineTo(caretPosition.x3, caretPosition.y3);
					},
					getCaretPosition: function getCaretPosition(tooltipPoint, size, vm) {
						var x1, x2, x3, y1, y2, y3;
						var caretSize = vm.caretSize;
						var cornerRadius = vm.cornerRadius;
						var xAlign = vm.xAlign;
						var yAlign = vm.yAlign;
						var ptX = tooltipPoint.x;
						var ptY = tooltipPoint.y;
						var width = size.width;
						var height = size.height;

						if (yAlign === 'center') {
							y2 = ptY + height / 2;

							if (xAlign === 'left') {
								x1 = ptX;
								x2 = x1 - caretSize;
								x3 = x1;

								y1 = y2 + caretSize;
								y3 = y2 - caretSize;
							} else {
								x1 = ptX + width;
								x2 = x1 + caretSize;
								x3 = x1;

								y1 = y2 - caretSize;
								y3 = y2 + caretSize;
							}
						} else {
							if (xAlign === 'left') {
								x2 = ptX + cornerRadius + caretSize;
								x1 = x2 - caretSize;
								x3 = x2 + caretSize;
							} else if (xAlign === 'right') {
								x2 = ptX + width - cornerRadius - caretSize;
								x1 = x2 - caretSize;
								x3 = x2 + caretSize;
							} else {
								x2 = ptX + width / 2;
								x1 = x2 - caretSize;
								x3 = x2 + caretSize;
							}
							if (yAlign === 'top') {
								y1 = ptY;
								y2 = y1 - caretSize;
								y3 = y1;
							} else {
								y1 = ptY + height;
								y2 = y1 + caretSize;
								y3 = y1;
								// invert drawing order
								var tmp = x3;
								x3 = x1;
								x1 = tmp;
							}
						}
						return { x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3 };
					},
					drawTitle: function drawTitle(pt, vm, ctx, opacity) {
						var title = vm.title;

						if (title.length) {
							ctx.textAlign = vm._titleAlign;
							ctx.textBaseline = 'top';

							var titleFontSize = vm.titleFontSize;
							var titleSpacing = vm.titleSpacing;

							ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
							ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

							var i, len;
							for (i = 0, len = title.length; i < len; ++i) {
								ctx.fillText(title[i], pt.x, pt.y);
								pt.y += titleFontSize + titleSpacing; // Line Height and spacing

								if (i + 1 === title.length) {
									pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
								}
							}
						}
					},
					drawBody: function drawBody(pt, vm, ctx, opacity) {
						var bodyFontSize = vm.bodyFontSize;
						var bodySpacing = vm.bodySpacing;
						var body = vm.body;

						ctx.textAlign = vm._bodyAlign;
						ctx.textBaseline = 'top';
						ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

						// Before Body
						var xLinePadding = 0;
						var fillLineOfText = function fillLineOfText(line) {
							ctx.fillText(line, pt.x + xLinePadding, pt.y);
							pt.y += bodyFontSize + bodySpacing;
						};

						// Before body lines
						helpers.each(vm.beforeBody, fillLineOfText);

						var drawColorBoxes = vm.displayColors;
						xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0;

						// Draw body lines now
						helpers.each(body, function (bodyItem, i) {
							helpers.each(bodyItem.before, fillLineOfText);

							helpers.each(bodyItem.lines, function (line) {
								// Draw Legend-like boxes if needed
								if (drawColorBoxes) {
									// Fill a white rect so that colours merge nicely if the opacity is < 1
									ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
									ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

									// Border
									ctx.lineWidth = 1;
									ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
									ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

									// Inner square
									ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
									ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
									var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
									ctx.fillStyle = textColor;
								}

								fillLineOfText(line);
							});

							helpers.each(bodyItem.after, fillLineOfText);
						});

						// Reset back to 0 for after body
						xLinePadding = 0;

						// After body lines
						helpers.each(vm.afterBody, fillLineOfText);
						pt.y -= bodySpacing; // Remove last body spacing
					},
					drawFooter: function drawFooter(pt, vm, ctx, opacity) {
						var footer = vm.footer;

						if (footer.length) {
							pt.y += vm.footerMarginTop;

							ctx.textAlign = vm._footerAlign;
							ctx.textBaseline = 'top';

							ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
							ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

							helpers.each(footer, function (line) {
								ctx.fillText(line, pt.x, pt.y);
								pt.y += vm.footerFontSize + vm.footerSpacing;
							});
						}
					},
					drawBackground: function drawBackground(pt, vm, ctx, tooltipSize, opacity) {
						ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
						ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
						ctx.lineWidth = vm.borderWidth;
						var xAlign = vm.xAlign;
						var yAlign = vm.yAlign;
						var x = pt.x;
						var y = pt.y;
						var width = tooltipSize.width;
						var height = tooltipSize.height;
						var radius = vm.cornerRadius;

						ctx.beginPath();
						ctx.moveTo(x + radius, y);
						if (yAlign === 'top') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x + width - radius, y);
						ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
						if (yAlign === 'center' && xAlign === 'right') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x + width, y + height - radius);
						ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
						if (yAlign === 'bottom') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x + radius, y + height);
						ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
						if (yAlign === 'center' && xAlign === 'left') {
							this.drawCaret(pt, tooltipSize);
						}
						ctx.lineTo(x, y + radius);
						ctx.quadraticCurveTo(x, y, x + radius, y);
						ctx.closePath();

						ctx.fill();

						if (vm.borderWidth > 0) {
							ctx.stroke();
						}
					},
					draw: function draw() {
						var ctx = this._chart.ctx;
						var vm = this._view;

						if (vm.opacity === 0) {
							return;
						}

						var tooltipSize = {
							width: vm.width,
							height: vm.height
						};
						var pt = {
							x: vm.x,
							y: vm.y
						};

						// IE11/Edge does not like very small opacities, so snap to 0
						var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

						// Truthy/falsey value for empty tooltip
						var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

						if (this._options.enabled && hasTooltipContent) {
							// Draw Background
							this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

							// Draw Title, Body, and Footer
							pt.x += vm.xPadding;
							pt.y += vm.yPadding;

							// Titles
							this.drawTitle(pt, vm, ctx, opacity);

							// Body
							this.drawBody(pt, vm, ctx, opacity);

							// Footer
							this.drawFooter(pt, vm, ctx, opacity);
						}
					},

					/**
      * Handle an event
      * @private
      * @param {IEvent} event - The event to handle
      * @returns {Boolean} true if the tooltip changed
      */
					handleEvent: function handleEvent(e) {
						var me = this;
						var options = me._options;
						var changed = false;

						me._lastActive = me._lastActive || [];

						// Find Active Elements for tooltips
						if (e.type === 'mouseout') {
							me._active = [];
						} else {
							me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
						}

						// Remember Last Actives
						changed = !helpers.arrayEquals(me._active, me._lastActive);

						// If tooltip didn't change, do not handle the target event
						if (!changed) {
							return false;
						}

						me._lastActive = me._active;

						if (options.enabled || options.custom) {
							me._eventPosition = {
								x: e.x,
								y: e.y
							};

							var model = me._model;
							me.update(true);
							me.pivot();

							// See if our tooltip position changed
							changed |= model.x !== me._model.x || model.y !== me._model.y;
						}

						return changed;
					}
				});

				/**
     * @namespace Chart.Tooltip.positioners
     */
				Chart.Tooltip.positioners = {
					/**
      * Average mode places the tooltip at the average position of the elements shown
      * @function Chart.Tooltip.positioners.average
      * @param elements {ChartElement[]} the elements being displayed in the tooltip
      * @returns {Point} tooltip position
      */
					average: function average(elements) {
						if (!elements.length) {
							return false;
						}

						var i, len;
						var x = 0;
						var y = 0;
						var count = 0;

						for (i = 0, len = elements.length; i < len; ++i) {
							var el = elements[i];
							if (el && el.hasValue()) {
								var pos = el.tooltipPosition();
								x += pos.x;
								y += pos.y;
								++count;
							}
						}

						return {
							x: Math.round(x / count),
							y: Math.round(y / count)
						};
					},

					/**
      * Gets the tooltip position nearest of the item nearest to the event position
      * @function Chart.Tooltip.positioners.nearest
      * @param elements {Chart.Element[]} the tooltip elements
      * @param eventPosition {Point} the position of the event in canvas coordinates
      * @returns {Point} the tooltip position
      */
					nearest: function nearest(elements, eventPosition) {
						var x = eventPosition.x;
						var y = eventPosition.y;
						var minDistance = Number.POSITIVE_INFINITY;
						var i, len, nearestElement;

						for (i = 0, len = elements.length; i < len; ++i) {
							var el = elements[i];
							if (el && el.hasValue()) {
								var center = el.getCenterPoint();
								var d = helpers.distanceBetweenPoints(eventPosition, center);

								if (d < minDistance) {
									minDistance = d;
									nearestElement = el;
								}
							}
						}

						if (nearestElement) {
							var tp = nearestElement.tooltipPosition();
							x = tp.x;
							y = tp.y;
						}

						return {
							x: x,
							y: y
						};
					}
				};
			};
		}, { "25": 25, "26": 26, "45": 45 }], 36: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				elements: {
					arc: {
						backgroundColor: defaults.global.defaultColor,
						borderColor: '#fff',
						borderWidth: 2
					}
				}
			});

			module.exports = Element.extend({
				inLabelRange: function inLabelRange(mouseX) {
					var vm = this._view;

					if (vm) {
						return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
					}
					return false;
				},

				inRange: function inRange(chartX, chartY) {
					var vm = this._view;

					if (vm) {
						var pointRelativePosition = helpers.getAngleFromPoint(vm, { x: chartX, y: chartY });
						var angle = pointRelativePosition.angle;
						var distance = pointRelativePosition.distance;

						// Sanitise angle range
						var startAngle = vm.startAngle;
						var endAngle = vm.endAngle;
						while (endAngle < startAngle) {
							endAngle += 2.0 * Math.PI;
						}
						while (angle > endAngle) {
							angle -= 2.0 * Math.PI;
						}
						while (angle < startAngle) {
							angle += 2.0 * Math.PI;
						}

						// Check if within the range of the open/close angle
						var betweenAngles = angle >= startAngle && angle <= endAngle;
						var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;

						return betweenAngles && withinRadius;
					}
					return false;
				},

				getCenterPoint: function getCenterPoint() {
					var vm = this._view;
					var halfAngle = (vm.startAngle + vm.endAngle) / 2;
					var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
					return {
						x: vm.x + Math.cos(halfAngle) * halfRadius,
						y: vm.y + Math.sin(halfAngle) * halfRadius
					};
				},

				getArea: function getArea() {
					var vm = this._view;
					return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
				},

				tooltipPosition: function tooltipPosition() {
					var vm = this._view;
					var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
					var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

					return {
						x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
						y: vm.y + Math.sin(centreAngle) * rangeFromCentre
					};
				},

				draw: function draw() {
					var ctx = this._chart.ctx;
					var vm = this._view;
					var sA = vm.startAngle;
					var eA = vm.endAngle;

					ctx.beginPath();

					ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
					ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

					ctx.closePath();
					ctx.strokeStyle = vm.borderColor;
					ctx.lineWidth = vm.borderWidth;

					ctx.fillStyle = vm.backgroundColor;

					ctx.fill();
					ctx.lineJoin = 'bevel';

					if (vm.borderWidth) {
						ctx.stroke();
					}
				}
			});
		}, { "25": 25, "26": 26, "45": 45 }], 37: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			var globalDefaults = defaults.global;

			defaults._set('global', {
				elements: {
					line: {
						tension: 0.4,
						backgroundColor: globalDefaults.defaultColor,
						borderWidth: 3,
						borderColor: globalDefaults.defaultColor,
						borderCapStyle: 'butt',
						borderDash: [],
						borderDashOffset: 0.0,
						borderJoinStyle: 'miter',
						capBezierPoints: true,
						fill: true // do we fill in the area between the line and its base axis
					}
				}
			});

			module.exports = Element.extend({
				draw: function draw() {
					var me = this;
					var vm = me._view;
					var ctx = me._chart.ctx;
					var spanGaps = vm.spanGaps;
					var points = me._children.slice(); // clone array
					var globalOptionLineElements = globalDefaults.elements.line;
					var lastDrawnIndex = -1;
					var index, current, previous, currentVM;

					// If we are looping, adding the first point again
					if (me._loop && points.length) {
						points.push(points[0]);
					}

					ctx.save();

					// Stroke Line Options
					ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

					// IE 9 and 10 do not support line dash
					if (ctx.setLineDash) {
						ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
					}

					ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
					ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
					ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
					ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

					// Stroke Line
					ctx.beginPath();
					lastDrawnIndex = -1;

					for (index = 0; index < points.length; ++index) {
						current = points[index];
						previous = helpers.previousItem(points, index);
						currentVM = current._view;

						// First point moves to it's starting position no matter what
						if (index === 0) {
							if (!currentVM.skip) {
								ctx.moveTo(currentVM.x, currentVM.y);
								lastDrawnIndex = index;
							}
						} else {
							previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

							if (!currentVM.skip) {
								if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
									// There was a gap and this is the first point after the gap
									ctx.moveTo(currentVM.x, currentVM.y);
								} else {
									// Line to next point
									helpers.canvas.lineTo(ctx, previous._view, current._view);
								}
								lastDrawnIndex = index;
							}
						}
					}

					ctx.stroke();
					ctx.restore();
				}
			});
		}, { "25": 25, "26": 26, "45": 45 }], 38: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			var defaultColor = defaults.global.defaultColor;

			defaults._set('global', {
				elements: {
					point: {
						radius: 3,
						pointStyle: 'circle',
						backgroundColor: defaultColor,
						borderColor: defaultColor,
						borderWidth: 1,
						// Hover
						hitRadius: 1,
						hoverRadius: 4,
						hoverBorderWidth: 1
					}
				}
			});

			function xRange(mouseX) {
				var vm = this._view;
				return vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
			}

			function yRange(mouseY) {
				var vm = this._view;
				return vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
			}

			module.exports = Element.extend({
				inRange: function inRange(mouseX, mouseY) {
					var vm = this._view;
					return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
				},

				inLabelRange: xRange,
				inXRange: xRange,
				inYRange: yRange,

				getCenterPoint: function getCenterPoint() {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y
					};
				},

				getArea: function getArea() {
					return Math.PI * Math.pow(this._view.radius, 2);
				},

				tooltipPosition: function tooltipPosition() {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y,
						padding: vm.radius + vm.borderWidth
					};
				},

				draw: function draw(chartArea) {
					var vm = this._view;
					var model = this._model;
					var ctx = this._chart.ctx;
					var pointStyle = vm.pointStyle;
					var radius = vm.radius;
					var x = vm.x;
					var y = vm.y;
					var color = helpers.color;
					var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
					var ratio = 0;

					if (vm.skip) {
						return;
					}

					ctx.strokeStyle = vm.borderColor || defaultColor;
					ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
					ctx.fillStyle = vm.backgroundColor || defaultColor;

					// Cliping for Points.
					// going out from inner charArea?
					if (chartArea !== undefined && (model.x < chartArea.left || chartArea.right * errMargin < model.x || model.y < chartArea.top || chartArea.bottom * errMargin < model.y)) {
						// Point fade out
						if (model.x < chartArea.left) {
							ratio = (x - model.x) / (chartArea.left - model.x);
						} else if (chartArea.right * errMargin < model.x) {
							ratio = (model.x - x) / (model.x - chartArea.right);
						} else if (model.y < chartArea.top) {
							ratio = (y - model.y) / (chartArea.top - model.y);
						} else if (chartArea.bottom * errMargin < model.y) {
							ratio = (model.y - y) / (model.y - chartArea.bottom);
						}
						ratio = Math.round(ratio * 100) / 100;
						ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
						ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
					}

					helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
				}
			});
		}, { "25": 25, "26": 26, "45": 45 }], 39: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);

			defaults._set('global', {
				elements: {
					rectangle: {
						backgroundColor: defaults.global.defaultColor,
						borderColor: defaults.global.defaultColor,
						borderSkipped: 'bottom',
						borderWidth: 0
					}
				}
			});

			function isVertical(bar) {
				return bar._view.width !== undefined;
			}

			/**
    * Helper function to get the bounds of the bar regardless of the orientation
    * @param bar {Chart.Element.Rectangle} the bar
    * @return {Bounds} bounds of the bar
    * @private
    */
			function getBarBounds(bar) {
				var vm = bar._view;
				var x1, x2, y1, y2;

				if (isVertical(bar)) {
					// vertical
					var halfWidth = vm.width / 2;
					x1 = vm.x - halfWidth;
					x2 = vm.x + halfWidth;
					y1 = Math.min(vm.y, vm.base);
					y2 = Math.max(vm.y, vm.base);
				} else {
					// horizontal bar
					var halfHeight = vm.height / 2;
					x1 = Math.min(vm.x, vm.base);
					x2 = Math.max(vm.x, vm.base);
					y1 = vm.y - halfHeight;
					y2 = vm.y + halfHeight;
				}

				return {
					left: x1,
					top: y1,
					right: x2,
					bottom: y2
				};
			}

			module.exports = Element.extend({
				draw: function draw() {
					var ctx = this._chart.ctx;
					var vm = this._view;
					var left, right, top, bottom, signX, signY, borderSkipped;
					var borderWidth = vm.borderWidth;

					if (!vm.horizontal) {
						// bar
						left = vm.x - vm.width / 2;
						right = vm.x + vm.width / 2;
						top = vm.y;
						bottom = vm.base;
						signX = 1;
						signY = bottom > top ? 1 : -1;
						borderSkipped = vm.borderSkipped || 'bottom';
					} else {
						// horizontal bar
						left = vm.base;
						right = vm.x;
						top = vm.y - vm.height / 2;
						bottom = vm.y + vm.height / 2;
						signX = right > left ? 1 : -1;
						signY = 1;
						borderSkipped = vm.borderSkipped || 'left';
					}

					// Canvas doesn't allow us to stroke inside the width so we can
					// adjust the sizes to fit if we're setting a stroke on the line
					if (borderWidth) {
						// borderWidth shold be less than bar width and bar height.
						var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
						borderWidth = borderWidth > barSize ? barSize : borderWidth;
						var halfStroke = borderWidth / 2;
						// Adjust borderWidth when bar top position is near vm.base(zero).
						var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
						var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
						var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
						var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
						// not become a vertical line?
						if (borderLeft !== borderRight) {
							top = borderTop;
							bottom = borderBottom;
						}
						// not become a horizontal line?
						if (borderTop !== borderBottom) {
							left = borderLeft;
							right = borderRight;
						}
					}

					ctx.beginPath();
					ctx.fillStyle = vm.backgroundColor;
					ctx.strokeStyle = vm.borderColor;
					ctx.lineWidth = borderWidth;

					// Corner points, from bottom-left to bottom-right clockwise
					// | 1 2 |
					// | 0 3 |
					var corners = [[left, bottom], [left, top], [right, top], [right, bottom]];

					// Find first (starting) corner with fallback to 'bottom'
					var borders = ['bottom', 'left', 'top', 'right'];
					var startCorner = borders.indexOf(borderSkipped, 0);
					if (startCorner === -1) {
						startCorner = 0;
					}

					function cornerAt(index) {
						return corners[(startCorner + index) % 4];
					}

					// Draw rectangle from 'startCorner'
					var corner = cornerAt(0);
					ctx.moveTo(corner[0], corner[1]);

					for (var i = 1; i < 4; i++) {
						corner = cornerAt(i);
						ctx.lineTo(corner[0], corner[1]);
					}

					ctx.fill();
					if (borderWidth) {
						ctx.stroke();
					}
				},

				height: function height() {
					var vm = this._view;
					return vm.base - vm.y;
				},

				inRange: function inRange(mouseX, mouseY) {
					var inRange = false;

					if (this._view) {
						var bounds = getBarBounds(this);
						inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
					}

					return inRange;
				},

				inLabelRange: function inLabelRange(mouseX, mouseY) {
					var me = this;
					if (!me._view) {
						return false;
					}

					var inRange = false;
					var bounds = getBarBounds(me);

					if (isVertical(me)) {
						inRange = mouseX >= bounds.left && mouseX <= bounds.right;
					} else {
						inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
					}

					return inRange;
				},

				inXRange: function inXRange(mouseX) {
					var bounds = getBarBounds(this);
					return mouseX >= bounds.left && mouseX <= bounds.right;
				},

				inYRange: function inYRange(mouseY) {
					var bounds = getBarBounds(this);
					return mouseY >= bounds.top && mouseY <= bounds.bottom;
				},

				getCenterPoint: function getCenterPoint() {
					var vm = this._view;
					var x, y;
					if (isVertical(this)) {
						x = vm.x;
						y = (vm.y + vm.base) / 2;
					} else {
						x = (vm.x + vm.base) / 2;
						y = vm.y;
					}

					return { x: x, y: y };
				},

				getArea: function getArea() {
					var vm = this._view;
					return vm.width * Math.abs(vm.y - vm.base);
				},

				tooltipPosition: function tooltipPosition() {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y
					};
				}
			});
		}, { "25": 25, "26": 26 }], 40: [function (require, module, exports) {
			'use strict';

			module.exports = {};
			module.exports.Arc = require(36);
			module.exports.Line = require(37);
			module.exports.Point = require(38);
			module.exports.Rectangle = require(39);
		}, { "36": 36, "37": 37, "38": 38, "39": 39 }], 41: [function (require, module, exports) {
			'use strict';

			var helpers = require(42);

			/**
    * @namespace Chart.helpers.canvas
    */
			var exports = module.exports = {
				/**
     * Clears the entire canvas associated to the given `chart`.
     * @param {Chart} chart - The chart for which to clear the canvas.
     */
				clear: function clear(chart) {
					chart.ctx.clearRect(0, 0, chart.width, chart.height);
				},

				/**
     * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
     * given size (width, height) and the same `radius` for all corners.
     * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
     * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
     * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
     * @param {Number} width - The rectangle's width.
     * @param {Number} height - The rectangle's height.
     * @param {Number} radius - The rounded amount (in pixels) for the four corners.
     * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
     */
				roundedRect: function roundedRect(ctx, x, y, width, height, radius) {
					if (radius) {
						var rx = Math.min(radius, width / 2);
						var ry = Math.min(radius, height / 2);

						ctx.moveTo(x + rx, y);
						ctx.lineTo(x + width - rx, y);
						ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
						ctx.lineTo(x + width, y + height - ry);
						ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
						ctx.lineTo(x + rx, y + height);
						ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
						ctx.lineTo(x, y + ry);
						ctx.quadraticCurveTo(x, y, x + rx, y);
					} else {
						ctx.rect(x, y, width, height);
					}
				},

				drawPoint: function drawPoint(ctx, style, radius, x, y) {
					var type, edgeLength, xOffset, yOffset, height, size;

					if ((typeof style === "undefined" ? "undefined" : _typeof(style)) === 'object') {
						type = style.toString();
						if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
							ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
							return;
						}
					}

					if (isNaN(radius) || radius <= 0) {
						return;
					}

					switch (style) {
						// Default includes circle
						default:
							ctx.beginPath();
							ctx.arc(x, y, radius, 0, Math.PI * 2);
							ctx.closePath();
							ctx.fill();
							break;
						case 'triangle':
							ctx.beginPath();
							edgeLength = 3 * radius / Math.sqrt(3);
							height = edgeLength * Math.sqrt(3) / 2;
							ctx.moveTo(x - edgeLength / 2, y + height / 3);
							ctx.lineTo(x + edgeLength / 2, y + height / 3);
							ctx.lineTo(x, y - 2 * height / 3);
							ctx.closePath();
							ctx.fill();
							break;
						case 'rect':
							size = 1 / Math.SQRT2 * radius;
							ctx.beginPath();
							ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
							ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
							break;
						case 'rectRounded':
							var offset = radius / Math.SQRT2;
							var leftX = x - offset;
							var topY = y - offset;
							var sideSize = Math.SQRT2 * radius;
							ctx.beginPath();
							this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
							ctx.closePath();
							ctx.fill();
							break;
						case 'rectRot':
							size = 1 / Math.SQRT2 * radius;
							ctx.beginPath();
							ctx.moveTo(x - size, y);
							ctx.lineTo(x, y + size);
							ctx.lineTo(x + size, y);
							ctx.lineTo(x, y - size);
							ctx.closePath();
							ctx.fill();
							break;
						case 'cross':
							ctx.beginPath();
							ctx.moveTo(x, y + radius);
							ctx.lineTo(x, y - radius);
							ctx.moveTo(x - radius, y);
							ctx.lineTo(x + radius, y);
							ctx.closePath();
							break;
						case 'crossRot':
							ctx.beginPath();
							xOffset = Math.cos(Math.PI / 4) * radius;
							yOffset = Math.sin(Math.PI / 4) * radius;
							ctx.moveTo(x - xOffset, y - yOffset);
							ctx.lineTo(x + xOffset, y + yOffset);
							ctx.moveTo(x - xOffset, y + yOffset);
							ctx.lineTo(x + xOffset, y - yOffset);
							ctx.closePath();
							break;
						case 'star':
							ctx.beginPath();
							ctx.moveTo(x, y + radius);
							ctx.lineTo(x, y - radius);
							ctx.moveTo(x - radius, y);
							ctx.lineTo(x + radius, y);
							xOffset = Math.cos(Math.PI / 4) * radius;
							yOffset = Math.sin(Math.PI / 4) * radius;
							ctx.moveTo(x - xOffset, y - yOffset);
							ctx.lineTo(x + xOffset, y + yOffset);
							ctx.moveTo(x - xOffset, y + yOffset);
							ctx.lineTo(x + xOffset, y - yOffset);
							ctx.closePath();
							break;
						case 'line':
							ctx.beginPath();
							ctx.moveTo(x - radius, y);
							ctx.lineTo(x + radius, y);
							ctx.closePath();
							break;
						case 'dash':
							ctx.beginPath();
							ctx.moveTo(x, y);
							ctx.lineTo(x + radius, y);
							ctx.closePath();
							break;
					}

					ctx.stroke();
				},

				clipArea: function clipArea(ctx, area) {
					ctx.save();
					ctx.beginPath();
					ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
					ctx.clip();
				},

				unclipArea: function unclipArea(ctx) {
					ctx.restore();
				},

				lineTo: function lineTo(ctx, previous, target, flip) {
					if (target.steppedLine) {
						if (target.steppedLine === 'after' && !flip || target.steppedLine !== 'after' && flip) {
							ctx.lineTo(previous.x, target.y);
						} else {
							ctx.lineTo(target.x, previous.y);
						}
						ctx.lineTo(target.x, target.y);
						return;
					}

					if (!target.tension) {
						ctx.lineTo(target.x, target.y);
						return;
					}

					ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
				}
			};

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
    * @namespace Chart.helpers.clear
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.clear = exports.clear;

			/**
    * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
    * @namespace Chart.helpers.drawRoundedRectangle
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.drawRoundedRectangle = function (ctx) {
				ctx.beginPath();
				exports.roundedRect.apply(exports, arguments);
				ctx.closePath();
			};
		}, { "42": 42 }], 42: [function (require, module, exports) {
			'use strict';

			/**
    * @namespace Chart.helpers
    */

			var helpers = {
				/**
     * An empty function that can be used, for example, for optional callback.
     */
				noop: function noop() {},

				/**
     * Returns a unique id, sequentially generated from a global variable.
     * @returns {Number}
     * @function
     */
				uid: function () {
					var id = 0;
					return function () {
						return id++;
					};
				}(),

				/**
     * Returns true if `value` is neither null nor undefined, else returns false.
     * @param {*} value - The value to test.
     * @returns {Boolean}
     * @since 2.7.0
     */
				isNullOrUndef: function isNullOrUndef(value) {
					return value === null || typeof value === 'undefined';
				},

				/**
     * Returns true if `value` is an array, else returns false.
     * @param {*} value - The value to test.
     * @returns {Boolean}
     * @function
     */
				isArray: Array.isArray ? Array.isArray : function (value) {
					return Object.prototype.toString.call(value) === '[object Array]';
				},

				/**
     * Returns true if `value` is an object (excluding null), else returns false.
     * @param {*} value - The value to test.
     * @returns {Boolean}
     * @since 2.7.0
     */
				isObject: function isObject(value) {
					return value !== null && Object.prototype.toString.call(value) === '[object Object]';
				},

				/**
     * Returns `value` if defined, else returns `defaultValue`.
     * @param {*} value - The value to return if defined.
     * @param {*} defaultValue - The value to return if `value` is undefined.
     * @returns {*}
     */
				valueOrDefault: function valueOrDefault(value, defaultValue) {
					return typeof value === 'undefined' ? defaultValue : value;
				},

				/**
     * Returns value at the given `index` in array if defined, else returns `defaultValue`.
     * @param {Array} value - The array to lookup for value at `index`.
     * @param {Number} index - The index in `value` to lookup for value.
     * @param {*} defaultValue - The value to return if `value[index]` is undefined.
     * @returns {*}
     */
				valueAtIndexOrDefault: function valueAtIndexOrDefault(value, index, defaultValue) {
					return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
				},

				/**
     * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
     * value returned by `fn`. If `fn` is not a function, this method returns undefined.
     * @param {Function} fn - The function to call.
     * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
     * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @returns {*}
     */
				callback: function callback(fn, args, thisArg) {
					if (fn && typeof fn.call === 'function') {
						return fn.apply(thisArg, args);
					}
				},

				/**
     * Note(SB) for performance sake, this method should only be used when loopable type
     * is unknown or in none intensive code (not called often and small loopable). Else
     * it's preferable to use a regular for() loop and save extra function calls.
     * @param {Object|Array} loopable - The object or array to be iterated.
     * @param {Function} fn - The function to call for each item.
     * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
     */
				each: function each(loopable, fn, thisArg, reverse) {
					var i, len, keys;
					if (helpers.isArray(loopable)) {
						len = loopable.length;
						if (reverse) {
							for (i = len - 1; i >= 0; i--) {
								fn.call(thisArg, loopable[i], i);
							}
						} else {
							for (i = 0; i < len; i++) {
								fn.call(thisArg, loopable[i], i);
							}
						}
					} else if (helpers.isObject(loopable)) {
						keys = Object.keys(loopable);
						len = keys.length;
						for (i = 0; i < len; i++) {
							fn.call(thisArg, loopable[keys[i]], keys[i]);
						}
					}
				},

				/**
     * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
     * @see http://stackoverflow.com/a/14853974
     * @param {Array} a0 - The array to compare
     * @param {Array} a1 - The array to compare
     * @returns {Boolean}
     */
				arrayEquals: function arrayEquals(a0, a1) {
					var i, ilen, v0, v1;

					if (!a0 || !a1 || a0.length !== a1.length) {
						return false;
					}

					for (i = 0, ilen = a0.length; i < ilen; ++i) {
						v0 = a0[i];
						v1 = a1[i];

						if (v0 instanceof Array && v1 instanceof Array) {
							if (!helpers.arrayEquals(v0, v1)) {
								return false;
							}
						} else if (v0 !== v1) {
							// NOTE: two different object instances will never be equal: {x:20} != {x:20}
							return false;
						}
					}

					return true;
				},

				/**
     * Returns a deep copy of `source` without keeping references on objects and arrays.
     * @param {*} source - The value to clone.
     * @returns {*}
     */
				clone: function clone(source) {
					if (helpers.isArray(source)) {
						return source.map(helpers.clone);
					}

					if (helpers.isObject(source)) {
						var target = {};
						var keys = Object.keys(source);
						var klen = keys.length;
						var k = 0;

						for (; k < klen; ++k) {
							target[keys[k]] = helpers.clone(source[keys[k]]);
						}

						return target;
					}

					return source;
				},

				/**
     * The default merger when Chart.helpers.merge is called without merger option.
     * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
     * @private
     */
				_merger: function _merger(key, target, source, options) {
					var tval = target[key];
					var sval = source[key];

					if (helpers.isObject(tval) && helpers.isObject(sval)) {
						helpers.merge(tval, sval, options);
					} else {
						target[key] = helpers.clone(sval);
					}
				},

				/**
     * Merges source[key] in target[key] only if target[key] is undefined.
     * @private
     */
				_mergerIf: function _mergerIf(key, target, source) {
					var tval = target[key];
					var sval = source[key];

					if (helpers.isObject(tval) && helpers.isObject(sval)) {
						helpers.mergeIf(tval, sval);
					} else if (!target.hasOwnProperty(key)) {
						target[key] = helpers.clone(sval);
					}
				},

				/**
     * Recursively deep copies `source` properties into `target` with the given `options`.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {Object} target - The target object in which all sources are merged into.
     * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
     * @param {Object} [options] - Merging options:
     * @param {Function} [options.merger] - The merge method (key, target, source, options)
     * @returns {Object} The `target` object.
     */
				merge: function merge(target, source, options) {
					var sources = helpers.isArray(source) ? source : [source];
					var ilen = sources.length;
					var merge, i, keys, klen, k;

					if (!helpers.isObject(target)) {
						return target;
					}

					options = options || {};
					merge = options.merger || helpers._merger;

					for (i = 0; i < ilen; ++i) {
						source = sources[i];
						if (!helpers.isObject(source)) {
							continue;
						}

						keys = Object.keys(source);
						for (k = 0, klen = keys.length; k < klen; ++k) {
							merge(keys[k], target, source, options);
						}
					}

					return target;
				},

				/**
     * Recursively deep copies `source` properties into `target` *only* if not defined in target.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {Object} target - The target object in which all sources are merged into.
     * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
     * @returns {Object} The `target` object.
     */
				mergeIf: function mergeIf(target, source) {
					return helpers.merge(target, source, { merger: helpers._mergerIf });
				}
			};

			module.exports = helpers;

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.callback instead.
    * @function Chart.helpers.callCallback
    * @deprecated since version 2.6.0
    * @todo remove at version 3
    * @private
    */
			helpers.callCallback = helpers.callback;

			/**
    * Provided for backward compatibility, use Array.prototype.indexOf instead.
    * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
    * @function Chart.helpers.indexOf
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.indexOf = function (array, item, fromIndex) {
				return Array.prototype.indexOf.call(array, item, fromIndex);
			};

			/**
    * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
    * @function Chart.helpers.getValueOrDefault
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.getValueOrDefault = helpers.valueOrDefault;

			/**
    * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
    * @function Chart.helpers.getValueAtIndexOrDefault
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
		}, {}], 43: [function (require, module, exports) {
			'use strict';

			var helpers = require(42);

			/**
    * Easing functions adapted from Robert Penner's easing equations.
    * @namespace Chart.helpers.easingEffects
    * @see http://www.robertpenner.com/easing/
    */
			var effects = {
				linear: function linear(t) {
					return t;
				},

				easeInQuad: function easeInQuad(t) {
					return t * t;
				},

				easeOutQuad: function easeOutQuad(t) {
					return -t * (t - 2);
				},

				easeInOutQuad: function easeInOutQuad(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t;
					}
					return -0.5 * (--t * (t - 2) - 1);
				},

				easeInCubic: function easeInCubic(t) {
					return t * t * t;
				},

				easeOutCubic: function easeOutCubic(t) {
					return (t = t - 1) * t * t + 1;
				},

				easeInOutCubic: function easeInOutCubic(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t * t;
					}
					return 0.5 * ((t -= 2) * t * t + 2);
				},

				easeInQuart: function easeInQuart(t) {
					return t * t * t * t;
				},

				easeOutQuart: function easeOutQuart(t) {
					return -((t = t - 1) * t * t * t - 1);
				},

				easeInOutQuart: function easeInOutQuart(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t * t * t;
					}
					return -0.5 * ((t -= 2) * t * t * t - 2);
				},

				easeInQuint: function easeInQuint(t) {
					return t * t * t * t * t;
				},

				easeOutQuint: function easeOutQuint(t) {
					return (t = t - 1) * t * t * t * t + 1;
				},

				easeInOutQuint: function easeInOutQuint(t) {
					if ((t /= 0.5) < 1) {
						return 0.5 * t * t * t * t * t;
					}
					return 0.5 * ((t -= 2) * t * t * t * t + 2);
				},

				easeInSine: function easeInSine(t) {
					return -Math.cos(t * (Math.PI / 2)) + 1;
				},

				easeOutSine: function easeOutSine(t) {
					return Math.sin(t * (Math.PI / 2));
				},

				easeInOutSine: function easeInOutSine(t) {
					return -0.5 * (Math.cos(Math.PI * t) - 1);
				},

				easeInExpo: function easeInExpo(t) {
					return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
				},

				easeOutExpo: function easeOutExpo(t) {
					return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
				},

				easeInOutExpo: function easeInOutExpo(t) {
					if (t === 0) {
						return 0;
					}
					if (t === 1) {
						return 1;
					}
					if ((t /= 0.5) < 1) {
						return 0.5 * Math.pow(2, 10 * (t - 1));
					}
					return 0.5 * (-Math.pow(2, -10 * --t) + 2);
				},

				easeInCirc: function easeInCirc(t) {
					if (t >= 1) {
						return t;
					}
					return -(Math.sqrt(1 - t * t) - 1);
				},

				easeOutCirc: function easeOutCirc(t) {
					return Math.sqrt(1 - (t = t - 1) * t);
				},

				easeInOutCirc: function easeInOutCirc(t) {
					if ((t /= 0.5) < 1) {
						return -0.5 * (Math.sqrt(1 - t * t) - 1);
					}
					return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
				},

				easeInElastic: function easeInElastic(t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if (t === 1) {
						return 1;
					}
					if (!p) {
						p = 0.3;
					}
					if (a < 1) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
				},

				easeOutElastic: function easeOutElastic(t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if (t === 1) {
						return 1;
					}
					if (!p) {
						p = 0.3;
					}
					if (a < 1) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
				},

				easeInOutElastic: function easeInOutElastic(t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if ((t /= 0.5) === 2) {
						return 1;
					}
					if (!p) {
						p = 0.45;
					}
					if (a < 1) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					if (t < 1) {
						return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
					}
					return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
				},
				easeInBack: function easeInBack(t) {
					var s = 1.70158;
					return t * t * ((s + 1) * t - s);
				},

				easeOutBack: function easeOutBack(t) {
					var s = 1.70158;
					return (t = t - 1) * t * ((s + 1) * t + s) + 1;
				},

				easeInOutBack: function easeInOutBack(t) {
					var s = 1.70158;
					if ((t /= 0.5) < 1) {
						return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
					}
					return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
				},

				easeInBounce: function easeInBounce(t) {
					return 1 - effects.easeOutBounce(1 - t);
				},

				easeOutBounce: function easeOutBounce(t) {
					if (t < 1 / 2.75) {
						return 7.5625 * t * t;
					}
					if (t < 2 / 2.75) {
						return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
					}
					if (t < 2.5 / 2.75) {
						return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
					}
					return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
				},

				easeInOutBounce: function easeInOutBounce(t) {
					if (t < 0.5) {
						return effects.easeInBounce(t * 2) * 0.5;
					}
					return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
				}
			};

			module.exports = {
				effects: effects
			};

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
    * @function Chart.helpers.easingEffects
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.easingEffects = effects;
		}, { "42": 42 }], 44: [function (require, module, exports) {
			'use strict';

			var helpers = require(42);

			/**
    * @alias Chart.helpers.options
    * @namespace
    */
			module.exports = {
				/**
     * Converts the given line height `value` in pixels for a specific font `size`.
     * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
     * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
     * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
     * @since 2.7.0
     */
				toLineHeight: function toLineHeight(value, size) {
					var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
					if (!matches || matches[1] === 'normal') {
						return size * 1.2;
					}

					value = +matches[2];

					switch (matches[3]) {
						case 'px':
							return value;
						case '%':
							value /= 100;
							break;
						default:
							break;
					}

					return size * value;
				},

				/**
     * Converts the given value into a padding object with pre-computed width/height.
     * @param {Number|Object} value - If a number, set the value to all TRBL component,
     *  else, if and object, use defined properties and sets undefined ones to 0.
     * @returns {Object} The padding values (top, right, bottom, left, width, height)
     * @since 2.7.0
     */
				toPadding: function toPadding(value) {
					var t, r, b, l;

					if (helpers.isObject(value)) {
						t = +value.top || 0;
						r = +value.right || 0;
						b = +value.bottom || 0;
						l = +value.left || 0;
					} else {
						t = r = b = l = +value || 0;
					}

					return {
						top: t,
						right: r,
						bottom: b,
						left: l,
						height: t + b,
						width: l + r
					};
				},

				/**
     * Evaluates the given `inputs` sequentially and returns the first defined value.
     * @param {Array[]} inputs - An array of values, falling back to the last value.
     * @param {Object} [context] - If defined and the current value is a function, the value
     * is called with `context` as first argument and the result becomes the new input.
     * @param {Number} [index] - If defined and the current value is an array, the value
     * at `index` become the new input.
     * @since 2.7.0
     */
				resolve: function resolve(inputs, context, index) {
					var i, ilen, value;

					for (i = 0, ilen = inputs.length; i < ilen; ++i) {
						value = inputs[i];
						if (value === undefined) {
							continue;
						}
						if (context !== undefined && typeof value === 'function') {
							value = value(context);
						}
						if (index !== undefined && helpers.isArray(value)) {
							value = value[index];
						}
						if (value !== undefined) {
							return value;
						}
					}
				}
			};
		}, { "42": 42 }], 45: [function (require, module, exports) {
			'use strict';

			module.exports = require(42);
			module.exports.easing = require(43);
			module.exports.canvas = require(41);
			module.exports.options = require(44);
		}, { "41": 41, "42": 42, "43": 43, "44": 44 }], 46: [function (require, module, exports) {
			/**
    * Platform fallback implementation (minimal).
    * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
    */

			module.exports = {
				acquireContext: function acquireContext(item) {
					if (item && item.canvas) {
						// Support for any object associated to a canvas (including a context2d)
						item = item.canvas;
					}

					return item && item.getContext('2d') || null;
				}
			};
		}, {}], 47: [function (require, module, exports) {
			/**
    * Chart.Platform implementation for targeting a web browser
    */

			'use strict';

			var helpers = require(45);

			var EXPANDO_KEY = '$chartjs';
			var CSS_PREFIX = 'chartjs-';
			var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
			var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
			var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

			/**
    * DOM event types -> Chart.js event types.
    * Note: only events with different types are mapped.
    * @see https://developer.mozilla.org/en-US/docs/Web/Events
    */
			var EVENT_TYPES = {
				touchstart: 'mousedown',
				touchmove: 'mousemove',
				touchend: 'mouseup',
				pointerenter: 'mouseenter',
				pointerdown: 'mousedown',
				pointermove: 'mousemove',
				pointerup: 'mouseup',
				pointerleave: 'mouseout',
				pointerout: 'mouseout'
			};

			/**
    * The "used" size is the final value of a dimension property after all calculations have
    * been performed. This method uses the computed style of `element` but returns undefined
    * if the computed style is not expressed in pixels. That can happen in some cases where
    * `element` has a size relative to its parent and this last one is not yet displayed,
    * for example because of `display: none` on a parent node.
    * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
    * @returns {Number} Size in pixels or undefined if unknown.
    */
			function readUsedSize(element, property) {
				var value = helpers.getStyle(element, property);
				var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
				return matches ? Number(matches[1]) : undefined;
			}

			/**
    * Initializes the canvas style and render size without modifying the canvas display size,
    * since responsiveness is handled by the controller.resize() method. The config is used
    * to determine the aspect ratio to apply in case no explicit height has been specified.
    */
			function initCanvas(canvas, config) {
				var style = canvas.style;

				// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
				// returns null or '' if no explicit value has been set to the canvas attribute.
				var renderHeight = canvas.getAttribute('height');
				var renderWidth = canvas.getAttribute('width');

				// Chart.js modifies some canvas values that we want to restore on destroy
				canvas[EXPANDO_KEY] = {
					initial: {
						height: renderHeight,
						width: renderWidth,
						style: {
							display: style.display,
							height: style.height,
							width: style.width
						}
					}
				};

				// Force canvas to display as block to avoid extra space caused by inline
				// elements, which would interfere with the responsive resize process.
				// https://github.com/chartjs/Chart.js/issues/2538
				style.display = style.display || 'block';

				if (renderWidth === null || renderWidth === '') {
					var displayWidth = readUsedSize(canvas, 'width');
					if (displayWidth !== undefined) {
						canvas.width = displayWidth;
					}
				}

				if (renderHeight === null || renderHeight === '') {
					if (canvas.style.height === '') {
						// If no explicit render height and style height, let's apply the aspect ratio,
						// which one can be specified by the user but also by charts as default option
						// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
						canvas.height = canvas.width / (config.options.aspectRatio || 2);
					} else {
						var displayHeight = readUsedSize(canvas, 'height');
						if (displayWidth !== undefined) {
							canvas.height = displayHeight;
						}
					}
				}

				return canvas;
			}

			/**
    * Detects support for options object argument in addEventListener.
    * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    * @private
    */
			var supportsEventListenerOptions = function () {
				var supports = false;
				try {
					var options = Object.defineProperty({}, 'passive', {
						get: function get() {
							supports = true;
						}
					});
					window.addEventListener('e', null, options);
				} catch (e) {
					// continue regardless of error
				}
				return supports;
			}();

			// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
			// https://github.com/chartjs/Chart.js/issues/4287
			var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;

			function _addEventListener(node, type, listener) {
				node.addEventListener(type, listener, eventListenerOptions);
			}

			function _removeEventListener(node, type, listener) {
				node.removeEventListener(type, listener, eventListenerOptions);
			}

			function createEvent(type, chart, x, y, nativeEvent) {
				return {
					type: type,
					chart: chart,
					native: nativeEvent || null,
					x: x !== undefined ? x : null,
					y: y !== undefined ? y : null
				};
			}

			function fromNativeEvent(event, chart) {
				var type = EVENT_TYPES[event.type] || event.type;
				var pos = helpers.getRelativePosition(event, chart);
				return createEvent(type, chart, pos.x, pos.y, event);
			}

			function throttled(fn, thisArg) {
				var ticking = false;
				var args = [];

				return function () {
					args = Array.prototype.slice.call(arguments);
					thisArg = thisArg || this;

					if (!ticking) {
						ticking = true;
						helpers.requestAnimFrame.call(window, function () {
							ticking = false;
							fn.apply(thisArg, args);
						});
					}
				};
			}

			// Implementation based on https://github.com/marcj/css-element-queries
			function createResizer(handler) {
				var resizer = document.createElement('div');
				var cls = CSS_PREFIX + 'size-monitor';
				var maxSize = 1000000;
				var style = 'position:absolute;' + 'left:0;' + 'top:0;' + 'right:0;' + 'bottom:0;' + 'overflow:hidden;' + 'pointer-events:none;' + 'visibility:hidden;' + 'z-index:-1;';

				resizer.style.cssText = style;
				resizer.className = cls;
				resizer.innerHTML = '<div class="' + cls + '-expand" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:' + maxSize + 'px;' + 'height:' + maxSize + 'px;' + 'left:0;' + 'top:0">' + '</div>' + '</div>' + '<div class="' + cls + '-shrink" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:200%;' + 'height:200%;' + 'left:0; ' + 'top:0">' + '</div>' + '</div>';

				var expand = resizer.childNodes[0];
				var shrink = resizer.childNodes[1];

				resizer._reset = function () {
					expand.scrollLeft = maxSize;
					expand.scrollTop = maxSize;
					shrink.scrollLeft = maxSize;
					shrink.scrollTop = maxSize;
				};
				var onScroll = function onScroll() {
					resizer._reset();
					handler();
				};

				_addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
				_addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

				return resizer;
			}

			// https://davidwalsh.name/detect-node-insertion
			function watchForRender(node, handler) {
				var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
				var proxy = expando.renderProxy = function (e) {
					if (e.animationName === CSS_RENDER_ANIMATION) {
						handler();
					}
				};

				helpers.each(ANIMATION_START_EVENTS, function (type) {
					_addEventListener(node, type, proxy);
				});

				node.classList.add(CSS_RENDER_MONITOR);
			}

			function unwatchForRender(node) {
				var expando = node[EXPANDO_KEY] || {};
				var proxy = expando.renderProxy;

				if (proxy) {
					helpers.each(ANIMATION_START_EVENTS, function (type) {
						_removeEventListener(node, type, proxy);
					});

					delete expando.renderProxy;
				}

				node.classList.remove(CSS_RENDER_MONITOR);
			}

			function addResizeListener(node, listener, chart) {
				var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

				// Let's keep track of this added resizer and thus avoid DOM query when removing it.
				var resizer = expando.resizer = createResizer(throttled(function () {
					if (expando.resizer) {
						return listener(createEvent('resize', chart));
					}
				}));

				// The resizer needs to be attached to the node parent, so we first need to be
				// sure that `node` is attached to the DOM before injecting the resizer element.
				watchForRender(node, function () {
					if (expando.resizer) {
						var container = node.parentNode;
						if (container && container !== resizer.parentNode) {
							container.insertBefore(resizer, container.firstChild);
						}

						// The container size might have changed, let's reset the resizer state.
						resizer._reset();
					}
				});
			}

			function removeResizeListener(node) {
				var expando = node[EXPANDO_KEY] || {};
				var resizer = expando.resizer;

				delete expando.resizer;
				unwatchForRender(node);

				if (resizer && resizer.parentNode) {
					resizer.parentNode.removeChild(resizer);
				}
			}

			function injectCSS(platform, css) {
				// http://stackoverflow.com/q/3922139
				var style = platform._style || document.createElement('style');
				if (!platform._style) {
					platform._style = style;
					css = '/* Chart.js */\n' + css;
					style.setAttribute('type', 'text/css');
					document.getElementsByTagName('head')[0].appendChild(style);
				}

				style.appendChild(document.createTextNode(css));
			}

			module.exports = {
				/**
     * This property holds whether this platform is enabled for the current environment.
     * Currently used by platform.js to select the proper implementation.
     * @private
     */
				_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

				initialize: function initialize() {
					var keyframes = 'from{opacity:0.99}to{opacity:1}';

					injectCSS(this,
					// DOM rendering detection
					// https://davidwalsh.name/detect-node-insertion
					'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '.' + CSS_RENDER_MONITOR + '{' + '-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + 'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + '}');
				},

				acquireContext: function acquireContext(item, config) {
					if (typeof item === 'string') {
						item = document.getElementById(item);
					} else if (item.length) {
						// Support for array based queries (such as jQuery)
						item = item[0];
					}

					if (item && item.canvas) {
						// Support for any object associated to a canvas (including a context2d)
						item = item.canvas;
					}

					// To prevent canvas fingerprinting, some add-ons undefine the getContext
					// method, for example: https://github.com/kkapsner/CanvasBlocker
					// https://github.com/chartjs/Chart.js/issues/2807
					var context = item && item.getContext && item.getContext('2d');

					// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
					// inside an iframe or when running in a protected environment. We could guess the
					// types from their toString() value but let's keep things flexible and assume it's
					// a sufficient condition if the item has a context2D which has item as `canvas`.
					// https://github.com/chartjs/Chart.js/issues/3887
					// https://github.com/chartjs/Chart.js/issues/4102
					// https://github.com/chartjs/Chart.js/issues/4152
					if (context && context.canvas === item) {
						initCanvas(item, config);
						return context;
					}

					return null;
				},

				releaseContext: function releaseContext(context) {
					var canvas = context.canvas;
					if (!canvas[EXPANDO_KEY]) {
						return;
					}

					var initial = canvas[EXPANDO_KEY].initial;
					['height', 'width'].forEach(function (prop) {
						var value = initial[prop];
						if (helpers.isNullOrUndef(value)) {
							canvas.removeAttribute(prop);
						} else {
							canvas.setAttribute(prop, value);
						}
					});

					helpers.each(initial.style || {}, function (value, key) {
						canvas.style[key] = value;
					});

					// The canvas render size might have been changed (and thus the state stack discarded),
					// we can't use save() and restore() to restore the initial state. So make sure that at
					// least the canvas context is reset to the default state by setting the canvas width.
					// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
					canvas.width = canvas.width;

					delete canvas[EXPANDO_KEY];
				},

				addEventListener: function addEventListener(chart, type, listener) {
					var canvas = chart.canvas;
					if (type === 'resize') {
						// Note: the resize event is not supported on all browsers.
						addResizeListener(canvas, listener, chart);
						return;
					}

					var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
					var proxies = expando.proxies || (expando.proxies = {});
					var proxy = proxies[chart.id + '_' + type] = function (event) {
						listener(fromNativeEvent(event, chart));
					};

					_addEventListener(canvas, type, proxy);
				},

				removeEventListener: function removeEventListener(chart, type, listener) {
					var canvas = chart.canvas;
					if (type === 'resize') {
						// Note: the resize event is not supported on all browsers.
						removeResizeListener(canvas, listener);
						return;
					}

					var expando = listener[EXPANDO_KEY] || {};
					var proxies = expando.proxies || {};
					var proxy = proxies[chart.id + '_' + type];
					if (!proxy) {
						return;
					}

					_removeEventListener(canvas, type, proxy);
				}
			};

			// DEPRECATIONS

			/**
    * Provided for backward compatibility, use EventTarget.addEventListener instead.
    * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
    * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
    * @function Chart.helpers.addEvent
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.addEvent = _addEventListener;

			/**
    * Provided for backward compatibility, use EventTarget.removeEventListener instead.
    * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
    * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
    * @function Chart.helpers.removeEvent
    * @deprecated since version 2.7.0
    * @todo remove at version 3
    * @private
    */
			helpers.removeEvent = _removeEventListener;
		}, { "45": 45 }], 48: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);
			var basic = require(46);
			var dom = require(47);

			// @TODO Make possible to select another platform at build time.
			var implementation = dom._enabled ? dom : basic;

			/**
    * @namespace Chart.platform
    * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
    * @since 2.4.0
    */
			module.exports = helpers.extend({
				/**
     * @since 2.7.0
     */
				initialize: function initialize() {},

				/**
     * Called at chart construction time, returns a context2d instance implementing
     * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
     * @param {*} item - The native item from which to acquire context (platform specific)
     * @param {Object} options - The chart options
     * @returns {CanvasRenderingContext2D} context2d instance
     */
				acquireContext: function acquireContext() {},

				/**
     * Called at chart destruction time, releases any resources associated to the context
     * previously returned by the acquireContext() method.
     * @param {CanvasRenderingContext2D} context - The context2d instance
     * @returns {Boolean} true if the method succeeded, else false
     */
				releaseContext: function releaseContext() {},

				/**
     * Registers the specified listener on the given chart.
     * @param {Chart} chart - Chart from which to listen for event
     * @param {String} type - The ({@link IEvent}) type to listen for
     * @param {Function} listener - Receives a notification (an object that implements
     * the {@link IEvent} interface) when an event of the specified type occurs.
     */
				addEventListener: function addEventListener() {},

				/**
     * Removes the specified listener previously registered with addEventListener.
     * @param {Chart} chart -Chart from which to remove the listener
     * @param {String} type - The ({@link IEvent}) type to remove
     * @param {Function} listener - The listener function to remove from the event target.
     */
				removeEventListener: function removeEventListener() {}

			}, implementation);

			/**
    * @interface IPlatform
    * Allows abstracting platform dependencies away from the chart
    * @borrows Chart.platform.acquireContext as acquireContext
    * @borrows Chart.platform.releaseContext as releaseContext
    * @borrows Chart.platform.addEventListener as addEventListener
    * @borrows Chart.platform.removeEventListener as removeEventListener
    */

			/**
    * @interface IEvent
    * @prop {String} type - The event type name, possible values are:
    * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
    * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
    * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
    * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
    * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
    */
		}, { "45": 45, "46": 46, "47": 47 }], 49: [function (require, module, exports) {
			/**
    * Plugin based on discussion from the following Chart.js issues:
    * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
    * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
    */

			'use strict';

			var defaults = require(25);
			var elements = require(40);
			var helpers = require(45);

			defaults._set('global', {
				plugins: {
					filler: {
						propagate: true
					}
				}
			});

			module.exports = function () {

				var mappers = {
					dataset: function dataset(source) {
						var index = source.fill;
						var chart = source.chart;
						var meta = chart.getDatasetMeta(index);
						var visible = meta && chart.isDatasetVisible(index);
						var points = visible && meta.dataset._children || [];
						var length = points.length || 0;

						return !length ? null : function (point, i) {
							return i < length && points[i]._view || null;
						};
					},

					boundary: function boundary(source) {
						var boundary = source.boundary;
						var x = boundary ? boundary.x : null;
						var y = boundary ? boundary.y : null;

						return function (point) {
							return {
								x: x === null ? point.x : x,
								y: y === null ? point.y : y
							};
						};
					}
				};

				// @todo if (fill[0] === '#')
				function decodeFill(el, index, count) {
					var model = el._model || {};
					var fill = model.fill;
					var target;

					if (fill === undefined) {
						fill = !!model.backgroundColor;
					}

					if (fill === false || fill === null) {
						return false;
					}

					if (fill === true) {
						return 'origin';
					}

					target = parseFloat(fill, 10);
					if (isFinite(target) && Math.floor(target) === target) {
						if (fill[0] === '-' || fill[0] === '+') {
							target = index + target;
						}

						if (target === index || target < 0 || target >= count) {
							return false;
						}

						return target;
					}

					switch (fill) {
						// compatibility
						case 'bottom':
							return 'start';
						case 'top':
							return 'end';
						case 'zero':
							return 'origin';
						// supported boundaries
						case 'origin':
						case 'start':
						case 'end':
							return fill;
						// invalid fill values
						default:
							return false;
					}
				}

				function computeBoundary(source) {
					var model = source.el._model || {};
					var scale = source.el._scale || {};
					var fill = source.fill;
					var target = null;
					var horizontal;

					if (isFinite(fill)) {
						return null;
					}

					// Backward compatibility: until v3, we still need to support boundary values set on
					// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
					// controllers might still use it (e.g. the Smith chart).

					if (fill === 'start') {
						target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
					} else if (fill === 'end') {
						target = model.scaleTop === undefined ? scale.top : model.scaleTop;
					} else if (model.scaleZero !== undefined) {
						target = model.scaleZero;
					} else if (scale.getBasePosition) {
						target = scale.getBasePosition();
					} else if (scale.getBasePixel) {
						target = scale.getBasePixel();
					}

					if (target !== undefined && target !== null) {
						if (target.x !== undefined && target.y !== undefined) {
							return target;
						}

						if (typeof target === 'number' && isFinite(target)) {
							horizontal = scale.isHorizontal();
							return {
								x: horizontal ? target : null,
								y: horizontal ? null : target
							};
						}
					}

					return null;
				}

				function resolveTarget(sources, index, propagate) {
					var source = sources[index];
					var fill = source.fill;
					var visited = [index];
					var target;

					if (!propagate) {
						return fill;
					}

					while (fill !== false && visited.indexOf(fill) === -1) {
						if (!isFinite(fill)) {
							return fill;
						}

						target = sources[fill];
						if (!target) {
							return false;
						}

						if (target.visible) {
							return fill;
						}

						visited.push(fill);
						fill = target.fill;
					}

					return false;
				}

				function createMapper(source) {
					var fill = source.fill;
					var type = 'dataset';

					if (fill === false) {
						return null;
					}

					if (!isFinite(fill)) {
						type = 'boundary';
					}

					return mappers[type](source);
				}

				function isDrawable(point) {
					return point && !point.skip;
				}

				function drawArea(ctx, curve0, curve1, len0, len1) {
					var i;

					if (!len0 || !len1) {
						return;
					}

					// building first area curve (normal)
					ctx.moveTo(curve0[0].x, curve0[0].y);
					for (i = 1; i < len0; ++i) {
						helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
					}

					// joining the two area curves
					ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

					// building opposite area curve (reverse)
					for (i = len1 - 1; i > 0; --i) {
						helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
					}
				}

				function doFill(ctx, points, mapper, view, color, loop) {
					var count = points.length;
					var span = view.spanGaps;
					var curve0 = [];
					var curve1 = [];
					var len0 = 0;
					var len1 = 0;
					var i, ilen, index, p0, p1, d0, d1;

					ctx.beginPath();

					for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
						index = i % count;
						p0 = points[index]._view;
						p1 = mapper(p0, index, view);
						d0 = isDrawable(p0);
						d1 = isDrawable(p1);

						if (d0 && d1) {
							len0 = curve0.push(p0);
							len1 = curve1.push(p1);
						} else if (len0 && len1) {
							if (!span) {
								drawArea(ctx, curve0, curve1, len0, len1);
								len0 = len1 = 0;
								curve0 = [];
								curve1 = [];
							} else {
								if (d0) {
									curve0.push(p0);
								}
								if (d1) {
									curve1.push(p1);
								}
							}
						}
					}

					drawArea(ctx, curve0, curve1, len0, len1);

					ctx.closePath();
					ctx.fillStyle = color;
					ctx.fill();
				}

				return {
					id: 'filler',

					afterDatasetsUpdate: function afterDatasetsUpdate(chart, options) {
						var count = (chart.data.datasets || []).length;
						var propagate = options.propagate;
						var sources = [];
						var meta, i, el, source;

						for (i = 0; i < count; ++i) {
							meta = chart.getDatasetMeta(i);
							el = meta.dataset;
							source = null;

							if (el && el._model && el instanceof elements.Line) {
								source = {
									visible: chart.isDatasetVisible(i),
									fill: decodeFill(el, i, count),
									chart: chart,
									el: el
								};
							}

							meta.$filler = source;
							sources.push(source);
						}

						for (i = 0; i < count; ++i) {
							source = sources[i];
							if (!source) {
								continue;
							}

							source.fill = resolveTarget(sources, i, propagate);
							source.boundary = computeBoundary(source);
							source.mapper = createMapper(source);
						}
					},

					beforeDatasetDraw: function beforeDatasetDraw(chart, args) {
						var meta = args.meta.$filler;
						if (!meta) {
							return;
						}

						var ctx = chart.ctx;
						var el = meta.el;
						var view = el._view;
						var points = el._children || [];
						var mapper = meta.mapper;
						var color = view.backgroundColor || defaults.global.defaultColor;

						if (mapper && color && points.length) {
							helpers.canvas.clipArea(ctx, chart.chartArea);
							doFill(ctx, points, mapper, view, color, el._loop);
							helpers.canvas.unclipArea(ctx);
						}
					}
				};
			};
		}, { "25": 25, "40": 40, "45": 45 }], 50: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				legend: {
					display: true,
					position: 'top',
					fullWidth: true,
					reverse: false,
					weight: 1000,

					// a callback that will handle
					onClick: function onClick(e, legendItem) {
						var index = legendItem.datasetIndex;
						var ci = this.chart;
						var meta = ci.getDatasetMeta(index);

						// See controller.isDatasetVisible comment
						meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

						// We hid a dataset ... rerender the chart
						ci.update();
					},

					onHover: null,

					labels: {
						boxWidth: 40,
						padding: 10,
						// Generates labels shown in the legend
						// Valid properties to return:
						// text : text to display
						// fillStyle : fill of coloured box
						// strokeStyle: stroke of coloured box
						// hidden : if this legend item refers to a hidden item
						// lineCap : cap style for line
						// lineDash
						// lineDashOffset :
						// lineJoin :
						// lineWidth :
						generateLabels: function generateLabels(chart) {
							var data = chart.data;
							return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
								return {
									text: dataset.label,
									fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
									hidden: !chart.isDatasetVisible(i),
									lineCap: dataset.borderCapStyle,
									lineDash: dataset.borderDash,
									lineDashOffset: dataset.borderDashOffset,
									lineJoin: dataset.borderJoinStyle,
									lineWidth: dataset.borderWidth,
									strokeStyle: dataset.borderColor,
									pointStyle: dataset.pointStyle,

									// Below is extra data used for toggling the datasets
									datasetIndex: i
								};
							}, this) : [];
						}
					}
				},

				legendCallback: function legendCallback(chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');
					for (var i = 0; i < chart.data.datasets.length; i++) {
						text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
						if (chart.data.datasets[i].label) {
							text.push(chart.data.datasets[i].label);
						}
						text.push('</li>');
					}
					text.push('</ul>');
					return text.join('');
				}
			});

			module.exports = function (Chart) {

				var layout = Chart.layoutService;
				var noop = helpers.noop;

				/**
     * Helper function to get the box width based on the usePointStyle option
     * @param labelopts {Object} the label options on the legend
     * @param fontSize {Number} the label font size
     * @return {Number} width of the color box area
     */
				function getBoxWidth(labelOpts, fontSize) {
					return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;
				}

				Chart.Legend = Element.extend({

					initialize: function initialize(config) {
						helpers.extend(this, config);

						// Contains hit boxes for each dataset (in dataset order)
						this.legendHitBoxes = [];

						// Are we in doughnut mode which has a different data type
						this.doughnutMode = false;
					},

					// These methods are ordered by lifecycle. Utilities then follow.
					// Any function defined here is inherited by all legend types.
					// Any function can be extended by the legend type

					beforeUpdate: noop,
					update: function update(maxWidth, maxHeight, margins) {
						var me = this;

						// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
						me.beforeUpdate();

						// Absorb the master measurements
						me.maxWidth = maxWidth;
						me.maxHeight = maxHeight;
						me.margins = margins;

						// Dimensions
						me.beforeSetDimensions();
						me.setDimensions();
						me.afterSetDimensions();
						// Labels
						me.beforeBuildLabels();
						me.buildLabels();
						me.afterBuildLabels();

						// Fit
						me.beforeFit();
						me.fit();
						me.afterFit();
						//
						me.afterUpdate();

						return me.minSize;
					},
					afterUpdate: noop,

					//

					beforeSetDimensions: noop,
					setDimensions: function setDimensions() {
						var me = this;
						// Set the unconstrained dimension before label rotation
						if (me.isHorizontal()) {
							// Reset position before calculating rotation
							me.width = me.maxWidth;
							me.left = 0;
							me.right = me.width;
						} else {
							me.height = me.maxHeight;

							// Reset position before calculating rotation
							me.top = 0;
							me.bottom = me.height;
						}

						// Reset padding
						me.paddingLeft = 0;
						me.paddingTop = 0;
						me.paddingRight = 0;
						me.paddingBottom = 0;

						// Reset minSize
						me.minSize = {
							width: 0,
							height: 0
						};
					},
					afterSetDimensions: noop,

					//

					beforeBuildLabels: noop,
					buildLabels: function buildLabels() {
						var me = this;
						var labelOpts = me.options.labels || {};
						var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

						if (labelOpts.filter) {
							legendItems = legendItems.filter(function (item) {
								return labelOpts.filter(item, me.chart.data);
							});
						}

						if (me.options.reverse) {
							legendItems.reverse();
						}

						me.legendItems = legendItems;
					},
					afterBuildLabels: noop,

					//

					beforeFit: noop,
					fit: function fit() {
						var me = this;
						var opts = me.options;
						var labelOpts = opts.labels;
						var display = opts.display;

						var ctx = me.ctx;

						var globalDefault = defaults.global;
						var valueOrDefault = helpers.valueOrDefault;
						var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
						var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
						var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
						var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

						// Reset hit boxes
						var hitboxes = me.legendHitBoxes = [];

						var minSize = me.minSize;
						var isHorizontal = me.isHorizontal();

						if (isHorizontal) {
							minSize.width = me.maxWidth; // fill all the width
							minSize.height = display ? 10 : 0;
						} else {
							minSize.width = display ? 10 : 0;
							minSize.height = me.maxHeight; // fill all the height
						}

						// Increase sizes here
						if (display) {
							ctx.font = labelFont;

							if (isHorizontal) {
								// Labels

								// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
								var lineWidths = me.lineWidths = [0];
								var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;

								ctx.textAlign = 'left';
								ctx.textBaseline = 'top';

								helpers.each(me.legendItems, function (legendItem, i) {
									var boxWidth = getBoxWidth(labelOpts, fontSize);
									var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

									if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
										totalHeight += fontSize + labelOpts.padding;
										lineWidths[lineWidths.length] = me.left;
									}

									// Store the hitbox width and height here. Final position will be updated in `draw`
									hitboxes[i] = {
										left: 0,
										top: 0,
										width: width,
										height: fontSize
									};

									lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
								});

								minSize.height += totalHeight;
							} else {
								var vPadding = labelOpts.padding;
								var columnWidths = me.columnWidths = [];
								var totalWidth = labelOpts.padding;
								var currentColWidth = 0;
								var currentColHeight = 0;
								var itemHeight = fontSize + vPadding;

								helpers.each(me.legendItems, function (legendItem, i) {
									var boxWidth = getBoxWidth(labelOpts, fontSize);
									var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

									// If too tall, go to new column
									if (currentColHeight + itemHeight > minSize.height) {
										totalWidth += currentColWidth + labelOpts.padding;
										columnWidths.push(currentColWidth); // previous column width

										currentColWidth = 0;
										currentColHeight = 0;
									}

									// Get max width
									currentColWidth = Math.max(currentColWidth, itemWidth);
									currentColHeight += itemHeight;

									// Store the hitbox width and height here. Final position will be updated in `draw`
									hitboxes[i] = {
										left: 0,
										top: 0,
										width: itemWidth,
										height: fontSize
									};
								});

								totalWidth += currentColWidth;
								columnWidths.push(currentColWidth);
								minSize.width += totalWidth;
							}
						}

						me.width = minSize.width;
						me.height = minSize.height;
					},
					afterFit: noop,

					// Shared Methods
					isHorizontal: function isHorizontal() {
						return this.options.position === 'top' || this.options.position === 'bottom';
					},

					// Actually draw the legend on the canvas
					draw: function draw() {
						var me = this;
						var opts = me.options;
						var labelOpts = opts.labels;
						var globalDefault = defaults.global;
						var lineDefault = globalDefault.elements.line;
						var legendWidth = me.width;
						var lineWidths = me.lineWidths;

						if (opts.display) {
							var ctx = me.ctx;
							var valueOrDefault = helpers.valueOrDefault;
							var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
							var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
							var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
							var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
							var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
							var cursor;

							// Canvas setup
							ctx.textAlign = 'left';
							ctx.textBaseline = 'middle';
							ctx.lineWidth = 0.5;
							ctx.strokeStyle = fontColor; // for strikethrough effect
							ctx.fillStyle = fontColor; // render in correct colour
							ctx.font = labelFont;

							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var hitboxes = me.legendHitBoxes;

							// current position
							var drawLegendBox = function drawLegendBox(x, y, legendItem) {
								if (isNaN(boxWidth) || boxWidth <= 0) {
									return;
								}

								// Set the ctx for the box
								ctx.save();

								ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
								ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
								ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
								ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
								ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
								ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
								var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;

								if (ctx.setLineDash) {
									// IE 9 and 10 do not support line dash
									ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
								}

								if (opts.labels && opts.labels.usePointStyle) {
									// Recalculate x and y for drawPoint() because its expecting
									// x and y to be center of figure (instead of top left)
									var radius = fontSize * Math.SQRT2 / 2;
									var offSet = radius / Math.SQRT2;
									var centerX = x + offSet;
									var centerY = y + offSet;

									// Draw pointStyle as legend symbol
									helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
								} else {
									// Draw box as legend symbol
									if (!isLineWidthZero) {
										ctx.strokeRect(x, y, boxWidth, fontSize);
									}
									ctx.fillRect(x, y, boxWidth, fontSize);
								}

								ctx.restore();
							};
							var fillText = function fillText(x, y, legendItem, textWidth) {
								var halfFontSize = fontSize / 2;
								var xLeft = boxWidth + halfFontSize + x;
								var yMiddle = y + halfFontSize;

								ctx.fillText(legendItem.text, xLeft, yMiddle);

								if (legendItem.hidden) {
									// Strikethrough the text if hidden
									ctx.beginPath();
									ctx.lineWidth = 2;
									ctx.moveTo(xLeft, yMiddle);
									ctx.lineTo(xLeft + textWidth, yMiddle);
									ctx.stroke();
								}
							};

							// Horizontal
							var isHorizontal = me.isHorizontal();
							if (isHorizontal) {
								cursor = {
									x: me.left + (legendWidth - lineWidths[0]) / 2,
									y: me.top + labelOpts.padding,
									line: 0
								};
							} else {
								cursor = {
									x: me.left + labelOpts.padding,
									y: me.top + labelOpts.padding,
									line: 0
								};
							}

							var itemHeight = fontSize + labelOpts.padding;
							helpers.each(me.legendItems, function (legendItem, i) {
								var textWidth = ctx.measureText(legendItem.text).width;
								var width = boxWidth + fontSize / 2 + textWidth;
								var x = cursor.x;
								var y = cursor.y;

								if (isHorizontal) {
									if (x + width >= legendWidth) {
										y = cursor.y += itemHeight;
										cursor.line++;
										x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;
									}
								} else if (y + itemHeight > me.bottom) {
									x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
									y = cursor.y = me.top + labelOpts.padding;
									cursor.line++;
								}

								drawLegendBox(x, y, legendItem);

								hitboxes[i].left = x;
								hitboxes[i].top = y;

								// Fill the actual label
								fillText(x, y, legendItem, textWidth);

								if (isHorizontal) {
									cursor.x += width + labelOpts.padding;
								} else {
									cursor.y += itemHeight;
								}
							});
						}
					},

					/**
      * Handle an event
      * @private
      * @param {IEvent} event - The event to handle
      * @return {Boolean} true if a change occured
      */
					handleEvent: function handleEvent(e) {
						var me = this;
						var opts = me.options;
						var type = e.type === 'mouseup' ? 'click' : e.type;
						var changed = false;

						if (type === 'mousemove') {
							if (!opts.onHover) {
								return;
							}
						} else if (type === 'click') {
							if (!opts.onClick) {
								return;
							}
						} else {
							return;
						}

						// Chart event already has relative position in it
						var x = e.x;
						var y = e.y;

						if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
							// See if we are touching one of the dataset boxes
							var lh = me.legendHitBoxes;
							for (var i = 0; i < lh.length; ++i) {
								var hitBox = lh[i];

								if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
									// Touching an element
									if (type === 'click') {
										// use e.native for backwards compatibility
										opts.onClick.call(me, e.native, me.legendItems[i]);
										changed = true;
										break;
									} else if (type === 'mousemove') {
										// use e.native for backwards compatibility
										opts.onHover.call(me, e.native, me.legendItems[i]);
										changed = true;
										break;
									}
								}
							}
						}

						return changed;
					}
				});

				function createNewLegendAndAttach(chart, legendOpts) {
					var legend = new Chart.Legend({
						ctx: chart.ctx,
						options: legendOpts,
						chart: chart
					});

					layout.configure(chart, legend, legendOpts);
					layout.addBox(chart, legend);
					chart.legend = legend;
				}

				return {
					id: 'legend',

					beforeInit: function beforeInit(chart) {
						var legendOpts = chart.options.legend;

						if (legendOpts) {
							createNewLegendAndAttach(chart, legendOpts);
						}
					},

					beforeUpdate: function beforeUpdate(chart) {
						var legendOpts = chart.options.legend;
						var legend = chart.legend;

						if (legendOpts) {
							helpers.mergeIf(legendOpts, defaults.global.legend);

							if (legend) {
								layout.configure(chart, legend, legendOpts);
								legend.options = legendOpts;
							} else {
								createNewLegendAndAttach(chart, legendOpts);
							}
						} else if (legend) {
							layout.removeBox(chart, legend);
							delete chart.legend;
						}
					},

					afterEvent: function afterEvent(chart, e) {
						var legend = chart.legend;
						if (legend) {
							legend.handleEvent(e);
						}
					}
				};
			};
		}, { "25": 25, "26": 26, "45": 45 }], 51: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var Element = require(26);
			var helpers = require(45);

			defaults._set('global', {
				title: {
					display: false,
					fontStyle: 'bold',
					fullWidth: true,
					lineHeight: 1.2,
					padding: 10,
					position: 'top',
					text: '',
					weight: 2000 // by default greater than legend (1000) to be above
				}
			});

			module.exports = function (Chart) {

				var layout = Chart.layoutService;
				var noop = helpers.noop;

				Chart.Title = Element.extend({
					initialize: function initialize(config) {
						var me = this;
						helpers.extend(me, config);

						// Contains hit boxes for each dataset (in dataset order)
						me.legendHitBoxes = [];
					},

					// These methods are ordered by lifecycle. Utilities then follow.

					beforeUpdate: noop,
					update: function update(maxWidth, maxHeight, margins) {
						var me = this;

						// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
						me.beforeUpdate();

						// Absorb the master measurements
						me.maxWidth = maxWidth;
						me.maxHeight = maxHeight;
						me.margins = margins;

						// Dimensions
						me.beforeSetDimensions();
						me.setDimensions();
						me.afterSetDimensions();
						// Labels
						me.beforeBuildLabels();
						me.buildLabels();
						me.afterBuildLabels();

						// Fit
						me.beforeFit();
						me.fit();
						me.afterFit();
						//
						me.afterUpdate();

						return me.minSize;
					},
					afterUpdate: noop,

					//

					beforeSetDimensions: noop,
					setDimensions: function setDimensions() {
						var me = this;
						// Set the unconstrained dimension before label rotation
						if (me.isHorizontal()) {
							// Reset position before calculating rotation
							me.width = me.maxWidth;
							me.left = 0;
							me.right = me.width;
						} else {
							me.height = me.maxHeight;

							// Reset position before calculating rotation
							me.top = 0;
							me.bottom = me.height;
						}

						// Reset padding
						me.paddingLeft = 0;
						me.paddingTop = 0;
						me.paddingRight = 0;
						me.paddingBottom = 0;

						// Reset minSize
						me.minSize = {
							width: 0,
							height: 0
						};
					},
					afterSetDimensions: noop,

					//

					beforeBuildLabels: noop,
					buildLabels: noop,
					afterBuildLabels: noop,

					//

					beforeFit: noop,
					fit: function fit() {
						var me = this;
						var valueOrDefault = helpers.valueOrDefault;
						var opts = me.options;
						var display = opts.display;
						var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
						var minSize = me.minSize;
						var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
						var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
						var textSize = display ? lineCount * lineHeight + opts.padding * 2 : 0;

						if (me.isHorizontal()) {
							minSize.width = me.maxWidth; // fill all the width
							minSize.height = textSize;
						} else {
							minSize.width = textSize;
							minSize.height = me.maxHeight; // fill all the height
						}

						me.width = minSize.width;
						me.height = minSize.height;
					},
					afterFit: noop,

					// Shared Methods
					isHorizontal: function isHorizontal() {
						var pos = this.options.position;
						return pos === 'top' || pos === 'bottom';
					},

					// Actually draw the title block on the canvas
					draw: function draw() {
						var me = this;
						var ctx = me.ctx;
						var valueOrDefault = helpers.valueOrDefault;
						var opts = me.options;
						var globalDefaults = defaults.global;

						if (opts.display) {
							var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
							var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
							var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
							var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
							var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
							var offset = lineHeight / 2 + opts.padding;
							var rotation = 0;
							var top = me.top;
							var left = me.left;
							var bottom = me.bottom;
							var right = me.right;
							var maxWidth, titleX, titleY;

							ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
							ctx.font = titleFont;

							// Horizontal
							if (me.isHorizontal()) {
								titleX = left + (right - left) / 2; // midpoint of the width
								titleY = top + offset;
								maxWidth = right - left;
							} else {
								titleX = opts.position === 'left' ? left + offset : right - offset;
								titleY = top + (bottom - top) / 2;
								maxWidth = bottom - top;
								rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
							}

							ctx.save();
							ctx.translate(titleX, titleY);
							ctx.rotate(rotation);
							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';

							var text = opts.text;
							if (helpers.isArray(text)) {
								var y = 0;
								for (var i = 0; i < text.length; ++i) {
									ctx.fillText(text[i], 0, y, maxWidth);
									y += lineHeight;
								}
							} else {
								ctx.fillText(text, 0, 0, maxWidth);
							}

							ctx.restore();
						}
					}
				});

				function createNewTitleBlockAndAttach(chart, titleOpts) {
					var title = new Chart.Title({
						ctx: chart.ctx,
						options: titleOpts,
						chart: chart
					});

					layout.configure(chart, title, titleOpts);
					layout.addBox(chart, title);
					chart.titleBlock = title;
				}

				return {
					id: 'title',

					beforeInit: function beforeInit(chart) {
						var titleOpts = chart.options.title;

						if (titleOpts) {
							createNewTitleBlockAndAttach(chart, titleOpts);
						}
					},

					beforeUpdate: function beforeUpdate(chart) {
						var titleOpts = chart.options.title;
						var titleBlock = chart.titleBlock;

						if (titleOpts) {
							helpers.mergeIf(titleOpts, defaults.global.title);

							if (titleBlock) {
								layout.configure(chart, titleBlock, titleOpts);
								titleBlock.options = titleOpts;
							} else {
								createNewTitleBlockAndAttach(chart, titleOpts);
							}
						} else if (titleBlock) {
							Chart.layoutService.removeBox(chart, titleBlock);
							delete chart.titleBlock;
						}
					}
				};
			};
		}, { "25": 25, "26": 26, "45": 45 }], 52: [function (require, module, exports) {
			'use strict';

			module.exports = function (Chart) {

				// Default config for a category scale
				var defaultConfig = {
					position: 'bottom'
				};

				var DatasetScale = Chart.Scale.extend({
					/**
     * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
     * else fall back to data.labels
     * @private
     */
					getLabels: function getLabels() {
						var data = this.chart.data;
						return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
					},

					determineDataLimits: function determineDataLimits() {
						var me = this;
						var labels = me.getLabels();
						me.minIndex = 0;
						me.maxIndex = labels.length - 1;
						var findIndex;

						if (me.options.ticks.min !== undefined) {
							// user specified min value
							findIndex = labels.indexOf(me.options.ticks.min);
							me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
						}

						if (me.options.ticks.max !== undefined) {
							// user specified max value
							findIndex = labels.indexOf(me.options.ticks.max);
							me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
						}

						me.min = labels[me.minIndex];
						me.max = labels[me.maxIndex];
					},

					buildTicks: function buildTicks() {
						var me = this;
						var labels = me.getLabels();
						// If we are viewing some subset of labels, slice the original array
						me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
					},

					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						var me = this;
						var data = me.chart.data;
						var isHorizontal = me.isHorizontal();

						if (data.yLabels && !isHorizontal) {
							return me.getRightValue(data.datasets[datasetIndex].data[index]);
						}
						return me.ticks[index - me.minIndex];
					},

					// Used to get data value locations.  Value can either be an index or a numerical value
					getPixelForValue: function getPixelForValue(value, index) {
						var me = this;
						var offset = me.options.offset;
						// 1 is added because we need the length but we have the indexes
						var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1);

						// If value is a data object, then index is the index in the data array,
						// not the index of the scale. We need to change that.
						var valueCategory;
						if (value !== undefined && value !== null) {
							valueCategory = me.isHorizontal() ? value.x : value.y;
						}
						if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
							var labels = me.getLabels();
							value = valueCategory || value;
							var idx = labels.indexOf(value);
							index = idx !== -1 ? idx : index;
						}

						if (me.isHorizontal()) {
							var valueWidth = me.width / offsetAmt;
							var widthOffset = valueWidth * (index - me.minIndex);

							if (offset) {
								widthOffset += valueWidth / 2;
							}

							return me.left + Math.round(widthOffset);
						}
						var valueHeight = me.height / offsetAmt;
						var heightOffset = valueHeight * (index - me.minIndex);

						if (offset) {
							heightOffset += valueHeight / 2;
						}

						return me.top + Math.round(heightOffset);
					},
					getPixelForTick: function getPixelForTick(index) {
						return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
					},
					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var offset = me.options.offset;
						var value;
						var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
						var horz = me.isHorizontal();
						var valueDimension = (horz ? me.width : me.height) / offsetAmt;

						pixel -= horz ? me.left : me.top;

						if (offset) {
							pixel -= valueDimension / 2;
						}

						if (pixel <= 0) {
							value = 0;
						} else {
							value = Math.round(pixel / valueDimension);
						}

						return value + me.minIndex;
					},
					getBasePixel: function getBasePixel() {
						return this.bottom;
					}
				});

				Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
			};
		}, {}], 53: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var defaultConfig = {
					position: 'left',
					ticks: {
						callback: Ticks.formatters.linear
					}
				};

				var LinearScale = Chart.LinearScaleBase.extend({

					determineDataLimits: function determineDataLimits() {
						var me = this;
						var opts = me.options;
						var chart = me.chart;
						var data = chart.data;
						var datasets = data.datasets;
						var isHorizontal = me.isHorizontal();
						var DEFAULT_MIN = 0;
						var DEFAULT_MAX = 1;

						function IDMatches(meta) {
							return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
						}

						// First Calculate the range
						me.min = null;
						me.max = null;

						var hasStacks = opts.stacked;
						if (hasStacks === undefined) {
							helpers.each(datasets, function (dataset, datasetIndex) {
								if (hasStacks) {
									return;
								}

								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
									hasStacks = true;
								}
							});
						}

						if (opts.stacked || hasStacks) {
							var valuesPerStack = {};

							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								var key = [meta.type,
								// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
								opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

								if (valuesPerStack[key] === undefined) {
									valuesPerStack[key] = {
										positiveValues: [],
										negativeValues: []
									};
								}

								// Store these per type
								var positiveValues = valuesPerStack[key].positiveValues;
								var negativeValues = valuesPerStack[key].negativeValues;

								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									helpers.each(dataset.data, function (rawValue, index) {
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										positiveValues[index] = positiveValues[index] || 0;
										negativeValues[index] = negativeValues[index] || 0;

										if (opts.relativePoints) {
											positiveValues[index] = 100;
										} else if (value < 0) {
											negativeValues[index] += value;
										} else {
											positiveValues[index] += value;
										}
									});
								}
							});

							helpers.each(valuesPerStack, function (valuesForType) {
								var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
								var minVal = helpers.min(values);
								var maxVal = helpers.max(values);
								me.min = me.min === null ? minVal : Math.min(me.min, minVal);
								me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
							});
						} else {
							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									helpers.each(dataset.data, function (rawValue, index) {
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										if (me.min === null) {
											me.min = value;
										} else if (value < me.min) {
											me.min = value;
										}

										if (me.max === null) {
											me.max = value;
										} else if (value > me.max) {
											me.max = value;
										}
									});
								}
							});
						}

						me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
						me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

						// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
						this.handleTickRangeOptions();
					},
					getTickLimit: function getTickLimit() {
						var maxTicks;
						var me = this;
						var tickOpts = me.options.ticks;

						if (me.isHorizontal()) {
							maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
						} else {
							// The factor of 2 used to scale the font size has been experimentally determined.
							var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
							maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
						}

						return maxTicks;
					},
					// Called after the ticks are built. We need
					handleDirectionalChanges: function handleDirectionalChanges() {
						if (!this.isHorizontal()) {
							// We are in a vertical orientation. The top value is the highest. So reverse the array
							this.ticks.reverse();
						}
					},
					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
					},
					// Utils
					getPixelForValue: function getPixelForValue(value) {
						// This must be called after fit has been run so that
						// this.left, this.top, this.right, and this.bottom have been defined
						var me = this;
						var start = me.start;

						var rightValue = +me.getRightValue(value);
						var pixel;
						var range = me.end - start;

						if (me.isHorizontal()) {
							pixel = me.left + me.width / range * (rightValue - start);
							return Math.round(pixel);
						}

						pixel = me.bottom - me.height / range * (rightValue - start);
						return Math.round(pixel);
					},
					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var isHorizontal = me.isHorizontal();
						var innerDimension = isHorizontal ? me.width : me.height;
						var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
						return me.start + (me.end - me.start) * offset;
					},
					getPixelForTick: function getPixelForTick(index) {
						return this.getPixelForValue(this.ticksAsNumbers[index]);
					}
				});
				Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
			};
		}, { "25": 25, "34": 34, "45": 45 }], 54: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var noop = helpers.noop;

				Chart.LinearScaleBase = Chart.Scale.extend({
					getRightValue: function getRightValue(value) {
						if (typeof value === 'string') {
							return +value;
						}
						return Chart.Scale.prototype.getRightValue.call(this, value);
					},

					handleTickRangeOptions: function handleTickRangeOptions() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;

						// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
						// do nothing since that would make the chart weird. If the user really wants a weird chart
						// axis, they can manually override it
						if (tickOpts.beginAtZero) {
							var minSign = helpers.sign(me.min);
							var maxSign = helpers.sign(me.max);

							if (minSign < 0 && maxSign < 0) {
								// move the top up to 0
								me.max = 0;
							} else if (minSign > 0 && maxSign > 0) {
								// move the bottom down to 0
								me.min = 0;
							}
						}

						var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
						var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

						if (tickOpts.min !== undefined) {
							me.min = tickOpts.min;
						} else if (tickOpts.suggestedMin !== undefined) {
							if (me.min === null) {
								me.min = tickOpts.suggestedMin;
							} else {
								me.min = Math.min(me.min, tickOpts.suggestedMin);
							}
						}

						if (tickOpts.max !== undefined) {
							me.max = tickOpts.max;
						} else if (tickOpts.suggestedMax !== undefined) {
							if (me.max === null) {
								me.max = tickOpts.suggestedMax;
							} else {
								me.max = Math.max(me.max, tickOpts.suggestedMax);
							}
						}

						if (setMin !== setMax) {
							// We set the min or the max but not both.
							// So ensure that our range is good
							// Inverted or 0 length range can happen when
							// ticks.min is set, and no datasets are visible
							if (me.min >= me.max) {
								if (setMin) {
									me.max = me.min + 1;
								} else {
									me.min = me.max - 1;
								}
							}
						}

						if (me.min === me.max) {
							me.max++;

							if (!tickOpts.beginAtZero) {
								me.min--;
							}
						}
					},
					getTickLimit: noop,
					handleDirectionalChanges: noop,

					buildTicks: function buildTicks() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;

						// Figure out what the max number of ticks we can support it is based on the size of
						// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
						// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
						// the graph. Make sure we always have at least 2 ticks
						var maxTicks = me.getTickLimit();
						maxTicks = Math.max(2, maxTicks);

						var numericGeneratorOptions = {
							maxTicks: maxTicks,
							min: tickOpts.min,
							max: tickOpts.max,
							stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
						};
						var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);

						me.handleDirectionalChanges();

						// At this point, we need to update our max and min given the tick values since we have expanded the
						// range of the scale
						me.max = helpers.max(ticks);
						me.min = helpers.min(ticks);

						if (tickOpts.reverse) {
							ticks.reverse();

							me.start = me.max;
							me.end = me.min;
						} else {
							me.start = me.min;
							me.end = me.max;
						}
					},
					convertTicksToLabels: function convertTicksToLabels() {
						var me = this;
						me.ticksAsNumbers = me.ticks.slice();
						me.zeroLineIndex = me.ticks.indexOf(0);

						Chart.Scale.prototype.convertTicksToLabels.call(me);
					}
				});
			};
		}, { "34": 34, "45": 45 }], 55: [function (require, module, exports) {
			'use strict';

			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var defaultConfig = {
					position: 'left',

					// label settings
					ticks: {
						callback: Ticks.formatters.logarithmic
					}
				};

				var LogarithmicScale = Chart.Scale.extend({
					determineDataLimits: function determineDataLimits() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;
						var chart = me.chart;
						var data = chart.data;
						var datasets = data.datasets;
						var valueOrDefault = helpers.valueOrDefault;
						var isHorizontal = me.isHorizontal();
						function IDMatches(meta) {
							return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
						}

						// Calculate Range
						me.min = null;
						me.max = null;
						me.minNotZero = null;

						var hasStacks = opts.stacked;
						if (hasStacks === undefined) {
							helpers.each(datasets, function (dataset, datasetIndex) {
								if (hasStacks) {
									return;
								}

								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
									hasStacks = true;
								}
							});
						}

						if (opts.stacked || hasStacks) {
							var valuesPerStack = {};

							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								var key = [meta.type,
								// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
								opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									if (valuesPerStack[key] === undefined) {
										valuesPerStack[key] = [];
									}

									helpers.each(dataset.data, function (rawValue, index) {
										var values = valuesPerStack[key];
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										values[index] = values[index] || 0;

										if (opts.relativePoints) {
											values[index] = 100;
										} else {
											// Don't need to split positive and negative since the log scale can't handle a 0 crossing
											values[index] += value;
										}
									});
								}
							});

							helpers.each(valuesPerStack, function (valuesForType) {
								var minVal = helpers.min(valuesForType);
								var maxVal = helpers.max(valuesForType);
								me.min = me.min === null ? minVal : Math.min(me.min, minVal);
								me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
							});
						} else {
							helpers.each(datasets, function (dataset, datasetIndex) {
								var meta = chart.getDatasetMeta(datasetIndex);
								if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
									helpers.each(dataset.data, function (rawValue, index) {
										var value = +me.getRightValue(rawValue);
										if (isNaN(value) || meta.data[index].hidden) {
											return;
										}

										if (me.min === null) {
											me.min = value;
										} else if (value < me.min) {
											me.min = value;
										}

										if (me.max === null) {
											me.max = value;
										} else if (value > me.max) {
											me.max = value;
										}

										if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
											me.minNotZero = value;
										}
									});
								}
							});
						}

						me.min = valueOrDefault(tickOpts.min, me.min);
						me.max = valueOrDefault(tickOpts.max, me.max);

						if (me.min === me.max) {
							if (me.min !== 0 && me.min !== null) {
								me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
								me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
							} else {
								me.min = 1;
								me.max = 10;
							}
						}
					},
					buildTicks: function buildTicks() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;

						var generationOptions = {
							min: tickOpts.min,
							max: tickOpts.max
						};
						var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);

						if (!me.isHorizontal()) {
							// We are in a vertical orientation. The top value is the highest. So reverse the array
							ticks.reverse();
						}

						// At this point, we need to update our max and min given the tick values since we have expanded the
						// range of the scale
						me.max = helpers.max(ticks);
						me.min = helpers.min(ticks);

						if (tickOpts.reverse) {
							ticks.reverse();

							me.start = me.max;
							me.end = me.min;
						} else {
							me.start = me.min;
							me.end = me.max;
						}
					},
					convertTicksToLabels: function convertTicksToLabels() {
						this.tickValues = this.ticks.slice();

						Chart.Scale.prototype.convertTicksToLabels.call(this);
					},
					// Get the correct tooltip label
					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
					},
					getPixelForTick: function getPixelForTick(index) {
						return this.getPixelForValue(this.tickValues[index]);
					},
					getPixelForValue: function getPixelForValue(value) {
						var me = this;
						var start = me.start;
						var newVal = +me.getRightValue(value);
						var opts = me.options;
						var tickOpts = opts.ticks;
						var innerDimension, pixel, range;

						if (me.isHorizontal()) {
							range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0
							if (newVal === 0) {
								pixel = me.left;
							} else {
								innerDimension = me.width;
								pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
							}
						} else {
							// Bottom - top since pixels increase downward on a screen
							innerDimension = me.height;
							if (start === 0 && !tickOpts.reverse) {
								range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
								if (newVal === start) {
									pixel = me.bottom;
								} else if (newVal === me.minNotZero) {
									pixel = me.bottom - innerDimension * 0.02;
								} else {
									pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
								}
							} else if (me.end === 0 && tickOpts.reverse) {
								range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
								if (newVal === me.end) {
									pixel = me.top;
								} else if (newVal === me.minNotZero) {
									pixel = me.top + innerDimension * 0.02;
								} else {
									pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
								}
							} else if (newVal === 0) {
								pixel = tickOpts.reverse ? me.top : me.bottom;
							} else {
								range = helpers.log10(me.end) - helpers.log10(start);
								innerDimension = me.height;
								pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
							}
						}
						return pixel;
					},
					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var range = helpers.log10(me.end) - helpers.log10(me.start);
						var value, innerDimension;

						if (me.isHorizontal()) {
							innerDimension = me.width;
							value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
						} else {
							// todo: if start === 0
							innerDimension = me.height;
							value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
						}
						return value;
					}
				});
				Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
			};
		}, { "34": 34, "45": 45 }], 56: [function (require, module, exports) {
			'use strict';

			var defaults = require(25);
			var helpers = require(45);
			var Ticks = require(34);

			module.exports = function (Chart) {

				var globalDefaults = defaults.global;

				var defaultConfig = {
					display: true,

					// Boolean - Whether to animate scaling the chart from the centre
					animate: true,
					position: 'chartArea',

					angleLines: {
						display: true,
						color: 'rgba(0, 0, 0, 0.1)',
						lineWidth: 1
					},

					gridLines: {
						circular: false
					},

					// label settings
					ticks: {
						// Boolean - Show a backdrop to the scale label
						showLabelBackdrop: true,

						// String - The colour of the label backdrop
						backdropColor: 'rgba(255,255,255,0.75)',

						// Number - The backdrop padding above & below the label in pixels
						backdropPaddingY: 2,

						// Number - The backdrop padding to the side of the label in pixels
						backdropPaddingX: 2,

						callback: Ticks.formatters.linear
					},

					pointLabels: {
						// Boolean - if true, show point labels
						display: true,

						// Number - Point label font size in pixels
						fontSize: 10,

						// Function - Used to convert point labels
						callback: function callback(label) {
							return label;
						}
					}
				};

				function getValueCount(scale) {
					var opts = scale.options;
					return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
				}

				function getPointLabelFontOptions(scale) {
					var pointLabelOptions = scale.options.pointLabels;
					var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
					var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
					var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
					var font = helpers.fontString(fontSize, fontStyle, fontFamily);

					return {
						size: fontSize,
						style: fontStyle,
						family: fontFamily,
						font: font
					};
				}

				function measureLabelSize(ctx, fontSize, label) {
					if (helpers.isArray(label)) {
						return {
							w: helpers.longestText(ctx, ctx.font, label),
							h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize
						};
					}

					return {
						w: ctx.measureText(label).width,
						h: fontSize
					};
				}

				function determineLimits(angle, pos, size, min, max) {
					if (angle === min || angle === max) {
						return {
							start: pos - size / 2,
							end: pos + size / 2
						};
					} else if (angle < min || angle > max) {
						return {
							start: pos - size - 5,
							end: pos
						};
					}

					return {
						start: pos,
						end: pos + size + 5
					};
				}

				/**
     * Helper function to fit a radial linear scale with point labels
     */
				function fitWithPointLabels(scale) {
					/*
      * Right, this is really confusing and there is a lot of maths going on here
      * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      *
      * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      *
      * Solution:
      *
      * We assume the radius of the polygon is half the size of the canvas at first
      * at each index we check if the text overlaps.
      *
      * Where it does, we store that angle and that index.
      *
      * After finding the largest index and angle we calculate how much we need to remove
      * from the shape radius to move the point inwards by that x.
      *
      * We average the left and right distances to get the maximum shape radius that can fit in the box
      * along with labels.
      *
      * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      * on each side, removing that from the size, halving it and adding the left x protrusion width.
      *
      * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      * and position it in the most space efficient manner
      *
      * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      */

					var plFont = getPointLabelFontOptions(scale);

					// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
					// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
					var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
					var furthestLimits = {
						r: scale.width,
						l: 0,
						t: scale.height,
						b: 0
					};
					var furthestAngles = {};
					var i, textSize, pointPosition;

					scale.ctx.font = plFont.font;
					scale._pointLabelSizes = [];

					var valueCount = getValueCount(scale);
					for (i = 0; i < valueCount; i++) {
						pointPosition = scale.getPointPosition(i, largestPossibleRadius);
						textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
						scale._pointLabelSizes[i] = textSize;

						// Add quarter circle to make degree 0 mean top of circle
						var angleRadians = scale.getIndexAngle(i);
						var angle = helpers.toDegrees(angleRadians) % 360;
						var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
						var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

						if (hLimits.start < furthestLimits.l) {
							furthestLimits.l = hLimits.start;
							furthestAngles.l = angleRadians;
						}

						if (hLimits.end > furthestLimits.r) {
							furthestLimits.r = hLimits.end;
							furthestAngles.r = angleRadians;
						}

						if (vLimits.start < furthestLimits.t) {
							furthestLimits.t = vLimits.start;
							furthestAngles.t = angleRadians;
						}

						if (vLimits.end > furthestLimits.b) {
							furthestLimits.b = vLimits.end;
							furthestAngles.b = angleRadians;
						}
					}

					scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
				}

				/**
     * Helper function to fit a radial linear scale with no point labels
     */
				function _fit(scale) {
					var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
					scale.drawingArea = Math.round(largestPossibleRadius);
					scale.setCenterPoint(0, 0, 0, 0);
				}

				function getTextAlignForAngle(angle) {
					if (angle === 0 || angle === 180) {
						return 'center';
					} else if (angle < 180) {
						return 'left';
					}

					return 'right';
				}

				function fillText(ctx, text, position, fontSize) {
					if (helpers.isArray(text)) {
						var y = position.y;
						var spacing = 1.5 * fontSize;

						for (var i = 0; i < text.length; ++i) {
							ctx.fillText(text[i], position.x, y);
							y += spacing;
						}
					} else {
						ctx.fillText(text, position.x, position.y);
					}
				}

				function adjustPointPositionForLabelHeight(angle, textSize, position) {
					if (angle === 90 || angle === 270) {
						position.y -= textSize.h / 2;
					} else if (angle > 270 || angle < 90) {
						position.y -= textSize.h;
					}
				}

				function drawPointLabels(scale) {
					var ctx = scale.ctx;
					var valueOrDefault = helpers.valueOrDefault;
					var opts = scale.options;
					var angleLineOpts = opts.angleLines;
					var pointLabelOpts = opts.pointLabels;

					ctx.lineWidth = angleLineOpts.lineWidth;
					ctx.strokeStyle = angleLineOpts.color;

					var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

					// Point Label Font
					var plFont = getPointLabelFontOptions(scale);

					ctx.textBaseline = 'top';

					for (var i = getValueCount(scale) - 1; i >= 0; i--) {
						if (angleLineOpts.display) {
							var outerPosition = scale.getPointPosition(i, outerDistance);
							ctx.beginPath();
							ctx.moveTo(scale.xCenter, scale.yCenter);
							ctx.lineTo(outerPosition.x, outerPosition.y);
							ctx.stroke();
							ctx.closePath();
						}

						if (pointLabelOpts.display) {
							// Extra 3px out for some label spacing
							var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

							// Keep this in loop since we may support array properties here
							var pointLabelFontColor = valueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
							ctx.font = plFont.font;
							ctx.fillStyle = pointLabelFontColor;

							var angleRadians = scale.getIndexAngle(i);
							var angle = helpers.toDegrees(angleRadians);
							ctx.textAlign = getTextAlignForAngle(angle);
							adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
							fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
						}
					}
				}

				function drawRadiusLine(scale, gridLineOpts, radius, index) {
					var ctx = scale.ctx;
					ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
					ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

					if (scale.options.gridLines.circular) {
						// Draw circular arcs between the points
						ctx.beginPath();
						ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
						ctx.closePath();
						ctx.stroke();
					} else {
						// Draw straight lines connecting each index
						var valueCount = getValueCount(scale);

						if (valueCount === 0) {
							return;
						}

						ctx.beginPath();
						var pointPosition = scale.getPointPosition(0, radius);
						ctx.moveTo(pointPosition.x, pointPosition.y);

						for (var i = 1; i < valueCount; i++) {
							pointPosition = scale.getPointPosition(i, radius);
							ctx.lineTo(pointPosition.x, pointPosition.y);
						}

						ctx.closePath();
						ctx.stroke();
					}
				}

				function numberOrZero(param) {
					return helpers.isNumber(param) ? param : 0;
				}

				var LinearRadialScale = Chart.LinearScaleBase.extend({
					setDimensions: function setDimensions() {
						var me = this;
						var opts = me.options;
						var tickOpts = opts.ticks;
						// Set the unconstrained dimension before label rotation
						me.width = me.maxWidth;
						me.height = me.maxHeight;
						me.xCenter = Math.round(me.width / 2);
						me.yCenter = Math.round(me.height / 2);

						var minSize = helpers.min([me.height, me.width]);
						var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
						me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;
					},
					determineDataLimits: function determineDataLimits() {
						var me = this;
						var chart = me.chart;
						var min = Number.POSITIVE_INFINITY;
						var max = Number.NEGATIVE_INFINITY;

						helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
							if (chart.isDatasetVisible(datasetIndex)) {
								var meta = chart.getDatasetMeta(datasetIndex);

								helpers.each(dataset.data, function (rawValue, index) {
									var value = +me.getRightValue(rawValue);
									if (isNaN(value) || meta.data[index].hidden) {
										return;
									}

									min = Math.min(value, min);
									max = Math.max(value, max);
								});
							}
						});

						me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
						me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;

						// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
						me.handleTickRangeOptions();
					},
					getTickLimit: function getTickLimit() {
						var tickOpts = this.options.ticks;
						var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
						return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
					},
					convertTicksToLabels: function convertTicksToLabels() {
						var me = this;

						Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

						// Point labels
						me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
					},
					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
					},
					fit: function fit() {
						if (this.options.pointLabels.display) {
							fitWithPointLabels(this);
						} else {
							_fit(this);
						}
					},
					/**
      * Set radius reductions and determine new radius and center point
      * @private
      */
					setReductions: function setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
						var me = this;
						var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
						var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
						var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
						var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

						radiusReductionLeft = numberOrZero(radiusReductionLeft);
						radiusReductionRight = numberOrZero(radiusReductionRight);
						radiusReductionTop = numberOrZero(radiusReductionTop);
						radiusReductionBottom = numberOrZero(radiusReductionBottom);

						me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
						me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
					},
					setCenterPoint: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
						var me = this;
						var maxRight = me.width - rightMovement - me.drawingArea;
						var maxLeft = leftMovement + me.drawingArea;
						var maxTop = topMovement + me.drawingArea;
						var maxBottom = me.height - bottomMovement - me.drawingArea;

						me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
						me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);
					},

					getIndexAngle: function getIndexAngle(index) {
						var angleMultiplier = Math.PI * 2 / getValueCount(this);
						var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;

						var startAngleRadians = startAngle * Math.PI * 2 / 360;

						// Start from the top instead of right, so remove a quarter of the circle
						return index * angleMultiplier + startAngleRadians;
					},
					getDistanceFromCenterForValue: function getDistanceFromCenterForValue(value) {
						var me = this;

						if (value === null) {
							return 0; // null always in center
						}

						// Take into account half font size + the yPadding of the top value
						var scalingFactor = me.drawingArea / (me.max - me.min);
						if (me.options.ticks.reverse) {
							return (me.max - value) * scalingFactor;
						}
						return (value - me.min) * scalingFactor;
					},
					getPointPosition: function getPointPosition(index, distanceFromCenter) {
						var me = this;
						var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
						return {
							x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
							y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
						};
					},
					getPointPositionForValue: function getPointPositionForValue(index, value) {
						return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
					},

					getBasePosition: function getBasePosition() {
						var me = this;
						var min = me.min;
						var max = me.max;

						return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
					},

					draw: function draw() {
						var me = this;
						var opts = me.options;
						var gridLineOpts = opts.gridLines;
						var tickOpts = opts.ticks;
						var valueOrDefault = helpers.valueOrDefault;

						if (opts.display) {
							var ctx = me.ctx;
							var startAngle = this.getIndexAngle(0);

							// Tick Font
							var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
							var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
							var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
							var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

							helpers.each(me.ticks, function (label, index) {
								// Don't draw a centre value (if it is minimum)
								if (index > 0 || tickOpts.reverse) {
									var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

									// Draw circular lines around the scale
									if (gridLineOpts.display && index !== 0) {
										drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
									}

									if (tickOpts.display) {
										var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
										ctx.font = tickLabelFont;

										ctx.save();
										ctx.translate(me.xCenter, me.yCenter);
										ctx.rotate(startAngle);

										if (tickOpts.showLabelBackdrop) {
											var labelWidth = ctx.measureText(label).width;
											ctx.fillStyle = tickOpts.backdropColor;
											ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);
										}

										ctx.textAlign = 'center';
										ctx.textBaseline = 'middle';
										ctx.fillStyle = tickFontColor;
										ctx.fillText(label, 0, -yCenterOffset);
										ctx.restore();
									}
								}
							});

							if (opts.angleLines.display || opts.pointLabels.display) {
								drawPointLabels(me);
							}
						}
					}
				});
				Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
			};
		}, { "25": 25, "34": 34, "45": 45 }], 57: [function (require, module, exports) {
			/* global window: false */
			'use strict';

			var moment = require(1);
			moment = typeof moment === 'function' ? moment : window.moment;

			var defaults = require(25);
			var helpers = require(45);

			// Integer constants are from the ES6 spec.
			var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
			var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

			var INTERVALS = {
				millisecond: {
					major: true,
					size: 1,
					steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
				},
				second: {
					major: true,
					size: 1000,
					steps: [1, 2, 5, 10, 30]
				},
				minute: {
					major: true,
					size: 60000,
					steps: [1, 2, 5, 10, 30]
				},
				hour: {
					major: true,
					size: 3600000,
					steps: [1, 2, 3, 6, 12]
				},
				day: {
					major: true,
					size: 86400000,
					steps: [1, 2, 5]
				},
				week: {
					major: false,
					size: 604800000,
					steps: [1, 2, 3, 4]
				},
				month: {
					major: true,
					size: 2.628e9,
					steps: [1, 2, 3]
				},
				quarter: {
					major: false,
					size: 7.884e9,
					steps: [1, 2, 3, 4]
				},
				year: {
					major: true,
					size: 3.154e10
				}
			};

			var UNITS = Object.keys(INTERVALS);

			function sorter(a, b) {
				return a - b;
			}

			function arrayUnique(items) {
				var hash = {};
				var out = [];
				var i, ilen, item;

				for (i = 0, ilen = items.length; i < ilen; ++i) {
					item = items[i];
					if (!hash[item]) {
						hash[item] = true;
						out.push(item);
					}
				}

				return out;
			}

			/**
    * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
    * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
    * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
    * extremity (left + width or top + height). Note that it would be more optimized to directly
    * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
    * to create the lookup table. The table ALWAYS contains at least two items: min and max.
    *
    * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
    * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
    * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
    * If 'series', timestamps will be positioned at the same distance from each other. In this
    * case, only timestamps that break the time linearity are registered, meaning that in the
    * best case, all timestamps are linear, the table contains only min and max.
    */
			function buildLookupTable(timestamps, min, max, distribution) {
				if (distribution === 'linear' || !timestamps.length) {
					return [{ time: min, pos: 0 }, { time: max, pos: 1 }];
				}

				var table = [];
				var items = [min];
				var i, ilen, prev, curr, next;

				for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
					curr = timestamps[i];
					if (curr > min && curr < max) {
						items.push(curr);
					}
				}

				items.push(max);

				for (i = 0, ilen = items.length; i < ilen; ++i) {
					next = items[i + 1];
					prev = items[i - 1];
					curr = items[i];

					// only add points that breaks the scale linearity
					if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
						table.push({ time: curr, pos: i / (ilen - 1) });
					}
				}

				return table;
			}

			// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
			function lookup(table, key, value) {
				var lo = 0;
				var hi = table.length - 1;
				var mid, i0, i1;

				while (lo >= 0 && lo <= hi) {
					mid = lo + hi >> 1;
					i0 = table[mid - 1] || null;
					i1 = table[mid];

					if (!i0) {
						// given value is outside table (before first item)
						return { lo: null, hi: i1 };
					} else if (i1[key] < value) {
						lo = mid + 1;
					} else if (i0[key] > value) {
						hi = mid - 1;
					} else {
						return { lo: i0, hi: i1 };
					}
				}

				// given value is outside table (after last item)
				return { lo: i1, hi: null };
			}

			/**
    * Linearly interpolates the given source `value` using the table items `skey` values and
    * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
    * returns the position for a timestamp equal to 42. If value is out of bounds, values at
    * index [0, 1] or [n - 1, n] are used for the interpolation.
    */
			function interpolate(table, skey, sval, tkey) {
				var range = lookup(table, skey, sval);

				// Note: the lookup table ALWAYS contains at least 2 items (min and max)
				var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
				var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

				var span = next[skey] - prev[skey];
				var ratio = span ? (sval - prev[skey]) / span : 0;
				var offset = (next[tkey] - prev[tkey]) * ratio;

				return prev[tkey] + offset;
			}

			/**
    * Convert the given value to a moment object using the given time options.
    * @see http://momentjs.com/docs/#/parsing/
    */
			function momentify(value, options) {
				var parser = options.parser;
				var format = options.parser || options.format;

				if (typeof parser === 'function') {
					return parser(value);
				}

				if (typeof value === 'string' && typeof format === 'string') {
					return moment(value, format);
				}

				if (!(value instanceof moment)) {
					value = moment(value);
				}

				if (value.isValid()) {
					return value;
				}

				// Labels are in an incompatible moment format and no `parser` has been provided.
				// The user might still use the deprecated `format` option to convert his inputs.
				if (typeof format === 'function') {
					return format(value);
				}

				return value;
			}

			function parse(input, scale) {
				if (helpers.isNullOrUndef(input)) {
					return null;
				}

				var options = scale.options.time;
				var value = momentify(scale.getRightValue(input), options);
				if (!value.isValid()) {
					return null;
				}

				if (options.round) {
					value.startOf(options.round);
				}

				return value.valueOf();
			}

			/**
    * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
    * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
    */
			function determineStepSize(min, max, unit, capacity) {
				var range = max - min;
				var interval = INTERVALS[unit];
				var milliseconds = interval.size;
				var steps = interval.steps;
				var i, ilen, factor;

				if (!steps) {
					return Math.ceil(range / ((capacity || 1) * milliseconds));
				}

				for (i = 0, ilen = steps.length; i < ilen; ++i) {
					factor = steps[i];
					if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
						break;
					}
				}

				return factor;
			}

			function determineUnit(minUnit, min, max, capacity) {
				var ilen = UNITS.length;
				var i, interval, factor;

				for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
					interval = INTERVALS[UNITS[i]];
					factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

					if (Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
						return UNITS[i];
					}
				}

				return UNITS[ilen - 1];
			}

			function determineMajorUnit(unit) {
				for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
					if (INTERVALS[UNITS[i]].major) {
						return UNITS[i];
					}
				}
			}

			/**
    * Generates a maximum of `capacity` timestamps between min and max, rounded to the
    * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
    * Important: this method can return ticks outside the min and max range, it's the
    * responsibility of the calling code to clamp values if needed.
    */
			function generate(min, max, minor, major, capacity, options) {
				var timeOpts = options.time;
				var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
				var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
				var majorTicksEnabled = options.ticks.major.enabled;
				var interval = INTERVALS[minor];
				var first = moment(min);
				var last = moment(max);
				var ticks = [];
				var time;

				if (!stepSize) {
					stepSize = determineStepSize(min, max, minor, capacity);
				}

				// For 'week' unit, handle the first day of week option
				if (weekday) {
					first = first.isoWeekday(weekday);
					last = last.isoWeekday(weekday);
				}

				// Align first/last ticks on unit
				first = first.startOf(weekday ? 'day' : minor);
				last = last.startOf(weekday ? 'day' : minor);

				// Make sure that the last tick include max
				if (last < max) {
					last.add(1, minor);
				}

				time = moment(first);

				if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
					// Align the first tick on the previous `minor` unit aligned on the `major` unit:
					// we first aligned time on the previous `major` unit then add the number of full
					// stepSize there is between first and the previous major time.
					time.startOf(major);
					time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
				}

				for (; time < last; time.add(stepSize, minor)) {
					ticks.push(+time);
				}

				ticks.push(+time);

				return ticks;
			}

			/**
    * Returns the right and left offsets from edges in the form of {left, right}.
    * Offsets are added when the `offset` option is true.
    */
			function computeOffsets(table, ticks, min, max, options) {
				var left = 0;
				var right = 0;
				var upper, lower;

				if (options.offset && ticks.length) {
					if (!options.time.min) {
						upper = ticks.length > 1 ? ticks[1] : max;
						lower = ticks[0];
						left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
					}
					if (!options.time.max) {
						upper = ticks[ticks.length - 1];
						lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
						right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
					}
				}

				return { left: left, right: right };
			}

			function ticksFromTimestamps(values, majorUnit) {
				var ticks = [];
				var i, ilen, value, major;

				for (i = 0, ilen = values.length; i < ilen; ++i) {
					value = values[i];
					major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;

					ticks.push({
						value: value,
						major: major
					});
				}

				return ticks;
			}

			module.exports = function (Chart) {

				var defaultConfig = {
					position: 'bottom',

					/**
      * Data distribution along the scale:
      * - 'linear': data are spread according to their time (distances can vary),
      * - 'series': data are spread at the same distance from each other.
      * @see https://github.com/chartjs/Chart.js/pull/4507
      * @since 2.7.0
      */
					distribution: 'linear',

					/**
      * Scale boundary strategy (bypassed by min/max time options)
      * - `data`: make sure data are fully visible, ticks outside are removed
      * - `ticks`: make sure ticks are fully visible, data outside are truncated
      * @see https://github.com/chartjs/Chart.js/pull/4556
      * @since 2.7.0
      */
					bounds: 'data',

					time: {
						parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
						format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
						unit: false, // false == automatic or override with week, month, year, etc.
						round: false, // none, or override with week, month, year, etc.
						displayFormat: false, // DEPRECATED
						isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
						minUnit: 'millisecond',

						// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
						displayFormats: {
							millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
							second: 'h:mm:ss a', // 11:20:01 AM
							minute: 'h:mm a', // 11:20 AM
							hour: 'hA', // 5PM
							day: 'MMM D', // Sep 4
							week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
							month: 'MMM YYYY', // Sept 2015
							quarter: '[Q]Q - YYYY', // Q3
							year: 'YYYY' // 2015
						}
					},
					ticks: {
						autoSkip: false,

						/**
       * Ticks generation input values:
       * - 'auto': generates "optimal" ticks based on scale size and time options.
       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
       * - 'labels': generates ticks from user given `data.labels` values ONLY.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
						source: 'auto',

						major: {
							enabled: false
						}
					}
				};

				var TimeScale = Chart.Scale.extend({
					initialize: function initialize() {
						if (!moment) {
							throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
						}

						this.mergeTicksOptions();

						Chart.Scale.prototype.initialize.call(this);
					},

					update: function update() {
						var me = this;
						var options = me.options;

						// DEPRECATIONS: output a message only one time per update
						if (options.time && options.time.format) {
							console.warn('options.time.format is deprecated and replaced by options.time.parser.');
						}

						return Chart.Scale.prototype.update.apply(me, arguments);
					},

					/**
      * Allows data to be referenced via 't' attribute
      */
					getRightValue: function getRightValue(rawValue) {
						if (rawValue && rawValue.t !== undefined) {
							rawValue = rawValue.t;
						}
						return Chart.Scale.prototype.getRightValue.call(this, rawValue);
					},

					determineDataLimits: function determineDataLimits() {
						var me = this;
						var chart = me.chart;
						var timeOpts = me.options.time;
						var min = parse(timeOpts.min, me) || MAX_INTEGER;
						var max = parse(timeOpts.max, me) || MIN_INTEGER;
						var timestamps = [];
						var datasets = [];
						var labels = [];
						var i, j, ilen, jlen, data, timestamp;

						// Convert labels to timestamps
						for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
							labels.push(parse(chart.data.labels[i], me));
						}

						// Convert data to timestamps
						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							if (chart.isDatasetVisible(i)) {
								data = chart.data.datasets[i].data;

								// Let's consider that all data have the same format.
								if (helpers.isObject(data[0])) {
									datasets[i] = [];

									for (j = 0, jlen = data.length; j < jlen; ++j) {
										timestamp = parse(data[j], me);
										timestamps.push(timestamp);
										datasets[i][j] = timestamp;
									}
								} else {
									timestamps.push.apply(timestamps, labels);
									datasets[i] = labels.slice(0);
								}
							} else {
								datasets[i] = [];
							}
						}

						if (labels.length) {
							// Sort labels **after** data have been converted
							labels = arrayUnique(labels).sort(sorter);
							min = Math.min(min, labels[0]);
							max = Math.max(max, labels[labels.length - 1]);
						}

						if (timestamps.length) {
							timestamps = arrayUnique(timestamps).sort(sorter);
							min = Math.min(min, timestamps[0]);
							max = Math.max(max, timestamps[timestamps.length - 1]);
						}

						// In case there is no valid min/max, let's use today limits
						min = min === MAX_INTEGER ? +moment().startOf('day') : min;
						max = max === MIN_INTEGER ? +moment().endOf('day') + 1 : max;

						// Make sure that max is strictly higher than min (required by the lookup table)
						me.min = Math.min(min, max);
						me.max = Math.max(min + 1, max);

						// PRIVATE
						me._horizontal = me.isHorizontal();
						me._table = [];
						me._timestamps = {
							data: timestamps,
							datasets: datasets,
							labels: labels
						};
					},

					buildTicks: function buildTicks() {
						var me = this;
						var min = me.min;
						var max = me.max;
						var options = me.options;
						var timeOpts = options.time;
						var formats = timeOpts.displayFormats;
						var capacity = me.getLabelCapacity(min);
						var unit = timeOpts.unit || determineUnit(timeOpts.minUnit, min, max, capacity);
						var majorUnit = determineMajorUnit(unit);
						var timestamps = [];
						var ticks = [];
						var i, ilen, timestamp;

						switch (options.ticks.source) {
							case 'data':
								timestamps = me._timestamps.data;
								break;
							case 'labels':
								timestamps = me._timestamps.labels;
								break;
							case 'auto':
							default:
								timestamps = generate(min, max, unit, majorUnit, capacity, options);
						}

						if (options.bounds === 'ticks' && timestamps.length) {
							min = timestamps[0];
							max = timestamps[timestamps.length - 1];
						}

						// Enforce limits with user min/max options
						min = parse(timeOpts.min, me) || min;
						max = parse(timeOpts.max, me) || max;

						// Remove ticks outside the min/max range
						for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
							timestamp = timestamps[i];
							if (timestamp >= min && timestamp <= max) {
								ticks.push(timestamp);
							}
						}

						me.min = min;
						me.max = max;

						// PRIVATE
						me._unit = unit;
						me._majorUnit = majorUnit;
						me._minorFormat = formats[unit];
						me._majorFormat = formats[majorUnit];
						me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
						me._offsets = computeOffsets(me._table, ticks, min, max, options);

						return ticksFromTimestamps(ticks, majorUnit);
					},

					getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
						var me = this;
						var data = me.chart.data;
						var timeOpts = me.options.time;
						var label = data.labels && index < data.labels.length ? data.labels[index] : '';
						var value = data.datasets[datasetIndex].data[index];

						if (helpers.isObject(value)) {
							label = me.getRightValue(value);
						}
						if (timeOpts.tooltipFormat) {
							label = momentify(label, timeOpts).format(timeOpts.tooltipFormat);
						}

						return label;
					},

					/**
      * Function to format an individual tick mark
      * @private
      */
					tickFormatFunction: function tickFormatFunction(tick, index, ticks) {
						var me = this;
						var options = me.options;
						var time = tick.valueOf();
						var majorUnit = me._majorUnit;
						var majorFormat = me._majorFormat;
						var majorTime = tick.clone().startOf(me._majorUnit).valueOf();
						var majorTickOpts = options.ticks.major;
						var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
						var label = tick.format(major ? majorFormat : me._minorFormat);
						var tickOpts = major ? majorTickOpts : options.ticks.minor;
						var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

						return formatter ? formatter(label, index, ticks) : label;
					},

					convertTicksToLabels: function convertTicksToLabels(ticks) {
						var labels = [];
						var i, ilen;

						for (i = 0, ilen = ticks.length; i < ilen; ++i) {
							labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
						}

						return labels;
					},

					/**
      * @private
      */
					getPixelForOffset: function getPixelForOffset(time) {
						var me = this;
						var size = me._horizontal ? me.width : me.height;
						var start = me._horizontal ? me.left : me.top;
						var pos = interpolate(me._table, 'time', time, 'pos');

						return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
					},

					getPixelForValue: function getPixelForValue(value, index, datasetIndex) {
						var me = this;
						var time = null;

						if (index !== undefined && datasetIndex !== undefined) {
							time = me._timestamps.datasets[datasetIndex][index];
						}

						if (time === null) {
							time = parse(value, me);
						}

						if (time !== null) {
							return me.getPixelForOffset(time);
						}
					},

					getPixelForTick: function getPixelForTick(index) {
						var ticks = this.getTicks();
						return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
					},

					getValueForPixel: function getValueForPixel(pixel) {
						var me = this;
						var size = me._horizontal ? me.width : me.height;
						var start = me._horizontal ? me.left : me.top;
						var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
						var time = interpolate(me._table, 'pos', pos, 'time');

						return moment(time);
					},

					/**
      * Crude approximation of what the label width might be
      * @private
      */
					getLabelWidth: function getLabelWidth(label) {
						var me = this;
						var ticksOpts = me.options.ticks;
						var tickLabelWidth = me.ctx.measureText(label).width;
						var angle = helpers.toRadians(ticksOpts.maxRotation);
						var cosRotation = Math.cos(angle);
						var sinRotation = Math.sin(angle);
						var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

						return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
					},

					/**
      * @private
      */
					getLabelCapacity: function getLabelCapacity(exampleTime) {
						var me = this;

						me._minorFormat = me.options.time.displayFormats.millisecond; // Pick the longest format for guestimation

						var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);
						var tickLabelWidth = me.getLabelWidth(exampleLabel);
						var innerWidth = me.isHorizontal() ? me.width : me.height;

						return Math.floor(innerWidth / tickLabelWidth);
					}
				});

				Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
			};
		}, { "1": 1, "25": 25, "45": 45 }] }, {}, [7])(7);
});

/***/ }),

/***/ 71:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
Turbolinks 5.1.1
Copyright © 2018 Basecamp, LLC
 */
(function(){var t=this;(function(){(function(){this.Turbolinks={supported:function(){return null!=window.history.pushState&&null!=window.requestAnimationFrame&&null!=window.addEventListener}(),visit:function(t,r){return e.controller.visit(t,r)},clearCache:function(){return e.controller.clearCache()},setProgressBarDelay:function(t){return e.controller.setProgressBarDelay(t)}}}).call(this)}).call(t);var e=t.Turbolinks;(function(){(function(){var t,r,n,o=[].slice;e.copyObject=function(t){var e,r,n;r={};for(e in t)n=t[e],r[e]=n;return r},e.closest=function(e,r){return t.call(e,r)},t=function(){var t,e;return t=document.documentElement,null!=(e=t.closest)?e:function(t){var e;for(e=this;e;){if(e.nodeType===Node.ELEMENT_NODE&&r.call(e,t))return e;e=e.parentNode}}}(),e.defer=function(t){return setTimeout(t,1)},e.throttle=function(t){var e;return e=null,function(){var r;return r=1<=arguments.length?o.call(arguments,0):[],null!=e?e:e=requestAnimationFrame(function(n){return function(){return e=null,t.apply(n,r)}}(this))}},e.dispatch=function(t,e){var r,o,i,s,a,u;return a=null!=e?e:{},u=a.target,r=a.cancelable,o=a.data,i=document.createEvent("Events"),i.initEvent(t,!0,r===!0),i.data=null!=o?o:{},i.cancelable&&!n&&(s=i.preventDefault,i.preventDefault=function(){return this.defaultPrevented||Object.defineProperty(this,"defaultPrevented",{get:function(){return!0}}),s.call(this)}),(null!=u?u:document).dispatchEvent(i),i},n=function(){var t;return t=document.createEvent("Events"),t.initEvent("test",!0,!0),t.preventDefault(),t.defaultPrevented}(),e.match=function(t,e){return r.call(t,e)},r=function(){var t,e,r,n;return t=document.documentElement,null!=(e=null!=(r=null!=(n=t.matchesSelector)?n:t.webkitMatchesSelector)?r:t.msMatchesSelector)?e:t.mozMatchesSelector}(),e.uuid=function(){var t,e,r;for(r="",t=e=1;36>=e;t=++e)r+=9===t||14===t||19===t||24===t?"-":15===t?"4":20===t?(Math.floor(4*Math.random())+8).toString(16):Math.floor(15*Math.random()).toString(16);return r}}).call(this),function(){e.Location=function(){function t(t){var e,r;null==t&&(t=""),r=document.createElement("a"),r.href=t.toString(),this.absoluteURL=r.href,e=r.hash.length,2>e?this.requestURL=this.absoluteURL:(this.requestURL=this.absoluteURL.slice(0,-e),this.anchor=r.hash.slice(1))}var e,r,n,o;return t.wrap=function(t){return t instanceof this?t:new this(t)},t.prototype.getOrigin=function(){return this.absoluteURL.split("/",3).join("/")},t.prototype.getPath=function(){var t,e;return null!=(t=null!=(e=this.requestURL.match(/\/\/[^\/]*(\/[^?;]*)/))?e[1]:void 0)?t:"/"},t.prototype.getPathComponents=function(){return this.getPath().split("/").slice(1)},t.prototype.getLastPathComponent=function(){return this.getPathComponents().slice(-1)[0]},t.prototype.getExtension=function(){var t,e;return null!=(t=null!=(e=this.getLastPathComponent().match(/\.[^.]*$/))?e[0]:void 0)?t:""},t.prototype.isHTML=function(){return this.getExtension().match(/^(?:|\.(?:htm|html|xhtml))$/)},t.prototype.isPrefixedBy=function(t){var e;return e=r(t),this.isEqualTo(t)||o(this.absoluteURL,e)},t.prototype.isEqualTo=function(t){return this.absoluteURL===(null!=t?t.absoluteURL:void 0)},t.prototype.toCacheKey=function(){return this.requestURL},t.prototype.toJSON=function(){return this.absoluteURL},t.prototype.toString=function(){return this.absoluteURL},t.prototype.valueOf=function(){return this.absoluteURL},r=function(t){return e(t.getOrigin()+t.getPath())},e=function(t){return n(t,"/")?t:t+"/"},o=function(t,e){return t.slice(0,e.length)===e},n=function(t,e){return t.slice(-e.length)===e},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.HttpRequest=function(){function r(r,n,o){this.delegate=r,this.requestCanceled=t(this.requestCanceled,this),this.requestTimedOut=t(this.requestTimedOut,this),this.requestFailed=t(this.requestFailed,this),this.requestLoaded=t(this.requestLoaded,this),this.requestProgressed=t(this.requestProgressed,this),this.url=e.Location.wrap(n).requestURL,this.referrer=e.Location.wrap(o).absoluteURL,this.createXHR()}return r.NETWORK_FAILURE=0,r.TIMEOUT_FAILURE=-1,r.timeout=60,r.prototype.send=function(){var t;return this.xhr&&!this.sent?(this.notifyApplicationBeforeRequestStart(),this.setProgress(0),this.xhr.send(),this.sent=!0,"function"==typeof(t=this.delegate).requestStarted?t.requestStarted():void 0):void 0},r.prototype.cancel=function(){return this.xhr&&this.sent?this.xhr.abort():void 0},r.prototype.requestProgressed=function(t){return t.lengthComputable?this.setProgress(t.loaded/t.total):void 0},r.prototype.requestLoaded=function(){return this.endRequest(function(t){return function(){var e;return 200<=(e=t.xhr.status)&&300>e?t.delegate.requestCompletedWithResponse(t.xhr.responseText,t.xhr.getResponseHeader("Turbolinks-Location")):(t.failed=!0,t.delegate.requestFailedWithStatusCode(t.xhr.status,t.xhr.responseText))}}(this))},r.prototype.requestFailed=function(){return this.endRequest(function(t){return function(){return t.failed=!0,t.delegate.requestFailedWithStatusCode(t.constructor.NETWORK_FAILURE)}}(this))},r.prototype.requestTimedOut=function(){return this.endRequest(function(t){return function(){return t.failed=!0,t.delegate.requestFailedWithStatusCode(t.constructor.TIMEOUT_FAILURE)}}(this))},r.prototype.requestCanceled=function(){return this.endRequest()},r.prototype.notifyApplicationBeforeRequestStart=function(){return e.dispatch("turbolinks:request-start",{data:{url:this.url,xhr:this.xhr}})},r.prototype.notifyApplicationAfterRequestEnd=function(){return e.dispatch("turbolinks:request-end",{data:{url:this.url,xhr:this.xhr}})},r.prototype.createXHR=function(){return this.xhr=new XMLHttpRequest,this.xhr.open("GET",this.url,!0),this.xhr.timeout=1e3*this.constructor.timeout,this.xhr.setRequestHeader("Accept","text/html, application/xhtml+xml"),this.xhr.setRequestHeader("Turbolinks-Referrer",this.referrer),this.xhr.onprogress=this.requestProgressed,this.xhr.onload=this.requestLoaded,this.xhr.onerror=this.requestFailed,this.xhr.ontimeout=this.requestTimedOut,this.xhr.onabort=this.requestCanceled},r.prototype.endRequest=function(t){return this.xhr?(this.notifyApplicationAfterRequestEnd(),null!=t&&t.call(this),this.destroy()):void 0},r.prototype.setProgress=function(t){var e;return this.progress=t,"function"==typeof(e=this.delegate).requestProgressed?e.requestProgressed(this.progress):void 0},r.prototype.destroy=function(){var t;return this.setProgress(1),"function"==typeof(t=this.delegate).requestFinished&&t.requestFinished(),this.delegate=null,this.xhr=null},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.ProgressBar=function(){function e(){this.trickle=t(this.trickle,this),this.stylesheetElement=this.createStylesheetElement(),this.progressElement=this.createProgressElement()}var r;return r=300,e.defaultCSS=".turbolinks-progress-bar {\n  position: fixed;\n  display: block;\n  top: 0;\n  left: 0;\n  height: 3px;\n  background: #0076ff;\n  z-index: 9999;\n  transition: width "+r+"ms ease-out, opacity "+r/2+"ms "+r/2+"ms ease-in;\n  transform: translate3d(0, 0, 0);\n}",e.prototype.show=function(){return this.visible?void 0:(this.visible=!0,this.installStylesheetElement(),this.installProgressElement(),this.startTrickling())},e.prototype.hide=function(){return this.visible&&!this.hiding?(this.hiding=!0,this.fadeProgressElement(function(t){return function(){return t.uninstallProgressElement(),t.stopTrickling(),t.visible=!1,t.hiding=!1}}(this))):void 0},e.prototype.setValue=function(t){return this.value=t,this.refresh()},e.prototype.installStylesheetElement=function(){return document.head.insertBefore(this.stylesheetElement,document.head.firstChild)},e.prototype.installProgressElement=function(){return this.progressElement.style.width=0,this.progressElement.style.opacity=1,document.documentElement.insertBefore(this.progressElement,document.body),this.refresh()},e.prototype.fadeProgressElement=function(t){return this.progressElement.style.opacity=0,setTimeout(t,1.5*r)},e.prototype.uninstallProgressElement=function(){return this.progressElement.parentNode?document.documentElement.removeChild(this.progressElement):void 0},e.prototype.startTrickling=function(){return null!=this.trickleInterval?this.trickleInterval:this.trickleInterval=setInterval(this.trickle,r)},e.prototype.stopTrickling=function(){return clearInterval(this.trickleInterval),this.trickleInterval=null},e.prototype.trickle=function(){return this.setValue(this.value+Math.random()/100)},e.prototype.refresh=function(){return requestAnimationFrame(function(t){return function(){return t.progressElement.style.width=10+90*t.value+"%"}}(this))},e.prototype.createStylesheetElement=function(){var t;return t=document.createElement("style"),t.type="text/css",t.textContent=this.constructor.defaultCSS,t},e.prototype.createProgressElement=function(){var t;return t=document.createElement("div"),t.className="turbolinks-progress-bar",t},e}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.BrowserAdapter=function(){function r(r){this.controller=r,this.showProgressBar=t(this.showProgressBar,this),this.progressBar=new e.ProgressBar}var n,o,i;return i=e.HttpRequest,n=i.NETWORK_FAILURE,o=i.TIMEOUT_FAILURE,r.prototype.visitProposedToLocationWithAction=function(t,e){return this.controller.startVisitToLocationWithAction(t,e)},r.prototype.visitStarted=function(t){return t.issueRequest(),t.changeHistory(),t.loadCachedSnapshot()},r.prototype.visitRequestStarted=function(t){return this.progressBar.setValue(0),t.hasCachedSnapshot()||"restore"!==t.action?this.showProgressBarAfterDelay():this.showProgressBar()},r.prototype.visitRequestProgressed=function(t){return this.progressBar.setValue(t.progress)},r.prototype.visitRequestCompleted=function(t){return t.loadResponse()},r.prototype.visitRequestFailedWithStatusCode=function(t,e){switch(e){case n:case o:return this.reload();default:return t.loadResponse()}},r.prototype.visitRequestFinished=function(t){return this.hideProgressBar()},r.prototype.visitCompleted=function(t){return t.followRedirect()},r.prototype.pageInvalidated=function(){return this.reload()},r.prototype.showProgressBarAfterDelay=function(){return this.progressBarTimeout=setTimeout(this.showProgressBar,this.controller.progressBarDelay)},r.prototype.showProgressBar=function(){return this.progressBar.show()},r.prototype.hideProgressBar=function(){return this.progressBar.hide(),clearTimeout(this.progressBarTimeout)},r.prototype.reload=function(){return window.location.reload()},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.History=function(){function r(e){this.delegate=e,this.onPageLoad=t(this.onPageLoad,this),this.onPopState=t(this.onPopState,this)}return r.prototype.start=function(){return this.started?void 0:(addEventListener("popstate",this.onPopState,!1),addEventListener("load",this.onPageLoad,!1),this.started=!0)},r.prototype.stop=function(){return this.started?(removeEventListener("popstate",this.onPopState,!1),removeEventListener("load",this.onPageLoad,!1),this.started=!1):void 0},r.prototype.push=function(t,r){return t=e.Location.wrap(t),this.update("push",t,r)},r.prototype.replace=function(t,r){return t=e.Location.wrap(t),this.update("replace",t,r)},r.prototype.onPopState=function(t){var r,n,o,i;return this.shouldHandlePopState()&&(i=null!=(n=t.state)?n.turbolinks:void 0)?(r=e.Location.wrap(window.location),o=i.restorationIdentifier,this.delegate.historyPoppedToLocationWithRestorationIdentifier(r,o)):void 0},r.prototype.onPageLoad=function(t){return e.defer(function(t){return function(){return t.pageLoaded=!0}}(this))},r.prototype.shouldHandlePopState=function(){return this.pageIsLoaded()},r.prototype.pageIsLoaded=function(){return this.pageLoaded||"complete"===document.readyState},r.prototype.update=function(t,e,r){var n;return n={turbolinks:{restorationIdentifier:r}},history[t+"State"](n,null,e)},r}()}.call(this),function(){e.Snapshot=function(){function t(t){var e,r;r=t.head,e=t.body,this.head=null!=r?r:document.createElement("head"),this.body=null!=e?e:document.createElement("body")}return t.wrap=function(t){return t instanceof this?t:this.fromHTML(t)},t.fromHTML=function(t){var e;return e=document.createElement("html"),e.innerHTML=t,this.fromElement(e)},t.fromElement=function(t){return new this({head:t.querySelector("head"),body:t.querySelector("body")})},t.prototype.clone=function(){return new t({head:this.head.cloneNode(!0),body:this.body.cloneNode(!0)})},t.prototype.getRootLocation=function(){var t,r;return r=null!=(t=this.getSetting("root"))?t:"/",new e.Location(r)},t.prototype.getCacheControlValue=function(){return this.getSetting("cache-control")},t.prototype.getElementForAnchor=function(t){try{return this.body.querySelector("[id='"+t+"'], a[name='"+t+"']")}catch(e){}},t.prototype.hasAnchor=function(t){return null!=this.getElementForAnchor(t)},t.prototype.isPreviewable=function(){return"no-preview"!==this.getCacheControlValue()},t.prototype.isCacheable=function(){return"no-cache"!==this.getCacheControlValue()},t.prototype.isVisitable=function(){return"reload"!==this.getSetting("visit-control")},t.prototype.getSetting=function(t){var e,r;return r=this.head.querySelectorAll("meta[name='turbolinks-"+t+"']"),e=r[r.length-1],null!=e?e.getAttribute("content"):void 0},t}()}.call(this),function(){var t=[].slice;e.Renderer=function(){function e(){}var r;return e.render=function(){var e,r,n,o;return n=arguments[0],r=arguments[1],e=3<=arguments.length?t.call(arguments,2):[],o=function(t,e,r){r.prototype=t.prototype;var n=new r,o=t.apply(n,e);return Object(o)===o?o:n}(this,e,function(){}),o.delegate=n,o.render(r),o},e.prototype.renderView=function(t){return this.delegate.viewWillRender(this.newBody),t(),this.delegate.viewRendered(this.newBody)},e.prototype.invalidateView=function(){return this.delegate.viewInvalidated()},e.prototype.createScriptElement=function(t){var e;return"false"===t.getAttribute("data-turbolinks-eval")?t:(e=document.createElement("script"),e.textContent=t.textContent,e.async=!1,r(e,t),e)},r=function(t,e){var r,n,o,i,s,a,u;for(i=e.attributes,a=[],r=0,n=i.length;n>r;r++)s=i[r],o=s.name,u=s.value,a.push(t.setAttribute(o,u));return a},e}()}.call(this),function(){e.HeadDetails=function(){function t(t){var e,r,i,s,a,u,l;for(this.element=t,this.elements={},l=this.element.childNodes,s=0,u=l.length;u>s;s++)i=l[s],i.nodeType===Node.ELEMENT_NODE&&(a=i.outerHTML,r=null!=(e=this.elements)[a]?e[a]:e[a]={type:o(i),tracked:n(i),elements:[]},r.elements.push(i))}var e,r,n,o;return t.prototype.hasElementWithKey=function(t){return t in this.elements},t.prototype.getTrackedElementSignature=function(){var t,e;return function(){var r,n;r=this.elements,n=[];for(t in r)e=r[t].tracked,e&&n.push(t);return n}.call(this).join("")},t.prototype.getScriptElementsNotInDetails=function(t){return this.getElementsMatchingTypeNotInDetails("script",t)},t.prototype.getStylesheetElementsNotInDetails=function(t){return this.getElementsMatchingTypeNotInDetails("stylesheet",t)},t.prototype.getElementsMatchingTypeNotInDetails=function(t,e){var r,n,o,i,s,a;o=this.elements,s=[];for(n in o)i=o[n],a=i.type,r=i.elements,a!==t||e.hasElementWithKey(n)||s.push(r[0]);return s},t.prototype.getProvisionalElements=function(){var t,e,r,n,o,i,s;r=[],n=this.elements;for(e in n)o=n[e],s=o.type,i=o.tracked,t=o.elements,null!=s||i?t.length>1&&r.push.apply(r,t.slice(1)):r.push.apply(r,t);return r},o=function(t){return e(t)?"script":r(t)?"stylesheet":void 0},n=function(t){return"reload"===t.getAttribute("data-turbolinks-track")},e=function(t){var e;return e=t.tagName.toLowerCase(),"script"===e},r=function(t){var e;return e=t.tagName.toLowerCase(),"style"===e||"link"===e&&"stylesheet"===t.getAttribute("rel")},t}()}.call(this),function(){var t=function(t,e){function n(){this.constructor=t}for(var o in e)r.call(e,o)&&(t[o]=e[o]);return n.prototype=e.prototype,t.prototype=new n,t.__super__=e.prototype,t},r={}.hasOwnProperty;e.SnapshotRenderer=function(r){function n(t,r,n){this.currentSnapshot=t,this.newSnapshot=r,this.isPreview=n,this.currentHeadDetails=new e.HeadDetails(this.currentSnapshot.head),this.newHeadDetails=new e.HeadDetails(this.newSnapshot.head),this.newBody=this.newSnapshot.body}return t(n,r),n.prototype.render=function(t){return this.shouldRender()?(this.mergeHead(),this.renderView(function(e){return function(){return e.replaceBody(),e.isPreview||e.focusFirstAutofocusableElement(),t()}}(this))):this.invalidateView()},n.prototype.mergeHead=function(){return this.copyNewHeadStylesheetElements(),this.copyNewHeadScriptElements(),this.removeCurrentHeadProvisionalElements(),this.copyNewHeadProvisionalElements()},n.prototype.replaceBody=function(){return this.activateBodyScriptElements(),this.importBodyPermanentElements(),this.assignNewBody()},n.prototype.shouldRender=function(){return this.newSnapshot.isVisitable()&&this.trackedElementsAreIdentical()},n.prototype.trackedElementsAreIdentical=function(){return this.currentHeadDetails.getTrackedElementSignature()===this.newHeadDetails.getTrackedElementSignature()},n.prototype.copyNewHeadStylesheetElements=function(){var t,e,r,n,o;for(n=this.getNewHeadStylesheetElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(t));return o},n.prototype.copyNewHeadScriptElements=function(){var t,e,r,n,o;for(n=this.getNewHeadScriptElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(this.createScriptElement(t)));return o},n.prototype.removeCurrentHeadProvisionalElements=function(){var t,e,r,n,o;for(n=this.getCurrentHeadProvisionalElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.removeChild(t));return o},n.prototype.copyNewHeadProvisionalElements=function(){var t,e,r,n,o;for(n=this.getNewHeadProvisionalElements(),o=[],e=0,r=n.length;r>e;e++)t=n[e],o.push(document.head.appendChild(t));return o},n.prototype.importBodyPermanentElements=function(){var t,e,r,n,o,i;for(n=this.getNewBodyPermanentElements(),i=[],e=0,r=n.length;r>e;e++)o=n[e],(t=this.findCurrentBodyPermanentElement(o))?i.push(o.parentNode.replaceChild(t,o)):i.push(void 0);return i},n.prototype.activateBodyScriptElements=function(){var t,e,r,n,o,i;for(n=this.getNewBodyScriptElements(),i=[],e=0,r=n.length;r>e;e++)o=n[e],t=this.createScriptElement(o),i.push(o.parentNode.replaceChild(t,o));return i},n.prototype.assignNewBody=function(){return document.body=this.newBody},n.prototype.focusFirstAutofocusableElement=function(){var t;return null!=(t=this.findFirstAutofocusableElement())?t.focus():void 0},n.prototype.getNewHeadStylesheetElements=function(){return this.newHeadDetails.getStylesheetElementsNotInDetails(this.currentHeadDetails)},n.prototype.getNewHeadScriptElements=function(){return this.newHeadDetails.getScriptElementsNotInDetails(this.currentHeadDetails)},n.prototype.getCurrentHeadProvisionalElements=function(){return this.currentHeadDetails.getProvisionalElements()},n.prototype.getNewHeadProvisionalElements=function(){return this.newHeadDetails.getProvisionalElements()},n.prototype.getNewBodyPermanentElements=function(){return this.newBody.querySelectorAll("[id][data-turbolinks-permanent]")},n.prototype.findCurrentBodyPermanentElement=function(t){return document.body.querySelector("#"+t.id+"[data-turbolinks-permanent]")},n.prototype.getNewBodyScriptElements=function(){return this.newBody.querySelectorAll("script")},n.prototype.findFirstAutofocusableElement=function(){return document.body.querySelector("[autofocus]")},n}(e.Renderer)}.call(this),function(){var t=function(t,e){function n(){this.constructor=t}for(var o in e)r.call(e,o)&&(t[o]=e[o]);return n.prototype=e.prototype,t.prototype=new n,t.__super__=e.prototype,t},r={}.hasOwnProperty;e.ErrorRenderer=function(e){function r(t){this.html=t}return t(r,e),r.prototype.render=function(t){return this.renderView(function(e){return function(){return e.replaceDocumentHTML(),e.activateBodyScriptElements(),t()}}(this))},r.prototype.replaceDocumentHTML=function(){return document.documentElement.innerHTML=this.html},r.prototype.activateBodyScriptElements=function(){var t,e,r,n,o,i;for(n=this.getScriptElements(),i=[],e=0,r=n.length;r>e;e++)o=n[e],t=this.createScriptElement(o),i.push(o.parentNode.replaceChild(t,o));return i},r.prototype.getScriptElements=function(){return document.documentElement.querySelectorAll("script")},r}(e.Renderer)}.call(this),function(){e.View=function(){function t(t){this.delegate=t,this.element=document.documentElement}return t.prototype.getRootLocation=function(){return this.getSnapshot().getRootLocation()},t.prototype.getElementForAnchor=function(t){return this.getSnapshot().getElementForAnchor(t)},t.prototype.getSnapshot=function(){return e.Snapshot.fromElement(this.element)},t.prototype.render=function(t,e){var r,n,o;return o=t.snapshot,r=t.error,n=t.isPreview,this.markAsPreview(n),null!=o?this.renderSnapshot(o,n,e):this.renderError(r,e)},t.prototype.markAsPreview=function(t){return t?this.element.setAttribute("data-turbolinks-preview",""):this.element.removeAttribute("data-turbolinks-preview")},t.prototype.renderSnapshot=function(t,r,n){return e.SnapshotRenderer.render(this.delegate,n,this.getSnapshot(),e.Snapshot.wrap(t),r)},t.prototype.renderError=function(t,r){return e.ErrorRenderer.render(this.delegate,r,t)},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.ScrollManager=function(){function r(r){this.delegate=r,this.onScroll=t(this.onScroll,this),this.onScroll=e.throttle(this.onScroll)}return r.prototype.start=function(){return this.started?void 0:(addEventListener("scroll",this.onScroll,!1),this.onScroll(),this.started=!0)},r.prototype.stop=function(){return this.started?(removeEventListener("scroll",this.onScroll,!1),this.started=!1):void 0},r.prototype.scrollToElement=function(t){return t.scrollIntoView()},r.prototype.scrollToPosition=function(t){var e,r;return e=t.x,r=t.y,window.scrollTo(e,r)},r.prototype.onScroll=function(t){return this.updatePosition({x:window.pageXOffset,y:window.pageYOffset})},r.prototype.updatePosition=function(t){var e;return this.position=t,null!=(e=this.delegate)?e.scrollPositionChanged(this.position):void 0},r}()}.call(this),function(){e.SnapshotCache=function(){function t(t){this.size=t,this.keys=[],this.snapshots={}}var r;return t.prototype.has=function(t){var e;return e=r(t),e in this.snapshots},t.prototype.get=function(t){var e;if(this.has(t))return e=this.read(t),this.touch(t),e},t.prototype.put=function(t,e){return this.write(t,e),this.touch(t),e},t.prototype.read=function(t){var e;return e=r(t),this.snapshots[e]},t.prototype.write=function(t,e){var n;return n=r(t),this.snapshots[n]=e},t.prototype.touch=function(t){var e,n;return n=r(t),e=this.keys.indexOf(n),e>-1&&this.keys.splice(e,1),this.keys.unshift(n),this.trim()},t.prototype.trim=function(){var t,e,r,n,o;for(n=this.keys.splice(this.size),o=[],t=0,r=n.length;r>t;t++)e=n[t],o.push(delete this.snapshots[e]);return o},r=function(t){return e.Location.wrap(t).toCacheKey()},t}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.Visit=function(){function r(r,n,o){this.controller=r,this.action=o,this.performScroll=t(this.performScroll,this),this.identifier=e.uuid(),this.location=e.Location.wrap(n),this.adapter=this.controller.adapter,this.state="initialized",this.timingMetrics={}}var n;return r.prototype.start=function(){return"initialized"===this.state?(this.recordTimingMetric("visitStart"),this.state="started",this.adapter.visitStarted(this)):void 0},r.prototype.cancel=function(){var t;return"started"===this.state?(null!=(t=this.request)&&t.cancel(),this.cancelRender(),this.state="canceled"):void 0},r.prototype.complete=function(){var t;return"started"===this.state?(this.recordTimingMetric("visitEnd"),this.state="completed","function"==typeof(t=this.adapter).visitCompleted&&t.visitCompleted(this),this.controller.visitCompleted(this)):void 0},r.prototype.fail=function(){var t;return"started"===this.state?(this.state="failed","function"==typeof(t=this.adapter).visitFailed?t.visitFailed(this):void 0):void 0},r.prototype.changeHistory=function(){var t,e;return this.historyChanged?void 0:(t=this.location.isEqualTo(this.referrer)?"replace":this.action,e=n(t),this.controller[e](this.location,this.restorationIdentifier),this.historyChanged=!0)},r.prototype.issueRequest=function(){return this.shouldIssueRequest()&&null==this.request?(this.progress=0,this.request=new e.HttpRequest(this,this.location,this.referrer),this.request.send()):void 0},r.prototype.getCachedSnapshot=function(){var t;return!(t=this.controller.getCachedSnapshotForLocation(this.location))||null!=this.location.anchor&&!t.hasAnchor(this.location.anchor)||"restore"!==this.action&&!t.isPreviewable()?void 0:t},r.prototype.hasCachedSnapshot=function(){return null!=this.getCachedSnapshot()},r.prototype.loadCachedSnapshot=function(){var t,e;return(e=this.getCachedSnapshot())?(t=this.shouldIssueRequest(),this.render(function(){var r;return this.cacheSnapshot(),this.controller.render({snapshot:e,isPreview:t},this.performScroll),"function"==typeof(r=this.adapter).visitRendered&&r.visitRendered(this),t?void 0:this.complete()})):void 0},r.prototype.loadResponse=function(){return null!=this.response?this.render(function(){var t,e;return this.cacheSnapshot(),this.request.failed?(this.controller.render({error:this.response},this.performScroll),"function"==typeof(t=this.adapter).visitRendered&&t.visitRendered(this),this.fail()):(this.controller.render({snapshot:this.response},this.performScroll),"function"==typeof(e=this.adapter).visitRendered&&e.visitRendered(this),this.complete())}):void 0},r.prototype.followRedirect=function(){return this.redirectedToLocation&&!this.followedRedirect?(this.location=this.redirectedToLocation,this.controller.replaceHistoryWithLocationAndRestorationIdentifier(this.redirectedToLocation,this.restorationIdentifier),this.followedRedirect=!0):void 0},r.prototype.requestStarted=function(){var t;return this.recordTimingMetric("requestStart"),"function"==typeof(t=this.adapter).visitRequestStarted?t.visitRequestStarted(this):void 0},r.prototype.requestProgressed=function(t){var e;return this.progress=t,"function"==typeof(e=this.adapter).visitRequestProgressed?e.visitRequestProgressed(this):void 0},r.prototype.requestCompletedWithResponse=function(t,r){return this.response=t,null!=r&&(this.redirectedToLocation=e.Location.wrap(r)),this.adapter.visitRequestCompleted(this)},r.prototype.requestFailedWithStatusCode=function(t,e){return this.response=e,this.adapter.visitRequestFailedWithStatusCode(this,t)},r.prototype.requestFinished=function(){var t;return this.recordTimingMetric("requestEnd"),"function"==typeof(t=this.adapter).visitRequestFinished?t.visitRequestFinished(this):void 0},r.prototype.performScroll=function(){return this.scrolled?void 0:("restore"===this.action?this.scrollToRestoredPosition()||this.scrollToTop():this.scrollToAnchor()||this.scrollToTop(),this.scrolled=!0)},r.prototype.scrollToRestoredPosition=function(){var t,e;return t=null!=(e=this.restorationData)?e.scrollPosition:void 0,null!=t?(this.controller.scrollToPosition(t),!0):void 0},r.prototype.scrollToAnchor=function(){return null!=this.location.anchor?(this.controller.scrollToAnchor(this.location.anchor),!0):void 0},r.prototype.scrollToTop=function(){return this.controller.scrollToPosition({x:0,y:0})},r.prototype.recordTimingMetric=function(t){var e;return null!=(e=this.timingMetrics)[t]?e[t]:e[t]=(new Date).getTime()},r.prototype.getTimingMetrics=function(){return e.copyObject(this.timingMetrics)},n=function(t){switch(t){case"replace":return"replaceHistoryWithLocationAndRestorationIdentifier";case"advance":case"restore":return"pushHistoryWithLocationAndRestorationIdentifier"}},r.prototype.shouldIssueRequest=function(){return"restore"===this.action?!this.hasCachedSnapshot():!0},r.prototype.cacheSnapshot=function(){return this.snapshotCached?void 0:(this.controller.cacheSnapshot(),this.snapshotCached=!0)},r.prototype.render=function(t){return this.cancelRender(),this.frame=requestAnimationFrame(function(e){return function(){return e.frame=null,t.call(e)}}(this))},r.prototype.cancelRender=function(){return this.frame?cancelAnimationFrame(this.frame):void 0},r}()}.call(this),function(){var t=function(t,e){return function(){return t.apply(e,arguments)}};e.Controller=function(){function r(){this.clickBubbled=t(this.clickBubbled,this),this.clickCaptured=t(this.clickCaptured,this),this.pageLoaded=t(this.pageLoaded,this),this.history=new e.History(this),this.view=new e.View(this),this.scrollManager=new e.ScrollManager(this),this.restorationData={},this.clearCache(),this.setProgressBarDelay(500)}return r.prototype.start=function(){return e.supported&&!this.started?(addEventListener("click",this.clickCaptured,!0),addEventListener("DOMContentLoaded",this.pageLoaded,!1),this.scrollManager.start(),this.startHistory(),this.started=!0,this.enabled=!0):void 0},r.prototype.disable=function(){return this.enabled=!1},r.prototype.stop=function(){return this.started?(removeEventListener("click",this.clickCaptured,!0),removeEventListener("DOMContentLoaded",this.pageLoaded,!1),this.scrollManager.stop(),this.stopHistory(),this.started=!1):void 0},r.prototype.clearCache=function(){return this.cache=new e.SnapshotCache(10)},r.prototype.visit=function(t,r){var n,o;return null==r&&(r={}),t=e.Location.wrap(t),this.applicationAllowsVisitingLocation(t)?this.locationIsVisitable(t)?(n=null!=(o=r.action)?o:"advance",this.adapter.visitProposedToLocationWithAction(t,n)):window.location=t:void 0},r.prototype.startVisitToLocationWithAction=function(t,r,n){var o;return e.supported?(o=this.getRestorationDataForIdentifier(n),this.startVisit(t,r,{restorationData:o})):window.location=t},r.prototype.setProgressBarDelay=function(t){return this.progressBarDelay=t},r.prototype.startHistory=function(){return this.location=e.Location.wrap(window.location),this.restorationIdentifier=e.uuid(),this.history.start(),this.history.replace(this.location,this.restorationIdentifier)},r.prototype.stopHistory=function(){return this.history.stop()},r.prototype.pushHistoryWithLocationAndRestorationIdentifier=function(t,r){return this.restorationIdentifier=r,this.location=e.Location.wrap(t),this.history.push(this.location,this.restorationIdentifier)},r.prototype.replaceHistoryWithLocationAndRestorationIdentifier=function(t,r){return this.restorationIdentifier=r,this.location=e.Location.wrap(t),this.history.replace(this.location,this.restorationIdentifier)},r.prototype.historyPoppedToLocationWithRestorationIdentifier=function(t,r){var n;return this.restorationIdentifier=r,this.enabled?(n=this.getRestorationDataForIdentifier(this.restorationIdentifier),this.startVisit(t,"restore",{restorationIdentifier:this.restorationIdentifier,restorationData:n,historyChanged:!0}),this.location=e.Location.wrap(t)):this.adapter.pageInvalidated()},r.prototype.getCachedSnapshotForLocation=function(t){var e;return e=this.cache.get(t),e?e.clone():void 0},r.prototype.shouldCacheSnapshot=function(){return this.view.getSnapshot().isCacheable()},r.prototype.cacheSnapshot=function(){var t;return this.shouldCacheSnapshot()?(this.notifyApplicationBeforeCachingSnapshot(),t=this.view.getSnapshot(),this.cache.put(this.lastRenderedLocation,t.clone())):void 0},r.prototype.scrollToAnchor=function(t){var e;return(e=this.view.getElementForAnchor(t))?this.scrollToElement(e):this.scrollToPosition({x:0,y:0})},r.prototype.scrollToElement=function(t){return this.scrollManager.scrollToElement(t)},r.prototype.scrollToPosition=function(t){return this.scrollManager.scrollToPosition(t)},r.prototype.scrollPositionChanged=function(t){var e;return e=this.getCurrentRestorationData(),e.scrollPosition=t},r.prototype.render=function(t,e){return this.view.render(t,e)},r.prototype.viewInvalidated=function(){return this.adapter.pageInvalidated()},r.prototype.viewWillRender=function(t){return this.notifyApplicationBeforeRender(t)},r.prototype.viewRendered=function(){return this.lastRenderedLocation=this.currentVisit.location,this.notifyApplicationAfterRender()},r.prototype.pageLoaded=function(){return this.lastRenderedLocation=this.location,this.notifyApplicationAfterPageLoad()},r.prototype.clickCaptured=function(){return removeEventListener("click",this.clickBubbled,!1),addEventListener("click",this.clickBubbled,!1)},r.prototype.clickBubbled=function(t){var e,r,n;return this.enabled&&this.clickEventIsSignificant(t)&&(r=this.getVisitableLinkForNode(t.target))&&(n=this.getVisitableLocationForLink(r))&&this.applicationAllowsFollowingLinkToLocation(r,n)?(t.preventDefault(),e=this.getActionForLink(r),
this.visit(n,{action:e})):void 0},r.prototype.applicationAllowsFollowingLinkToLocation=function(t,e){var r;return r=this.notifyApplicationAfterClickingLinkToLocation(t,e),!r.defaultPrevented},r.prototype.applicationAllowsVisitingLocation=function(t){var e;return e=this.notifyApplicationBeforeVisitingLocation(t),!e.defaultPrevented},r.prototype.notifyApplicationAfterClickingLinkToLocation=function(t,r){return e.dispatch("turbolinks:click",{target:t,data:{url:r.absoluteURL},cancelable:!0})},r.prototype.notifyApplicationBeforeVisitingLocation=function(t){return e.dispatch("turbolinks:before-visit",{data:{url:t.absoluteURL},cancelable:!0})},r.prototype.notifyApplicationAfterVisitingLocation=function(t){return e.dispatch("turbolinks:visit",{data:{url:t.absoluteURL}})},r.prototype.notifyApplicationBeforeCachingSnapshot=function(){return e.dispatch("turbolinks:before-cache")},r.prototype.notifyApplicationBeforeRender=function(t){return e.dispatch("turbolinks:before-render",{data:{newBody:t}})},r.prototype.notifyApplicationAfterRender=function(){return e.dispatch("turbolinks:render")},r.prototype.notifyApplicationAfterPageLoad=function(t){return null==t&&(t={}),e.dispatch("turbolinks:load",{data:{url:this.location.absoluteURL,timing:t}})},r.prototype.startVisit=function(t,e,r){var n;return null!=(n=this.currentVisit)&&n.cancel(),this.currentVisit=this.createVisit(t,e,r),this.currentVisit.start(),this.notifyApplicationAfterVisitingLocation(t)},r.prototype.createVisit=function(t,r,n){var o,i,s,a,u;return i=null!=n?n:{},a=i.restorationIdentifier,s=i.restorationData,o=i.historyChanged,u=new e.Visit(this,t,r),u.restorationIdentifier=null!=a?a:e.uuid(),u.restorationData=e.copyObject(s),u.historyChanged=o,u.referrer=this.location,u},r.prototype.visitCompleted=function(t){return this.notifyApplicationAfterPageLoad(t.getTimingMetrics())},r.prototype.clickEventIsSignificant=function(t){return!(t.defaultPrevented||t.target.isContentEditable||t.which>1||t.altKey||t.ctrlKey||t.metaKey||t.shiftKey)},r.prototype.getVisitableLinkForNode=function(t){return this.nodeIsVisitable(t)?e.closest(t,"a[href]:not([target]):not([download])"):void 0},r.prototype.getVisitableLocationForLink=function(t){var r;return r=new e.Location(t.getAttribute("href")),this.locationIsVisitable(r)?r:void 0},r.prototype.getActionForLink=function(t){var e;return null!=(e=t.getAttribute("data-turbolinks-action"))?e:"advance"},r.prototype.nodeIsVisitable=function(t){var r;return(r=e.closest(t,"[data-turbolinks]"))?"false"!==r.getAttribute("data-turbolinks"):!0},r.prototype.locationIsVisitable=function(t){return t.isPrefixedBy(this.view.getRootLocation())&&t.isHTML()},r.prototype.getCurrentRestorationData=function(){return this.getRestorationDataForIdentifier(this.restorationIdentifier)},r.prototype.getRestorationDataForIdentifier=function(t){var e;return null!=(e=this.restorationData)[t]?e[t]:e[t]={}},r}()}.call(this),function(){!function(){var t,e;if((t=e=document.currentScript)&&!e.hasAttribute("data-turbolinks-suppress-warning"))for(;t=t.parentNode;)if(t===document.body)return console.warn("You are loading Turbolinks from a <script> element inside the <body> element. This is probably not what you meant to do!\n\nLoad your application\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\n\nFor more information, see: https://github.com/turbolinks/turbolinks#working-with-script-elements\n\n\u2014\u2014\nSuppress this warning by adding a `data-turbolinks-suppress-warning` attribute to: %s",e.outerHTML)}()}.call(this),function(){var t,r,n;e.start=function(){return r()?(null==e.controller&&(e.controller=t()),e.controller.start()):void 0},r=function(){return null==window.Turbolinks&&(window.Turbolinks=e),n()},t=function(){var t;return t=new e.Controller,t.adapter=new e.BrowserAdapter(t),t},n=function(){return window.Turbolinks===e},n()&&e.start()}.call(this)}).call(this),"object"==typeof module&&module.exports?module.exports=e:"function"=="function"&&__webpack_require__(72)&&!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}).call(this);

/***/ }),

/***/ 72:
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZTI4ZWE0M2ZkMjE4YTFlZTVhMTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9rZXljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9mcm9udGVuZC9qcy92ZW5kb3IvdmVuZG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0cy9kYXRlcGlja2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0cy9zbGlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXRzL21vdXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvaWUuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Zyb250ZW5kL2pzL3ZlbmRvci9qcXVlcnktdWktdGltZXBpY2tlci1hZGRvbi5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvZnJvbnRlbmQvanMvdmVuZG9yL3BvcHBlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9mcm9udGVuZC9qcy92ZW5kb3IvYm9vdHN0cmFwLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9mcm9udGVuZC9qcy92ZW5kb3IvYm9vdHN0cmFwLXNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvZnJvbnRlbmQvanMvdmVuZG9yL2NoYXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJib2xpbmtzL2Rpc3QvdHVyYm9saW5rcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiXSwibmFtZXMiOlsid2luZG93IiwiJCIsImpRdWVyeSIsInJlcXVpcmUiLCJQb3BwZXIiLCJUdXJib2xpbmtzIiwiZm4iLCJzZXJpYWxpemVPYmplY3QiLCJzaG91bGRWYWxpZGF0ZSIsInNlbGYiLCJqc29uIiwicHVzaF9jb3VudGVycyIsInBhdHRlcm5zIiwiaXNWYWxpZCIsIiRmaWVsZHMiLCJmaW5kIiwibm90IiwiYnVpbGQiLCJiYXNlIiwia2V5IiwidmFsdWUiLCJwdXNoX2NvdW50ZXIiLCJ1bmRlZmluZWQiLCJyZW1vdmUiLCJyZW1vdmVDbGFzcyIsImNsZWFyVGltZW91dCIsInZhbGlkYXRpb25UaW1lb3V0Iiwic2V0VGltZW91dCIsImZhZGVPdXQiLCJtYXAiLCJ2YWxpZGF0ZSIsInRlc3QiLCJuYW1lIiwiayIsImtleXMiLCJtYXRjaCIsIm1lcmdlIiwicmV2ZXJzZV9rZXkiLCJ2YWxpZGF0aW9uX3J1bGVzIiwiYXR0cmlidXRlcyIsImhhc093blByb3BlcnR5IiwidmFsaWRhdGlvbiIsInJlc3BvbnNlIiwicG9wIiwicmVwbGFjZSIsIlJlZ0V4cCIsInB1c2giLCJmaXhlZCIsIm5hbWVkIiwiZXh0ZW5kIiwiY2xvc2VzdCIsImFkZENsYXNzIiwiZmlyc3QiLCJsZW5ndGgiLCJjbGljayIsIiR0aGlzIiwidmFsIiwidmFsaWRhdGlvblJ1bGVzIiwiYXR0ciIsInNwbGl0IiwiZmFpbGVkUnVsZXMiLCJpIiwicnVsZSIsImlucHV0IiwiaXNOYU4iLCJwYXJzZUludCIsImlzRmluaXRlIiwiTnVtYmVyIiwiaW5kZXhPZiIsImlzIiwiaGFzQ2xhc3MiLCJzaWJsaW5ncyIsInBhcmVudCIsIiRpbnZhbGlkRmVlZGJhY2siLCJhcHBlbmQiLCJPYmplY3QiLCJyZXNvbHZlIiwicGF0aCIsIm9iaiIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwidWkiLCJ0aW1lcGlja2VyIiwidmVyc2lvbiIsIlRpbWVwaWNrZXIiLCJyZWdpb25hbCIsImN1cnJlbnRUZXh0IiwiY2xvc2VUZXh0IiwiYW1OYW1lcyIsInBtTmFtZXMiLCJ0aW1lRm9ybWF0IiwidGltZVN1ZmZpeCIsInRpbWVPbmx5VGl0bGUiLCJ0aW1lVGV4dCIsImhvdXJUZXh0IiwibWludXRlVGV4dCIsInNlY29uZFRleHQiLCJtaWxsaXNlY1RleHQiLCJtaWNyb3NlY1RleHQiLCJ0aW1lem9uZVRleHQiLCJpc1JUTCIsIl9kZWZhdWx0cyIsInNob3dCdXR0b25QYW5lbCIsInRpbWVPbmx5IiwidGltZU9ubHlTaG93RGF0ZSIsInNob3dIb3VyIiwic2hvd01pbnV0ZSIsInNob3dTZWNvbmQiLCJzaG93TWlsbGlzZWMiLCJzaG93TWljcm9zZWMiLCJzaG93VGltZXpvbmUiLCJzaG93VGltZSIsInN0ZXBIb3VyIiwic3RlcE1pbnV0ZSIsInN0ZXBTZWNvbmQiLCJzdGVwTWlsbGlzZWMiLCJzdGVwTWljcm9zZWMiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWMiLCJtaWNyb3NlYyIsInRpbWV6b25lIiwiaG91ck1pbiIsIm1pbnV0ZU1pbiIsInNlY29uZE1pbiIsIm1pbGxpc2VjTWluIiwibWljcm9zZWNNaW4iLCJob3VyTWF4IiwibWludXRlTWF4Iiwic2Vjb25kTWF4IiwibWlsbGlzZWNNYXgiLCJtaWNyb3NlY01heCIsIm1pbkRhdGVUaW1lIiwibWF4RGF0ZVRpbWUiLCJtYXhUaW1lIiwibWluVGltZSIsIm9uU2VsZWN0IiwiaG91ckdyaWQiLCJtaW51dGVHcmlkIiwic2Vjb25kR3JpZCIsIm1pbGxpc2VjR3JpZCIsIm1pY3Jvc2VjR3JpZCIsImFsd2F5c1NldFRpbWUiLCJzZXBhcmF0b3IiLCJhbHRGaWVsZFRpbWVPbmx5IiwiYWx0VGltZUZvcm1hdCIsImFsdFNlcGFyYXRvciIsImFsdFRpbWVTdWZmaXgiLCJhbHRSZWRpcmVjdEZvY3VzIiwicGlja2VyVGltZUZvcm1hdCIsInBpY2tlclRpbWVTdWZmaXgiLCJzaG93VGltZXBpY2tlciIsInRpbWV6b25lTGlzdCIsImFkZFNsaWRlckFjY2VzcyIsInNsaWRlckFjY2Vzc0FyZ3MiLCJjb250cm9sVHlwZSIsIm9uZUxpbmUiLCJkZWZhdWx0VmFsdWUiLCJwYXJzZSIsImFmdGVySW5qZWN0IiwicHJvdG90eXBlIiwiJGlucHV0IiwiJGFsdElucHV0IiwiJHRpbWVPYmoiLCJpbnN0IiwiaG91cl9zbGlkZXIiLCJtaW51dGVfc2xpZGVyIiwic2Vjb25kX3NsaWRlciIsIm1pbGxpc2VjX3NsaWRlciIsIm1pY3Jvc2VjX3NsaWRlciIsInRpbWV6b25lX3NlbGVjdCIsImhvdXJNaW5PcmlnaW5hbCIsIm1pbnV0ZU1pbk9yaWdpbmFsIiwic2Vjb25kTWluT3JpZ2luYWwiLCJtaWxsaXNlY01pbk9yaWdpbmFsIiwibWljcm9zZWNNaW5PcmlnaW5hbCIsImhvdXJNYXhPcmlnaW5hbCIsIm1pbnV0ZU1heE9yaWdpbmFsIiwic2Vjb25kTWF4T3JpZ2luYWwiLCJtaWxsaXNlY01heE9yaWdpbmFsIiwibWljcm9zZWNNYXhPcmlnaW5hbCIsImFtcG0iLCJmb3JtYXR0ZWREYXRlIiwiZm9ybWF0dGVkVGltZSIsImZvcm1hdHRlZERhdGVUaW1lIiwidW5pdHMiLCJzdXBwb3J0IiwiY29udHJvbCIsInNldERlZmF1bHRzIiwic2V0dGluZ3MiLCJleHRlbmRSZW1vdmUiLCJfbmV3SW5zdCIsIm9wdHMiLCJ0cF9pbnN0IiwiaW5saW5lU2V0dGluZ3MiLCJmbnMiLCJvdmVycmlkZXMiLCJhdHRyTmFtZSIsImF0dHJWYWx1ZSIsImV2YWwiLCJlcnIiLCJiZWZvcmVTaG93IiwiZHBfaW5zdCIsImlzRnVuY3Rpb24iLCJldm50cyIsImNhbGwiLCJvbkNoYW5nZU1vbnRoWWVhciIsInllYXIiLCJtb250aCIsIm9uQ2xvc2UiLCJkYXRlVGV4dCIsInRpbWVEZWZpbmVkIiwiX3VwZGF0ZURhdGVUaW1lIiwidG9VcHBlckNhc2UiLCJkZXRlY3RTdXBwb3J0Iiwic2xpZGVyIiwiX2NvbnRyb2xzIiwidHpsIiwidHppIiwidHp2IiwibGFiZWwiLCJ0aW1lem9uZU9mZnNldFN0cmluZyIsImlzbzg2MDEiLCJ0aW1lem9uZU9mZnNldE51bWJlciIsIkRhdGUiLCJnZXRUaW1lem9uZU9mZnNldCIsImFsdEZpZWxkIiwiY3NzIiwiY3Vyc29yIiwiZm9jdXMiLCJ0cmlnZ2VyIiwibWluRGF0ZSIsIm1heERhdGUiLCJnZXRUaW1lIiwiYmluZCIsIl9vbkZvY3VzIiwiX2FkZFRpbWVQaWNrZXIiLCJjdXJyRFQiLCJ0cmltIiwiX3BhcnNlVGltZSIsIl9saW1pdE1pbk1heERhdGVUaW1lIiwiX2luamVjdFRpbWVQaWNrZXIiLCJfYWZ0ZXJJbmplY3QiLCJ0aW1lU3RyaW5nIiwid2l0aERhdGUiLCJkYXRlcGlja2VyIiwiX2dldEluc3QiLCJkcF9kYXRlRm9ybWF0IiwiX2dldCIsInBhcnNlUmVzIiwicGFyc2VEYXRlVGltZUludGVybmFsIiwiX2dldEZvcm1hdENvbmZpZyIsInRpbWVPYmoiLCJsb2ciLCJwYXJzZVRpbWUiLCJvIiwiJGRwIiwiZHBEaXYiLCJsaXRlbSIsInVpdGVtIiwic2hvdyIsIm1heCIsImdyaWRTaXplIiwic2l6ZSIsImwiLCJub0Rpc3BsYXkiLCJodG1sIiwidGltZUlucHV0Iiwic3Vic3RyIiwiaCIsInRtcGgiLCJmb3JtYXRUaW1lIiwibSIsInNob3dUeiIsIiR0cCIsInByZXBlbmQiLCJoaWRlIiwiY3JlYXRlIiwid2lkdGgiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJib3JkZXJDb2xsYXBzZSIsImUiLCIkdCIsIm4iLCJhcCIsImYiLCJkYXRhIiwiX29uVGltZUNoYW5nZSIsIl9vblNlbGVjdEhhbmRsZXIiLCJ0ZXh0QWxpZ24iLCJvdmVyZmxvdyIsImFwcGx5IiwiaWR4IiwidGV4dCIsImxvY2FsX3RpbWV6b25lIiwic2VsZWN0ZWRZZWFyIiwic2VsZWN0ZWRNb250aCIsInNlbGVjdGVkRGF5Iiwic2VsZWN0TG9jYWxUaW1lem9uZSIsImNoYW5nZSIsIiRidXR0b25QYW5lbCIsImJlZm9yZSIsInBhcnNlZFRpbWUiLCJ1cGRhdGUiLCJzZXRIb3VycyIsInNldE1pbnV0ZXMiLCJzZXRTZWNvbmRzIiwiX3NldFRpbWUiLCJibHVyIiwicnRsIiwic2xpZGVyQWNjZXNzIiwic2xpZGVyQWNjZXNzV2lkdGgiLCJvdXRlcldpZHRoIiwiZWFjaCIsIiRnIiwib2xkV2lkdGgiLCJvbGRNYXJnaW5MZWZ0IiwidG9TdHJpbmciLCJuZXdXaWR0aCIsIm5ld01hcmdpbkxlZnQiLCJhZGp1c3RTbGlkZXJzIiwiZHBfZGF0ZSIsIm1pbkRhdGVUaW1lRGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImdldE1pY3Jvc2Vjb25kcyIsIm1heERhdGVUaW1lRGF0ZSIsInRlbXBNaW5UaW1lIiwidGVtcE1heFRpbWUiLCJtaW5NYXgiLCJzZWNNYXgiLCJvcHRpb25zIiwibWluIiwic3RlcCIsImhhc0NoYW5nZWQiLCJpbkFycmF5Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJzUG9zIiwic2VsZWN0aW9uU3RhcnQiLCJlUG9zIiwic2VsZWN0aW9uRW5kIiwiaW5wdXRFbCIsImR0VG1wIiwiY3VycmVudFllYXIiLCJjdXJyZW50TW9udGgiLCJjdXJyZW50RGF5IiwiZHQiLCJfZGF5bGlnaHRTYXZpbmdBZGp1c3QiLCJkYXRlRm10IiwiZm9ybWF0Q2ZnIiwidGltZUF2YWlsYWJsZSIsImZvcm1hdERhdGUiLCJsYXN0VmFsIiwiYWx0Rm9ybWF0dGVkRGF0ZVRpbWUiLCJhbHRGb3JtYXQiLCJnZXQiLCJfdXBkYXRlRGF0ZXBpY2tlciIsInVuaXQiLCJwcm9wIiwib3JpZW50YXRpb24iLCJzbGlkZSIsImV2ZW50Iiwic3RvcCIsIk1hdGgiLCJhYnMiLCJzZWxlY3QiLCJzZWwiLCJmb3JtYXQiLCJjaGlsZHJlbiIsImFwcGVuZFRvIiwidG1wX2FyZ3MiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwiZGF0ZXRpbWVwaWNrZXIiLCJwYXJzZURhdGVUaW1lIiwiZGF0ZUZvcm1hdCIsImRhdGVUaW1lU3RyaW5nIiwiZGF0ZVNldHRpbmdzIiwidGltZVNldHRpbmdzIiwidCIsImRhdGUiLCJzZXRNaWNyb3NlY29uZHMiLCJzdHJpY3RQYXJzZSIsInMiLCJnZXRQYXR0ZXJuQW1wbSIsIm1hcmtlcnMiLCJqb2luIiwiZ2V0Rm9ybWF0UG9zaXRpb25zIiwiZmluZHMiLCJ0b0xvd2VyQ2FzZSIsIm9yZGVycyIsImMiLCJ6IiwiY2hhckF0IiwicmVnc3RyIiwibWwiLCJvcmRlciIsInRyZWciLCJyZXNUaW1lIiwieCIsImxvb3NlUGFyc2UiLCJkIiwiZXJyMiIsInRpbWUiLCJ0bXB0aW1lIiwiYW1wbU5hbWUiLCJjb252ZXJ0MjR0bzEyIiwiX2Jhc2Vfc2VsZWN0RGF0ZSIsIl9zZWxlY3REYXRlIiwiaWQiLCJkYXRlU3RyIiwid2FzX2lubGluZSIsImlubGluZSIsInN0YXlfb3BlbiIsIl9ub3RpZnlDaGFuZ2UiLCJfYmFzZV91cGRhdGVEYXRlcGlja2VyIiwiX2N1ckluc3QiLCJfZGF0ZXBpY2tlclNob3dpbmciLCJfbGFzdElucHV0IiwiX2Jhc2VfZG9LZXlQcmVzcyIsIl9kb0tleVByZXNzIiwidGFyZ2V0IiwidHoiLCJkYXRlQ2hhcnMiLCJfcG9zc2libGVDaGFycyIsImRhdGV0aW1lQ2hhcnMiLCJjaHIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZSIsImtleUNvZGUiLCJjdHJsS2V5IiwiX2Jhc2VfdXBkYXRlQWx0ZXJuYXRlIiwiX3VwZGF0ZUFsdGVybmF0ZSIsIl9nZXREYXRlIiwiX2Jhc2VfZG9LZXlVcCIsIl9kb0tleVVwIiwiX2Jhc2VfZ290b1RvZGF5IiwiX2dvdG9Ub2RheSIsInR6b2Zmc2V0Iiwibm93IiwiX3NldERhdGUiLCJfZGlzYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyIiwiX2VuYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyIiwiZGVmYXVsdHMiLCJfc2V0VGltZURhdGVwaWNrZXIiLCJfc2V0RGF0ZUZyb21GaWVsZCIsInRwX2RhdGUiLCJfYmFzZV9zZXREYXRlRGF0ZXBpY2tlciIsIl9zZXREYXRlRGF0ZXBpY2tlciIsIl9kYXRlIiwidGltZXpvbmVBZGp1c3QiLCJfYmFzZV9nZXREYXRlRGF0ZXBpY2tlciIsIl9nZXREYXRlRGF0ZXBpY2tlciIsIm5vRGVmYXVsdCIsInRhZ05hbWUiLCJfYmFzZV9wYXJzZURhdGUiLCJwYXJzZURhdGUiLCJzdWJzdHJpbmciLCJfYmFzZV9mb3JtYXREYXRlIiwiX2Zvcm1hdERhdGUiLCJkYXkiLCJfYmFzZV9vcHRpb25EYXRlcGlja2VyIiwiX29wdGlvbkRhdGVwaWNrZXIiLCJuYW1lX2Nsb25lIiwib25zZWxlY3QiLCJyZXQiLCJvbGRWYWwiLCIkdGFyZ2V0IiwiaXNFbXB0eU9iamVjdCIsInByb3BzIiwidGYiLCJpc0luIiwiY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmciLCJwcm9wZXJ0eSIsInNwbGl0RGF0ZVRpbWUiLCJ0aW1lUGFydHMiLCJ0aW1lUGFydHNMZW4iLCJhbGxQYXJ0cyIsImFsbFBhcnRzTGVuIiwiZGF0ZVN0cmluZyIsInNwbGljZSIsInBhcnRzIiwidHpNaW51dGVzIiwib2ZmIiwibWludXRlcyIsImhvdXJzIiwiaXNvIiwidHpTdHJpbmciLCJub3JtYWxpemVkIiwiZnJvbVRpbWV6b25lIiwidG9UaW1lem9uZSIsImZyb21UeiIsInRvVHoiLCJ0aW1lUmFuZ2UiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiaGFuZGxlUmFuZ2UiLCJkYXRldGltZVJhbmdlIiwiZGF0ZVJhbmdlIiwibWV0aG9kIiwibWluSW50ZXJ2YWwiLCJtYXhJbnRlcnZhbCIsInN0YXJ0IiwiZW5kIiwiY2hlY2tEYXRlcyIsImNoYW5nZWQiLCJvdGhlciIsInN0YXJ0ZHQiLCJlbmRkdCIsImNoYW5nZWRkdCIsInNldE1pbGxpc2Vjb25kcyIsInNlbGVjdGVkIiwib3B0aW9uIiwic2VsZWN0ZWREYXRlVGltZSIsImNvbnNvbGUiLCJfdXRpbCIsIl9leHRlbmRSZW1vdmUiLCJfaXNFbXB0eU9iamVjdCIsIl9jb252ZXJ0MjR0bzEyIiwiX2RldGVjdFN1cHBvcnQiLCJfc2VsZWN0TG9jYWxUaW1lem9uZSIsIl9jb21wdXRlRWZmZWN0aXZlU2V0dGluZyIsIl9zcGxpdERhdGVUaW1lIiwiX3BhcnNlRGF0ZVRpbWVJbnRlcm5hbCIsIm1pY3Jvc2Vjb25kcyIsImZsb29yIiwiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJuYXRpdmVIaW50cyIsImlzTmF0aXZlIiwic29tZSIsImhpbnQiLCJpc0Jyb3dzZXIiLCJsb25nZXJUaW1lb3V0QnJvd3NlcnMiLCJ0aW1lb3V0RHVyYXRpb24iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtaWNyb3Rhc2tEZWJvdW5jZSIsInNjaGVkdWxlZCIsImVsZW0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwic2V0QXR0cmlidXRlIiwidGFza0RlYm91bmNlIiwic3VwcG9ydHNOYXRpdmVNdXRhdGlvbk9ic2VydmVyIiwiZGVib3VuY2UiLCJmdW5jdGlvblRvQ2hlY2siLCJnZXRUeXBlIiwiZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5IiwiZWxlbWVudCIsIm5vZGVUeXBlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFBhcmVudE5vZGUiLCJub2RlTmFtZSIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0U2Nyb2xsUGFyZW50IiwiYm9keSIsIl9nZXRTdHlsZUNvbXB1dGVkUHJvcCIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImRvY3VtZW50RWxlbWVudCIsImlzT2Zmc2V0Q29udGFpbmVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJnZXRSb290Iiwibm9kZSIsImZpbmRDb21tb25PZmZzZXRQYXJlbnQiLCJlbGVtZW50MSIsImVsZW1lbnQyIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJjb250YWlucyIsImVsZW1lbnQxcm9vdCIsImdldFNjcm9sbCIsInNpZGUiLCJ1cHBlclNpZGUiLCJzY3JvbGxpbmdFbGVtZW50IiwiaW5jbHVkZVNjcm9sbCIsInJlY3QiLCJzdWJ0cmFjdCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJtb2RpZmllciIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImdldEJvcmRlcnNTaXplIiwic3R5bGVzIiwiYXhpcyIsInNpZGVBIiwic2lkZUIiLCJpc0lFMTAiLCJpc0lFMTAkMSIsImFwcFZlcnNpb24iLCJnZXRTaXplIiwiY29tcHV0ZWRTdHlsZSIsImdldFdpbmRvd1NpemVzIiwiaGVpZ2h0IiwiY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJzb3VyY2UiLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJlc3VsdCIsInNpemVzIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJob3JpelNjcm9sbGJhciIsIm9mZnNldFdpZHRoIiwidmVydFNjcm9sbGJhciIsIm9mZnNldEhlaWdodCIsImdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSIsImlzSFRNTCIsImNoaWxkcmVuUmVjdCIsInBhcmVudFJlY3QiLCJzY3JvbGxQYXJlbnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsIm1hcmdpblRvcCIsImdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZSIsInJlbGF0aXZlT2Zmc2V0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwib2Zmc2V0IiwiaXNGaXhlZCIsImdldEJvdW5kYXJpZXMiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJwYWRkaW5nIiwiYm91bmRhcmllc0VsZW1lbnQiLCJib3VuZGFyaWVzIiwiYm91bmRhcmllc05vZGUiLCJfZ2V0V2luZG93U2l6ZXMiLCJnZXRBcmVhIiwiX3JlZiIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwicGxhY2VtZW50IiwicmVmUmVjdCIsInJlY3RzIiwic29ydGVkQXJlYXMiLCJhcmVhIiwic29ydCIsImEiLCJiIiwiZmlsdGVyZWRBcmVhcyIsImZpbHRlciIsIl9yZWYyIiwiY29tcHV0ZWRQbGFjZW1lbnQiLCJ2YXJpYXRpb24iLCJnZXRSZWZlcmVuY2VPZmZzZXRzIiwic3RhdGUiLCJjb21tb25PZmZzZXRQYXJlbnQiLCJnZXRPdXRlclNpemVzIiwicGFyc2VGbG9hdCIsIm1hcmdpbkJvdHRvbSIsInkiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImhhc2giLCJtYXRjaGVkIiwiZ2V0UG9wcGVyT2Zmc2V0cyIsInJlZmVyZW5jZU9mZnNldHMiLCJwb3BwZXJSZWN0IiwicG9wcGVyT2Zmc2V0cyIsImlzSG9yaXoiLCJtYWluU2lkZSIsInNlY29uZGFyeVNpZGUiLCJtZWFzdXJlbWVudCIsInNlY29uZGFyeU1lYXN1cmVtZW50IiwiYXJyIiwiY2hlY2siLCJmaW5kSW5kZXgiLCJjdXIiLCJydW5Nb2RpZmllcnMiLCJtb2RpZmllcnMiLCJlbmRzIiwibW9kaWZpZXJzVG9SdW4iLCJmb3JFYWNoIiwiZnVuY3Rpb24iLCJ3YXJuIiwiZW5hYmxlZCIsImlzRGVzdHJveWVkIiwiZmxpcHBlZCIsImZsaXAiLCJvcmlnaW5hbFBsYWNlbWVudCIsInBvc2l0aW9uIiwiaXNDcmVhdGVkIiwib25DcmVhdGUiLCJvblVwZGF0ZSIsImlzTW9kaWZpZXJFbmFibGVkIiwibW9kaWZpZXJOYW1lIiwiZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIiwicHJlZml4ZXMiLCJ1cHBlclByb3AiLCJwcmVmaXgiLCJ0b0NoZWNrIiwic3R5bGUiLCJkZXN0cm95IiwicmVtb3ZlQXR0cmlidXRlIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlT25EZXN0cm95IiwicmVtb3ZlQ2hpbGQiLCJhdHRhY2hUb1Njcm9sbFBhcmVudHMiLCJjYWxsYmFjayIsInNjcm9sbFBhcmVudHMiLCJpc0JvZHkiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVCb3VuZCIsInNjcm9sbEVsZW1lbnQiLCJldmVudHNFbmFibGVkIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMiLCJzY2hlZHVsZVVwZGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaXNOdW1lcmljIiwic2V0U3R5bGVzIiwic2V0QXR0cmlidXRlcyIsImFwcGx5U3R5bGUiLCJhcnJvdyIsImFycm93RWxlbWVudCIsImFwcGx5U3R5bGVPbkxvYWQiLCJtb2RpZmllck9wdGlvbnMiLCJjb21wdXRlU3R5bGUiLCJsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24iLCJncHVBY2NlbGVyYXRpb24iLCJvZmZzZXRQYXJlbnRSZWN0IiwicHJlZml4ZWRQcm9wZXJ0eSIsIndpbGxDaGFuZ2UiLCJpbnZlcnRUb3AiLCJpbnZlcnRMZWZ0IiwiaXNNb2RpZmllclJlcXVpcmVkIiwicmVxdWVzdGluZ05hbWUiLCJyZXF1ZXN0ZWROYW1lIiwicmVxdWVzdGluZyIsImlzUmVxdWlyZWQiLCJfcmVxdWVzdGluZyIsInJlcXVlc3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJfZGF0YSRvZmZzZXRzIiwiaXNWZXJ0aWNhbCIsImxlbiIsImFsdFNpZGUiLCJvcFNpZGUiLCJhcnJvd0VsZW1lbnRTaXplIiwiY2VudGVyIiwic2lkZVZhbHVlIiwicm91bmQiLCJnZXRPcHBvc2l0ZVZhcmlhdGlvbiIsInBsYWNlbWVudHMiLCJ2YWxpZFBsYWNlbWVudHMiLCJjbG9ja3dpc2UiLCJjb3VudGVyIiwiaW5kZXgiLCJjb25jYXQiLCJyZXZlcnNlIiwiQkVIQVZJT1JTIiwiRkxJUCIsIkNMT0NLV0lTRSIsIkNPVU5URVJDTE9DS1dJU0UiLCJwbGFjZW1lbnRPcHBvc2l0ZSIsImZsaXBPcmRlciIsImJlaGF2aW9yIiwicmVmT2Zmc2V0cyIsIm92ZXJsYXBzUmVmIiwib3ZlcmZsb3dzTGVmdCIsIm92ZXJmbG93c1JpZ2h0Iiwib3ZlcmZsb3dzVG9wIiwib3ZlcmZsb3dzQm90dG9tIiwib3ZlcmZsb3dzQm91bmRhcmllcyIsImZsaXBwZWRWYXJpYXRpb24iLCJmbGlwVmFyaWF0aW9ucyIsImtlZXBUb2dldGhlciIsInRvVmFsdWUiLCJzdHIiLCJwYXJzZU9mZnNldCIsImJhc2VQbGFjZW1lbnQiLCJ1c2VIZWlnaHQiLCJmcmFnbWVudHMiLCJmcmFnIiwiZGl2aWRlciIsInNlYXJjaCIsInNwbGl0UmVnZXgiLCJvcHMiLCJvcCIsIm1lcmdlV2l0aFByZXZpb3VzIiwiaW5kZXgyIiwicHJldmVudE92ZXJmbG93IiwicHJpb3JpdHkiLCJwcmltYXJ5IiwiZXNjYXBlV2l0aFJlZmVyZW5jZSIsInNlY29uZGFyeSIsInNoaWZ0Iiwic2hpZnR2YXJpYXRpb24iLCJzaGlmdE9mZnNldHMiLCJib3VuZCIsImlubmVyIiwic3VidHJhY3RMZW5ndGgiLCJvbkxvYWQiLCJEZWZhdWx0cyIsIl90aGlzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwianF1ZXJ5IiwidXBkYXRlJCQxIiwiZGVzdHJveSQkMSIsImVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxIiwiVXRpbHMiLCJQb3BwZXJVdGlscyIsIkVycm9yIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfY3JlYXRlQ2xhc3MiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJVdGlsIiwidHJhbnNpdGlvbiIsIk1BWF9VSUQiLCJUcmFuc2l0aW9uRW5kRXZlbnQiLCJXZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIk9UcmFuc2l0aW9uIiwidG9UeXBlIiwiaXNFbGVtZW50IiwiZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCIsImJpbmRUeXBlIiwiZGVsZWdhdGVUeXBlIiwiaGFuZGxlIiwiaGFuZGxlT2JqIiwiaGFuZGxlciIsInRyYW5zaXRpb25FbmRUZXN0IiwiUVVuaXQiLCJlbCIsInRyYW5zaXRpb25FbmRFbXVsYXRvciIsImR1cmF0aW9uIiwiY2FsbGVkIiwib25lIiwiVFJBTlNJVElPTl9FTkQiLCJ0cmlnZ2VyVHJhbnNpdGlvbkVuZCIsInNldFRyYW5zaXRpb25FbmRTdXBwb3J0IiwiZW11bGF0ZVRyYW5zaXRpb25FbmQiLCJzdXBwb3J0c1RyYW5zaXRpb25FbmQiLCJzcGVjaWFsIiwiZ2V0VUlEIiwicmFuZG9tIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTZWxlY3RvckZyb21FbGVtZW50Iiwic2VsZWN0b3IiLCJnZXRBdHRyaWJ1dGUiLCIkc2VsZWN0b3IiLCJlcnJvciIsInJlZmxvdyIsIkJvb2xlYW4iLCJ0eXBlQ2hlY2tDb25maWciLCJjb21wb25lbnROYW1lIiwiY29uZmlnIiwiY29uZmlnVHlwZXMiLCJleHBlY3RlZFR5cGVzIiwidmFsdWVUeXBlIiwiQWxlcnQiLCJOQU1FIiwiVkVSU0lPTiIsIkRBVEFfS0VZIiwiRVZFTlRfS0VZIiwiREFUQV9BUElfS0VZIiwiSlFVRVJZX05PX0NPTkZMSUNUIiwiVFJBTlNJVElPTl9EVVJBVElPTiIsIlNlbGVjdG9yIiwiRElTTUlTUyIsIkV2ZW50IiwiQ0xPU0UiLCJDTE9TRUQiLCJDTElDS19EQVRBX0FQSSIsIkNsYXNzTmFtZSIsIkFMRVJUIiwiRkFERSIsIlNIT1ciLCJfZWxlbWVudCIsImNsb3NlIiwicm9vdEVsZW1lbnQiLCJfZ2V0Um9vdEVsZW1lbnQiLCJjdXN0b21FdmVudCIsIl90cmlnZ2VyQ2xvc2VFdmVudCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIl9yZW1vdmVFbGVtZW50IiwiZGlzcG9zZSIsInJlbW92ZURhdGEiLCJjbG9zZUV2ZW50IiwiX3RoaXMyIiwiX2Rlc3Ryb3lFbGVtZW50IiwiZGV0YWNoIiwiX2pRdWVyeUludGVyZmFjZSIsIiRlbGVtZW50IiwiX2hhbmRsZURpc21pc3MiLCJhbGVydEluc3RhbmNlIiwicHJldmVudERlZmF1bHQiLCJvbiIsIm5vQ29uZmxpY3QiLCJCdXR0b24iLCJBQ1RJVkUiLCJCVVRUT04iLCJGT0NVUyIsIkRBVEFfVE9HR0xFX0NBUlJPVCIsIkRBVEFfVE9HR0xFIiwiSU5QVVQiLCJGT0NVU19CTFVSX0RBVEFfQVBJIiwidG9nZ2xlIiwidHJpZ2dlckNoYW5nZUV2ZW50IiwiYWRkQXJpYVByZXNzZWQiLCJ0eXBlIiwiY2hlY2tlZCIsImFjdGl2ZUVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJ0b2dnbGVDbGFzcyIsImJ1dHRvbiIsIkNhcm91c2VsIiwiQVJST1dfTEVGVF9LRVlDT0RFIiwiQVJST1dfUklHSFRfS0VZQ09ERSIsIlRPVUNIRVZFTlRfQ09NUEFUX1dBSVQiLCJEZWZhdWx0IiwiaW50ZXJ2YWwiLCJrZXlib2FyZCIsInBhdXNlIiwid3JhcCIsIkRlZmF1bHRUeXBlIiwiRGlyZWN0aW9uIiwiTkVYVCIsIlBSRVYiLCJMRUZUIiwiUklHSFQiLCJTTElERSIsIlNMSUQiLCJLRVlET1dOIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJUT1VDSEVORCIsIkxPQURfREFUQV9BUEkiLCJDQVJPVVNFTCIsIklURU0iLCJBQ1RJVkVfSVRFTSIsIk5FWFRfUFJFViIsIklORElDQVRPUlMiLCJEQVRBX1NMSURFIiwiREFUQV9SSURFIiwiX2l0ZW1zIiwiX2ludGVydmFsIiwiX2FjdGl2ZUVsZW1lbnQiLCJfaXNQYXVzZWQiLCJfaXNTbGlkaW5nIiwidG91Y2hUaW1lb3V0IiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJuZXh0IiwiX3NsaWRlIiwibmV4dFdoZW5WaXNpYmxlIiwiaGlkZGVuIiwiY3ljbGUiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ2aXNpYmlsaXR5U3RhdGUiLCJ0byIsIl90aGlzMyIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsImRpcmVjdGlvbiIsIl90aGlzNCIsIl9rZXlkb3duIiwid2hpY2giLCJtYWtlQXJyYXkiLCJfZ2V0SXRlbUJ5RGlyZWN0aW9uIiwiaXNOZXh0RGlyZWN0aW9uIiwiaXNQcmV2RGlyZWN0aW9uIiwibGFzdEl0ZW1JbmRleCIsImlzR29pbmdUb1dyYXAiLCJkZWx0YSIsIml0ZW1JbmRleCIsIl90cmlnZ2VyU2xpZGVFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJldmVudERpcmVjdGlvbk5hbWUiLCJ0YXJnZXRJbmRleCIsImZyb21JbmRleCIsInNsaWRlRXZlbnQiLCJmcm9tIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJuZXh0SW5kaWNhdG9yIiwiX3RoaXM1IiwiYWN0aXZlRWxlbWVudEluZGV4IiwibmV4dEVsZW1lbnQiLCJuZXh0RWxlbWVudEluZGV4IiwiaXNDeWNsaW5nIiwiZGlyZWN0aW9uYWxDbGFzc05hbWUiLCJvcmRlckNsYXNzTmFtZSIsInNsaWRFdmVudCIsImFjdGlvbiIsIl9kYXRhQXBpQ2xpY2tIYW5kbGVyIiwic2xpZGVJbmRleCIsIiRjYXJvdXNlbCIsIkNvbGxhcHNlIiwiU0hPV04iLCJISURFIiwiSElEREVOIiwiQ09MTEFQU0UiLCJDT0xMQVBTSU5HIiwiQ09MTEFQU0VEIiwiRGltZW5zaW9uIiwiV0lEVEgiLCJIRUlHSFQiLCJBQ1RJVkVTIiwiX2lzVHJhbnNpdGlvbmluZyIsIl90cmlnZ2VyQXJyYXkiLCJ0YWJUb2dnbGVzIiwiX3BhcmVudCIsIl9nZXRQYXJlbnQiLCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiX3RoaXM2IiwiYWN0aXZlcyIsImFjdGl2ZXNEYXRhIiwic3RhcnRFdmVudCIsImRpbWVuc2lvbiIsIl9nZXREaW1lbnNpb24iLCJzZXRUcmFuc2l0aW9uaW5nIiwiY29tcGxldGUiLCJjYXBpdGFsaXplZERpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJfdGhpczciLCIkZWxlbSIsImlzVHJhbnNpdGlvbmluZyIsImhhc1dpZHRoIiwiX3RoaXM4IiwiX2dldFRhcmdldEZyb21FbGVtZW50IiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwiJHRyaWdnZXIiLCJEcm9wZG93biIsIkVTQ0FQRV9LRVlDT0RFIiwiU1BBQ0VfS0VZQ09ERSIsIlRBQl9LRVlDT0RFIiwiQVJST1dfVVBfS0VZQ09ERSIsIkFSUk9XX0RPV05fS0VZQ09ERSIsIlJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCIsIlJFR0VYUF9LRVlET1dOIiwiQ0xJQ0siLCJLRVlET1dOX0RBVEFfQVBJIiwiS0VZVVBfREFUQV9BUEkiLCJESVNBQkxFRCIsIkRST1BVUCIsIk1FTlVSSUdIVCIsIk1FTlVMRUZUIiwiRk9STV9DSElMRCIsIk1FTlUiLCJOQVZCQVJfTkFWIiwiVklTSUJMRV9JVEVNUyIsIkF0dGFjaG1lbnRNYXAiLCJUT1AiLCJUT1BFTkQiLCJCT1RUT00iLCJCT1RUT01FTkQiLCJfcG9wcGVyIiwiX21lbnUiLCJfZ2V0TWVudUVsZW1lbnQiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwiZGlzYWJsZWQiLCJfZ2V0UGFyZW50RnJvbUVsZW1lbnQiLCJpc0FjdGl2ZSIsIl9jbGVhck1lbnVzIiwic2hvd0V2ZW50IiwiX2dldFBvcHBlckNvbmZpZyIsIm5vb3AiLCJfdGhpczkiLCJzdG9wUHJvcGFnYXRpb24iLCJlbGVtZW50RGF0YSIsIl9nZXRQbGFjZW1lbnQiLCIkcGFyZW50RHJvcGRvd24iLCJwb3BwZXJDb25maWciLCJ0b2dnbGVzIiwiY29udGV4dCIsImRyb3Bkb3duTWVudSIsImhpZGVFdmVudCIsIl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJpdGVtcyIsIk1vZGFsIiwiQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiIsImJhY2tkcm9wIiwiRk9DVVNJTiIsIlJFU0laRSIsIkNMSUNLX0RJU01JU1MiLCJLRVlET1dOX0RJU01JU1MiLCJNT1VTRVVQX0RJU01JU1MiLCJNT1VTRURPV05fRElTTUlTUyIsIlNDUk9MTEJBUl9NRUFTVVJFUiIsIkJBQ0tEUk9QIiwiT1BFTiIsIkRJQUxPRyIsIkRBVEFfRElTTUlTUyIsIkZJWEVEX0NPTlRFTlQiLCJOQVZCQVJfVE9HR0xFUiIsIl9kaWFsb2ciLCJfYmFja2Ryb3AiLCJfaXNTaG93biIsIl9pc0JvZHlPdmVyZmxvd2luZyIsIl9pZ25vcmVCYWNrZHJvcENsaWNrIiwiX29yaWdpbmFsQm9keVBhZGRpbmciLCJfc2Nyb2xsYmFyV2lkdGgiLCJfdGhpczEwIiwiX2NoZWNrU2Nyb2xsYmFyIiwiX3NldFNjcm9sbGJhciIsIl9zZXRFc2NhcGVFdmVudCIsIl9zZXRSZXNpemVFdmVudCIsIl9zaG93QmFja2Ryb3AiLCJfc2hvd0VsZW1lbnQiLCJfdGhpczExIiwiX2hpZGVNb2RhbCIsImhhbmRsZVVwZGF0ZSIsIl9hZGp1c3REaWFsb2ciLCJfdGhpczEyIiwiRUxFTUVOVF9OT0RFIiwiYXBwZW5kQ2hpbGQiLCJkaXNwbGF5IiwiX2VuZm9yY2VGb2N1cyIsInNob3duRXZlbnQiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJfdGhpczEzIiwiaGFzIiwiX3RoaXMxNCIsIl90aGlzMTUiLCJfdGhpczE2IiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJfcmVzZXRTY3JvbGxiYXIiLCJfcmVtb3ZlQmFja2Ryb3AiLCJfdGhpczE3IiwiYW5pbWF0ZSIsImRvQW5pbWF0ZSIsImNsYXNzTmFtZSIsImN1cnJlbnRUYXJnZXQiLCJjYWxsYmFja1JlbW92ZSIsImlzTW9kYWxPdmVyZmxvd2luZyIsInNjcm9sbEhlaWdodCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiX2dldFNjcm9sbGJhcldpZHRoIiwiX3RoaXMxOCIsImFjdHVhbFBhZGRpbmciLCJjYWxjdWxhdGVkUGFkZGluZyIsImFjdHVhbE1hcmdpbiIsImNhbGN1bGF0ZWRNYXJnaW4iLCJtYXJnaW4iLCJzY3JvbGxEaXYiLCJzY3JvbGxiYXJXaWR0aCIsIl90aGlzMTkiLCJTY3JvbGxTcHkiLCJBQ1RJVkFURSIsIlNDUk9MTCIsIkRST1BET1dOX0lURU0iLCJEUk9QRE9XTl9NRU5VIiwiREFUQV9TUFkiLCJOQVZfTElTVF9HUk9VUCIsIk5BVl9MSU5LUyIsIkxJU1RfSVRFTVMiLCJEUk9QRE9XTiIsIkRST1BET1dOX0lURU1TIiwiRFJPUERPV05fVE9HR0xFIiwiT2Zmc2V0TWV0aG9kIiwiT0ZGU0VUIiwiUE9TSVRJT04iLCJfdGhpczIwIiwiX3Njcm9sbEVsZW1lbnQiLCJfc2VsZWN0b3IiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJfdGhpczIxIiwiYXV0b01ldGhvZCIsIm9mZnNldE1ldGhvZCIsIm9mZnNldEJhc2UiLCJfZ2V0U2Nyb2xsVG9wIiwiX2dldFNjcm9sbEhlaWdodCIsInRhcmdldHMiLCJ0YXJnZXRTZWxlY3RvciIsInRhcmdldEJDUiIsIml0ZW0iLCJwYWdlWU9mZnNldCIsIl9nZXRPZmZzZXRIZWlnaHQiLCJtYXhTY3JvbGwiLCJfYWN0aXZhdGUiLCJfY2xlYXIiLCJpc0FjdGl2ZVRhcmdldCIsInF1ZXJpZXMiLCIkbGluayIsInBhcmVudHMiLCJzY3JvbGxTcHlzIiwiJHNweSIsIlRhYiIsIkRST1BET1dOX0FDVElWRV9DSElMRCIsIl90aGlzMjIiLCJwcmV2aW91cyIsImxpc3RFbGVtZW50IiwiaGlkZGVuRXZlbnQiLCJjb250YWluZXIiLCJfdGhpczIzIiwiYWN0aXZlIiwiX3RyYW5zaXRpb25Db21wbGV0ZSIsImRyb3Bkb3duQ2hpbGQiLCJkcm9wZG93bkVsZW1lbnQiLCJUb29sdGlwIiwiQ0xBU1NfUFJFRklYIiwiQlNDTFNfUFJFRklYX1JFR0VYIiwiYW5pbWF0aW9uIiwidGVtcGxhdGUiLCJ0aXRsZSIsImRlbGF5IiwiZmFsbGJhY2tQbGFjZW1lbnQiLCJBVVRPIiwiSG92ZXJTdGF0ZSIsIk9VVCIsIklOU0VSVEVEIiwiRk9DVVNPVVQiLCJUT09MVElQIiwiVE9PTFRJUF9JTk5FUiIsIkFSUk9XIiwiVHJpZ2dlciIsIkhPVkVSIiwiTUFOVUFMIiwiX2lzRW5hYmxlZCIsIl90aW1lb3V0IiwiX2hvdmVyU3RhdGUiLCJfYWN0aXZlVHJpZ2dlciIsInRpcCIsIl9zZXRMaXN0ZW5lcnMiLCJlbmFibGUiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsImRhdGFLZXkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJfaXNXaXRoQWN0aXZlVHJpZ2dlciIsIl9lbnRlciIsIl9sZWF2ZSIsImdldFRpcEVsZW1lbnQiLCJfdGhpczI0IiwiaXNXaXRoQ29udGVudCIsImlzSW5UaGVEb20iLCJvd25lckRvY3VtZW50IiwidGlwSWQiLCJzZXRDb250ZW50IiwiYXR0YWNobWVudCIsIl9nZXRBdHRhY2htZW50IiwiYWRkQXR0YWNobWVudENsYXNzIiwiX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSIsIl9maXhUcmFuc2l0aW9uIiwicHJldkhvdmVyU3RhdGUiLCJfVFJBTlNJVElPTl9EVVJBVElPTiIsIl90aGlzMjUiLCJfY2xlYW5UaXBDbGFzcyIsImdldFRpdGxlIiwiJHRpcCIsInNldEVsZW1lbnRDb250ZW50IiwiY29udGVudCIsImVtcHR5IiwiX3RoaXMyNiIsInRyaWdnZXJzIiwiZXZlbnRJbiIsImV2ZW50T3V0IiwiX2ZpeFRpdGxlIiwidGl0bGVUeXBlIiwidGFiQ2xhc3MiLCJpbml0Q29uZmlnQW5pbWF0aW9uIiwiUG9wb3ZlciIsIlRJVExFIiwiQ09OVEVOVCIsIl9Ub29sdGlwIiwiX2dldENvbnRlbnQiLCJyZSIsImNoIiwiciIsIkRFRkFVTFRTIiwic2VsZWN0cGlja2VyIiwiRnVuY3Rpb24iLCJpbmNsdWRlcyIsInN0YXJ0c1dpdGgiLCJjaGFyQ29kZUF0IiwidXNlRGVmYXVsdCIsIl9zZXQiLCJ2YWxIb29rcyIsInNldCIsInRyaWdnZXJOYXRpdmUiLCJleHByIiwicHNldWRvcyIsImljb250YWlucyIsImliZWdpbnMiLCJhaWNvbnRhaW5zIiwiYWliZWdpbnMiLCIkbmV3RWxlbWVudCIsIiRidXR0b24iLCIkbWVudSIsIiRsaXMiLCJ3aW5kb3dQYWRkaW5nIiwicmVuZGVyIiwic2V0U3R5bGUiLCJzZWxlY3RBbGwiLCJkZXNlbGVjdEFsbCIsImluaXQiLCJub25lU2VsZWN0ZWRUZXh0Iiwibm9uZVJlc3VsdHNUZXh0IiwiY291bnRTZWxlY3RlZFRleHQiLCJtYXhPcHRpb25zVGV4dCIsInNlbGVjdEFsbFRleHQiLCJkZXNlbGVjdEFsbFRleHQiLCJkb25lQnV0dG9uIiwiZG9uZUJ1dHRvblRleHQiLCJtdWx0aXBsZVNlcGFyYXRvciIsInN0eWxlQmFzZSIsInNlbGVjdGVkVGV4dEZvcm1hdCIsImhpZGVEaXNhYmxlZCIsInNob3dTdWJ0ZXh0Iiwic2hvd0ljb24iLCJzaG93Q29udGVudCIsImRyb3B1cEF1dG8iLCJoZWFkZXIiLCJsaXZlU2VhcmNoIiwibGl2ZVNlYXJjaFBsYWNlaG9sZGVyIiwibGl2ZVNlYXJjaE5vcm1hbGl6ZSIsImxpdmVTZWFyY2hTdHlsZSIsImFjdGlvbnNCb3giLCJpY29uQmFzZSIsInRpY2tJY29uIiwic2hvd1RpY2siLCJjYXJldCIsIm1heE9wdGlvbnMiLCJtb2JpbGUiLCJzZWxlY3RPblRhYiIsImRyb3Bkb3duQWxpZ25SaWdodCIsImxpT2JqIiwibXVsdGlwbGUiLCJhdXRvZm9jdXMiLCJjcmVhdGVWaWV3IiwiYWZ0ZXIiLCIkbWVudUlubmVyIiwiJHNlYXJjaGJveCIsImNoZWNrRGlzYWJsZWQiLCJjbGlja0xpc3RlbmVyIiwibGl2ZVNlYXJjaExpc3RlbmVyIiwic2V0V2lkdGgiLCJzZWxlY3RQb3NpdGlvbiIsInZhbGlkaXR5IiwidmFsaWQiLCJjcmVhdGVEcm9wZG93biIsImNyZWF0ZUxpIiwiaW5uZXJIVE1MIiwicmVsb2FkTGkiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwic2VsZWN0ZWRJbmRleCIsInAiLCJ1IiwiY3NzVGV4dCIsImciLCJ2IiwidyIsIkMiLCJTIiwiSSIsIlQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiRSIsImVxIiwiZmluZExpcyIsInNldERpc2FibGVkIiwic2V0U2VsZWN0ZWQiLCJ0b2dnbGVQbGFjZWhvbGRlciIsInRhYkluZGV4IiwidG9BcnJheSIsImxpSGVpZ2h0Iiwic2l6ZUluZm8iLCJjbG9uZU5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm91dGVySGVpZ2h0IiwidmVydCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJob3JpeiIsImJvcmRlclJpZ2h0V2lkdGgiLCJoZWFkZXJIZWlnaHQiLCJzZWFyY2hIZWlnaHQiLCJhY3Rpb25zSGVpZ2h0IiwiZG9uZUJ1dHRvbkhlaWdodCIsImRpdmlkZXJIZWlnaHQiLCJtZW51UGFkZGluZyIsIm1lbnVFeHRyYXMiLCJzZXRTaXplIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJsYXN0IiwiY2xvbmUiLCIkYnNDb250YWluZXIiLCJpc0Rpc2FibGVkIiwicmVtb3ZlQXR0ciIsIm9mZnNldFRvcCIsIl9zZWFyY2hTdHlsZSIsImJlZ2lucyIsImNoYW5nZUFsbCIsImtleWRvd24iLCJkZWZpbmUiLCJDaGFydCIsImNvZGUiLCJjb2xvck5hbWVzIiwiZ2V0UmdiYSIsImdldEhzbGEiLCJnZXRSZ2IiLCJnZXRIc2wiLCJnZXRId2IiLCJnZXRBbHBoYSIsImhleFN0cmluZyIsInJnYlN0cmluZyIsInJnYmFTdHJpbmciLCJwZXJjZW50U3RyaW5nIiwicGVyY2VudGFTdHJpbmciLCJoc2xTdHJpbmciLCJoc2xhU3RyaW5nIiwiaHdiU3RyaW5nIiwia2V5d29yZCIsInN0cmluZyIsImFiYnIiLCJoZXgiLCJyZ2JhIiwicGVyIiwicmdiIiwic2NhbGUiLCJoc2wiLCJhbHBoYSIsImh3YiIsImhzbGEiLCJ2YWxzIiwiaGV4RG91YmxlIiwicmV2ZXJzZU5hbWVzIiwibnVtIiwiY29udmVydCIsIkNvbG9yIiwidmFsdWVzIiwiaHN2IiwiY215ayIsInNldFZhbHVlcyIsInJlZCIsImxpZ2h0bmVzcyIsIndoaXRlbmVzcyIsImN5YW4iLCJzZXRTcGFjZSIsInJnYkFycmF5IiwiaHNsQXJyYXkiLCJoc3ZBcnJheSIsImh3YkFycmF5IiwiY215a0FycmF5IiwicmdiYUFycmF5IiwiaHNsYUFycmF5Iiwic2V0Q2hhbm5lbCIsImdyZWVuIiwiYmx1ZSIsImh1ZSIsInNhdHVyYXRpb24iLCJzYXR1cmF0aW9udiIsImJsYWNrbmVzcyIsIm1hZ2VudGEiLCJ5ZWxsb3ciLCJibGFjayIsInJnYk51bWJlciIsImx1bWlub3NpdHkiLCJsdW0iLCJjaGFuIiwicG93IiwiY29udHJhc3QiLCJjb2xvcjIiLCJsdW0xIiwibHVtMiIsImxldmVsIiwiY29udHJhc3RSYXRpbyIsImRhcmsiLCJ5aXEiLCJsaWdodCIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJyYXRpbyIsImRhcmtlbiIsInNhdHVyYXRlIiwiZGVzYXR1cmF0ZSIsIndoaXRlbiIsImJsYWNrZW4iLCJncmV5c2NhbGUiLCJjbGVhcmVyIiwib3BhcXVlciIsInJvdGF0ZSIsImRlZ3JlZXMiLCJtaXgiLCJtaXhpbkNvbG9yIiwid2VpZ2h0IiwiY29sb3IxIiwidzEiLCJ3MiIsInRvSlNPTiIsInNwYWNlcyIsIm1heGVzIiwiZ2V0VmFsdWVzIiwic3BhY2UiLCJjaGFucyIsImNhcHBlZCIsInNuYW1lIiwiYXJncyIsInN2YWx1ZXMiLCJyZ2IyaHNsIiwicmdiMmhzdiIsInJnYjJod2IiLCJyZ2IyY215ayIsInJnYjJrZXl3b3JkIiwicmdiMnh5eiIsInJnYjJsYWIiLCJyZ2IybGNoIiwiaHNsMnJnYiIsImhzbDJoc3YiLCJoc2wyaHdiIiwiaHNsMmNteWsiLCJoc2wya2V5d29yZCIsImhzdjJyZ2IiLCJoc3YyaHNsIiwiaHN2Mmh3YiIsImhzdjJjbXlrIiwiaHN2MmtleXdvcmQiLCJod2IycmdiIiwiaHdiMmhzbCIsImh3YjJoc3YiLCJod2IyY215ayIsImh3YjJrZXl3b3JkIiwiY215azJyZ2IiLCJjbXlrMmhzbCIsImNteWsyaHN2IiwiY215azJod2IiLCJjbXlrMmtleXdvcmQiLCJrZXl3b3JkMnJnYiIsImtleXdvcmQyaHNsIiwia2V5d29yZDJoc3YiLCJrZXl3b3JkMmh3YiIsImtleXdvcmQyY215ayIsImtleXdvcmQybGFiIiwia2V5d29yZDJ4eXoiLCJ4eXoycmdiIiwieHl6MmxhYiIsInh5ejJsY2giLCJsYWIyeHl6IiwibGFiMnJnYiIsImxhYjJsY2giLCJsY2gybGFiIiwibGNoMnh5eiIsImxjaDJyZ2IiLCJyZXZlcnNlS2V5d29yZHMiLCJKU09OIiwic3RyaW5naWZ5IiwieHl6IiwidDEiLCJ0MiIsInQzIiwic3YiLCJoaSIsInEiLCJzbCIsIndoIiwiYmwiLCJsYWIiLCJ5MiIsImhyIiwiYXRhbjIiLCJQSSIsInNxcnQiLCJsY2giLCJjb3MiLCJzaW4iLCJjc3NLZXl3b3JkcyIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW55ZWxsb3ciLCJncmV5IiwiaG9uZXlkZXciLCJob3RwaW5rIiwiaW5kaWFucmVkIiwiaW5kaWdvIiwiaXZvcnkiLCJraGFraSIsImxhdmVuZGVyIiwibGF2ZW5kZXJibHVzaCIsImxhd25ncmVlbiIsImxlbW9uY2hpZmZvbiIsImxpZ2h0Ymx1ZSIsImxpZ2h0Y29yYWwiLCJsaWdodGN5YW4iLCJsaWdodGdvbGRlbnJvZHllbGxvdyIsImxpZ2h0Z3JheSIsImxpZ2h0Z3JlZW4iLCJsaWdodGdyZXkiLCJsaWdodHBpbmsiLCJsaWdodHNhbG1vbiIsImxpZ2h0c2VhZ3JlZW4iLCJsaWdodHNreWJsdWUiLCJsaWdodHNsYXRlZ3JheSIsImxpZ2h0c2xhdGVncmV5IiwibGlnaHRzdGVlbGJsdWUiLCJsaWdodHllbGxvdyIsImxpbWUiLCJsaW1lZ3JlZW4iLCJsaW5lbiIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93Z3JlZW4iLCJjb252ZXJzaW9ucyIsIkNvbnZlcnRlciIsImZ1bmMiLCJhcmciLCJwYWlyIiwiZXhlYyIsImNvbnZzIiwicm91dGVTcGFjZSIsImZzcGFjZSIsImhlbHBlcnMiLCJFbGVtZW50IiwiZWxlbWVudHMiLCJJbnRlcmFjdGlvbiIsInBsYXRmb3JtIiwicGx1Z2lucyIsInJlZ2lzdGVyIiwiaW5pdGlhbGl6ZSIsImNhbnZhc0hlbHBlcnMiLCJjYW52YXMiLCJCYXIiLCJCdWJibGUiLCJEb3VnaG51dCIsIkxpbmUiLCJQb2xhckFyZWEiLCJSYWRhciIsIlNjYXR0ZXIiLCJob3ZlciIsIm1vZGUiLCJzY2FsZXMiLCJ4QXhlcyIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJncmlkTGluZXMiLCJvZmZzZXRHcmlkTGluZXMiLCJ5QXhlcyIsInJlY3RhbmdsZSIsImJvcmRlclNraXBwZWQiLCJ0b29sdGlwcyIsImNhbGxiYWNrcyIsInlMYWJlbCIsImxhYmVscyIsImRhdGFzZXRMYWJlbCIsImRhdGFzZXRzIiwiZGF0YXNldEluZGV4IiwieExhYmVsIiwiY29udHJvbGxlcnMiLCJiYXIiLCJEYXRhc2V0Q29udHJvbGxlciIsImRhdGFFbGVtZW50VHlwZSIsIlJlY3RhbmdsZSIsIm1lIiwibWV0YSIsImdldE1ldGEiLCJzdGFjayIsImdldERhdGFzZXQiLCJyZXNldCIsImlsZW4iLCJfcnVsZXIiLCJnZXRSdWxlciIsInVwZGF0ZUVsZW1lbnQiLCJjaGFydCIsImRhdGFzZXQiLCJjdXN0b20iLCJyZWN0YW5nbGVPcHRpb25zIiwiX3hTY2FsZSIsImdldFNjYWxlRm9ySWQiLCJ4QXhpc0lEIiwiX3lTY2FsZSIsInlBeGlzSUQiLCJfZGF0YXNldEluZGV4IiwiX2luZGV4IiwiX21vZGVsIiwiYmFja2dyb3VuZENvbG9yIiwidmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsInVwZGF0ZUVsZW1lbnRHZW9tZXRyeSIsInBpdm90IiwibW9kZWwiLCJ2c2NhbGUiLCJnZXRWYWx1ZVNjYWxlIiwiZ2V0QmFzZVBpeGVsIiwiaG9yaXpvbnRhbCIsImlzSG9yaXpvbnRhbCIsInJ1bGVyIiwidnBpeGVscyIsImNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsImNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwiaGVhZCIsImdldFZhbHVlU2NhbGVJZCIsImdldEluZGV4U2NhbGVJZCIsImdldEluZGV4U2NhbGUiLCJnZXRTdGFja0NvdW50Iiwic3RhY2tlZCIsInN0YWNrcyIsImdldERhdGFzZXRNZXRhIiwiaXNEYXRhc2V0VmlzaWJsZSIsImdldFN0YWNrSW5kZXgiLCJzdGFja0NvdW50IiwicGl4ZWxzIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsImdldFJpZ2h0VmFsdWUiLCJpbWV0YSIsIml2YWx1ZSIsImNvbnRyb2xsZXIiLCJzdGFja0luZGV4IiwibGVmdFNhbXBsZVNpemUiLCJyaWdodFNhbXBsZVNpemUiLCJsZWZ0Q2F0ZWdvcnlTaXplIiwicmlnaHRDYXRlZ29yeVNpemUiLCJmdWxsQmFyU2l6ZSIsInZhbHVlT3JEZWZhdWx0IiwiYmFyVGhpY2tuZXNzIiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJkcmF3IiwiY2xpcEFyZWEiLCJjdHgiLCJjaGFydEFyZWEiLCJ1bmNsaXBBcmVhIiwic2V0SG92ZXJTdHlsZSIsImhvdmVyQmFja2dyb3VuZENvbG9yIiwiZ2V0SG92ZXJDb2xvciIsImhvdmVyQm9yZGVyQ29sb3IiLCJob3ZlckJvcmRlcldpZHRoIiwicmVtb3ZlSG92ZXJTdHlsZSIsInJlY3RhbmdsZUVsZW1lbnRPcHRpb25zIiwiaG9yaXpvbnRhbEJhciIsImRhdGFQb2ludCIsImJ1YmJsZSIsIlBvaW50IiwicG9pbnRzIiwicG9pbnQiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZHNJbmRleCIsImdldFBpeGVsRm9yRGVjaW1hbCIsIk5hTiIsIl9vcHRpb25zIiwiaGl0UmFkaXVzIiwicG9pbnRTdHlsZSIsInJhZGl1cyIsInNraXAiLCJob3ZlclJhZGl1cyIsImRhdGFJbmRleCIsImFuaW1hdGVSb3RhdGUiLCJhbmltYXRlU2NhbGUiLCJsZWdlbmRDYWxsYmFjayIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwiZHMiLCJhcmMiLCJhcmNPcHRzIiwiZmlsbCIsInN0cm9rZSIsImJ3IiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJvbkNsaWNrIiwibGVnZW5kSXRlbSIsImN1dG91dFBlcmNlbnRhZ2UiLCJyb3RhdGlvbiIsImNpcmN1bWZlcmVuY2UiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImlzQXJyYXkiLCJkb3VnaG51dCIsInBpZSIsIkFyYyIsImxpbmtTY2FsZXMiLCJnZXRSaW5nSW5kZXgiLCJyaW5nSW5kZXgiLCJqIiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJtaW5TaXplIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiY29udGFpbnMwIiwiY29udGFpbnM5MCIsImNvbnRhaW5zMTgwIiwiY29udGFpbnMyNzAiLCJjdXRvdXQiLCJnZXRNYXhCb3JkZXJXaWR0aCIsIm91dGVyUmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJyYWRpdXNMZW5ndGgiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJ0b3RhbCIsImNhbGN1bGF0ZVRvdGFsIiwiYW5pbWF0aW9uT3B0cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImFyY3MiLCJob3ZlcldpZHRoIiwiX2NoYXJ0Iiwic2hvd0xpbmVzIiwic3BhbkdhcHMiLCJsaW5lRW5hYmxlZCIsInNob3dMaW5lIiwibGluZSIsImRhdGFzZXRFbGVtZW50VHlwZSIsImxpbmVFbGVtZW50T3B0aW9ucyIsInRlbnNpb24iLCJsaW5lVGVuc2lvbiIsIl9zY2FsZSIsIl9jaGlsZHJlbiIsImJvcmRlckNhcFN0eWxlIiwiYm9yZGVyRGFzaCIsImJvcmRlckRhc2hPZmZzZXQiLCJib3JkZXJKb2luU3R5bGUiLCJzdGVwcGVkTGluZSIsInN0ZXBwZWQiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwidXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImdldFBvaW50QmFja2dyb3VuZENvbG9yIiwicG9pbnRCYWNrZ3JvdW5kQ29sb3IiLCJnZXRQb2ludEJvcmRlckNvbG9yIiwicG9pbnRCb3JkZXJDb2xvciIsImdldFBvaW50Qm9yZGVyV2lkdGgiLCJwb2ludEJvcmRlcldpZHRoIiwicG9pbnRPcHRpb25zIiwicG9pbnRSYWRpdXMiLCJwb2ludEhpdFJhZGl1cyIsImNhbGN1bGF0ZVBvaW50WSIsInN1bVBvcyIsInN1bU5lZyIsImRzTWV0YSIsInN0YWNrZWRSaWdodFZhbHVlIiwicmlnaHRWYWx1ZSIsImNvbnRyb2xQb2ludHMiLCJwdCIsImNhcENvbnRyb2xQb2ludCIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJzcGxpbmVDdXJ2ZSIsInByZXZpb3VzSXRlbSIsIm5leHRJdGVtIiwiY29udHJvbFBvaW50UHJldmlvdXNYIiwiY29udHJvbFBvaW50UHJldmlvdXNZIiwiY29udHJvbFBvaW50TmV4dFgiLCJjb250cm9sUG9pbnROZXh0WSIsImNhcEJlemllclBvaW50cyIsInBvaW50SG92ZXJSYWRpdXMiLCJwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yIiwicG9pbnRIb3ZlckJvcmRlckNvbG9yIiwicG9pbnRIb3ZlckJvcmRlcldpZHRoIiwiYW5nbGVMaW5lcyIsImNpcmN1bGFyIiwicG9pbnRMYWJlbHMiLCJ0aWNrcyIsImJlZ2luQXRaZXJvIiwicG9sYXJBcmVhIiwiY291bnQiLCJjb3VudFZpc2libGVFbGVtZW50cyIsInhDZW50ZXIiLCJ5Q2VudGVyIiwidmlzaWJsZUNvdW50IiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJkaXN0YW5jZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwicmVzZXRSYWRpdXMiLCJyYWRhciIsIl9sb29wIiwicG9pbnRFbGVtZW50T3B0aW9ucyIsInBvaW50UG9zaXRpb24iLCJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCJzY2F0dGVyIiwiZWFzaW5nIiwib25Qcm9ncmVzcyIsIm9uQ29tcGxldGUiLCJBbmltYXRpb24iLCJjdXJyZW50U3RlcCIsIm51bVN0ZXBzIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uQW5pbWF0aW9uQ29tcGxldGUiLCJhbmltYXRpb25TZXJ2aWNlIiwiZnJhbWVEdXJhdGlvbiIsImFuaW1hdGlvbnMiLCJkcm9wRnJhbWVzIiwicmVxdWVzdCIsImFkZEFuaW1hdGlvbiIsImxhenkiLCJhbmltYXRpbmciLCJjYW5jZWxBbmltYXRpb24iLCJyZXF1ZXN0QW5pbUZyYW1lIiwic3RhcnREaWdlc3QiLCJmcmFtZXNUb0Ryb3AiLCJhZHZhbmNlIiwidHlwZXMiLCJpbnN0YW5jZXMiLCJpbml0Q29uZmlnIiwiY29uZmlnTWVyZ2UiLCJ1cGRhdGVDb25maWciLCJuZXdPcHRpb25zIiwic2NhbGVPcHRpb25zIiwidG9vbHRpcCIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiY29uc3RydWN0IiwiYWNxdWlyZUNvbnRleHQiLCJ1aWQiLCJhc3BlY3RSYXRpbyIsIl9idWZmZXJlZFJlbmRlciIsIm5vdGlmeSIsInJldGluYVNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJpbmRFdmVudHMiLCJyZXNwb25zaXZlIiwicmVzaXplIiwiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsImJ1aWxkU2NhbGVzIiwiaW5pdFRvb2xUaXAiLCJjbGVhciIsInNpbGVudCIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJnZXRNYXhpbXVtV2lkdGgiLCJuZXdIZWlnaHQiLCJnZXRNYXhpbXVtSGVpZ2h0IiwibmV3U2l6ZSIsIm9uUmVzaXplIiwicmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uIiwic2NhbGVzT3B0aW9ucyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsImR0eXBlIiwiZHBvc2l0aW9uIiwiaXNEZWZhdWx0Iiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsInNjYWxlU2VydmljZSIsImdldFNjYWxlQ29uc3RydWN0b3IiLCJtZXJnZVRpY2tzT3B0aW9ucyIsImFkZFNjYWxlc1RvTGF5b3V0IiwiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwibmV3Q29udHJvbGxlcnMiLCJkZXN0cm95RGF0YXNldE1ldGEiLCJ1cGRhdGVJbmRleCIsIkNvbnRyb2xsZXJDbGFzcyIsInJlc2V0RWxlbWVudHMiLCJfZGF0YSIsImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsInVwZGF0ZUxheW91dCIsInVwZGF0ZURhdGFzZXRzIiwiX2J1ZmZlcmVkUmVxdWVzdCIsImxheW91dFNlcnZpY2UiLCJ1cGRhdGVEYXRhc2V0IiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbk9iamVjdCIsImVhc2luZ0Z1bmN0aW9uIiwiZWZmZWN0cyIsInN0ZXBEZWNpbWFsIiwiZWFzaW5nVmFsdWUiLCJpc051bGxPclVuZGVmIiwiYm94ZXMiLCJib3giLCJkcmF3RGF0YXNldHMiLCJkcmF3RGF0YXNldCIsImdldEVsZW1lbnRBdEV2ZW50IiwibW9kZXMiLCJzaW5nbGUiLCJnZXRFbGVtZW50c0F0RXZlbnQiLCJpbnRlcnNlY3QiLCJnZXRFbGVtZW50c0F0WEF4aXMiLCJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwiZ2V0RGF0YXNldEF0RXZlbnQiLCJfbWV0YSIsImdlbmVyYXRlTGVnZW5kIiwidW5iaW5kRXZlbnRzIiwicmVsZWFzZUNvbnRleHQiLCJ0b0Jhc2U2NEltYWdlIiwidG9EYXRhVVJMIiwiX2NoYXJ0SW5zdGFuY2UiLCJsaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwibGlzdGVuZXIiLCJldmVudEhhbmRsZXIiLCJldmVudHMiLCJ1cGRhdGVIb3ZlclN0eWxlIiwiaGFuZGxlRXZlbnQiLCJidWZmZXJlZFJlcXVlc3QiLCJhbmltYXRpb25EdXJhdGlvbiIsImhvdmVyT3B0aW9ucyIsImxhc3RBY3RpdmUiLCJvbkhvdmVyIiwibmF0aXZlIiwiYXJyYXlFcXVhbHMiLCJDb250cm9sbGVyIiwiYXJyYXlFdmVudHMiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImFycmF5IiwiX2NoYXJ0anMiLCJyZXMiLCJvYmplY3QiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsImFkZEVsZW1lbnRzIiwic2NhbGVJRCIsImNyZWF0ZU1ldGFEYXRhc2V0IiwiY3JlYXRlTWV0YURhdGEiLCJtZXRhRGF0YSIsImFkZEVsZW1lbnRBbmRSZXNldCIsInJlc3luY0VsZW1lbnRzIiwiZWxlbWVudE9wdHMiLCJudW1NZXRhIiwibnVtRGF0YSIsImluc2VydEVsZW1lbnRzIiwib25EYXRhUHVzaCIsIm9uRGF0YVBvcCIsIm9uRGF0YVNoaWZ0Iiwib25EYXRhU3BsaWNlIiwib25EYXRhVW5zaGlmdCIsImluaGVyaXRzIiwic2NvcGUiLCJjb2xvciIsImludGVycG9sYXRlIiwidmlldyIsImVhc2UiLCJhY3R1YWwiLCJvcmlnaW4iLCJjMCIsImMxIiwiY29uZmlndXJhdGlvbiIsIl92aWV3IiwiX3N0YXJ0IiwidG9vbHRpcFBvc2l0aW9uIiwiaGFzVmFsdWUiLCJpc051bWJlciIsInNldEZuIiwibWVyZ2VyIiwidHZhbCIsInN2YWwiLCJzY2FsZU1lcmdlIiwiZ2V0U2NhbGVEZWZhdWx0cyIsIl9tZXJnZXIiLCJzbGVuIiwid2hlcmUiLCJjb2xsZWN0aW9uIiwiZmlsdGVyQ2FsbGJhY2siLCJmaWx0ZXJlZCIsImZpbmROZXh0V2hlcmUiLCJhcnJheVRvU2VhcmNoIiwic3RhcnRJbmRleCIsImN1cnJlbnRJdGVtIiwiZmluZFByZXZpb3VzV2hlcmUiLCJleHRlbnNpb25zIiwiQ2hhcnRFbGVtZW50IiwiU3Vycm9nYXRlIiwiX19zdXBlcl9fIiwiYWxtb3N0RXF1YWxzIiwiZXBzaWxvbiIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJzaWduIiwibG9nMTAiLCJMTjEwIiwidG9SYWRpYW5zIiwidG9EZWdyZWVzIiwicmFkaWFucyIsImdldEFuZ2xlRnJvbVBvaW50IiwiY2VudHJlUG9pbnQiLCJhbmdsZVBvaW50IiwiZGlzdGFuY2VGcm9tWENlbnRlciIsImRpc3RhbmNlRnJvbVlDZW50ZXIiLCJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJhbmdsZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsImFsaWFzUGl4ZWwiLCJwaXhlbFdpZHRoIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsImN1cnJlbnQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwiRVBTSUxPTiIsInBvaW50c1dpdGhUYW5nZW50cyIsImRlbHRhSyIsIm1LIiwicG9pbnRzTGVuIiwicG9pbnRCZWZvcmUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwic2xvcGVEZWx0YVgiLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwiZGVsdGFYIiwibG9vcCIsIm5pY2VOdW0iLCJleHBvbmVudCIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsImV2dCIsIm1vdXNlWCIsIm1vdXNlWSIsIm9yaWdpbmFsRXZlbnQiLCJzcmNFbGVtZW50IiwiYm91bmRpbmdSZWN0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwiZ2V0U3R5bGUiLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsInBhcnNlTWF4U3R5bGUiLCJzdHlsZVZhbHVlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiaXNDb25zdHJhaW5lZFZhbHVlIiwiZ2V0Q29uc3RyYWludERpbWVuc2lvbiIsImRvbU5vZGUiLCJtYXhTdHlsZSIsInBlcmNlbnRhZ2VQcm9wZXJ0eSIsImRlZmF1bHRWaWV3IiwiY29uc3RyYWluZWROb2RlIiwiY29uc3RyYWluZWRDb250YWluZXIiLCJoYXNDTm9kZSIsImhhc0NDb250YWluZXIiLCJpbmZpbml0eSIsImdldENvbnN0cmFpbnRXaWR0aCIsImdldENvbnN0cmFpbnRIZWlnaHQiLCJjdyIsImN1cnJlbnRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJmb3JjZVJhdGlvIiwicGl4ZWxSYXRpbyIsImZvbnRTdHJpbmciLCJwaXhlbFNpemUiLCJmb250U3R5bGUiLCJmb250RmFtaWx5IiwibG9uZ2VzdFRleHQiLCJmb250IiwiYXJyYXlPZlRoaW5ncyIsImNhY2hlIiwiZ2MiLCJnYXJiYWdlQ29sbGVjdCIsImxvbmdlc3QiLCJ0aGluZyIsIm1lYXN1cmVUZXh0IiwibmVzdGVkVGhpbmciLCJnY0xlbiIsInRleHRXaWR0aCIsIm51bWJlck9mTGFiZWxMaW5lcyIsIm51bWJlck9mTGluZXMiLCJDYW52YXNHcmFkaWVudCIsImRlZmF1bHRDb2xvciIsImNvbG9yVmFsdWUiLCJDYW52YXNQYXR0ZXJuIiwicGFyc2VWaXNpYmxlSXRlbXMiLCJqbGVuIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJpblJhbmdlIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiZGlzdGFuY2VNZXRyaWMiLCJtaW5EaXN0YW5jZSIsIm5lYXJlc3RJdGVtcyIsImdldENlbnRlclBvaW50IiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJkZWx0YVkiLCJpbmRleE1vZGUiLCJuZWFyZXN0Iiwic2l6ZUEiLCJzaXplQiIsImludGVyc2VjdHNJdGVtIiwiaW5YUmFuZ2UiLCJpbllSYW5nZSIsImRlZmF1bHRGb250Q29sb3IiLCJkZWZhdWx0Rm9udEZhbWlseSIsImRlZmF1bHRGb250U2l6ZSIsImRlZmF1bHRGb250U3R5bGUiLCJsYXlvdXQiLCJmaWx0ZXJCeVBvc2l0aW9uIiwic29ydEJ5V2VpZ2h0IiwiX3RtcEluZGV4XyIsInYwIiwidjEiLCJhZGRCb3giLCJmdWxsV2lkdGgiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwiY29uZmlndXJlIiwibGF5b3V0T3B0aW9ucyIsInRvUGFkZGluZyIsImxlZnRQYWRkaW5nIiwicmlnaHRQYWRkaW5nIiwidG9wUGFkZGluZyIsImJvdHRvbVBhZGRpbmciLCJsZWZ0Qm94ZXMiLCJyaWdodEJveGVzIiwidG9wQm94ZXMiLCJib3R0b21Cb3hlcyIsImNoYXJ0QXJlYUJveGVzIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwiY2hhcnRBcmVhV2lkdGgiLCJjaGFydEFyZWFIZWlnaHQiLCJ2ZXJ0aWNhbEJveFdpZHRoIiwiaG9yaXpvbnRhbEJveEhlaWdodCIsIm1heENoYXJ0QXJlYVdpZHRoIiwibWF4Q2hhcnRBcmVhSGVpZ2h0IiwibWluQm94U2l6ZXMiLCJnZXRNaW5pbXVtQm94U2l6ZSIsIm1heEhvcml6b250YWxMZWZ0UGFkZGluZyIsIm1heEhvcml6b250YWxSaWdodFBhZGRpbmciLCJtYXhWZXJ0aWNhbFRvcFBhZGRpbmciLCJtYXhWZXJ0aWNhbEJvdHRvbVBhZGRpbmciLCJob3Jpem9udGFsQm94IiwiZ2V0UGFkZGluZyIsImJveFBhZGRpbmciLCJ2ZXJ0aWNhbEJveCIsInRvdGFsTGVmdEJveGVzV2lkdGgiLCJ0b3RhbFJpZ2h0Qm94ZXNXaWR0aCIsInRvdGFsVG9wQm94ZXNIZWlnaHQiLCJ0b3RhbEJvdHRvbUJveGVzSGVpZ2h0IiwiZml0Qm94IiwibWluQm94U2l6ZSIsIm1pbkJveCIsInNjYWxlTWFyZ2luIiwiZmluYWxGaXRWZXJ0aWNhbEJveCIsImxlZnRQYWRkaW5nQWRkaXRpb24iLCJ0b3BQYWRkaW5nQWRkaXRpb24iLCJuZXdNYXhDaGFydEFyZWFIZWlnaHQiLCJuZXdNYXhDaGFydEFyZWFXaWR0aCIsInBsYWNlQm94IiwiX3BsdWdpbnMiLCJfY2FjaGVJZCIsInBsdWdpbiIsInVucmVnaXN0ZXIiLCJnZXRBbGwiLCJob29rIiwiZGVzY3JpcHRvcnMiLCJwYXJhbXMiLCJwbHVnaW5TZXJ2aWNlIiwiUGx1Z2luQmFzZSIsIlRpY2tzIiwiZHJhd0JvcmRlciIsImRyYXdPbkNoYXJ0QXJlYSIsImRyYXdUaWNrcyIsInRpY2tNYXJrTGVuZ3RoIiwiemVyb0xpbmVXaWR0aCIsInplcm9MaW5lQ29sb3IiLCJ6ZXJvTGluZUJvcmRlckRhc2giLCJ6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQiLCJzY2FsZUxhYmVsIiwibGFiZWxTdHJpbmciLCJsaW5lSGVpZ2h0IiwibWluUm90YXRpb24iLCJtYXhSb3RhdGlvbiIsIm1pcnJvciIsImF1dG9Ta2lwIiwiYXV0b1NraXBQYWRkaW5nIiwibGFiZWxPZmZzZXQiLCJmb3JtYXR0ZXJzIiwibWlub3IiLCJtYWpvciIsImxhYmVsc0Zyb21UaWNrcyIsImdldExpbmVWYWx1ZSIsImxpbmVWYWx1ZSIsImdldFBpeGVsRm9yVGljayIsImNvbXB1dGVUZXh0U2l6ZSIsInRpY2siLCJwYXJzZUZvbnRPcHRpb25zIiwiZ2xvYmFsRGVmYXVsdHMiLCJmb250U2l6ZSIsImZhbWlseSIsInBhcnNlTGluZUhlaWdodCIsInRvTGluZUhlaWdodCIsIlNjYWxlIiwiZ2V0VGlja3MiLCJfdGlja3MiLCJiZWZvcmVVcGRhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1hcmdpbnMiLCJsb25nZXN0VGV4dENhY2hlIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiY29udmVydFRpY2tzVG9MYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInRpY2tPcHRzIiwidXNlckNhbGxiYWNrIiwidGlja0ZvbnQiLCJsYWJlbFJvdGF0aW9uIiwib3JpZ2luYWxMYWJlbFdpZHRoIiwibGFiZWxXaWR0aCIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJ0aWNrV2lkdGgiLCJhbmdsZVJhZGlhbnMiLCJzY2FsZUxhYmVsT3B0cyIsImdyaWRMaW5lT3B0cyIsImlzRnVsbFdpZHRoIiwic2NhbGVMYWJlbExpbmVIZWlnaHQiLCJzY2FsZUxhYmVsUGFkZGluZyIsImRlbHRhSGVpZ2h0IiwibGFyZ2VzdFRleHRXaWR0aCIsInRhbGxlc3RMYWJlbEhlaWdodEluTGluZXMiLCJsaW5lU3BhY2UiLCJ0aWNrUGFkZGluZyIsImxvbmdlc3RMYWJlbFdpZHRoIiwibGFiZWxIZWlnaHQiLCJmaXJzdExhYmVsV2lkdGgiLCJsYXN0TGFiZWxXaWR0aCIsImhhbmRsZU1hcmdpbnMiLCJyYXdWYWx1ZSIsImdldExhYmVsRm9ySW5kZXgiLCJnZXRWYWx1ZUZvclBpeGVsIiwicGl4ZWwiLCJmaW5hbFZhbCIsImRlY2ltYWwiLCJ2YWx1ZU9mZnNldCIsImdldEJhc2VWYWx1ZSIsIl9hdXRvU2tpcCIsInNraXBSYXRpbyIsIm9wdGlvblRpY2tzIiwidGlja0NvdW50IiwibGFiZWxSb3RhdGlvblJhZGlhbnMiLCJsb25nZXN0Um90YXRlZExhYmVsIiwic2hvdWxkU2tpcCIsIm1heFRpY2tzIiwibWF4VGlja3NMaW1pdCIsIm9wdGlvbk1ham9yVGlja3MiLCJpc1JvdGF0ZWQiLCJ0aWNrRm9udENvbG9yIiwiZm9udENvbG9yIiwibWFqb3JUaWNrRm9udENvbG9yIiwibWFqb3JUaWNrRm9udCIsInRsIiwic2NhbGVMYWJlbEZvbnRDb2xvciIsInNjYWxlTGFiZWxGb250IiwiaXRlbXNUb0RyYXciLCJ4VGlja1N0YXJ0IiwieFRpY2tFbmQiLCJ5VGlja1N0YXJ0IiwieVRpY2tFbmQiLCJsaW5lQ29sb3IiLCJ6ZXJvTGluZUluZGV4IiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwieDEiLCJ5MSIsIngyIiwibGFiZWxYIiwibGFiZWxZIiwidGV4dEJhc2VsaW5lIiwibGFiZWxZT2Zmc2V0IiwieExpbmVWYWx1ZSIsImlzTGVmdCIsImxhYmVsWE9mZnNldCIsInlMaW5lVmFsdWUiLCJnbFdpZHRoIiwiZ2xDb2xvciIsImdsQm9yZGVyRGFzaCIsImdsQm9yZGVyRGFzaE9mZnNldCIsIml0ZW1Ub0RyYXciLCJzYXZlIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInJlc3RvcmUiLCJ0cmFuc2xhdGUiLCJmaWxsVGV4dCIsInNjYWxlTGFiZWxYIiwic2NhbGVMYWJlbFkiLCJoYWxmTGluZUhlaWdodCIsImNvbnN0cnVjdG9ycyIsInJlZ2lzdGVyU2NhbGVUeXBlIiwic2NhbGVDb25zdHJ1Y3RvciIsInNjYWxlRGVmYXVsdHMiLCJ1cGRhdGVTY2FsZURlZmF1bHRzIiwiYWRkaXRpb25zIiwiZ2VuZXJhdG9ycyIsImxpbmVhciIsImdlbmVyYXRpb25PcHRpb25zIiwiZGF0YVJhbmdlIiwic3BhY2luZyIsInN0ZXBTaXplIiwibmljZVJhbmdlIiwibmljZU1pbiIsIm5pY2VNYXgiLCJjZWlsIiwibnVtU3BhY2VzIiwibG9nYXJpdGhtaWMiLCJ0aWNrVmFsIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJleHAiLCJzaWduaWZpY2FuZCIsIm1pbk5vdFplcm8iLCJsYXN0VGljayIsInRpY2tWYWx1ZSIsImxvZ0RlbHRhIiwidGlja1N0cmluZyIsIm51bURlY2ltYWwiLCJ0b0ZpeGVkIiwicmVtYWluIiwidG9FeHBvbmVudGlhbCIsInRpdGxlRm9udFN0eWxlIiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJ0aXRsZUZvbnRDb2xvciIsInRpdGxlQWxpZ24iLCJib2R5U3BhY2luZyIsImJvZHlGb250Q29sb3IiLCJib2R5QWxpZ24iLCJmb290ZXJGb250U3R5bGUiLCJmb290ZXJTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyRm9udENvbG9yIiwiZm9vdGVyQWxpZ24iLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiY2FyZXRTaXplIiwiY29ybmVyUmFkaXVzIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwiZGlzcGxheUNvbG9ycyIsImJlZm9yZVRpdGxlIiwidG9vbHRpcEl0ZW1zIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVCb2R5IiwiYmVmb3JlTGFiZWwiLCJsYWJlbENvbG9yIiwibGFiZWxUZXh0Q29sb3IiLCJhZnRlckxhYmVsIiwiYWZ0ZXJCb2R5IiwiYmVmb3JlRm9vdGVyIiwiZm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJtZXJnZU9wYWNpdHkiLCJjb2xvclN0cmluZyIsIm9wYWNpdHkiLCJwdXNoT3JDb25jYXQiLCJ0b1B1c2giLCJjcmVhdGVUb29sdGlwSXRlbSIsImdldEJhc2VNb2RlbCIsInRvb2x0aXBPcHRzIiwieEFsaWduIiwieUFsaWduIiwiX2JvZHlGb250RmFtaWx5IiwiYm9keUZvbnRGYW1pbHkiLCJfYm9keUZvbnRTdHlsZSIsImJvZHlGb250U3R5bGUiLCJfYm9keUFsaWduIiwiYm9keUZvbnRTaXplIiwiX3RpdGxlRm9udEZhbWlseSIsInRpdGxlRm9udEZhbWlseSIsIl90aXRsZUZvbnRTdHlsZSIsInRpdGxlRm9udFNpemUiLCJfdGl0bGVBbGlnbiIsIl9mb290ZXJGb250RmFtaWx5IiwiZm9vdGVyRm9udEZhbWlseSIsIl9mb290ZXJGb250U3R5bGUiLCJmb290ZXJGb250U2l6ZSIsIl9mb290ZXJBbGlnbiIsImxlZ2VuZENvbG9yQmFja2dyb3VuZCIsImdldFRvb2x0aXBTaXplIiwiY29tYmluZWRCb2R5TGVuZ3RoIiwiYm9keUl0ZW0iLCJsaW5lcyIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50Iiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwiZGV0ZXJtaW5lQWxpZ25tZW50IiwibGYiLCJyZiIsIm9sZiIsIm9yZiIsInlmIiwibWlkWCIsIm1pZFkiLCJnZXRCYWNrZ3JvdW5kUG9pbnQiLCJ2bSIsImFsaWdubWVudCIsInBhZGRpbmdBbmRTaXplIiwicmFkaXVzQW5kUGFkZGluZyIsImdldEJlZm9yZUJvZHkiLCJnZXRCb2R5IiwiYm9keUl0ZW1zIiwiZ2V0QWZ0ZXJCb2R5IiwiZ2V0Rm9vdGVyIiwiZXhpc3RpbmdNb2RlbCIsIl9hY3RpdmUiLCJiYWNrZ3JvdW5kUG9pbnQiLCJ0b29sdGlwU2l6ZSIsImNhcmV0WCIsImNhcmV0WSIsImxhYmVsQ29sb3JzIiwibGFiZWxUZXh0Q29sb3JzIiwicG9zaXRpb25lcnMiLCJfZXZlbnRQb3NpdGlvbiIsIml0ZW1Tb3J0IiwiZGF0YVBvaW50cyIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsInRtcCIsImRyYXdUaXRsZSIsImRyYXdCb2R5IiwieExpbmVQYWRkaW5nIiwiZmlsbExpbmVPZlRleHQiLCJkcmF3Q29sb3JCb3hlcyIsImZpbGxSZWN0Iiwic3Ryb2tlUmVjdCIsInRleHRDb2xvciIsImRyYXdGb290ZXIiLCJkcmF3QmFja2dyb3VuZCIsInF1YWRyYXRpY0N1cnZlVG8iLCJjbG9zZVBhdGgiLCJoYXNUb29sdGlwQ29udGVudCIsIl9sYXN0QWN0aXZlIiwiYXZlcmFnZSIsInBvcyIsImV2ZW50UG9zaXRpb24iLCJuZWFyZXN0RWxlbWVudCIsInRwIiwiaW5MYWJlbFJhbmdlIiwiY2hhcnRYIiwiY2hhcnRZIiwicG9pbnRSZWxhdGl2ZVBvc2l0aW9uIiwiYmV0d2VlbkFuZ2xlcyIsIndpdGhpblJhZGl1cyIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJjZW50cmVBbmdsZSIsInJhbmdlRnJvbUNlbnRyZSIsInNBIiwiZUEiLCJsaW5lSm9pbiIsImdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyIsImxhc3REcmF3bkluZGV4IiwiY3VycmVudFZNIiwibGluZUNhcCIsInhSYW5nZSIsInlSYW5nZSIsImVyck1hcmdpbiIsImRyYXdQb2ludCIsImdldEJhckJvdW5kcyIsImhhbGZXaWR0aCIsImhhbGZIZWlnaHQiLCJzaWduWCIsInNpZ25ZIiwiYmFyU2l6ZSIsImhhbGZTdHJva2UiLCJib3JkZXJMZWZ0IiwiYm9yZGVyUmlnaHQiLCJib3JkZXJUb3AiLCJib3JkZXJCb3R0b20iLCJjb3JuZXJzIiwiYm9yZGVycyIsInN0YXJ0Q29ybmVyIiwiY29ybmVyQXQiLCJjb3JuZXIiLCJib3VuZHMiLCJjbGVhclJlY3QiLCJyb3VuZGVkUmVjdCIsInJ4IiwicnkiLCJlZGdlTGVuZ3RoIiwieE9mZnNldCIsInlPZmZzZXQiLCJkcmF3SW1hZ2UiLCJTUVJUMiIsImxlZnRYIiwidG9wWSIsInNpZGVTaXplIiwiY2xpcCIsImJlemllckN1cnZlVG8iLCJkcmF3Um91bmRlZFJlY3RhbmdsZSIsImlzT2JqZWN0IiwidGhpc0FyZyIsImxvb3BhYmxlIiwiYTAiLCJhMSIsImtsZW4iLCJfbWVyZ2VySWYiLCJtZXJnZUlmIiwic291cmNlcyIsImNhbGxDYWxsYmFjayIsImdldFZhbHVlT3JEZWZhdWx0IiwiZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJhc2luIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJlYXNpbmdFZmZlY3RzIiwibWF0Y2hlcyIsImlucHV0cyIsImdldENvbnRleHQiLCJFWFBBTkRPX0tFWSIsIkNTU19QUkVGSVgiLCJDU1NfUkVOREVSX01PTklUT1IiLCJDU1NfUkVOREVSX0FOSU1BVElPTiIsIkFOSU1BVElPTl9TVEFSVF9FVkVOVFMiLCJFVkVOVF9UWVBFUyIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVybGVhdmUiLCJwb2ludGVyb3V0IiwicmVhZFVzZWRTaXplIiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsInJlbmRlcldpZHRoIiwiaW5pdGlhbCIsImRpc3BsYXlXaWR0aCIsImRpc3BsYXlIZWlnaHQiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHMiLCJldmVudExpc3RlbmVyT3B0aW9ucyIsImNyZWF0ZUV2ZW50IiwibmF0aXZlRXZlbnQiLCJmcm9tTmF0aXZlRXZlbnQiLCJ0aHJvdHRsZWQiLCJ0aWNraW5nIiwiY3JlYXRlUmVzaXplciIsInJlc2l6ZXIiLCJjbHMiLCJtYXhTaXplIiwiZXhwYW5kIiwiY2hpbGROb2RlcyIsInNocmluayIsIl9yZXNldCIsIm9uU2Nyb2xsIiwid2F0Y2hGb3JSZW5kZXIiLCJleHBhbmRvIiwicHJveHkiLCJyZW5kZXJQcm94eSIsImFuaW1hdGlvbk5hbWUiLCJhZGQiLCJ1bndhdGNoRm9yUmVuZGVyIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJyZW1vdmVSZXNpemVMaXN0ZW5lciIsImluamVjdENTUyIsIl9zdHlsZSIsIl9lbmFibGVkIiwia2V5ZnJhbWVzIiwicHJveGllcyIsImFkZEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJiYXNpYyIsImRvbSIsImltcGxlbWVudGF0aW9uIiwiZmlsbGVyIiwicHJvcGFnYXRlIiwibWFwcGVycyIsInZpc2libGUiLCJib3VuZGFyeSIsImRlY29kZUZpbGwiLCJjb21wdXRlQm91bmRhcnkiLCJzY2FsZUJvdHRvbSIsInNjYWxlVG9wIiwic2NhbGVaZXJvIiwiZ2V0QmFzZVBvc2l0aW9uIiwicmVzb2x2ZVRhcmdldCIsInZpc2l0ZWQiLCJjcmVhdGVNYXBwZXIiLCJpc0RyYXdhYmxlIiwiZHJhd0FyZWEiLCJjdXJ2ZTAiLCJjdXJ2ZTEiLCJsZW4wIiwibGVuMSIsImRvRmlsbCIsIm1hcHBlciIsInNwYW4iLCJwMCIsInAxIiwiZDAiLCJkMSIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCIkZmlsbGVyIiwiYmVmb3JlRGF0YXNldERyYXciLCJjaSIsImJveFdpZHRoIiwibGluZURhc2giLCJnZXRCb3hXaWR0aCIsImxhYmVsT3B0cyIsInVzZVBvaW50U3R5bGUiLCJMZWdlbmQiLCJsZWdlbmRIaXRCb3hlcyIsImRvdWdobnV0TW9kZSIsImJlZm9yZUJ1aWxkTGFiZWxzIiwiYnVpbGRMYWJlbHMiLCJhZnRlckJ1aWxkTGFiZWxzIiwibGVnZW5kSXRlbXMiLCJnbG9iYWxEZWZhdWx0IiwibGFiZWxGb250IiwiaGl0Ym94ZXMiLCJsaW5lV2lkdGhzIiwidG90YWxIZWlnaHQiLCJ2UGFkZGluZyIsImNvbHVtbldpZHRocyIsInRvdGFsV2lkdGgiLCJjdXJyZW50Q29sV2lkdGgiLCJjdXJyZW50Q29sSGVpZ2h0IiwiaXRlbUhlaWdodCIsIml0ZW1XaWR0aCIsImxpbmVEZWZhdWx0IiwibGVnZW5kV2lkdGgiLCJkcmF3TGVnZW5kQm94IiwiaXNMaW5lV2lkdGhaZXJvIiwib2ZmU2V0IiwiaGFsZkZvbnRTaXplIiwieExlZnQiLCJ5TWlkZGxlIiwibGgiLCJoaXRCb3giLCJjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2giLCJsZWdlbmRPcHRzIiwiYmVmb3JlSW5pdCIsImFmdGVyRXZlbnQiLCJUaXRsZSIsImxpbmVDb3VudCIsInRleHRTaXplIiwidGl0bGVGb250IiwidGl0bGVYIiwidGl0bGVZIiwiY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaCIsInRpdGxlT3B0cyIsInRpdGxlQmxvY2siLCJkZWZhdWx0Q29uZmlnIiwiRGF0YXNldFNjYWxlIiwiZ2V0TGFiZWxzIiwieExhYmVscyIsInlMYWJlbHMiLCJtaW5JbmRleCIsIm1heEluZGV4Iiwib2Zmc2V0QW10IiwidmFsdWVDYXRlZ29yeSIsInZhbHVlV2lkdGgiLCJ3aWR0aE9mZnNldCIsInZhbHVlSGVpZ2h0IiwiaGVpZ2h0T2Zmc2V0IiwiaG9yeiIsInZhbHVlRGltZW5zaW9uIiwiTGluZWFyU2NhbGUiLCJMaW5lYXJTY2FsZUJhc2UiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwiSURNYXRjaGVzIiwiaGFzU3RhY2tzIiwidmFsdWVzUGVyU3RhY2siLCJwb3NpdGl2ZVZhbHVlcyIsIm5lZ2F0aXZlVmFsdWVzIiwicmVsYXRpdmVQb2ludHMiLCJ2YWx1ZXNGb3JUeXBlIiwibWluVmFsIiwibWF4VmFsIiwiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsImdldFRpY2tMaW1pdCIsInRpY2tGb250U2l6ZSIsImhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcyIsImlubmVyRGltZW5zaW9uIiwidGlja3NBc051bWJlcnMiLCJtaW5TaWduIiwibWF4U2lnbiIsInNldE1pbiIsInN1Z2dlc3RlZE1pbiIsInNldE1heCIsInN1Z2dlc3RlZE1heCIsIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwiZml4ZWRTdGVwU2l6ZSIsIkxvZ2FyaXRobWljU2NhbGUiLCJ0aWNrVmFsdWVzIiwibmV3VmFsIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nWSIsImJhY2tkcm9wUGFkZGluZ1giLCJnZXRWYWx1ZUNvdW50IiwiZ2V0UG9pbnRMYWJlbEZvbnRPcHRpb25zIiwicG9pbnRMYWJlbE9wdGlvbnMiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwicGxGb250IiwibGFyZ2VzdFBvc3NpYmxlUmFkaXVzIiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsIl9wb2ludExhYmVsU2l6ZXMiLCJ2YWx1ZUNvdW50IiwiZ2V0UG9pbnRQb3NpdGlvbiIsImdldEluZGV4QW5nbGUiLCJoTGltaXRzIiwidkxpbWl0cyIsInNldFJlZHVjdGlvbnMiLCJkcmF3aW5nQXJlYSIsInNldENlbnRlclBvaW50IiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJhbmdsZUxpbmVPcHRzIiwicG9pbnRMYWJlbE9wdHMiLCJvdXRlckRpc3RhbmNlIiwib3V0ZXJQb3NpdGlvbiIsInBvaW50TGFiZWxQb3NpdGlvbiIsInBvaW50TGFiZWxGb250Q29sb3IiLCJkcmF3UmFkaXVzTGluZSIsIm51bWJlck9yWmVybyIsInBhcmFtIiwiTGluZWFyUmFkaWFsU2NhbGUiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInN0YXJ0QW5nbGVSYWRpYW5zIiwic2NhbGluZ0ZhY3RvciIsImRpc3RhbmNlRnJvbUNlbnRlciIsInRoaXNBbmdsZSIsInRpY2tGb250U3R5bGUiLCJ0aWNrRm9udEZhbWlseSIsInRpY2tMYWJlbEZvbnQiLCJ5Q2VudGVyT2Zmc2V0IiwibW9tZW50IiwiTUlOX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiSU5URVJWQUxTIiwibWlsbGlzZWNvbmQiLCJzdGVwcyIsIndlZWsiLCJxdWFydGVyIiwiVU5JVFMiLCJzb3J0ZXIiLCJhcnJheVVuaXF1ZSIsIm91dCIsImJ1aWxkTG9va3VwVGFibGUiLCJ0aW1lc3RhbXBzIiwiZGlzdHJpYnV0aW9uIiwidGFibGUiLCJsb29rdXAiLCJsbyIsIm1pZCIsImkwIiwiaTEiLCJza2V5IiwidGtleSIsIm1vbWVudGlmeSIsInBhcnNlciIsInN0YXJ0T2YiLCJ2YWx1ZU9mIiwiZGV0ZXJtaW5lU3RlcFNpemUiLCJjYXBhY2l0eSIsIm1pbGxpc2Vjb25kcyIsImZhY3RvciIsImRldGVybWluZVVuaXQiLCJtaW5Vbml0IiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwiZ2VuZXJhdGUiLCJ0aW1lT3B0cyIsInVuaXRTdGVwU2l6ZSIsIndlZWtkYXkiLCJpc29XZWVrZGF5IiwibWFqb3JUaWNrc0VuYWJsZWQiLCJjb21wdXRlT2Zmc2V0cyIsInVwcGVyIiwibG93ZXIiLCJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwibWFqb3JVbml0IiwiZGlzcGxheUZvcm1hdCIsImRpc3BsYXlGb3JtYXRzIiwiVGltZVNjYWxlIiwidGltZXN0YW1wIiwiZW5kT2YiLCJfaG9yaXpvbnRhbCIsIl90YWJsZSIsIl90aW1lc3RhbXBzIiwiZm9ybWF0cyIsImdldExhYmVsQ2FwYWNpdHkiLCJfdW5pdCIsIl9tYWpvclVuaXQiLCJfbWlub3JGb3JtYXQiLCJfbWFqb3JGb3JtYXQiLCJ0b29sdGlwRm9ybWF0IiwidGlja0Zvcm1hdEZ1bmN0aW9uIiwibWFqb3JGb3JtYXQiLCJtYWpvclRpbWUiLCJtYWpvclRpY2tPcHRzIiwiZm9ybWF0dGVyIiwiZ2V0UGl4ZWxGb3JPZmZzZXQiLCJnZXRMYWJlbFdpZHRoIiwidGlja3NPcHRzIiwidGlja0xhYmVsV2lkdGgiLCJleGFtcGxlVGltZSIsImV4YW1wbGVMYWJlbCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxzQ0FBc0M7QUFDOUMsUUFBUTtBQUNSLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUF1RDtBQUM5RTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhCQUE4QjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsY0FBYyxXQUFXO0FBQ3hFLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0Esc0JBQXNCLGNBQWMsc0JBQXNCLGdCQUFnQjtBQUMxRSxnQkFBZ0IsV0FBVyxZQUFZO0FBQ3ZDLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsUUFBUSxnQkFBZ0I7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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFDRjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUMzblVEO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQSxDQUFDOzs7Ozs7OztBQ2hCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQzVDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywr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QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QyxFQUFFOztBQUVGO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QyxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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Q0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN2a0VEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FB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QUFDOztBQUVELENBQUM7Ozs7Ozs7O0FDL3VCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FB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QXlELE1BQU0sc0RBQXNELEdBQUcsR0FBRyx1QkFBdUIsWUFBWSxRQUFRLDBGQUEwRixlQUFlLG1oQkFBbWhCLEdBQUcsdUJBQXVCLFVBQVUsbUJBQW1CLGdGQUFnRixjQUFjLDBEQUEwRCxjQUFjLE1BQU0sOERBQThELGNBQWMsNkJBQTZCLGdCQUFnQixZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUEscUdBQXVILGE7Ozs7Ozs7QUNMOTlIO0FBQ0EiLCJmaWxlIjoiL3dvcmRwcmVzcy93cC1jb250ZW50L3RoZW1lcy9tYWtlLWl0LWFsbC9mcm9udGVuZC9qcy92ZW5kb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1OSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZTI4ZWE0M2ZkMjE4YTFlZTVhMTUiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMy4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOC0wMS0yMFQxNzoyNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jLCBub2RlICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggbm9kZVsgaSBdICkge1xuXHRcdFx0XHRcdHNjcmlwdFsgaSBdID0gbm9kZVsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4zLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYywgbm9kZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM2IHx8IFwiYWJzb2x1dGVcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cdFx0KSApO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0dmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiB8fFxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkge1xuXG5cdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHByb3ZpZGUgYm9yZGVyLWJveCB2YWx1ZXNcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYm94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24gKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSA3IDkiLCIoIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59ICggZnVuY3Rpb24oICQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG5yZXR1cm4gJC51aS52ZXJzaW9uID0gXCIxLjEyLjFcIjtcblxufSApICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvdmVyc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSA3IiwiLyohXG4gKiBqUXVlcnkgVUkgS2V5Y29kZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogS2V5Y29kZVxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFByb3ZpZGUga2V5Y29kZXMgYXMga2V5bmFtZXNcbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkudWkua2V5Q29kZS9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSAoIGZ1bmN0aW9uKCAkICkge1xucmV0dXJuICQudWkua2V5Q29kZSA9IHtcblx0QkFDS1NQQUNFOiA4LFxuXHRDT01NQTogMTg4LFxuXHRERUxFVEU6IDQ2LFxuXHRET1dOOiA0MCxcblx0RU5EOiAzNSxcblx0RU5URVI6IDEzLFxuXHRFU0NBUEU6IDI3LFxuXHRIT01FOiAzNixcblx0TEVGVDogMzcsXG5cdFBBR0VfRE9XTjogMzQsXG5cdFBBR0VfVVA6IDMzLFxuXHRQRVJJT0Q6IDE5MCxcblx0UklHSFQ6IDM5LFxuXHRTUEFDRTogMzIsXG5cdFRBQjogOSxcblx0VVA6IDM4XG59O1xuXG59ICkgKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9rZXljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIvKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFdpZGdldFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgc3RhdGVmdWwgd2lkZ2V0cyB3aXRoIGEgY29tbW9uIEFQSS5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3dpZGdldC9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSggZnVuY3Rpb24oICQgKSB7XG5cbnZhciB3aWRnZXRVdWlkID0gMDtcbnZhciB3aWRnZXRTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuJC5jbGVhbkRhdGEgPSAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBldmVudHMsIGVsZW0sIGk7XG5cdFx0Zm9yICggaSA9IDA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdC8vIE9ubHkgdHJpZ2dlciByZW1vdmUgd2hlbiBuZWNlc3NhcnkgdG8gc2F2ZSB0aW1lXG5cdFx0XHRcdGV2ZW50cyA9ICQuX2RhdGEoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHRcdFx0aWYgKCBldmVudHMgJiYgZXZlbnRzLnJlbW92ZSApIHtcblx0XHRcdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIdHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0fVxuXHRcdG9yaWcoIGVsZW1zICk7XG5cdH07XG59ICkoICQuY2xlYW5EYXRhICk7XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlO1xuXG5cdC8vIFByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0dmFyIHByb3hpZWRQcm90b3R5cGUgPSB7fTtcblxuXHR2YXIgbmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHR2YXIgZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0aWYgKCAkLmlzQXJyYXkoIHByb3RvdHlwZSApICkge1xuXHRcdHByb3RvdHlwZSA9ICQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIHt9IF0uY29uY2F0KCBwcm90b3R5cGUgKSApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gRXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXG5cdFx0Ly8gQ29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblxuXHRcdC8vIFRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9ICk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cblx0Ly8gV2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggISQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuY3Rpb24gX3N1cGVyKCkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIF9zdXBlckFwcGx5KCBhcmdzICkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXI7XG5cdFx0XHRcdHZhciBfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5O1xuXHRcdFx0XHR2YXIgcmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9ICkoKTtcblx0fSApO1xuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoIGJhc2VQcm90b3R5cGUsIHtcblxuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/ICggYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCB8fCBuYW1lICkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSApO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gUmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLFxuXHRcdFx0XHRjaGlsZC5fcHJvdG8gKTtcblx0XHR9ICk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xuXG5cdHJldHVybiBjb25zdHJ1Y3Rvcjtcbn07XG5cbiQud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdHZhciBpbnB1dCA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHR2YXIgaW5wdXRJbmRleCA9IDA7XG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0dmFyIGtleTtcblx0dmFyIHZhbHVlO1xuXG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIENsb25lIG9iamVjdHNcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9ICQuaXNQbGFpbk9iamVjdCggdGFyZ2V0WyBrZXkgXSApID9cblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHRhcmdldFsga2V5IF0sIHZhbHVlICkgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiO1xuXHRcdHZhciBhcmdzID0gd2lkZ2V0U2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGVtcHR5IGNvbGxlY3Rpb24sIHdlIG5lZWQgdG8gaGF2ZSB0aGUgaW5zdGFuY2UgbWV0aG9kXG5cdFx0XHQvLyByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgdGhlIGpRdWVyeSBpbnN0YW5jZVxuXHRcdFx0aWYgKCAhdGhpcy5sZW5ndGggJiYgb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblxuXHRcdFx0XHRcdGlmICggb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBpbnN0YW5jZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVsgb3B0aW9ucyBdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdFx0aWYgKCBhcmdzLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KCBhcmdzICkgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyB8fCB7fSApO1xuXHRcdFx0XHRcdGlmICggaW5zdGFuY2UuX2luaXQgKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5faW5pdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcbn07XG5cbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcbiQuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdO1xuXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XG5cdHdpZGdldE5hbWU6IFwid2lkZ2V0XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcIlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRjbGFzc2VzOiB7fSxcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB3aWRnZXRVdWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblx0XHR0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwID0ge307XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblxuXHRcdFx0XHQvLyBFbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFsgMCBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbIDAgXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblxuXHRfY3JlYXRlOiAkLm5vb3AsXG5cblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0JC5lYWNoKCB0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCB2YWx1ZSwga2V5ICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gV2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIENsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0fSxcblxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5O1xuXHRcdHZhciBwYXJ0cztcblx0XHR2YXIgY3VyT3B0aW9uO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHQvLyBEb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJjbGFzc2VzXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25DbGFzc2VzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uQ2xhc3NlczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc0tleSwgZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50cztcblxuXHRcdGZvciAoIGNsYXNzS2V5IGluIHZhbHVlICkge1xuXHRcdFx0Y3VycmVudEVsZW1lbnRzID0gdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cFsgY2xhc3NLZXkgXTtcblx0XHRcdGlmICggdmFsdWVbIGNsYXNzS2V5IF0gPT09IHRoaXMub3B0aW9ucy5jbGFzc2VzWyBjbGFzc0tleSBdIHx8XG5cdFx0XHRcdFx0IWN1cnJlbnRFbGVtZW50cyB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgYXJlIGRvaW5nIHRoaXMgdG8gY3JlYXRlIGEgbmV3IGpRdWVyeSBvYmplY3QgYmVjYXVzZSB0aGUgX3JlbW92ZUNsYXNzKCkgY2FsbFxuXHRcdFx0Ly8gb24gdGhlIG5leHQgbGluZSBpcyBnb2luZyB0byBkZXN0cm95IHRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZWxlbWVudHMgYmVpbmdcblx0XHRcdC8vIHRyYWNrZWQuIFdlIG5lZWQgdG8gc2F2ZSBhIGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCB0aGUgbmV3IGNsYXNzZXNcblx0XHRcdC8vIGJlbG93LlxuXHRcdFx0ZWxlbWVudHMgPSAkKCBjdXJyZW50RWxlbWVudHMuZ2V0KCkgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50RWxlbWVudHMsIGNsYXNzS2V5ICk7XG5cblx0XHRcdC8vIFdlIGRvbid0IHVzZSBfYWRkQ2xhc3MoKSBoZXJlLCBiZWNhdXNlIHRoYXQgdXNlcyB0aGlzLm9wdGlvbnMuY2xhc3Nlc1xuXHRcdFx0Ly8gZm9yIGdlbmVyYXRpbmcgdGhlIHN0cmluZyBvZiBjbGFzc2VzLiBXZSB3YW50IHRvIHVzZSB0aGUgdmFsdWUgcGFzc2VkIGluIGZyb21cblx0XHRcdC8vIF9zZXRPcHRpb24oKSwgdGhpcyBpcyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBjbGFzc2VzIG9wdGlvbiB3aGljaCB3YXMgcGFzc2VkIHRvXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCkuIFdlIHBhc3MgdGhpcyB2YWx1ZSBkaXJlY3RseSB0byBfY2xhc3NlcygpLlxuXHRcdFx0ZWxlbWVudHMuYWRkQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudHMsXG5cdFx0XHRcdGtleXM6IGNsYXNzS2V5LFxuXHRcdFx0XHRjbGFzc2VzOiB2YWx1ZSxcblx0XHRcdFx0YWRkOiB0cnVlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0KCksIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZFwiLCBudWxsLCAhIXZhbHVlICk7XG5cblx0XHQvLyBJZiB0aGUgd2lkZ2V0IGlzIGJlY29taW5nIGRpc2FibGVkLCB0aGVuIG5vdGhpbmcgaXMgaW50ZXJhY3RpdmVcblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaG92ZXJhYmxlLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmZvY3VzYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IGZhbHNlIH0gKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyggeyBkaXNhYmxlZDogdHJ1ZSB9ICk7XG5cdH0sXG5cblx0X2NsYXNzZXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBmdWxsID0gW107XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7XG5cdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRjbGFzc2VzOiB0aGlzLm9wdGlvbnMuY2xhc3NlcyB8fCB7fVxuXHRcdH0sIG9wdGlvbnMgKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NDbGFzc1N0cmluZyggY2xhc3NlcywgY2hlY2tPcHRpb24gKSB7XG5cdFx0XHR2YXIgY3VycmVudCwgaTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Y3VycmVudCA9IHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdIHx8ICQoKTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmFkZCApIHtcblx0XHRcdFx0XHRjdXJyZW50ID0gJCggJC51bmlxdWUoIGN1cnJlbnQuZ2V0KCkuY29uY2F0KCBvcHRpb25zLmVsZW1lbnQuZ2V0KCkgKSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoIGN1cnJlbnQubm90KCBvcHRpb25zLmVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdID0gY3VycmVudDtcblx0XHRcdFx0ZnVsbC5wdXNoKCBjbGFzc2VzWyBpIF0gKTtcblx0XHRcdFx0aWYgKCBjaGVja09wdGlvbiAmJiBvcHRpb25zLmNsYXNzZXNbIGNsYXNzZXNbIGkgXSBdICkge1xuXHRcdFx0XHRcdGZ1bGwucHVzaCggb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fb24oIG9wdGlvbnMuZWxlbWVudCwge1xuXHRcdFx0XCJyZW1vdmVcIjogXCJfdW50cmFja0NsYXNzZXNFbGVtZW50XCJcblx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMua2V5cyApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5rZXlzLm1hdGNoKCAvXFxTKy9nICkgfHwgW10sIHRydWUgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmV4dHJhICkge1xuXHRcdFx0cHJvY2Vzc0NsYXNzU3RyaW5nKCBvcHRpb25zLmV4dHJhLm1hdGNoKCAvXFxTKy9nICkgfHwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVsbC5qb2luKCBcIiBcIiApO1xuXHR9LFxuXG5cdF91bnRyYWNrQ2xhc3Nlc0VsZW1lbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0JC5lYWNoKCB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdGlmICggJC5pbkFycmF5KCBldmVudC50YXJnZXQsIHZhbHVlICkgIT09IC0xICkge1xuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBrZXkgXSA9ICQoIHZhbHVlLm5vdCggZXZlbnQudGFyZ2V0ICkuZ2V0KCkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X3JlbW92ZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgZmFsc2UgKTtcblx0fSxcblxuXHRfYWRkQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBrZXlzLCBleHRyYSApIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3MoIGVsZW1lbnQsIGtleXMsIGV4dHJhLCB0cnVlICk7XG5cdH0sXG5cblx0X3RvZ2dsZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEsIGFkZCApIHtcblx0XHRhZGQgPSAoIHR5cGVvZiBhZGQgPT09IFwiYm9vbGVhblwiICkgPyBhZGQgOiBleHRyYTtcblx0XHR2YXIgc2hpZnQgPSAoIHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiIHx8IGVsZW1lbnQgPT09IG51bGwgKSxcblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGV4dHJhOiBzaGlmdCA/IGtleXMgOiBleHRyYSxcblx0XHRcdFx0a2V5czogc2hpZnQgPyBlbGVtZW50IDoga2V5cyxcblx0XHRcdFx0ZWxlbWVudDogc2hpZnQgPyB0aGlzLmVsZW1lbnQgOiBlbGVtZW50LFxuXHRcdFx0XHRhZGQ6IGFkZFxuXHRcdFx0fTtcblx0XHRvcHRpb25zLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIG9wdGlvbnMgKSwgYWRkICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50O1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBObyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXG5cdFx0XHRcdC8vIEFsbG93IHdpZGdldHMgdG8gY3VzdG9taXplIHRoZSBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGFzIGFuIGFycmF5IGluc3RlYWQgb2YgYm9vbGVhblxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcblx0XHRcdFx0aWYgKCAhc3VwcHJlc3NEaXNhYmxlZENoZWNrICYmXG5cdFx0XHRcdFx0XHQoIGluc3RhbmNlLm9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFtcXHc6LV0qKVxccyooLiopJC8gKTtcblx0XHRcdHZhciBldmVudE5hbWUgPSBtYXRjaFsgMSBdICsgaW5zdGFuY2UuZXZlbnROYW1lc3BhY2U7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQub24oIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5vbiggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoIGV2ZW50TmFtZSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgK1xuXHRcdFx0dGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50Lm9mZiggZXZlbnROYW1lICkub2ZmKCBldmVudE5hbWUgKTtcblxuXHRcdC8vIENsZWFyIHRoZSBzdGFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1Nilcblx0XHR0aGlzLmJpbmRpbmdzID0gJCggdGhpcy5iaW5kaW5ncy5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCggdGhpcy5mb2N1c2FibGUubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoIHRoaXMuaG92ZXJhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fSxcblx0XHRcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXNvdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWc7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIFRoZSBvcmlnaW5hbCBldmVudCBtYXkgY29tZSBmcm9tIGFueSBlbGVtZW50XG5cdFx0Ly8gc28gd2UgbmVlZCB0byByZXNldCB0aGUgdGFyZ2V0IG9uIHRoZSBuZXcgZXZlbnRcblx0XHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbIDAgXTtcblxuXHRcdC8vIENvcHkgb3JpZ2luYWwgZXZlbnQgcHJvcGVydGllcyBvdmVyIHRvIHRoZSBuZXcgZXZlbnRcblx0XHRvcmlnID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoIG9yaWcgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGlmICggISggcHJvcCBpbiBldmVudCApICkge1xuXHRcdFx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggZXZlbnQsIGRhdGEgKTtcblx0XHRyZXR1cm4gISggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICYmXG5cdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcy5lbGVtZW50WyAwIF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIGhhc09wdGlvbnM7XG5cdFx0dmFyIGVmZmVjdE5hbWUgPSAhb3B0aW9ucyA/XG5cdFx0XHRtZXRob2QgOlxuXHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdGRlZmF1bHRFZmZlY3QgOlxuXHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNPcHRpb25zICYmICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBtZXRob2QgXSggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIGVmZmVjdE5hbWUgIT09IG1ldGhvZCAmJiBlbGVtZW50WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBlZmZlY3ROYW1lIF0oIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnF1ZXVlKCBmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbnJldHVybiAkLndpZGdldDtcblxufSApICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCJ3aW5kb3cuJCA9IHdpbmRvdy5qUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuXG4vLyBEYXRlcGlja2VyXG5yZXF1aXJlKFwianF1ZXJ5LXVpL3VpL3dpZGdldHMvZGF0ZXBpY2tlclwiKTtcblxuLy8gVGltZXBpY2tlclxucmVxdWlyZShcImpxdWVyeS11aS91aS93aWRnZXRzL3NsaWRlclwiKTtcbnJlcXVpcmUoXCIuL2pxdWVyeS11aS10aW1lcGlja2VyLWFkZG9uXCIpO1xuXG4vLyBCb290c3RyYXBcbndpbmRvdy5Qb3BwZXIgPSByZXF1aXJlKFwiLi9wb3BwZXJcIik7XG5yZXF1aXJlKFwiLi9ib290c3RyYXBcIik7XG5yZXF1aXJlKFwiLi9ib290c3RyYXAtc2VsZWN0XCIpO1xuXG4vLyBNZXRyaWNzXG5yZXF1aXJlKFwiLi9jaGFydC5qc1wiKTtcblxuLy8gVHVyYm9saW5rc1xud2luZG93LlR1cmJvbGlua3MgPSByZXF1aXJlKFwidHVyYm9saW5rc1wiKTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg0MDc3NzEvMjk1NzY3N1xuLy8gTW9kaWZpZWQgYnkgLzE1NDk4MTggdG8gc3VwcG9ydCBkb3Qgbm90YXRpb25cbihmdW5jdGlvbigkKXtcblx0JC5mbi5zZXJpYWxpemVPYmplY3QgPSBmdW5jdGlvbihzaG91bGRWYWxpZGF0ZSA9IGZhbHNlKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0anNvbiA9IHt9LFxuXHRcdFx0cHVzaF9jb3VudGVycyA9IHt9LFxuXHRcdFx0cGF0dGVybnMgPSB7XG5cdFx0XHRcdFwidmFsaWRhdGVcIjogL15bYS16QS1aXVthLXpBLVowLTlfXSooPzpbXFxbXFwuXSg/OlxcZCp8W2EtekEtWjAtOV9dKylbXFxdXT8pKiQvLFxuXHRcdFx0XHRcImtleVwiOiAgICAgIC9bYS16QS1aMC05X10rfCg/PVxcW1xcXSkvZyxcblx0XHRcdFx0XCJwdXNoXCI6ICAgICAvXiQvLFxuXHRcdFx0XHRcImZpeGVkXCI6ICAgIC9eXFxkKyQvLFxuXHRcdFx0XHRcIm5hbWVkXCI6ICAgIC9eW2EtekEtWjAtOV9dKyQvXG5cdFx0XHR9LFxuXHRcdFx0aXNWYWxpZCA9IHRydWUsXG5cdFx0XHQkZmllbGRzID0gJCh0aGlzKS5maW5kKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpLm5vdCgnaW5wdXRbdHlwZT1yYWRpb106bm90KDpjaGVja2VkKScpOyAvLyBmaWx0ZXJzIG91dCBub24tY2hlY2tlZCByYWRpbyBmaWVsZHNcblxuXHRcdHRoaXMuYnVpbGQgPSBmdW5jdGlvbihiYXNlLCBrZXksIHZhbHVlKSB7XG5cdFx0XHRiYXNlW2tleV0gPSB2YWx1ZTtcblx0XHRcdHJldHVybiBiYXNlO1xuXHRcdH07XG5cblx0XHR0aGlzLnB1c2hfY291bnRlciA9IGZ1bmN0aW9uKGtleSl7XG5cdFx0XHRpZiAocHVzaF9jb3VudGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHVzaF9jb3VudGVyc1trZXldID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHB1c2hfY291bnRlcnNba2V5XSsrO1xuXHRcdH07XG5cblx0XHRpZiAoc2hvdWxkVmFsaWRhdGUpIHtcblx0XHRcdCQoJy5pbnZhbGlkLWZlZWRiYWNrJykucmVtb3ZlKCk7XG5cdFx0XHQkKCcuaXMtdmFsaWQsIC5pcy1pbnZhbGlkLCAuY2FyZC1oZWFkZXIucmVkLWhpZ2hsaWdodCwgLmNhcmQtaGVhZGVyLmdyZWVuLWhpZ2hsaWdodCcpLnJlbW92ZUNsYXNzKCdpcy12YWxpZCBpcy1pbnZhbGlkIHJlZC1oaWdobGlnaHQgZ3JlZW4taGlnaGxpZ2h0Jyk7XG5cdFx0XG5cdFx0XHRjbGVhclRpbWVvdXQodmFsaWRhdGlvblRpbWVvdXQpO1xuXG5cdFx0XHR2YWxpZGF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoJy5pcy12YWxpZCwgLmlzLWludmFsaWQsIC5jYXJkLWhlYWRlci5yZWQtaGlnaGxpZ2h0LCAuY2FyZC1oZWFkZXIuZ3JlZW4taGlnaGxpZ2h0JykucmVtb3ZlQ2xhc3MoJ2lzLXZhbGlkIGlzLWludmFsaWQgcmVkLWhpZ2hsaWdodCBncmVlbi1oaWdobGlnaHQnKTtcblx0XHRcdFx0JCgnLmludmFsaWQtZmVlZGJhY2snKS5mYWRlT3V0KDI1MCwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5yZW1vdmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAxNTAwMCk7XG5cdFx0fVxuXG5cdFx0JGZpZWxkcy5ub3QoJzpkaXNhYmxlZCcpLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdC8vIHNraXAgaW52YWxpZCBrZXlzXG5cdFx0XHRpZiAoIXBhdHRlcm5zLnZhbGlkYXRlLnRlc3QodGhpcy5uYW1lKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrLFxuXHRcdFx0XHRrZXlzID0gdGhpcy5uYW1lLm1hdGNoKHBhdHRlcm5zLmtleSksXG5cdFx0XHRcdG1lcmdlID0gdGhpcy52YWx1ZSxcblx0XHRcdFx0cmV2ZXJzZV9rZXkgPSB0aGlzLm5hbWUsXG5cdFx0XHRcdHZhbGlkYXRpb25fcnVsZXMgPSB0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoJ3ZhbGlkYXRpb24nKSA/IHRoaXMuYXR0cmlidXRlcy52YWxpZGF0aW9uLnZhbHVlIDogbnVsbDtcblxuXHRcdFx0aWYgKHNob3VsZFZhbGlkYXRlICYmIHZhbGlkYXRpb25fcnVsZXMgIT09IG51bGwpIHtcblx0XHRcdFx0dmFyIHJlc3BvbnNlID0gJCh0aGlzKS52YWxpZGF0ZSgpO1xuXG5cdFx0XHRcdGlmIChpc1ZhbGlkKSB7XG5cdFx0XHRcdFx0aXNWYWxpZCA9IHJlc3BvbnNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICgoayA9IGtleXMucG9wKCkpICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHQvLyBhZGp1c3QgcmV2ZXJzZV9rZXlcblx0XHRcdFx0cmV2ZXJzZV9rZXkgPSByZXZlcnNlX2tleS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcW1wiICsgayArIFwiXFxcXF0kXCIpLCAnJyk7XG5cblx0XHRcdFx0Ly8gcHVzaFxuXHRcdFx0XHRpZiAoay5tYXRjaChwYXR0ZXJucy5wdXNoKSkge1xuXHRcdFx0XHRcdG1lcmdlID0gc2VsZi5idWlsZCh7fSwgc2VsZi5wdXNoX2NvdW50ZXIocmV2ZXJzZV9rZXkpLCBtZXJnZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaXhlZCBvciBuYW1lZFxuXHRcdFx0XHRlbHNlIGlmIChrLm1hdGNoKHBhdHRlcm5zLmZpeGVkKSB8fCBrLm1hdGNoKHBhdHRlcm5zLm5hbWVkKSkge1xuXHRcdFx0XHRcdG1lcmdlID0gc2VsZi5idWlsZCh7fSwgaywgbWVyZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGpzb24gPSAkLmV4dGVuZCh0cnVlLCBqc29uLCBtZXJnZSk7XG5cdFx0fSk7XG5cblx0XHRqc29uLmlzVmFsaWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpc1ZhbGlkO1xuXHRcdH07XG5cblx0XHRpZiAoc2hvdWxkVmFsaWRhdGUpIHtcblx0XHRcdCQodGhpcykuZmluZCgnLmNhcmQ6bm90KC5leGlzdGluZykgLmlzLXZhbGlkJykuY2xvc2VzdCgnLmNhcmQnKS5maW5kKCcuY2FyZC1oZWFkZXInKS5hZGRDbGFzcygnZ3JlZW4taGlnaGxpZ2h0Jyk7IC8vIGhpZ2hsaWdodCBhbGwgY2FyZHMgZ3JlZW4gZmlyc3Rcblx0XHRcdCQodGhpcykuZmluZCgnLmNhcmQ6bm90KC5leGlzdGluZykgLmlzLWludmFsaWQnKS5jbG9zZXN0KCcuY2FyZCcpLmZpbmQoJy5jYXJkLWhlYWRlcicpLnJlbW92ZUNsYXNzKCdncmVlbi1oaWdobGlnaHQnKS5hZGRDbGFzcygncmVkLWhpZ2hsaWdodCcpOyAvLyBoaWdobGlnaHQgYW55IGNhcmRzIHdpdGggZXJyb3JzIGluIHRoZW1cblx0XHRcdFxuXHRcdFx0Ly8gb3BlbiBhY2NvcmRpb24gd2l0aCBlcnJvclxuXHRcdFx0aWYgKCQodGhpcykuZmluZCgnLnZpZXctYWNjb3JkaW9uLmZhLWNoZXZyb24tZG93bicpLmZpcnN0KCkuY2xvc2VzdCgnLmNhcmQtaGVhZGVyLmdyZWVuLWhpZ2hsaWdodCcpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHQkKHRoaXMpLmZpbmQoJy5jYXJkLWhlYWRlci5yZWQtaGlnaGxpZ2h0IC52aWV3LWFjY29yZGlvbicpLmNsaWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpzb247XG5cdH07XG5cblx0JC5mbi52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciAkdGhpcyAgICAgICAgICAgPSAkKHRoaXMpLFxuXHRcdFx0dmFsdWUgICAgICAgICAgID0gJHRoaXMudmFsKCksXG5cdFx0XHR2YWxpZGF0aW9uUnVsZXMgPSAkdGhpcy5hdHRyKCd2YWxpZGF0aW9uJykuc3BsaXQoJ3wnKSxcblx0XHRcdGZhaWxlZFJ1bGVzICAgICA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZGF0aW9uUnVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBydWxlID0gdmFsaWRhdGlvblJ1bGVzW2ldO1xuXG5cdFx0XHRzd2l0Y2ggKHJ1bGUpIHtcblx0XHRcdFx0Y2FzZSBcIm51bGxhYmxlXCI6XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuXHRcdFx0XHRcdFx0dmFsaWRhdGlvblJ1bGVzID0gW107IC8vIGJyZWFrIG91dCBvZiBmb3Jcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAocnVsZS5tYXRjaCgvcmVxdWlyZWQvKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuXHRcdFx0XHRcdFx0aWYgKHJ1bGUuc3BsaXQoJzonKS5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0ZmFpbGVkUnVsZXMucHVzaCgnVGhpcyBmaWVsZCBpcyByZXF1aXJlZC4nKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2gocnVsZS5zcGxpdCgnOicpWzFdKTsgLy8gY3VzdG9tIG1lc3NhZ2UgY2FuIGJlIGF0dGFjaGVkIHRvIHJlcXVpcmVkXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhbGlkYXRpb25SdWxlcyA9IFtdOyAvLyBicmVhayBvdXQgb2YgZm9yXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJpbnRlZ2VyXCI6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgKGlzTmFOKHBhcnNlSW50KHZhbHVlKSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBiZSBhbiB3aG9sZSBudW1iZXIuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgKHJ1bGUubWF0Y2goL21heDovKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUubGVuZ3RoID4gTnVtYmVyKHJ1bGUuc3BsaXQoJzonKVsxXSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBoYXZlIGxlc3MgdGhhbiAnICsgKE51bWJlcihydWxlLnNwbGl0KCc6JylbMV0pICsgMSkgKyAnIGNoYXJhY3RlcnMuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgKHJ1bGUubWF0Y2goL21pbjovKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA8IE51bWJlcihydWxlLnNwbGl0KCc6JylbMV0pKSB7XG5cdFx0XHRcdFx0XHRmYWlsZWRSdWxlcy5wdXNoKCdUaGlzIGZpZWxkIG11c3QgaGF2ZSBhdCBsZWFzdCAnICsgcnVsZS5zcGxpdCgnOicpWzFdICsgJyBjaGFyYWN0ZXJzLicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIChydWxlLm1hdGNoKC9pbjovKSB8fCB7fSkuaW5wdXQ6XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgKHJ1bGUuc3BsaXQoJzonKVsxXS5zcGxpdCgnLCcpLmluZGV4T2YodmFsdWUpID09PSAtMSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBjb250YWluIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAnICsgcnVsZS5zcGxpdCgnOicpWzFdLnNwbGl0KCcsJykgKyAnLicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIChydWxlLm1hdGNoKC9ub3Q6LykgfHwge30pLmlucHV0OlxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gcnVsZS5zcGxpdCgnOicpWzFdLnNwbGl0KC8nLylbMV0pIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgaGFzIGFuIGludmFsaWQgdmFsdWUuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgKHJ1bGUubWF0Y2goL3JlcXVpcmVzOi8pIHx8IHt9KS5pbnB1dDpcblx0XHRcdFx0XHRpZiAoJHRoaXMuY2xvc2VzdCgnZm9ybScpLmZpbmQoJ2lucHV0W25hbWU9XCInICsgcnVsZS5zcGxpdCgnOicpWzFdICsgJ1wiXScpLnZhbCgpID09PSAnJykge1xuXHRcdFx0XHRcdFx0ZmFpbGVkUnVsZXMucHVzaCgnVGhpcyBmaWVsZCBpcyByZXF1aXJlZC4nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImVtYWlsXCI6XG5cdFx0XHRcdFx0aWYgKCEvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRmYWlsZWRSdWxlcy5wdXNoKCdUaGlzIGZpZWxkIG11c3QgYmUgYW4gZW1haWwuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwaG9uZVwiOlxuXHRcdFx0XHRcdGlmICghL15bXFwrXT9bKF0/WzAtOV17M31bKV0/Wy1cXHNcXC5dP1swLTldezN9Wy1cXHNcXC5dP1swLTldezQsNn0kL2ltLnRlc3QodmFsdWUucmVwbGFjZSgnICcsICcnKSkpIHtcblx0XHRcdFx0XHRcdGZhaWxlZFJ1bGVzLnB1c2goJ1RoaXMgZmllbGQgbXVzdCBiZSBhIHBob25lIG51bWJlci4nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoJHRoaXMuaXMoJ3NlbGVjdCcpKSB7IC8vIHN0eWxlIHN1cHBvcnQgZm9yIGJvb3RzdHJhcC1zZWxlY3Rcblx0XHRcdGlmICgkdGhpcy5oYXNDbGFzcygnYWRkLWhhcmR3YXJlLWRldmljZScpKSB7XG5cdFx0XHRcdGlmICgkdGhpcy5jbG9zZXN0KCcuYWZmZWN0ZWQtaXRlbXMtc2VjdGlvbicpLmZpbmQoJy5hZmZlY3RlZC1pdGVtcycpLmZpbmQoJ2xpW2RhdGEtdHlwZT1cImhhcmR3YXJlXCJdJykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0ZmFpbGVkUnVsZXMucHVzaCgnQWRkIGF0IGxlYXN0IG9uZSBoYXJkd2FyZSBkZXZpY2UuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0JHRoaXMgPSAkdGhpcy5zaWJsaW5ncygnYnV0dG9uLmRyb3Bkb3duLXRvZ2dsZScpO1xuXHRcdH1cblxuXHRcdGlmIChmYWlsZWRSdWxlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHQkdGhpcy5hZGRDbGFzcygnaXMtaW52YWxpZCcpO1xuXG5cdFx0XHRpZiAoISR0aGlzLnBhcmVudCgpLmlzKCcuYXNzaWduZWQtdG8tb3B0aW9ucycpKSB7XG5cdFx0XHRcdHZhciAkaW52YWxpZEZlZWRiYWNrID0gJCgnPGRpdiBjbGFzcz1cImludmFsaWQtZmVlZGJhY2tcIj4nKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZhaWxlZFJ1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0JGludmFsaWRGZWVkYmFjay5hcHBlbmQoZmFpbGVkUnVsZXNbaV0gKyAoaSA+PSAxID8gJzxiciAvPicgOiAnJykpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JHRoaXMuY2xvc2VzdCgnLmZvcm0tZ3JvdXAnKS5hcHBlbmQoJGludmFsaWRGZWVkYmFjayk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0JHRoaXMuYWRkQ2xhc3MoJ2lzLXZhbGlkJyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn0pKGpRdWVyeSk7XG5cbi8qKlxuICogUmVzb2x2ZSBhIGRvdCBub3RhdGlvbiBwYXRoIHN0cmluZyB0aHJvdWdoIGFuIG9iamVjdFxuICogRnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjIxMjk5NjAvMTU0OTgxOFxuICovXG5PYmplY3QucmVzb2x2ZSA9IGZ1bmN0aW9uKHBhdGgsIG9iaikge1xuXHRyZXR1cm4gcGF0aC5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXJyKSB7XG5cdFx0cmV0dXJuIHByZXYgPyBwcmV2W2N1cnJdIDogdW5kZWZpbmVkO1xuXHR9LCBvYmogfHwgc2VsZik7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Zyb250ZW5kL2pzL3ZlbmRvci92ZW5kb3IuanMiLCIvLyBqc2NzOmRpc2FibGUgbWF4aW11bUxpbmVMZW5ndGhcbi8qIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVycyAqL1xuLyohXG4gKiBqUXVlcnkgVUkgRGF0ZXBpY2tlciAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogRGF0ZXBpY2tlclxuLy8+Pmdyb3VwOiBXaWRnZXRzXG4vLz4+ZGVzY3JpcHRpb246IERpc3BsYXlzIGEgY2FsZW5kYXIgZnJvbSBhbiBpbnB1dCBvciBpbmxpbmUgZm9yIHNlbGVjdGluZyBkYXRlcy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kYXRlcGlja2VyL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2RhdGVwaWNrZXIvXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29yZS5jc3Ncbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9kYXRlcGlja2VyLmNzc1xuLy8+PmNzcy50aGVtZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGhlbWUuY3NzXG5cbiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbXG5cdFx0XHRcImpxdWVyeVwiLFxuXHRcdFx0XCIuLi92ZXJzaW9uXCIsXG5cdFx0XHRcIi4uL2tleWNvZGVcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59KCBmdW5jdGlvbiggJCApIHtcblxuJC5leHRlbmQoICQudWksIHsgZGF0ZXBpY2tlcjogeyB2ZXJzaW9uOiBcIjEuMTIuMVwiIH0gfSApO1xuXG52YXIgZGF0ZXBpY2tlcl9pbnN0QWN0aXZlO1xuXG5mdW5jdGlvbiBkYXRlcGlja2VyX2dldFppbmRleCggZWxlbSApIHtcblx0dmFyIHBvc2l0aW9uLCB2YWx1ZTtcblx0d2hpbGUgKCBlbGVtLmxlbmd0aCAmJiBlbGVtWyAwIF0gIT09IGRvY3VtZW50ICkge1xuXG5cdFx0Ly8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXG5cdFx0Ly8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXG5cdFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxuXHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIElFIHJldHVybnMgMCB3aGVuIHpJbmRleCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHQvLyBvdGhlciBicm93c2VycyByZXR1cm4gYSBzdHJpbmdcblx0XHRcdC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG5cdFx0XHQvLyA8ZGl2IHN0eWxlPVwiei1pbmRleDogLTEwO1wiPjxkaXYgc3R5bGU9XCJ6LWluZGV4OiAwO1wiPjwvZGl2PjwvZGl2PlxuXHRcdFx0dmFsdWUgPSBwYXJzZUludCggZWxlbS5jc3MoIFwiekluZGV4XCIgKSwgMTAgKTtcblx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZSApICYmIHZhbHVlICE9PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsZW0gPSBlbGVtLnBhcmVudCgpO1xuXHR9XG5cblx0cmV0dXJuIDA7XG59XG4vKiBEYXRlIHBpY2tlciBtYW5hZ2VyLlxuICAgVXNlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgJC5kYXRlcGlja2VyLCB0byBpbnRlcmFjdCB3aXRoIHRoZSBkYXRlIHBpY2tlci5cbiAgIFNldHRpbmdzIGZvciAoZ3JvdXBzIG9mKSBkYXRlIHBpY2tlcnMgYXJlIG1haW50YWluZWQgaW4gYW4gaW5zdGFuY2Ugb2JqZWN0LFxuICAgYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuICovXG5cbmZ1bmN0aW9uIERhdGVwaWNrZXIoKSB7XG5cdHRoaXMuX2N1ckluc3QgPSBudWxsOyAvLyBUaGUgY3VycmVudCBpbnN0YW5jZSBpbiB1c2Vcblx0dGhpcy5fa2V5RXZlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIGxhc3QgZXZlbnQgd2FzIGEga2V5IGV2ZW50XG5cdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gW107IC8vIExpc3Qgb2YgZGF0ZSBwaWNrZXIgaW5wdXRzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkXG5cdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIHBvcHVwIHBpY2tlciBpcyBzaG93aW5nICwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7IC8vIFRydWUgaWYgc2hvd2luZyB3aXRoaW4gYSBcImRpYWxvZ1wiLCBmYWxzZSBpZiBub3Rcblx0dGhpcy5fbWFpbkRpdklkID0gXCJ1aS1kYXRlcGlja2VyLWRpdlwiOyAvLyBUaGUgSUQgb2YgdGhlIG1haW4gZGF0ZXBpY2tlciBkaXZpc2lvblxuXHR0aGlzLl9pbmxpbmVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1pbmxpbmVcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGlubGluZSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fYXBwZW5kQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItYXBwZW5kXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBhcHBlbmQgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3RyaWdnZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci10cmlnZ2VyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyIG1hcmtlciBjbGFzc1xuXHR0aGlzLl9kaWFsb2dDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaWFsb2dcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGRpYWxvZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlzYWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRpc2FibGVkXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaXNhYmxlZCBjb3ZlcmluZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdW5zZWxlY3RhYmxlXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB1bnNlbGVjdGFibGUgY2VsbCBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fY3VycmVudENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWN1cnJlbnQtZGF5XCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGRheSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGF5T3ZlckNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRheXMtY2VsbC1vdmVyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkYXkgaG92ZXIgbWFya2VyIGNsYXNzXG5cdHRoaXMucmVnaW9uYWwgPSBbXTsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlIGNvZGVcblx0dGhpcy5yZWdpb25hbFsgXCJcIiBdID0geyAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzXG5cdFx0Y2xvc2VUZXh0OiBcIkRvbmVcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBjbG9zZSBsaW5rXG5cdFx0cHJldlRleHQ6IFwiUHJldlwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIHByZXZpb3VzIG1vbnRoIGxpbmtcblx0XHRuZXh0VGV4dDogXCJOZXh0XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgbmV4dCBtb250aCBsaW5rXG5cdFx0Y3VycmVudFRleHQ6IFwiVG9kYXlcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBjdXJyZW50IG1vbnRoIGxpbmtcblx0XHRtb250aE5hbWVzOiBbIFwiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXG5cdFx0XHRcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIiBdLCAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiIF0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXM6IFsgXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiIF0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiIF0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNNaW46IFsgXCJTdVwiLFwiTW9cIixcIlR1XCIsXCJXZVwiLFwiVGhcIixcIkZyXCIsXCJTYVwiIF0sIC8vIENvbHVtbiBoZWFkaW5ncyBmb3IgZGF5cyBzdGFydGluZyBhdCBTdW5kYXlcblx0XHR3ZWVrSGVhZGVyOiBcIldrXCIsIC8vIENvbHVtbiBoZWFkZXIgZm9yIHdlZWsgb2YgdGhlIHllYXJcblx0XHRkYXRlRm9ybWF0OiBcIm1tL2RkL3l5XCIsIC8vIFNlZSBmb3JtYXQgb3B0aW9ucyBvbiBwYXJzZURhdGVcblx0XHRmaXJzdERheTogMCwgLy8gVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgU3VuID0gMCwgTW9uID0gMSwgLi4uXG5cdFx0aXNSVEw6IGZhbHNlLCAvLyBUcnVlIGlmIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UsIGZhbHNlIGlmIGxlZnQtdG8tcmlnaHRcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSB5ZWFyIHNlbGVjdCBwcmVjZWRlcyBtb250aCwgZmFsc2UgZm9yIG1vbnRoIHRoZW4geWVhclxuXHRcdHllYXJTdWZmaXg6IFwiXCIgLy8gQWRkaXRpb25hbCB0ZXh0IHRvIGFwcGVuZCB0byB0aGUgeWVhciBpbiB0aGUgbW9udGggaGVhZGVyc1xuXHR9O1xuXHR0aGlzLl9kZWZhdWx0cyA9IHsgLy8gR2xvYmFsIGRlZmF1bHRzIGZvciBhbGwgdGhlIGRhdGUgcGlja2VyIGluc3RhbmNlc1xuXHRcdHNob3dPbjogXCJmb2N1c1wiLCAvLyBcImZvY3VzXCIgZm9yIHBvcHVwIG9uIGZvY3VzLFxuXHRcdFx0Ly8gXCJidXR0b25cIiBmb3IgdHJpZ2dlciBidXR0b24sIG9yIFwiYm90aFwiIGZvciBlaXRoZXJcblx0XHRzaG93QW5pbTogXCJmYWRlSW5cIiwgLy8gTmFtZSBvZiBqUXVlcnkgYW5pbWF0aW9uIGZvciBwb3B1cFxuXHRcdHNob3dPcHRpb25zOiB7fSwgLy8gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9uc1xuXHRcdGRlZmF1bHREYXRlOiBudWxsLCAvLyBVc2VkIHdoZW4gZmllbGQgaXMgYmxhbms6IGFjdHVhbCBkYXRlLFxuXHRcdFx0Ly8gKy8tbnVtYmVyIGZvciBvZmZzZXQgZnJvbSB0b2RheSwgbnVsbCBmb3IgdG9kYXlcblx0XHRhcHBlbmRUZXh0OiBcIlwiLCAvLyBEaXNwbGF5IHRleHQgZm9sbG93aW5nIHRoZSBpbnB1dCBib3gsIGUuZy4gc2hvd2luZyB0aGUgZm9ybWF0XG5cdFx0YnV0dG9uVGV4dDogXCIuLi5cIiwgLy8gVGV4dCBmb3IgdHJpZ2dlciBidXR0b25cblx0XHRidXR0b25JbWFnZTogXCJcIiwgLy8gVVJMIGZvciB0cmlnZ2VyIGJ1dHRvbiBpbWFnZVxuXHRcdGJ1dHRvbkltYWdlT25seTogZmFsc2UsIC8vIFRydWUgaWYgdGhlIGltYWdlIGFwcGVhcnMgYWxvbmUsIGZhbHNlIGlmIGl0IGFwcGVhcnMgb24gYSBidXR0b25cblx0XHRoaWRlSWZOb1ByZXZOZXh0OiBmYWxzZSwgLy8gVHJ1ZSB0byBoaWRlIG5leHQvcHJldmlvdXMgbW9udGggbGlua3Ncblx0XHRcdC8vIGlmIG5vdCBhcHBsaWNhYmxlLCBmYWxzZSB0byBqdXN0IGRpc2FibGUgdGhlbVxuXHRcdG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQ6IGZhbHNlLCAvLyBUcnVlIGlmIGRhdGUgZm9ybWF0dGluZyBhcHBsaWVkIHRvIHByZXYvdG9kYXkvbmV4dCBsaW5rc1xuXHRcdGdvdG9DdXJyZW50OiBmYWxzZSwgLy8gVHJ1ZSBpZiB0b2RheSBsaW5rIGdvZXMgYmFjayB0byBjdXJyZW50IHNlbGVjdGlvbiBpbnN0ZWFkXG5cdFx0Y2hhbmdlTW9udGg6IGZhbHNlLCAvLyBUcnVlIGlmIG1vbnRoIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHRjaGFuZ2VZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB5ZWFyIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHR5ZWFyUmFuZ2U6IFwiYy0xMDpjKzEwXCIsIC8vIFJhbmdlIG9mIHllYXJzIHRvIGRpc3BsYXkgaW4gZHJvcC1kb3duLFxuXHRcdFx0Ly8gZWl0aGVyIHJlbGF0aXZlIHRvIHRvZGF5J3MgeWVhciAoLW5uOitubiksIHJlbGF0aXZlIHRvIGN1cnJlbnRseSBkaXNwbGF5ZWQgeWVhclxuXHRcdFx0Ly8gKGMtbm46YytubiksIGFic29sdXRlIChubm5uOm5ubm4pLCBvciBhIGNvbWJpbmF0aW9uIG9mIHRoZSBhYm92ZSAobm5ubjotbilcblx0XHRzaG93T3RoZXJNb250aHM6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSB0byBsZWF2ZSBibGFua1xuXHRcdHNlbGVjdE90aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSBmb3IgdW5zZWxlY3RhYmxlXG5cdFx0c2hvd1dlZWs6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgd2VlayBvZiB0aGUgeWVhciwgZmFsc2UgdG8gbm90IHNob3cgaXRcblx0XHRjYWxjdWxhdGVXZWVrOiB0aGlzLmlzbzg2MDFXZWVrLCAvLyBIb3cgdG8gY2FsY3VsYXRlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyLFxuXHRcdFx0Ly8gdGFrZXMgYSBEYXRlIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIHdlZWsgZm9yIGl0XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmOiBcIisxMFwiLCAvLyBTaG9ydCB5ZWFyIHZhbHVlcyA8IHRoaXMgYXJlIGluIHRoZSBjdXJyZW50IGNlbnR1cnksXG5cdFx0XHQvLyA+IHRoaXMgYXJlIGluIHRoZSBwcmV2aW91cyBjZW50dXJ5LFxuXHRcdFx0Ly8gc3RyaW5nIHZhbHVlIHN0YXJ0aW5nIHdpdGggXCIrXCIgZm9yIGN1cnJlbnQgeWVhciArIHZhbHVlXG5cdFx0bWluRGF0ZTogbnVsbCwgLy8gVGhlIGVhcmxpZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRtYXhEYXRlOiBudWxsLCAvLyBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRkdXJhdGlvbjogXCJmYXN0XCIsIC8vIER1cmF0aW9uIG9mIGRpc3BsYXkvY2xvc3VyZVxuXHRcdGJlZm9yZVNob3dEYXk6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBkYXRlIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGhcblx0XHRcdC8vIFswXSA9IHRydWUgaWYgc2VsZWN0YWJsZSwgZmFsc2UgaWYgbm90LCBbMV0gPSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUocykgb3IgXCJcIixcblx0XHRcdC8vIFsyXSA9IGNlbGwgdGl0bGUgKG9wdGlvbmFsKSwgZS5nLiAkLmRhdGVwaWNrZXIubm9XZWVrZW5kc1xuXHRcdGJlZm9yZVNob3c6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gaW5wdXQgZmllbGQgYW5kXG5cdFx0XHQvLyByZXR1cm5zIGEgc2V0IG9mIGN1c3RvbSBzZXR0aW5ncyBmb3IgdGhlIGRhdGUgcGlja2VyXG5cdFx0b25TZWxlY3Q6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdFx0b25DaGFuZ2VNb250aFllYXI6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIG1vbnRoIG9yIHllYXIgaXMgY2hhbmdlZFxuXHRcdG9uQ2xvc2U6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgY2xvc2VkXG5cdFx0bnVtYmVyT2ZNb250aHM6IDEsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc2hvdyBhdCBhIHRpbWVcblx0XHRzaG93Q3VycmVudEF0UG9zOiAwLCAvLyBUaGUgcG9zaXRpb24gaW4gbXVsdGlwZSBtb250aHMgYXQgd2hpY2ggdG8gc2hvdyB0aGUgY3VycmVudCBtb250aCAoc3RhcnRpbmcgYXQgMClcblx0XHRzdGVwTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkXG5cdFx0c3RlcEJpZ01vbnRoczogMTIsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc3RlcCBiYWNrL2ZvcndhcmQgZm9yIHRoZSBiaWcgbGlua3Ncblx0XHRhbHRGaWVsZDogXCJcIiwgLy8gU2VsZWN0b3IgZm9yIGFuIGFsdGVybmF0ZSBmaWVsZCB0byBzdG9yZSBzZWxlY3RlZCBkYXRlcyBpbnRvXG5cdFx0YWx0Rm9ybWF0OiBcIlwiLCAvLyBUaGUgZGF0ZSBmb3JtYXQgdG8gdXNlIGZvciB0aGUgYWx0ZXJuYXRlIGZpZWxkXG5cdFx0Y29uc3RyYWluSW5wdXQ6IHRydWUsIC8vIFRoZSBpbnB1dCBpcyBjb25zdHJhaW5lZCBieSB0aGUgY3VycmVudCBkYXRlIGZvcm1hdFxuXHRcdHNob3dCdXR0b25QYW5lbDogZmFsc2UsIC8vIFRydWUgdG8gc2hvdyBidXR0b24gcGFuZWwsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0YXV0b1NpemU6IGZhbHNlLCAvLyBUcnVlIHRvIHNpemUgdGhlIGlucHV0IGZvciB0aGUgZGF0ZSBmb3JtYXQsIGZhbHNlIHRvIGxlYXZlIGFzIGlzXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlIC8vIFRoZSBpbml0aWFsIGRpc2FibGVkIHN0YXRlXG5cdH07XG5cdCQuZXh0ZW5kKCB0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFsgXCJcIiBdICk7XG5cdHRoaXMucmVnaW9uYWwuZW4gPSAkLmV4dGVuZCggdHJ1ZSwge30sIHRoaXMucmVnaW9uYWxbIFwiXCIgXSApO1xuXHR0aGlzLnJlZ2lvbmFsWyBcImVuLVVTXCIgXSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgdGhpcy5yZWdpb25hbC5lbiApO1xuXHR0aGlzLmRwRGl2ID0gZGF0ZXBpY2tlcl9iaW5kSG92ZXIoICQoIFwiPGRpdiBpZD0nXCIgKyB0aGlzLl9tYWluRGl2SWQgKyBcIicgY2xhc3M9J3VpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cIiApICk7XG59XG5cbiQuZXh0ZW5kKCBEYXRlcGlja2VyLnByb3RvdHlwZSwge1xuXHQvKiBDbGFzcyBuYW1lIGFkZGVkIHRvIGVsZW1lbnRzIHRvIGluZGljYXRlIGFscmVhZHkgY29uZmlndXJlZCB3aXRoIGEgZGF0ZSBwaWNrZXIuICovXG5cdG1hcmtlckNsYXNzTmFtZTogXCJoYXNEYXRlcGlja2VyXCIsXG5cblx0Ly9LZWVwIHRyYWNrIG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRtYXhSb3dzOiA0LFxuXG5cdC8vIFRPRE8gcmVuYW1lIHRvIFwid2lkZ2V0XCIgd2hlbiBzd2l0Y2hpbmcgdG8gd2lkZ2V0IGZhY3Rvcnlcblx0X3dpZGdldERhdGVwaWNrZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRwRGl2O1xuXHR9LFxuXG5cdC8qIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoZSBkYXRlIHBpY2tlci5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgYXMgZGVmYXVsdHMgKGFub255bW91cyBvYmplY3QpXG5cdCAqIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0XG5cdCAqL1xuXHRzZXREZWZhdWx0czogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKCB0aGlzLl9kZWZhdWx0cywgc2V0dGluZ3MgfHwge30gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgZm9yIHRoaXMgZGF0ZSBwaWNrZXIgaW5zdGFuY2UgKGFub255bW91cylcblx0ICovXG5cdF9hdHRhY2hEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHR2YXIgbm9kZU5hbWUsIGlubGluZSwgaW5zdDtcblx0XHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlubGluZSA9ICggbm9kZU5hbWUgPT09IFwiZGl2XCIgfHwgbm9kZU5hbWUgPT09IFwic3BhblwiICk7XG5cdFx0aWYgKCAhdGFyZ2V0LmlkICkge1xuXHRcdFx0dGhpcy51dWlkICs9IDE7XG5cdFx0XHR0YXJnZXQuaWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0fVxuXHRcdGluc3QgPSB0aGlzLl9uZXdJbnN0KCAkKCB0YXJnZXQgKSwgaW5saW5lICk7XG5cdFx0aW5zdC5zZXR0aW5ncyA9ICQuZXh0ZW5kKCB7fSwgc2V0dGluZ3MgfHwge30gKTtcblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHR0aGlzLl9jb25uZWN0RGF0ZXBpY2tlciggdGFyZ2V0LCBpbnN0ICk7XG5cdFx0fSBlbHNlIGlmICggaW5saW5lICkge1xuXHRcdFx0dGhpcy5faW5saW5lRGF0ZXBpY2tlciggdGFyZ2V0LCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvYmplY3QuICovXG5cdF9uZXdJbnN0OiBmdW5jdGlvbiggdGFyZ2V0LCBpbmxpbmUgKSB7XG5cdFx0dmFyIGlkID0gdGFyZ2V0WyAwIF0uaWQucmVwbGFjZSggLyhbXkEtWmEtejAtOV9cXC1dKS9nLCBcIlxcXFxcXFxcJDFcIiApOyAvLyBlc2NhcGUgalF1ZXJ5IG1ldGEgY2hhcnNcblx0XHRyZXR1cm4geyBpZDogaWQsIGlucHV0OiB0YXJnZXQsIC8vIGFzc29jaWF0ZWQgdGFyZ2V0XG5cdFx0XHRzZWxlY3RlZERheTogMCwgc2VsZWN0ZWRNb250aDogMCwgc2VsZWN0ZWRZZWFyOiAwLCAvLyBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ZHJhd01vbnRoOiAwLCBkcmF3WWVhcjogMCwgLy8gbW9udGggYmVpbmcgZHJhd25cblx0XHRcdGlubGluZTogaW5saW5lLCAvLyBpcyBkYXRlcGlja2VyIGlubGluZSBvciBub3Rcblx0XHRcdGRwRGl2OiAoICFpbmxpbmUgPyB0aGlzLmRwRGl2IDogLy8gcHJlc2VudGF0aW9uIGRpdlxuXHRcdFx0ZGF0ZXBpY2tlcl9iaW5kSG92ZXIoICQoIFwiPGRpdiBjbGFzcz0nXCIgKyB0aGlzLl9pbmxpbmVDbGFzcyArIFwiIHVpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cIiApICkgKSB9O1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYW4gaW5wdXQgZmllbGQuICovXG5cdF9jb25uZWN0RGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCwgaW5zdCApIHtcblx0XHR2YXIgaW5wdXQgPSAkKCB0YXJnZXQgKTtcblx0XHRpbnN0LmFwcGVuZCA9ICQoIFtdICk7XG5cdFx0aW5zdC50cmlnZ2VyID0gJCggW10gKTtcblx0XHRpZiAoIGlucHV0Lmhhc0NsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hdHRhY2htZW50cyggaW5wdXQsIGluc3QgKTtcblx0XHRpbnB1dC5hZGRDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKS5vbiggXCJrZXlkb3duXCIsIHRoaXMuX2RvS2V5RG93biApLlxuXHRcdFx0b24oIFwia2V5cHJlc3NcIiwgdGhpcy5fZG9LZXlQcmVzcyApLm9uKCBcImtleXVwXCIsIHRoaXMuX2RvS2V5VXAgKTtcblx0XHR0aGlzLl9hdXRvU2l6ZSggaW5zdCApO1xuXHRcdCQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiwgaW5zdCApO1xuXG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBvbmNlIGl0IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBpbnB1dCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiAoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIE1ha2UgYXR0YWNobWVudHMgYmFzZWQgb24gc2V0dGluZ3MuICovXG5cdF9hdHRhY2htZW50czogZnVuY3Rpb24oIGlucHV0LCBpbnN0ICkge1xuXHRcdHZhciBzaG93T24sIGJ1dHRvblRleHQsIGJ1dHRvbkltYWdlLFxuXHRcdFx0YXBwZW5kVGV4dCA9IHRoaXMuX2dldCggaW5zdCwgXCJhcHBlbmRUZXh0XCIgKSxcblx0XHRcdGlzUlRMID0gdGhpcy5fZ2V0KCBpbnN0LCBcImlzUlRMXCIgKTtcblxuXHRcdGlmICggaW5zdC5hcHBlbmQgKSB7XG5cdFx0XHRpbnN0LmFwcGVuZC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKCBhcHBlbmRUZXh0ICkge1xuXHRcdFx0aW5zdC5hcHBlbmQgPSAkKCBcIjxzcGFuIGNsYXNzPSdcIiArIHRoaXMuX2FwcGVuZENsYXNzICsgXCInPlwiICsgYXBwZW5kVGV4dCArIFwiPC9zcGFuPlwiICk7XG5cdFx0XHRpbnB1dFsgaXNSVEwgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiIF0oIGluc3QuYXBwZW5kICk7XG5cdFx0fVxuXG5cdFx0aW5wdXQub2ZmKCBcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyICk7XG5cblx0XHRpZiAoIGluc3QudHJpZ2dlciApIHtcblx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRzaG93T24gPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd09uXCIgKTtcblx0XHRpZiAoIHNob3dPbiA9PT0gXCJmb2N1c1wiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIgKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGluIHRoZSBtYXJrZWQgZmllbGRcblx0XHRcdGlucHV0Lm9uKCBcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyICk7XG5cdFx0fVxuXHRcdGlmICggc2hvd09uID09PSBcImJ1dHRvblwiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIgKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGJ1dHRvbiBjbGlja2VkXG5cdFx0XHRidXR0b25UZXh0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImJ1dHRvblRleHRcIiApO1xuXHRcdFx0YnV0dG9uSW1hZ2UgPSB0aGlzLl9nZXQoIGluc3QsIFwiYnV0dG9uSW1hZ2VcIiApO1xuXHRcdFx0aW5zdC50cmlnZ2VyID0gJCggdGhpcy5fZ2V0KCBpbnN0LCBcImJ1dHRvbkltYWdlT25seVwiICkgP1xuXHRcdFx0XHQkKCBcIjxpbWcvPlwiICkuYWRkQ2xhc3MoIHRoaXMuX3RyaWdnZXJDbGFzcyApLlxuXHRcdFx0XHRcdGF0dHIoIHsgc3JjOiBidXR0b25JbWFnZSwgYWx0OiBidXR0b25UZXh0LCB0aXRsZTogYnV0dG9uVGV4dCB9ICkgOlxuXHRcdFx0XHQkKCBcIjxidXR0b24gdHlwZT0nYnV0dG9uJz48L2J1dHRvbj5cIiApLmFkZENsYXNzKCB0aGlzLl90cmlnZ2VyQ2xhc3MgKS5cblx0XHRcdFx0XHRodG1sKCAhYnV0dG9uSW1hZ2UgPyBidXR0b25UZXh0IDogJCggXCI8aW1nLz5cIiApLmF0dHIoXG5cdFx0XHRcdFx0eyBzcmM6YnV0dG9uSW1hZ2UsIGFsdDpidXR0b25UZXh0LCB0aXRsZTpidXR0b25UZXh0IH0gKSApICk7XG5cdFx0XHRpbnB1dFsgaXNSVEwgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiIF0oIGluc3QudHJpZ2dlciApO1xuXHRcdFx0aW5zdC50cmlnZ2VyLm9uKCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgPT09IGlucHV0WyAwIF0gKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ICE9PSBpbnB1dFsgMCBdICkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKCBpbnB1dFsgMCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlciggaW5wdXRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0LyogQXBwbHkgdGhlIG1heGltdW0gbGVuZ3RoIGZvciB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9hdXRvU2l6ZTogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0aWYgKCB0aGlzLl9nZXQoIGluc3QsIFwiYXV0b1NpemVcIiApICYmICFpbnN0LmlubGluZSApIHtcblx0XHRcdHZhciBmaW5kTWF4LCBtYXgsIG1heEksIGksXG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSggMjAwOSwgMTIgLSAxLCAyMCApLCAvLyBFbnN1cmUgZG91YmxlIGRpZ2l0c1xuXHRcdFx0XHRkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApO1xuXG5cdFx0XHRpZiAoIGRhdGVGb3JtYXQubWF0Y2goIC9bRE1dLyApICkge1xuXHRcdFx0XHRmaW5kTWF4ID0gZnVuY3Rpb24oIG5hbWVzICkge1xuXHRcdFx0XHRcdG1heCA9IDA7XG5cdFx0XHRcdFx0bWF4SSA9IDA7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdGlmICggbmFtZXNbIGkgXS5sZW5ndGggPiBtYXggKSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IG5hbWVzWyBpIF0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRtYXhJID0gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1heEk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGRhdGUuc2V0TW9udGgoIGZpbmRNYXgoIHRoaXMuX2dldCggaW5zdCwgKCBkYXRlRm9ybWF0Lm1hdGNoKCAvTU0vICkgP1xuXHRcdFx0XHRcdFwibW9udGhOYW1lc1wiIDogXCJtb250aE5hbWVzU2hvcnRcIiApICkgKSApO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoIGZpbmRNYXgoIHRoaXMuX2dldCggaW5zdCwgKCBkYXRlRm9ybWF0Lm1hdGNoKCAvREQvICkgP1xuXHRcdFx0XHRcdFwiZGF5TmFtZXNcIiA6IFwiZGF5TmFtZXNTaG9ydFwiICkgKSApICsgMjAgLSBkYXRlLmdldERheSgpICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0LmlucHV0LmF0dHIoIFwic2l6ZVwiLCB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LCBkYXRlICkubGVuZ3RoICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEF0dGFjaCBhbiBpbmxpbmUgZGF0ZSBwaWNrZXIgdG8gYSBkaXYuICovXG5cdF9pbmxpbmVEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBpbnN0ICkge1xuXHRcdHZhciBkaXZTcGFuID0gJCggdGFyZ2V0ICk7XG5cdFx0aWYgKCBkaXZTcGFuLmhhc0NsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRkaXZTcGFuLmFkZENsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApLmFwcGVuZCggaW5zdC5kcERpdiApO1xuXHRcdCQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiwgaW5zdCApO1xuXHRcdHRoaXMuX3NldERhdGUoIGluc3QsIHRoaXMuX2dldERlZmF1bHREYXRlKCBpbnN0ICksIHRydWUgKTtcblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cblx0XHQvL0lmIGRpc2FibGVkIG9wdGlvbiBpcyB0cnVlLCBkaXNhYmxlIHRoZSBkYXRlcGlja2VyIGJlZm9yZSBzaG93aW5nIGl0IChzZWUgdGlja2V0ICM1NjY1KVxuXHRcdGlmICggaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgZGlzcGxheTpibG9jayBpbiBwbGFjZSBvZiBpbnN0LmRwRGl2LnNob3coKSB3aGljaCB3b24ndCB3b3JrIG9uIGRpc2Nvbm5lY3RlZCBlbGVtZW50c1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeXVpLmNvbS90aWNrZXQvNzU1MiAtIEEgRGF0ZXBpY2tlciBjcmVhdGVkIG9uIGEgZGV0YWNoZWQgZGl2IGhhcyB6ZXJvIGhlaWdodFxuXHRcdGluc3QuZHBEaXYuY3NzKCBcImRpc3BsYXlcIiwgXCJibG9ja1wiICk7XG5cdH0sXG5cblx0LyogUG9wLXVwIHRoZSBkYXRlIHBpY2tlciBpbiBhIFwiZGlhbG9nXCIgYm94LlxuXHQgKiBAcGFyYW0gIGlucHV0IGVsZW1lbnQgLSBpZ25vcmVkXG5cdCAqIEBwYXJhbSAgZGF0ZVx0c3RyaW5nIG9yIERhdGUgLSB0aGUgaW5pdGlhbCBkYXRlIHRvIGRpc3BsYXlcblx0ICogQHBhcmFtICBvblNlbGVjdCAgZnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZFxuXHQgKiBAcGFyYW0gIHNldHRpbmdzICBvYmplY3QgLSB1cGRhdGUgdGhlIGRpYWxvZyBkYXRlIHBpY2tlciBpbnN0YW5jZSdzIHNldHRpbmdzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHQgKiBAcGFyYW0gIHBvcyBpbnRbMl0gLSBjb29yZGluYXRlcyBmb3IgdGhlIGRpYWxvZydzIHBvc2l0aW9uIHdpdGhpbiB0aGUgc2NyZWVuIG9yXG5cdCAqXHRcdFx0XHRcdGV2ZW50IC0gd2l0aCB4L3kgY29vcmRpbmF0ZXMgb3Jcblx0ICpcdFx0XHRcdFx0bGVhdmUgZW1wdHkgZm9yIGRlZmF1bHQgKHNjcmVlbiBjZW50cmUpXG5cdCAqIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0XG5cdCAqL1xuXHRfZGlhbG9nRGF0ZXBpY2tlcjogZnVuY3Rpb24oIGlucHV0LCBkYXRlLCBvblNlbGVjdCwgc2V0dGluZ3MsIHBvcyApIHtcblx0XHR2YXIgaWQsIGJyb3dzZXJXaWR0aCwgYnJvd3NlckhlaWdodCwgc2Nyb2xsWCwgc2Nyb2xsWSxcblx0XHRcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0OyAvLyBpbnRlcm5hbCBpbnN0YW5jZVxuXG5cdFx0aWYgKCAhaW5zdCApIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0aWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0XHR0aGlzLl9kaWFsb2dJbnB1dCA9ICQoIFwiPGlucHV0IHR5cGU9J3RleHQnIGlkPSdcIiArIGlkICtcblx0XHRcdFx0XCInIHN0eWxlPSdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMHB4OyB3aWR0aDogMHB4OycvPlwiICk7XG5cdFx0XHR0aGlzLl9kaWFsb2dJbnB1dC5vbiggXCJrZXlkb3duXCIsIHRoaXMuX2RvS2V5RG93biApO1xuXHRcdFx0JCggXCJib2R5XCIgKS5hcHBlbmQoIHRoaXMuX2RpYWxvZ0lucHV0ICk7XG5cdFx0XHRpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdCA9IHRoaXMuX25ld0luc3QoIHRoaXMuX2RpYWxvZ0lucHV0LCBmYWxzZSApO1xuXHRcdFx0aW5zdC5zZXR0aW5ncyA9IHt9O1xuXHRcdFx0JC5kYXRhKCB0aGlzLl9kaWFsb2dJbnB1dFsgMCBdLCBcImRhdGVwaWNrZXJcIiwgaW5zdCApO1xuXHRcdH1cblx0XHRkYXRlcGlja2VyX2V4dGVuZFJlbW92ZSggaW5zdC5zZXR0aW5ncywgc2V0dGluZ3MgfHwge30gKTtcblx0XHRkYXRlID0gKCBkYXRlICYmIGRhdGUuY29uc3RydWN0b3IgPT09IERhdGUgPyB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LCBkYXRlICkgOiBkYXRlICk7XG5cdFx0dGhpcy5fZGlhbG9nSW5wdXQudmFsKCBkYXRlICk7XG5cblx0XHR0aGlzLl9wb3MgPSAoIHBvcyA/ICggcG9zLmxlbmd0aCA/IHBvcyA6IFsgcG9zLnBhZ2VYLCBwb3MucGFnZVkgXSApIDogbnVsbCApO1xuXHRcdGlmICggIXRoaXMuX3BvcyApIHtcblx0XHRcdGJyb3dzZXJXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblx0XHRcdGJyb3dzZXJIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXHRcdFx0c2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdHNjcm9sbFkgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0dGhpcy5fcG9zID0gLy8gc2hvdWxkIHVzZSBhY3R1YWwgd2lkdGgvaGVpZ2h0IGJlbG93XG5cdFx0XHRcdFsgKCBicm93c2VyV2lkdGggLyAyICkgLSAxMDAgKyBzY3JvbGxYLCAoIGJyb3dzZXJIZWlnaHQgLyAyICkgLSAxNTAgKyBzY3JvbGxZIF07XG5cdFx0fVxuXG5cdFx0Ly8gTW92ZSBpbnB1dCBvbiBzY3JlZW4gZm9yIGZvY3VzLCBidXQgaGlkZGVuIGJlaGluZCBkaWFsb2dcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC5jc3MoIFwibGVmdFwiLCAoIHRoaXMuX3Bvc1sgMCBdICsgMjAgKSArIFwicHhcIiApLmNzcyggXCJ0b3BcIiwgdGhpcy5fcG9zWyAxIF0gKyBcInB4XCIgKTtcblx0XHRpbnN0LnNldHRpbmdzLm9uU2VsZWN0ID0gb25TZWxlY3Q7XG5cdFx0dGhpcy5faW5EaWFsb2cgPSB0cnVlO1xuXHRcdHRoaXMuZHBEaXYuYWRkQ2xhc3MoIHRoaXMuX2RpYWxvZ0NsYXNzICk7XG5cdFx0dGhpcy5fc2hvd0RhdGVwaWNrZXIoIHRoaXMuX2RpYWxvZ0lucHV0WyAwIF0gKTtcblx0XHRpZiAoICQuYmxvY2tVSSApIHtcblx0XHRcdCQuYmxvY2tVSSggdGhpcy5kcERpdiApO1xuXHRcdH1cblx0XHQkLmRhdGEoIHRoaXMuX2RpYWxvZ0lucHV0WyAwIF0sIFwiZGF0ZXBpY2tlclwiLCBpbnN0ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogRGV0YWNoIGEgZGF0ZXBpY2tlciBmcm9tIGl0cyBjb250cm9sLlxuXHQgKiBAcGFyYW0gIHRhcmdldFx0ZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKi9cblx0X2Rlc3Ryb3lEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBub2RlTmFtZSxcblx0XHRcdCR0YXJnZXQgPSAkKCB0YXJnZXQgKSxcblx0XHRcdGluc3QgPSAkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblxuXHRcdGlmICggISR0YXJnZXQuaGFzQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHQkLnJlbW92ZURhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRpbnN0LmFwcGVuZC5yZW1vdmUoKTtcblx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHRcdCR0YXJnZXQucmVtb3ZlQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkuXG5cdFx0XHRcdG9mZiggXCJmb2N1c1wiLCB0aGlzLl9zaG93RGF0ZXBpY2tlciApLlxuXHRcdFx0XHRvZmYoIFwia2V5ZG93blwiLCB0aGlzLl9kb0tleURvd24gKS5cblx0XHRcdFx0b2ZmKCBcImtleXByZXNzXCIsIHRoaXMuX2RvS2V5UHJlc3MgKS5cblx0XHRcdFx0b2ZmKCBcImtleXVwXCIsIHRoaXMuX2RvS2V5VXAgKTtcblx0XHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIgKSB7XG5cdFx0XHQkdGFyZ2V0LnJlbW92ZUNsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApLmVtcHR5KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRlcGlja2VyX2luc3RBY3RpdmUgPT09IGluc3QgKSB7XG5cdFx0XHRkYXRlcGlja2VyX2luc3RBY3RpdmUgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvKiBFbmFibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9lbmFibGVEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQoIHRhcmdldCApLFxuXHRcdFx0aW5zdCA9ICQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiApO1xuXG5cdFx0aWYgKCAhJHRhcmdldC5oYXNDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlciggXCJidXR0b25cIiApLlxuXHRcdFx0XHRlYWNoKCBmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IGZhbHNlOyB9ICkuZW5kKCkuXG5cdFx0XHRcdGZpbHRlciggXCJpbWdcIiApLmNzcyggeyBvcGFjaXR5OiBcIjEuMFwiLCBjdXJzb3I6IFwiXCIgfSApO1xuXHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIiApIHtcblx0XHRcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oIFwiLlwiICsgdGhpcy5faW5saW5lQ2xhc3MgKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0XHRcdGlubGluZS5maW5kKCBcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIgKS5cblx0XHRcdFx0cHJvcCggXCJkaXNhYmxlZFwiLCBmYWxzZSApO1xuXHRcdH1cblx0XHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKCB0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKCB2YWx1ZSApIHsgcmV0dXJuICggdmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSApOyB9ICk7IC8vIGRlbGV0ZSBlbnRyeVxuXHR9LFxuXG5cdC8qIERpc2FibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9kaXNhYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgbm9kZU5hbWUsIGlubGluZSxcblx0XHRcdCR0YXJnZXQgPSAkKCB0YXJnZXQgKSxcblx0XHRcdGluc3QgPSAkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblxuXHRcdGlmICggISR0YXJnZXQuaGFzQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHR0YXJnZXQuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlciggXCJidXR0b25cIiApLlxuXHRcdFx0XHRlYWNoKCBmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IHRydWU7IH0gKS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKCBcImltZ1wiICkuY3NzKCB7IG9wYWNpdHk6IFwiMC41XCIsIGN1cnNvcjogXCJkZWZhdWx0XCIgfSApO1xuXHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIiApIHtcblx0XHRcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oIFwiLlwiICsgdGhpcy5faW5saW5lQ2xhc3MgKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLmFkZENsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0XHRcdGlubGluZS5maW5kKCBcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIgKS5cblx0XHRcdFx0cHJvcCggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdFx0fVxuXHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAoIHRoaXMuX2Rpc2FibGVkSW5wdXRzLFxuXHRcdFx0ZnVuY3Rpb24oIHZhbHVlICkgeyByZXR1cm4gKCB2YWx1ZSA9PT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlICk7IH0gKTsgLy8gZGVsZXRlIGVudHJ5XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHNbIHRoaXMuX2Rpc2FibGVkSW5wdXRzLmxlbmd0aCBdID0gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qIElzIHRoZSBmaXJzdCBmaWVsZCBpbiBhIGpRdWVyeSBjb2xsZWN0aW9uIGRpc2FibGVkIGFzIGEgZGF0ZXBpY2tlcj9cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHJldHVybiBib29sZWFuIC0gdHJ1ZSBpZiBkaXNhYmxlZCwgZmFsc2UgaWYgZW5hYmxlZFxuXHQgKi9cblx0X2lzRGlzYWJsZWREYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdGlmICggIXRhcmdldCApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5fZGlzYWJsZWRJbnB1dHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXMuX2Rpc2FibGVkSW5wdXRzWyBpIF0gPT09IHRhcmdldCApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxuXHQgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcmV0dXJuICBvYmplY3QgLSB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZSBkYXRhXG5cdCAqIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhXG5cdCAqL1xuXHRfZ2V0SW5zdDogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuICQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiApO1xuXHRcdH1cblx0XHRjYXRjaCAoIGVyciApIHtcblx0XHRcdHRocm93IFwiTWlzc2luZyBpbnN0YW5jZSBkYXRhIGZvciB0aGlzIGRhdGVwaWNrZXJcIjtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIG9yIHJldHJpZXZlIHRoZSBzZXR0aW5ncyBmb3IgYSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBuYW1lXHRvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVwZGF0ZSBvclxuXHQgKlx0XHRcdFx0c3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gY2hhbmdlIG9yIHJldHJpZXZlLFxuXHQgKlx0XHRcdFx0d2hlbiByZXRyaWV2aW5nIGFsc28gXCJhbGxcIiBmb3IgYWxsIGluc3RhbmNlIHNldHRpbmdzIG9yXG5cdCAqXHRcdFx0XHRcImRlZmF1bHRzXCIgZm9yIGFsbCBnbG9iYWwgZGVmYXVsdHNcblx0ICogQHBhcmFtICB2YWx1ZSAgIGFueSAtIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nXG5cdCAqXHRcdFx0XHQob21pdCBpZiBhYm92ZSBpcyBhbiBvYmplY3Qgb3IgdG8gcmV0cmlldmUgYSB2YWx1ZSlcblx0ICovXG5cdF9vcHRpb25EYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgc2V0dGluZ3MsIGRhdGUsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0ICk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gKCBuYW1lID09PSBcImRlZmF1bHRzXCIgPyAkLmV4dGVuZCgge30sICQuZGF0ZXBpY2tlci5fZGVmYXVsdHMgKSA6XG5cdFx0XHRcdCggaW5zdCA/ICggbmFtZSA9PT0gXCJhbGxcIiA/ICQuZXh0ZW5kKCB7fSwgaW5zdC5zZXR0aW5ncyApIDpcblx0XHRcdFx0dGhpcy5fZ2V0KCBpbnN0LCBuYW1lICkgKSA6IG51bGwgKSApO1xuXHRcdH1cblxuXHRcdHNldHRpbmdzID0gbmFtZSB8fCB7fTtcblx0XHRpZiAoIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0c2V0dGluZ3MgPSB7fTtcblx0XHRcdHNldHRpbmdzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGluc3QgKSB7XG5cdFx0XHRpZiAoIHRoaXMuX2N1ckluc3QgPT09IGluc3QgKSB7XG5cdFx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR9XG5cblx0XHRcdGRhdGUgPSB0aGlzLl9nZXREYXRlRGF0ZXBpY2tlciggdGFyZ2V0LCB0cnVlICk7XG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZSggaW5zdCwgXCJtaW5cIiApO1xuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWF4XCIgKTtcblx0XHRcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKCBpbnN0LnNldHRpbmdzLCBzZXR0aW5ncyApO1xuXG5cdFx0XHQvLyByZWZvcm1hdCB0aGUgb2xkIG1pbkRhdGUvbWF4RGF0ZSB2YWx1ZXMgaWYgZGF0ZUZvcm1hdCBjaGFuZ2VzIGFuZCBhIG5ldyBtaW5EYXRlL21heERhdGUgaXNuJ3QgcHJvdmlkZWRcblx0XHRcdGlmICggbWluRGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWluRGF0ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1pbkRhdGUgPSB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LCBtaW5EYXRlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG1heERhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1heERhdGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aW5zdC5zZXR0aW5ncy5tYXhEYXRlID0gdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCwgbWF4RGF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBcImRpc2FibGVkXCIgaW4gc2V0dGluZ3MgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIoIHRhcmdldCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZURhdGVwaWNrZXIoIHRhcmdldCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hdHRhY2htZW50cyggJCggdGFyZ2V0ICksIGluc3QgKTtcblx0XHRcdHRoaXMuX2F1dG9TaXplKCBpbnN0ICk7XG5cdFx0XHR0aGlzLl9zZXREYXRlKCBpbnN0LCBkYXRlICk7XG5cdFx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoIGluc3QgKTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2hhbmdlIG1ldGhvZCBkZXByZWNhdGVkXG5cdF9jaGFuZ2VEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBuYW1lLCB2YWx1ZSApIHtcblx0XHR0aGlzLl9vcHRpb25EYXRlcGlja2VyKCB0YXJnZXQsIG5hbWUsIHZhbHVlICk7XG5cdH0sXG5cblx0LyogUmVkcmF3IHRoZSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9yZWZyZXNoRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldCApO1xuXHRcdGlmICggaW5zdCApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlcyBmb3IgYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldCBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgZGF0ZVx0RGF0ZSAtIHRoZSBuZXcgZGF0ZVxuXHQgKi9cblx0X3NldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBkYXRlICkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0ICk7XG5cdFx0aWYgKCBpbnN0ICkge1xuXHRcdFx0dGhpcy5fc2V0RGF0ZSggaW5zdCwgZGF0ZSApO1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlciggaW5zdCApO1xuXHRcdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEdldCB0aGUgZGF0ZShzKSBmb3IgdGhlIGZpcnN0IGVudHJ5IGluIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcGFyYW0gIG5vRGVmYXVsdCBib29sZWFuIC0gdHJ1ZSBpZiBubyBkZWZhdWx0IGRhdGUgaXMgdG8gYmUgdXNlZFxuXHQgKiBAcmV0dXJuIERhdGUgLSB0aGUgY3VycmVudCBkYXRlXG5cdCAqL1xuXHRfZ2V0RGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKCB0YXJnZXQsIG5vRGVmYXVsdCApIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldCApO1xuXHRcdGlmICggaW5zdCAmJiAhaW5zdC5pbmxpbmUgKSB7XG5cdFx0XHR0aGlzLl9zZXREYXRlRnJvbUZpZWxkKCBpbnN0LCBub0RlZmF1bHQgKTtcblx0XHR9XG5cdFx0cmV0dXJuICggaW5zdCA/IHRoaXMuX2dldERhdGUoIGluc3QgKSA6IG51bGwgKTtcblx0fSxcblxuXHQvKiBIYW5kbGUga2V5c3Ryb2tlcy4gKi9cblx0X2RvS2V5RG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBvblNlbGVjdCwgZGF0ZVN0ciwgc2VsLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCggZXZlbnQudGFyZ2V0ICksXG5cdFx0XHRoYW5kbGVkID0gdHJ1ZSxcblx0XHRcdGlzUlRMID0gaW5zdC5kcERpdi5pcyggXCIudWktZGF0ZXBpY2tlci1ydGxcIiApO1xuXG5cdFx0aW5zdC5fa2V5RXZlbnQgPSB0cnVlO1xuXHRcdGlmICggJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2UgOTogJC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGhpZGUgb24gdGFiIG91dFxuXHRcdFx0XHRjYXNlIDEzOiBzZWwgPSAkKCBcInRkLlwiICsgJC5kYXRlcGlja2VyLl9kYXlPdmVyQ2xhc3MgKyBcIjpub3QoLlwiICtcblx0XHRcdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY3VycmVudENsYXNzICsgXCIpXCIsIGluc3QuZHBEaXYgKTtcblx0XHRcdFx0XHRcdGlmICggc2VsWyAwIF0gKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0RGF5KCBldmVudC50YXJnZXQsIGluc3Quc2VsZWN0ZWRNb250aCwgaW5zdC5zZWxlY3RlZFllYXIsIHNlbFsgMCBdICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9uU2VsZWN0ID0gJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwib25TZWxlY3RcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBvblNlbGVjdCApIHtcblx0XHRcdFx0XHRcdFx0ZGF0ZVN0ciA9ICQuZGF0ZXBpY2tlci5fZm9ybWF0RGF0ZSggaW5zdCApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRcdG9uU2VsZWN0LmFwcGx5KCAoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WyAwIF0gOiBudWxsICksIFsgZGF0ZVN0ciwgaW5zdCBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZG9uJ3Qgc3VibWl0IHRoZSBmb3JtXG5cdFx0XHRcdGNhc2UgMjc6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIGVzY2FwZVxuXHRcdFx0XHRjYXNlIDMzOiAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKCBldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBCaWdNb250aHNcIiApIDpcblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApICksIFwiTVwiICk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gcHJldmlvdXMgbW9udGgveWVhciBvbiBwYWdlIHVwLysgY3RybFxuXHRcdFx0XHRjYXNlIDM0OiAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKCBldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBCaWdNb250aHNcIiApIDpcblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApICksIFwiTVwiICk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNTogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY2xlYXJEYXRlKCBldmVudC50YXJnZXQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY2xlYXIgb24gY3RybCBvciBjb21tYW5kICtlbmRcblx0XHRcdFx0Y2FzZSAzNjogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KCBldmVudC50YXJnZXQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY3VycmVudCBvbiBjdHJsIG9yIGNvbW1hbmQgK2hvbWVcblx0XHRcdFx0Y2FzZSAzNzogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAoIGlzUlRMID8gKzEgOiAtMSApLCBcIkRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblxuXHRcdFx0XHRcdFx0Ly8gLTEgZGF5IG9uIGN0cmwgb3IgY29tbWFuZCArbGVmdFxuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSApIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBldmVudC50YXJnZXQsICggZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBCaWdNb250aHNcIiApIDpcblx0XHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwic3RlcE1vbnRoc1wiICkgKSwgXCJNXCIgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArbGVmdCBvbiBNYWNcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM4OiBpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSApIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBldmVudC50YXJnZXQsIC03LCBcIkRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyAtMSB3ZWVrIG9uIGN0cmwgb3IgY29tbWFuZCArdXBcblx0XHRcdFx0Y2FzZSAzOTogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAoIGlzUlRMID8gLTEgOiArMSApLCBcIkRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblxuXHRcdFx0XHRcdFx0Ly8gKzEgZGF5IG9uIGN0cmwgb3IgY29tbWFuZCArcmlnaHRcblx0XHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAoIGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIgKSA6XG5cdFx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApICksIFwiTVwiICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK3JpZ2h0XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0MDogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCArNywgXCJEXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gKzEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK2Rvd25cblx0XHRcdFx0ZGVmYXVsdDogaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmtleUNvZGUgPT09IDM2ICYmIGV2ZW50LmN0cmxLZXkgKSB7IC8vIGRpc3BsYXkgdGhlIGRhdGUgcGlja2VyIG9uIGN0cmwraG9tZVxuXHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlciggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoYW5kbGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBoYW5kbGVkICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBGaWx0ZXIgZW50ZXJlZCBjaGFyYWN0ZXJzIC0gYmFzZWQgb24gZGF0ZSBmb3JtYXQuICovXG5cdF9kb0tleVByZXNzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGNoYXJzLCBjaHIsXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCBldmVudC50YXJnZXQgKTtcblxuXHRcdGlmICggJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwiY29uc3RyYWluSW5wdXRcIiApICkge1xuXHRcdFx0Y2hhcnMgPSAkLmRhdGVwaWNrZXIuX3Bvc3NpYmxlQ2hhcnMoICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApICk7XG5cdFx0XHRjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBldmVudC5jaGFyQ29kZSA9PSBudWxsID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlICk7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8ICggY2hyIDwgXCIgXCIgfHwgIWNoYXJzIHx8IGNoYXJzLmluZGV4T2YoIGNociApID4gLTEgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU3luY2hyb25pc2UgbWFudWFsIGVudHJ5IGFuZCBmaWVsZC9hbHRlcm5hdGUgZmllbGQuICovXG5cdF9kb0tleVVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGRhdGUsXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCBldmVudC50YXJnZXQgKTtcblxuXHRcdGlmICggaW5zdC5pbnB1dC52YWwoKSAhPT0gaW5zdC5sYXN0VmFsICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0ZSA9ICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApLFxuXHRcdFx0XHRcdCggaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsICksXG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApO1xuXG5cdFx0XHRcdGlmICggZGF0ZSApIHsgLy8gb25seSBpZiB2YWxpZFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZCggaW5zdCApO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoICggZXJyICkge1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGZvciBhIGdpdmVuIGlucHV0IGZpZWxkLlxuXHQgKiBJZiBmYWxzZSByZXR1cm5lZCBmcm9tIGJlZm9yZVNob3cgZXZlbnQgaGFuZGxlciBkbyBub3Qgc2hvdy5cblx0ICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXIgb3Jcblx0ICpcdFx0XHRcdFx0ZXZlbnQgLSBpZiB0cmlnZ2VyZWQgYnkgZm9jdXNcblx0ICovXG5cdF9zaG93RGF0ZXBpY2tlcjogZnVuY3Rpb24oIGlucHV0ICkge1xuXHRcdGlucHV0ID0gaW5wdXQudGFyZ2V0IHx8IGlucHV0O1xuXHRcdGlmICggaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJpbnB1dFwiICkgeyAvLyBmaW5kIGZyb20gYnV0dG9uL2ltYWdlIHRyaWdnZXJcblx0XHRcdGlucHV0ID0gJCggXCJpbnB1dFwiLCBpbnB1dC5wYXJlbnROb2RlIClbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoICQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoIGlucHV0ICkgfHwgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgPT09IGlucHV0ICkgeyAvLyBhbHJlYWR5IGhlcmVcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5zdCwgYmVmb3JlU2hvdywgYmVmb3JlU2hvd1NldHRpbmdzLCBpc0ZpeGVkLFxuXHRcdFx0b2Zmc2V0LCBzaG93QW5pbSwgZHVyYXRpb247XG5cblx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCBpbnB1dCApO1xuXHRcdGlmICggJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCApIHtcblx0XHRcdCQuZGF0ZXBpY2tlci5fY3VySW5zdC5kcERpdi5zdG9wKCB0cnVlLCB0cnVlICk7XG5cdFx0XHRpZiAoIGluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlciggJC5kYXRlcGlja2VyLl9jdXJJbnN0LmlucHV0WyAwIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRiZWZvcmVTaG93ID0gJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwiYmVmb3JlU2hvd1wiICk7XG5cdFx0YmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoIGlucHV0LCBbIGlucHV0LCBpbnN0IF0gKSA6IHt9O1xuXHRcdGlmICggYmVmb3JlU2hvd1NldHRpbmdzID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZGF0ZXBpY2tlcl9leHRlbmRSZW1vdmUoIGluc3Quc2V0dGluZ3MsIGJlZm9yZVNob3dTZXR0aW5ncyApO1xuXG5cdFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcblx0XHQkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9IGlucHV0O1xuXHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZCggaW5zdCApO1xuXG5cdFx0aWYgKCAkLmRhdGVwaWNrZXIuX2luRGlhbG9nICkgeyAvLyBoaWRlIGN1cnNvclxuXHRcdFx0aW5wdXQudmFsdWUgPSBcIlwiO1xuXHRcdH1cblx0XHRpZiAoICEkLmRhdGVwaWNrZXIuX3BvcyApIHsgLy8gcG9zaXRpb24gYmVsb3cgaW5wdXRcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zID0gJC5kYXRlcGlja2VyLl9maW5kUG9zKCBpbnB1dCApO1xuXHRcdFx0JC5kYXRlcGlja2VyLl9wb3NbIDEgXSArPSBpbnB1dC5vZmZzZXRIZWlnaHQ7IC8vIGFkZCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0aXNGaXhlZCA9IGZhbHNlO1xuXHRcdCQoIGlucHV0ICkucGFyZW50cygpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aXNGaXhlZCB8PSAkKCB0aGlzICkuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiO1xuXHRcdFx0cmV0dXJuICFpc0ZpeGVkO1xuXHRcdH0gKTtcblxuXHRcdG9mZnNldCA9IHsgbGVmdDogJC5kYXRlcGlja2VyLl9wb3NbIDAgXSwgdG9wOiAkLmRhdGVwaWNrZXIuX3Bvc1sgMSBdIH07XG5cdFx0JC5kYXRlcGlja2VyLl9wb3MgPSBudWxsO1xuXG5cdFx0Ly90byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3hcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCk7XG5cblx0XHQvLyBkZXRlcm1pbmUgc2l6aW5nIG9mZnNjcmVlblxuXHRcdGluc3QuZHBEaXYuY3NzKCB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiwgdG9wOiBcIi0xMDAwcHhcIiB9ICk7XG5cdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cblx0XHQvLyBmaXggd2lkdGggZm9yIGR5bmFtaWMgbnVtYmVyIG9mIGRhdGUgcGlja2Vyc1xuXHRcdC8vIGFuZCBhZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcblx0XHRvZmZzZXQgPSAkLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KCBpbnN0LCBvZmZzZXQsIGlzRml4ZWQgKTtcblx0XHRpbnN0LmRwRGl2LmNzcyggeyBwb3NpdGlvbjogKCAkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSA/XG5cdFx0XHRcInN0YXRpY1wiIDogKCBpc0ZpeGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiICkgKSwgZGlzcGxheTogXCJub25lXCIsXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCArIFwicHhcIiwgdG9wOiBvZmZzZXQudG9wICsgXCJweFwiIH0gKTtcblxuXHRcdGlmICggIWluc3QuaW5saW5lICkge1xuXHRcdFx0c2hvd0FuaW0gPSAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzaG93QW5pbVwiICk7XG5cdFx0XHRkdXJhdGlvbiA9ICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImR1cmF0aW9uXCIgKTtcblx0XHRcdGluc3QuZHBEaXYuY3NzKCBcInotaW5kZXhcIiwgZGF0ZXBpY2tlcl9nZXRaaW5kZXgoICQoIGlucHV0ICkgKSArIDEgKTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgPSB0cnVlO1xuXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBzaG93QW5pbSBdICkge1xuXHRcdFx0XHRpbnN0LmRwRGl2LnNob3coIHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzaG93T3B0aW9uc1wiICksIGR1cmF0aW9uICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnN0LmRwRGl2WyBzaG93QW5pbSB8fCBcInNob3dcIiBdKCBzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICQuZGF0ZXBpY2tlci5fc2hvdWxkRm9jdXNJbnB1dCggaW5zdCApICkge1xuXHRcdFx0XHRpbnN0LmlucHV0LnRyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQkLmRhdGVwaWNrZXIuX2N1ckluc3QgPSBpbnN0O1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgZGF0ZSBwaWNrZXIgY29udGVudC4gKi9cblx0X3VwZGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHRoaXMubWF4Um93cyA9IDQ7IC8vUmVzZXQgdGhlIG1heCBudW1iZXIgb2Ygcm93cyBiZWluZyBkaXNwbGF5ZWQgKHNlZSAjNzA0Mylcblx0XHRkYXRlcGlja2VyX2luc3RBY3RpdmUgPSBpbnN0OyAvLyBmb3IgZGVsZWdhdGUgaG92ZXIgZXZlbnRzXG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpLmFwcGVuZCggdGhpcy5fZ2VuZXJhdGVIVE1MKCBpbnN0ICkgKTtcblx0XHR0aGlzLl9hdHRhY2hIYW5kbGVycyggaW5zdCApO1xuXG5cdFx0dmFyIG9yaWd5ZWFyc2h0bWwsXG5cdFx0XHRudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyggaW5zdCApLFxuXHRcdFx0Y29scyA9IG51bU1vbnRoc1sgMSBdLFxuXHRcdFx0d2lkdGggPSAxNyxcblx0XHRcdGFjdGl2ZUNlbGwgPSBpbnN0LmRwRGl2LmZpbmQoIFwiLlwiICsgdGhpcy5fZGF5T3ZlckNsYXNzICsgXCIgYVwiICk7XG5cblx0XHRpZiAoIGFjdGl2ZUNlbGwubGVuZ3RoID4gMCApIHtcblx0XHRcdGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyLmFwcGx5KCBhY3RpdmVDZWxsLmdldCggMCApICk7XG5cdFx0fVxuXG5cdFx0aW5zdC5kcERpdi5yZW1vdmVDbGFzcyggXCJ1aS1kYXRlcGlja2VyLW11bHRpLTIgdWktZGF0ZXBpY2tlci1tdWx0aS0zIHVpLWRhdGVwaWNrZXItbXVsdGktNFwiICkud2lkdGgoIFwiXCIgKTtcblx0XHRpZiAoIGNvbHMgPiAxICkge1xuXHRcdFx0aW5zdC5kcERpdi5hZGRDbGFzcyggXCJ1aS1kYXRlcGlja2VyLW11bHRpLVwiICsgY29scyApLmNzcyggXCJ3aWR0aFwiLCAoIHdpZHRoICogY29scyApICsgXCJlbVwiICk7XG5cdFx0fVxuXHRcdGluc3QuZHBEaXZbICggbnVtTW9udGhzWyAwIF0gIT09IDEgfHwgbnVtTW9udGhzWyAxIF0gIT09IDEgPyBcImFkZFwiIDogXCJyZW1vdmVcIiApICtcblx0XHRcdFwiQ2xhc3NcIiBdKCBcInVpLWRhdGVwaWNrZXItbXVsdGlcIiApO1xuXHRcdGluc3QuZHBEaXZbICggdGhpcy5fZ2V0KCBpbnN0LCBcImlzUlRMXCIgKSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiICkgK1xuXHRcdFx0XCJDbGFzc1wiIF0oIFwidWktZGF0ZXBpY2tlci1ydGxcIiApO1xuXG5cdFx0aWYgKCBpbnN0ID09PSAkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoIGluc3QgKSApIHtcblx0XHRcdGluc3QuaW5wdXQudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmZmVyZWQgcmVuZGVyIG9mIHRoZSB5ZWFycyBzZWxlY3QgKHRvIGF2b2lkIGZsYXNoZXMgb24gRmlyZWZveClcblx0XHRpZiAoIGluc3QueWVhcnNodG1sICkge1xuXHRcdFx0b3JpZ3llYXJzaHRtbCA9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly9hc3N1cmUgdGhhdCBpbnN0LnllYXJzaHRtbCBkaWRuJ3QgY2hhbmdlLlxuXHRcdFx0XHRpZiAoIG9yaWd5ZWFyc2h0bWwgPT09IGluc3QueWVhcnNodG1sICYmIGluc3QueWVhcnNodG1sICkge1xuXHRcdFx0XHRcdGluc3QuZHBEaXYuZmluZCggXCJzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyOmZpcnN0XCIgKS5yZXBsYWNlV2l0aCggaW5zdC55ZWFyc2h0bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fSwgMCApO1xuXHRcdH1cblx0fSxcblxuXHQvLyAjNjY5NCAtIGRvbid0IGZvY3VzIHRoZSBpbnB1dCBpZiBpdCdzIGFscmVhZHkgZm9jdXNlZFxuXHQvLyB0aGlzIGJyZWFrcyB0aGUgY2hhbmdlIGV2ZW50IGluIElFXG5cdC8vIFN1cHBvcnQ6IElFIGFuZCBqUXVlcnkgPDEuOVxuXHRfc2hvdWxkRm9jdXNJbnB1dDogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0cmV0dXJuIGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC5pcyggXCI6dmlzaWJsZVwiICkgJiYgIWluc3QuaW5wdXQuaXMoIFwiOmRpc2FibGVkXCIgKSAmJiAhaW5zdC5pbnB1dC5pcyggXCI6Zm9jdXNcIiApO1xuXHR9LFxuXG5cdC8qIENoZWNrIHBvc2l0aW9uaW5nIHRvIHJlbWFpbiBvbiBzY3JlZW4uICovXG5cdF9jaGVja09mZnNldDogZnVuY3Rpb24oIGluc3QsIG9mZnNldCwgaXNGaXhlZCApIHtcblx0XHR2YXIgZHBXaWR0aCA9IGluc3QuZHBEaXYub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZHBIZWlnaHQgPSBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRpbnB1dFdpZHRoID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJXaWR0aCgpIDogMCxcblx0XHRcdGlucHV0SGVpZ2h0ID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJIZWlnaHQoKSA6IDAsXG5cdFx0XHR2aWV3V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAoIGlzRml4ZWQgPyAwIDogJCggZG9jdW1lbnQgKS5zY3JvbGxMZWZ0KCkgKSxcblx0XHRcdHZpZXdIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgKCBpc0ZpeGVkID8gMCA6ICQoIGRvY3VtZW50ICkuc2Nyb2xsVG9wKCkgKTtcblxuXHRcdG9mZnNldC5sZWZ0IC09ICggdGhpcy5fZ2V0KCBpbnN0LCBcImlzUlRMXCIgKSA/ICggZHBXaWR0aCAtIGlucHV0V2lkdGggKSA6IDAgKTtcblx0XHRvZmZzZXQubGVmdCAtPSAoIGlzRml4ZWQgJiYgb2Zmc2V0LmxlZnQgPT09IGluc3QuaW5wdXQub2Zmc2V0KCkubGVmdCApID8gJCggZG9jdW1lbnQgKS5zY3JvbGxMZWZ0KCkgOiAwO1xuXHRcdG9mZnNldC50b3AgLT0gKCBpc0ZpeGVkICYmIG9mZnNldC50b3AgPT09ICggaW5zdC5pbnB1dC5vZmZzZXQoKS50b3AgKyBpbnB1dEhlaWdodCApICkgPyAkKCBkb2N1bWVudCApLnNjcm9sbFRvcCgpIDogMDtcblxuXHRcdC8vIE5vdyBjaGVjayBpZiBkYXRlcGlja2VyIGlzIHNob3dpbmcgb3V0c2lkZSB3aW5kb3cgdmlld3BvcnQgLSBtb3ZlIHRvIGEgYmV0dGVyIHBsYWNlIGlmIHNvLlxuXHRcdG9mZnNldC5sZWZ0IC09IE1hdGgubWluKCBvZmZzZXQubGVmdCwgKCBvZmZzZXQubGVmdCArIGRwV2lkdGggPiB2aWV3V2lkdGggJiYgdmlld1dpZHRoID4gZHBXaWR0aCApID9cblx0XHRcdE1hdGguYWJzKCBvZmZzZXQubGVmdCArIGRwV2lkdGggLSB2aWV3V2lkdGggKSA6IDAgKTtcblx0XHRvZmZzZXQudG9wIC09IE1hdGgubWluKCBvZmZzZXQudG9wLCAoIG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0ICkgP1xuXHRcdFx0TWF0aC5hYnMoIGRwSGVpZ2h0ICsgaW5wdXRIZWlnaHQgKSA6IDAgKTtcblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH0sXG5cblx0LyogRmluZCBhbiBvYmplY3QncyBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuLiAqL1xuXHRfZmluZFBvczogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcG9zaXRpb24sXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggb2JqICksXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldCggaW5zdCwgXCJpc1JUTFwiICk7XG5cblx0XHR3aGlsZSAoIG9iaiAmJiAoIG9iai50eXBlID09PSBcImhpZGRlblwiIHx8IG9iai5ub2RlVHlwZSAhPT0gMSB8fCAkLmV4cHIuZmlsdGVycy5oaWRkZW4oIG9iaiApICkgKSB7XG5cdFx0XHRvYmogPSBvYmpbIGlzUlRMID8gXCJwcmV2aW91c1NpYmxpbmdcIiA6IFwibmV4dFNpYmxpbmdcIiBdO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uID0gJCggb2JqICkub2Zmc2V0KCk7XG5cdFx0cmV0dXJuIFsgcG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wIF07XG5cdH0sXG5cblx0LyogSGlkZSB0aGUgZGF0ZSBwaWNrZXIgZnJvbSB2aWV3LlxuXHQgKiBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlclxuXHQgKi9cblx0X2hpZGVEYXRlcGlja2VyOiBmdW5jdGlvbiggaW5wdXQgKSB7XG5cdFx0dmFyIHNob3dBbmltLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MsIG9uQ2xvc2UsXG5cdFx0XHRpbnN0ID0gdGhpcy5fY3VySW5zdDtcblxuXHRcdGlmICggIWluc3QgfHwgKCBpbnB1dCAmJiBpbnN0ICE9PSAkLmRhdGEoIGlucHV0LCBcImRhdGVwaWNrZXJcIiApICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdHNob3dBbmltID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dBbmltXCIgKTtcblx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZ2V0KCBpbnN0LCBcImR1cmF0aW9uXCIgKTtcblx0XHRcdHBvc3RQcm9jZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fdGlkeURpYWxvZyggaW5zdCApO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gREVQUkVDQVRFRDogYWZ0ZXIgQkMgZm9yIDEuOC54ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSBpcyBub3QgbmVlZGVkXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAoICQuZWZmZWN0cy5lZmZlY3RbIHNob3dBbmltIF0gfHwgJC5lZmZlY3RzWyBzaG93QW5pbSBdICkgKSB7XG5cdFx0XHRcdGluc3QuZHBEaXYuaGlkZSggc2hvd0FuaW0sICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInNob3dPcHRpb25zXCIgKSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnN0LmRwRGl2WyAoIHNob3dBbmltID09PSBcInNsaWRlRG93blwiID8gXCJzbGlkZVVwXCIgOlxuXHRcdFx0XHRcdCggc2hvd0FuaW0gPT09IFwiZmFkZUluXCIgPyBcImZhZGVPdXRcIiA6IFwiaGlkZVwiICkgKSBdKCAoIHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsICksIHBvc3RQcm9jZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXNob3dBbmltICkge1xuXHRcdFx0XHRwb3N0UHJvY2VzcygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGF0ZXBpY2tlclNob3dpbmcgPSBmYWxzZTtcblxuXHRcdFx0b25DbG9zZSA9IHRoaXMuX2dldCggaW5zdCwgXCJvbkNsb3NlXCIgKTtcblx0XHRcdGlmICggb25DbG9zZSApIHtcblx0XHRcdFx0b25DbG9zZS5hcHBseSggKCBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFsgMCBdIDogbnVsbCApLCBbICggaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBcIlwiICksIGluc3QgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xuXHRcdFx0aWYgKCB0aGlzLl9pbkRpYWxvZyApIHtcblx0XHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKCB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IFwiMFwiLCB0b3A6IFwiLTEwMHB4XCIgfSApO1xuXHRcdFx0XHRpZiAoICQuYmxvY2tVSSApIHtcblx0XHRcdFx0XHQkLnVuYmxvY2tVSSgpO1xuXHRcdFx0XHRcdCQoIFwiYm9keVwiICkuYXBwZW5kKCB0aGlzLmRwRGl2ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFRpZHkgdXAgYWZ0ZXIgYSBkaWFsb2cgZGlzcGxheS4gKi9cblx0X3RpZHlEaWFsb2c6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3MoIHRoaXMuX2RpYWxvZ0NsYXNzICkub2ZmKCBcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIgKTtcblx0fSxcblxuXHQvKiBDbG9zZSBkYXRlIHBpY2tlciBpZiBjbGlja2VkIGVsc2V3aGVyZS4gKi9cblx0X2NoZWNrRXh0ZXJuYWxDbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggISQuZGF0ZXBpY2tlci5fY3VySW5zdCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgJHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCggJHRhcmdldFsgMCBdICk7XG5cblx0XHRpZiAoICggKCAkdGFyZ2V0WyAwIF0uaWQgIT09ICQuZGF0ZXBpY2tlci5fbWFpbkRpdklkICYmXG5cdFx0XHRcdCR0YXJnZXQucGFyZW50cyggXCIjXCIgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCApLmxlbmd0aCA9PT0gMCAmJlxuXHRcdFx0XHQhJHRhcmdldC5oYXNDbGFzcyggJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSApICYmXG5cdFx0XHRcdCEkdGFyZ2V0LmNsb3Nlc3QoIFwiLlwiICsgJC5kYXRlcGlja2VyLl90cmlnZ2VyQ2xhc3MgKS5sZW5ndGggJiZcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAhKCAkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSApICkgKSB8fFxuXHRcdFx0KCAkdGFyZ2V0Lmhhc0NsYXNzKCAkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lICkgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9PSBpbnN0ICkgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0RGF0ZTogZnVuY3Rpb24oIGlkLCBvZmZzZXQsIHBlcmlvZCApIHtcblx0XHR2YXIgdGFyZ2V0ID0gJCggaWQgKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXG5cdFx0aWYgKCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggdGFyZ2V0WyAwIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoIGluc3QsIG9mZnNldCArXG5cdFx0XHQoIHBlcmlvZCA9PT0gXCJNXCIgPyB0aGlzLl9nZXQoIGluc3QsIFwic2hvd0N1cnJlbnRBdFBvc1wiICkgOiAwICksIC8vIHVuZG8gcG9zaXRpb25pbmdcblx0XHRcdHBlcmlvZCApO1xuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIGN1cnJlbnQgbGluay4gKi9cblx0X2dvdG9Ub2RheTogZnVuY3Rpb24oIGlkICkge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0dGFyZ2V0ID0gJCggaWQgKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXG5cdFx0aWYgKCB0aGlzLl9nZXQoIGluc3QsIFwiZ290b0N1cnJlbnRcIiApICYmIGluc3QuY3VycmVudERheSApIHtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHR9XG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKCBpbnN0ICk7XG5cdFx0dGhpcy5fYWRqdXN0RGF0ZSggdGFyZ2V0ICk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBuZXcgbW9udGgveWVhci4gKi9cblx0X3NlbGVjdE1vbnRoWWVhcjogZnVuY3Rpb24oIGlkLCBzZWxlY3QsIHBlcmlvZCApIHtcblx0XHR2YXIgdGFyZ2V0ID0gJCggaWQgKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXG5cdFx0aW5zdFsgXCJzZWxlY3RlZFwiICsgKCBwZXJpb2QgPT09IFwiTVwiID8gXCJNb250aFwiIDogXCJZZWFyXCIgKSBdID1cblx0XHRpbnN0WyBcImRyYXdcIiArICggcGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiICkgXSA9XG5cdFx0XHRwYXJzZUludCggc2VsZWN0Lm9wdGlvbnNbIHNlbGVjdC5zZWxlY3RlZEluZGV4IF0udmFsdWUsIDEwICk7XG5cblx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoIGluc3QgKTtcblx0XHR0aGlzLl9hZGp1c3REYXRlKCB0YXJnZXQgKTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIGRheS4gKi9cblx0X3NlbGVjdERheTogZnVuY3Rpb24oIGlkLCBtb250aCwgeWVhciwgdGQgKSB7XG5cdFx0dmFyIGluc3QsXG5cdFx0XHR0YXJnZXQgPSAkKCBpZCApO1xuXG5cdFx0aWYgKCAkKCB0ZCApLmhhc0NsYXNzKCB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyApIHx8IHRoaXMuX2lzRGlzYWJsZWREYXRlcGlja2VyKCB0YXJnZXRbIDAgXSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSAkKCBcImFcIiwgdGQgKS5odG1sKCk7XG5cdFx0aW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGggPSBtb250aDtcblx0XHRpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSB5ZWFyO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUoIGlkLCB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LFxuXHRcdFx0aW5zdC5jdXJyZW50RGF5LCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50WWVhciApICk7XG5cdH0sXG5cblx0LyogRXJhc2UgdGhlIGlucHV0IGZpZWxkIGFuZCBoaWRlIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0X2NsZWFyRGF0ZTogZnVuY3Rpb24oIGlkICkge1xuXHRcdHZhciB0YXJnZXQgPSAkKCBpZCApO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUoIHRhcmdldCwgXCJcIiApO1xuXHR9LFxuXG5cdC8qIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS4gKi9cblx0X3NlbGVjdERhdGU6IGZ1bmN0aW9uKCBpZCwgZGF0ZVN0ciApIHtcblx0XHR2YXIgb25TZWxlY3QsXG5cdFx0XHR0YXJnZXQgPSAkKCBpZCApLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldFsgMCBdICk7XG5cblx0XHRkYXRlU3RyID0gKCBkYXRlU3RyICE9IG51bGwgPyBkYXRlU3RyIDogdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCApICk7XG5cdFx0aWYgKCBpbnN0LmlucHV0ICkge1xuXHRcdFx0aW5zdC5pbnB1dC52YWwoIGRhdGVTdHIgKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cblx0XHRvblNlbGVjdCA9IHRoaXMuX2dldCggaW5zdCwgXCJvblNlbGVjdFwiICk7XG5cdFx0aWYgKCBvblNlbGVjdCApIHtcblx0XHRcdG9uU2VsZWN0LmFwcGx5KCAoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WyAwIF0gOiBudWxsICksIFsgZGF0ZVN0ciwgaW5zdCBdICk7ICAvLyB0cmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xuXHRcdH0gZWxzZSBpZiAoIGluc3QuaW5wdXQgKSB7XG5cdFx0XHRpbnN0LmlucHV0LnRyaWdnZXIoIFwiY2hhbmdlXCIgKTsgLy8gZmlyZSB0aGUgY2hhbmdlIGV2ZW50XG5cdFx0fVxuXG5cdFx0aWYgKCBpbnN0LmlubGluZSApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IGluc3QuaW5wdXRbIDAgXTtcblx0XHRcdGlmICggdHlwZW9mKCBpbnN0LmlucHV0WyAwIF0gKSAhPT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0aW5zdC5pbnB1dC50cmlnZ2VyKCBcImZvY3VzXCIgKTsgLy8gcmVzdG9yZSBmb2N1c1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIGFueSBhbHRlcm5hdGUgZmllbGQgdG8gc3luY2hyb25pc2Ugd2l0aCB0aGUgbWFpbiBmaWVsZC4gKi9cblx0X3VwZGF0ZUFsdGVybmF0ZTogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIGFsdEZvcm1hdCwgZGF0ZSwgZGF0ZVN0cixcblx0XHRcdGFsdEZpZWxkID0gdGhpcy5fZ2V0KCBpbnN0LCBcImFsdEZpZWxkXCIgKTtcblxuXHRcdGlmICggYWx0RmllbGQgKSB7IC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXG5cdFx0XHRhbHRGb3JtYXQgPSB0aGlzLl9nZXQoIGluc3QsIFwiYWx0Rm9ybWF0XCIgKSB8fCB0aGlzLl9nZXQoIGluc3QsIFwiZGF0ZUZvcm1hdFwiICk7XG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZSggaW5zdCApO1xuXHRcdFx0ZGF0ZVN0ciA9IHRoaXMuZm9ybWF0RGF0ZSggYWx0Rm9ybWF0LCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApO1xuXHRcdFx0JCggYWx0RmllbGQgKS52YWwoIGRhdGVTdHIgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU2V0IGFzIGJlZm9yZVNob3dEYXkgZnVuY3Rpb24gdG8gcHJldmVudCBzZWxlY3Rpb24gb2Ygd2Vla2VuZHMuXG5cdCAqIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGN1c3RvbWlzZVxuXHQgKiBAcmV0dXJuIFtib29sZWFuLCBzdHJpbmddIC0gaXMgdGhpcyBkYXRlIHNlbGVjdGFibGU/LCB3aGF0IGlzIGl0cyBDU1MgY2xhc3M/XG5cdCAqL1xuXHRub1dlZWtlbmRzOiBmdW5jdGlvbiggZGF0ZSApIHtcblx0XHR2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblx0XHRyZXR1cm4gWyAoIGRheSA+IDAgJiYgZGF5IDwgNiApLCBcIlwiIF07XG5cdH0sXG5cblx0LyogU2V0IGFzIGNhbGN1bGF0ZVdlZWsgdG8gZGV0ZXJtaW5lIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGJhc2VkIG9uIHRoZSBJU08gODYwMSBkZWZpbml0aW9uLlxuXHQgKiBAcGFyYW0gIGRhdGUgIERhdGUgLSB0aGUgZGF0ZSB0byBnZXQgdGhlIHdlZWsgZm9yXG5cdCAqIEByZXR1cm4gIG51bWJlciAtIHRoZSBudW1iZXIgb2YgdGhlIHdlZWsgd2l0aGluIHRoZSB5ZWFyIHRoYXQgY29udGFpbnMgdGhpcyBkYXRlXG5cdCAqL1xuXHRpc284NjAxV2VlazogZnVuY3Rpb24oIGRhdGUgKSB7XG5cdFx0dmFyIHRpbWUsXG5cdFx0XHRjaGVja0RhdGUgPSBuZXcgRGF0ZSggZGF0ZS5nZXRUaW1lKCkgKTtcblxuXHRcdC8vIEZpbmQgVGh1cnNkYXkgb2YgdGhpcyB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKCBjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtICggY2hlY2tEYXRlLmdldERheSgpIHx8IDcgKSApO1xuXG5cdFx0dGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG5cdFx0Y2hlY2tEYXRlLnNldE1vbnRoKCAwICk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKCAxICk7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucm91bmQoICggdGltZSAtIGNoZWNrRGF0ZSApIC8gODY0MDAwMDAgKSAvIDcgKSArIDE7XG5cdH0sXG5cblx0LyogUGFyc2UgYSBzdHJpbmcgdmFsdWUgaW50byBhIGRhdGUgb2JqZWN0LlxuXHQgKiBTZWUgZm9ybWF0RGF0ZSBiZWxvdyBmb3IgdGhlIHBvc3NpYmxlIGZvcm1hdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSAgZm9ybWF0IHN0cmluZyAtIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIGRhdGVcblx0ICogQHBhcmFtICB2YWx1ZSBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgT2JqZWN0IC0gYXR0cmlidXRlcyBpbmNsdWRlOlxuXHQgKlx0XHRcdFx0XHRzaG9ydFllYXJDdXRvZmYgIG51bWJlciAtIHRoZSBjdXRvZmYgeWVhciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGNlbnR1cnkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1Nob3J0XHRzdHJpbmdbN10gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzXHRcdHN0cmluZ1s3XSAtIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0bW9udGhOYW1lc1Nob3J0IHN0cmluZ1sxMl0gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0bW9udGhOYW1lc1x0XHRzdHJpbmdbMTJdIC0gbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqIEByZXR1cm4gIERhdGUgLSB0aGUgZXh0cmFjdGVkIGRhdGUgdmFsdWUgb3IgbnVsbCBpZiB2YWx1ZSBpcyBibGFua1xuXHQgKi9cblx0cGFyc2VEYXRlOiBmdW5jdGlvbiggZm9ybWF0LCB2YWx1ZSwgc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCBmb3JtYXQgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsICkge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIGFyZ3VtZW50c1wiO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gKCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgKyBcIlwiICk7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LCBkaW0sIGV4dHJhLFxuXHRcdFx0aVZhbHVlID0gMCxcblx0XHRcdHNob3J0WWVhckN1dG9mZlRlbXAgPSAoIHNldHRpbmdzID8gc2V0dGluZ3Muc2hvcnRZZWFyQ3V0b2ZmIDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLnNob3J0WWVhckN1dG9mZixcblx0XHRcdHNob3J0WWVhckN1dG9mZiA9ICggdHlwZW9mIHNob3J0WWVhckN1dG9mZlRlbXAgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmZUZW1wIDpcblx0XHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoIHNob3J0WWVhckN1dG9mZlRlbXAsIDEwICkgKSxcblx0XHRcdGRheU5hbWVzU2hvcnQgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxuXHRcdFx0ZGF5TmFtZXMgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXMgOiBudWxsICkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxcblx0XHRcdG1vbnRoTmFtZXMgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxuXHRcdFx0eWVhciA9IC0xLFxuXHRcdFx0bW9udGggPSAtMSxcblx0XHRcdGRheSA9IC0xLFxuXHRcdFx0ZG95ID0gLTEsXG5cdFx0XHRsaXRlcmFsID0gZmFsc2UsXG5cdFx0XHRkYXRlLFxuXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gKCBpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdCggaUZvcm1hdCArIDEgKSA9PT0gbWF0Y2ggKTtcblx0XHRcdFx0aWYgKCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdGlGb3JtYXQrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEV4dHJhY3QgYSBudW1iZXIgZnJvbSB0aGUgc3RyaW5nIHZhbHVlXG5cdFx0XHRnZXROdW1iZXIgPSBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHZhciBpc0RvdWJsZWQgPSBsb29rQWhlYWQoIG1hdGNoICksXG5cdFx0XHRcdFx0c2l6ZSA9ICggbWF0Y2ggPT09IFwiQFwiID8gMTQgOiAoIG1hdGNoID09PSBcIiFcIiA/IDIwIDpcblx0XHRcdFx0XHQoIG1hdGNoID09PSBcInlcIiAmJiBpc0RvdWJsZWQgPyA0IDogKCBtYXRjaCA9PT0gXCJvXCIgPyAzIDogMiApICkgKSApLFxuXHRcdFx0XHRcdG1pblNpemUgPSAoIG1hdGNoID09PSBcInlcIiA/IHNpemUgOiAxICksXG5cdFx0XHRcdFx0ZGlnaXRzID0gbmV3IFJlZ0V4cCggXCJeXFxcXGR7XCIgKyBtaW5TaXplICsgXCIsXCIgKyBzaXplICsgXCJ9XCIgKSxcblx0XHRcdFx0XHRudW0gPSB2YWx1ZS5zdWJzdHJpbmcoIGlWYWx1ZSApLm1hdGNoKCBkaWdpdHMgKTtcblx0XHRcdFx0aWYgKCAhbnVtICkge1xuXHRcdFx0XHRcdHRocm93IFwiTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aVZhbHVlICs9IG51bVsgMCBdLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCBudW1bIDAgXSwgMTAgKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxuXHRcdFx0Z2V0TmFtZSA9IGZ1bmN0aW9uKCBtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAtMSxcblx0XHRcdFx0XHRuYW1lcyA9ICQubWFwKCBsb29rQWhlYWQoIG1hdGNoICkgPyBsb25nTmFtZXMgOiBzaG9ydE5hbWVzLCBmdW5jdGlvbiggdiwgayApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIFsgaywgdiBdIF07XG5cdFx0XHRcdFx0fSApLnNvcnQoIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIC0oIGFbIDEgXS5sZW5ndGggLSBiWyAxIF0ubGVuZ3RoICk7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdCQuZWFjaCggbmFtZXMsIGZ1bmN0aW9uKCBpLCBwYWlyICkge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFpclsgMSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUuc3Vic3RyKCBpVmFsdWUsIG5hbWUubGVuZ3RoICkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBwYWlyWyAwIF07XG5cdFx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIENvbmZpcm0gdGhhdCBhIGxpdGVyYWwgY2hhcmFjdGVyIG1hdGNoZXMgdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0Y2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdmFsdWUuY2hhckF0KCBpVmFsdWUgKSAhPT0gZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApICkge1xuXHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBsaXRlcmFsIGF0IHBvc2l0aW9uIFwiICsgaVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlWYWx1ZSsrO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrICkge1xuXHRcdFx0aWYgKCBsaXRlcmFsICkge1xuXHRcdFx0XHRpZiAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZCggXCInXCIgKSApIHtcblx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSApIHtcblx0XHRcdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0XHRcdFx0ZGF5ID0gZ2V0TnVtYmVyKCBcImRcIiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0XHRcdGdldE5hbWUoIFwiRFwiLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdGRveSA9IGdldE51bWJlciggXCJvXCIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdFx0XHRtb250aCA9IGdldE51bWJlciggXCJtXCIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRtb250aCA9IGdldE5hbWUoIFwiTVwiLCBtb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRcdFx0XHR5ZWFyID0gZ2V0TnVtYmVyKCBcInlcIiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSggZ2V0TnVtYmVyKCBcIkBcIiApICk7XG5cdFx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHRcdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiIVwiOlxuXHRcdFx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCAoIGdldE51bWJlciggXCIhXCIgKSAtIHRoaXMuX3RpY2tzVG8xOTcwICkgLyAxMDAwMCApO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmICggbG9va0FoZWFkKCBcIidcIiApICkge1xuXHRcdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpVmFsdWUgPCB2YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRleHRyYSA9IHZhbHVlLnN1YnN0ciggaVZhbHVlICk7XG5cdFx0XHRpZiAoICEvXlxccysvLnRlc3QoIGV4dHJhICkgKSB7XG5cdFx0XHRcdHRocm93IFwiRXh0cmEvdW5wYXJzZWQgY2hhcmFjdGVycyBmb3VuZCBpbiBkYXRlOiBcIiArIGV4dHJhO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggeWVhciA9PT0gLTEgKSB7XG5cdFx0XHR5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdH0gZWxzZSBpZiAoIHllYXIgPCAxMDAgKSB7XG5cdFx0XHR5ZWFyICs9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArXG5cdFx0XHRcdCggeWVhciA8PSBzaG9ydFllYXJDdXRvZmYgPyAwIDogLTEwMCApO1xuXHRcdH1cblxuXHRcdGlmICggZG95ID4gLTEgKSB7XG5cdFx0XHRtb250aCA9IDE7XG5cdFx0XHRkYXkgPSBkb3k7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGRpbSA9IHRoaXMuX2dldERheXNJbk1vbnRoKCB5ZWFyLCBtb250aCAtIDEgKTtcblx0XHRcdFx0aWYgKCBkYXkgPD0gZGltICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1vbnRoKys7XG5cdFx0XHRcdGRheSAtPSBkaW07XG5cdFx0XHR9IHdoaWxlICggdHJ1ZSApO1xuXHRcdH1cblxuXHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIHllYXIsIG1vbnRoIC0gMSwgZGF5ICkgKTtcblx0XHRpZiAoIGRhdGUuZ2V0RnVsbFllYXIoKSAhPT0geWVhciB8fCBkYXRlLmdldE1vbnRoKCkgKyAxICE9PSBtb250aCB8fCBkYXRlLmdldERhdGUoKSAhPT0gZGF5ICkge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIGRhdGVcIjsgLy8gRS5nLiAzMS8wMi8wMFxuXHRcdH1cblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTdGFuZGFyZCBkYXRlIGZvcm1hdHMuICovXG5cdEFUT006IFwieXktbW0tZGRcIiwgLy8gUkZDIDMzMzkgKElTTyA4NjAxKVxuXHRDT09LSUU6IFwiRCwgZGQgTSB5eVwiLFxuXHRJU09fODYwMTogXCJ5eS1tbS1kZFwiLFxuXHRSRkNfODIyOiBcIkQsIGQgTSB5XCIsXG5cdFJGQ184NTA6IFwiREQsIGRkLU0teVwiLFxuXHRSRkNfMTAzNjogXCJELCBkIE0geVwiLFxuXHRSRkNfMTEyMzogXCJELCBkIE0geXlcIixcblx0UkZDXzI4MjI6IFwiRCwgZCBNIHl5XCIsXG5cdFJTUzogXCJELCBkIE0geVwiLCAvLyBSRkMgODIyXG5cdFRJQ0tTOiBcIiFcIixcblx0VElNRVNUQU1QOiBcIkBcIixcblx0VzNDOiBcInl5LW1tLWRkXCIsIC8vIElTTyA4NjAxXG5cblx0X3RpY2tzVG8xOTcwOiAoICggKCAxOTcwIC0gMSApICogMzY1ICsgTWF0aC5mbG9vciggMTk3MCAvIDQgKSAtIE1hdGguZmxvb3IoIDE5NzAgLyAxMDAgKSArXG5cdFx0TWF0aC5mbG9vciggMTk3MCAvIDQwMCApICkgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCApLFxuXG5cdC8qIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXG5cdCAqIFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxuXHQgKiBkICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKVxuXHQgKiBkZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KVxuXHQgKiBvICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKVxuXHQgKiBvbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdClcblx0ICogRCAgLSBkYXkgbmFtZSBzaG9ydFxuXHQgKiBERCAtIGRheSBuYW1lIGxvbmdcblx0ICogbSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pXG5cdCAqIG1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KVxuXHQgKiBNICAtIG1vbnRoIG5hbWUgc2hvcnRcblx0ICogTU0gLSBtb250aCBuYW1lIGxvbmdcblx0ICogeSAgLSB5ZWFyICh0d28gZGlnaXQpXG5cdCAqIHl5IC0geWVhciAoZm91ciBkaWdpdClcblx0ICogQCAtIFVuaXggdGltZXN0YW1wIChtcyBzaW5jZSAwMS8wMS8xOTcwKVxuXHQgKiAhIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSlcblx0ICogXCIuLi5cIiAtIGxpdGVyYWwgdGV4dFxuXHQgKiAnJyAtIHNpbmdsZSBxdW90ZVxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZGVzaXJlZCBmb3JtYXQgb2YgdGhlIGRhdGVcblx0ICogQHBhcmFtICBkYXRlIERhdGUgLSB0aGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKi9cblx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24oIGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCAhZGF0ZSApIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0ZGF5TmFtZXNTaG9ydCA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXG5cdFx0XHRkYXlOYW1lcyA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lcyA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lcyxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydCA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsICkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lc1Nob3J0LFxuXHRcdFx0bW9udGhOYW1lcyA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzIDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXG5cblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHRcdGxvb2tBaGVhZCA9IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoIGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICsgMSApID09PSBtYXRjaCApO1xuXHRcdFx0XHRpZiAoIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVybyBpZiBuZWNlc3Nhcnlcblx0XHRcdGZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKCBtYXRjaCwgdmFsdWUsIGxlbiApIHtcblx0XHRcdFx0dmFyIG51bSA9IFwiXCIgKyB2YWx1ZTtcblx0XHRcdFx0aWYgKCBsb29rQWhlYWQoIG1hdGNoICkgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBudW0ubGVuZ3RoIDwgbGVuICkge1xuXHRcdFx0XHRcdFx0bnVtID0gXCIwXCIgKyBudW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudW07XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3JtYXQgYSBuYW1lLCBzaG9ydCBvciBsb25nIGFzIHJlcXVlc3RlZFxuXHRcdFx0Zm9ybWF0TmFtZSA9IGZ1bmN0aW9uKCBtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcyApIHtcblx0XHRcdFx0cmV0dXJuICggbG9va0FoZWFkKCBtYXRjaCApID8gbG9uZ05hbWVzWyB2YWx1ZSBdIDogc2hvcnROYW1lc1sgdmFsdWUgXSApO1xuXHRcdFx0fSxcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cblx0XHRpZiAoIGRhdGUgKSB7XG5cdFx0XHRmb3IgKCBpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKyApIHtcblx0XHRcdFx0aWYgKCBsaXRlcmFsICkge1xuXHRcdFx0XHRcdGlmICggZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApID09PSBcIidcIiAmJiAhbG9va0FoZWFkKCBcIidcIiApICkge1xuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKCBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICkgKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKCBcImRcIiwgZGF0ZS5nZXREYXRlKCksIDIgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TmFtZSggXCJEXCIsIGRhdGUuZ2V0RGF5KCksIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlciggXCJvXCIsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZCggKCBuZXcgRGF0ZSggZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpICkuZ2V0VGltZSgpIC0gbmV3IERhdGUoIGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMCApLmdldFRpbWUoKSApIC8gODY0MDAwMDAgKSwgMyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoIFwibVwiLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAyICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoIFwiTVwiLCBkYXRlLmdldE1vbnRoKCksIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSAoIGxvb2tBaGVhZCggXCJ5XCIgKSA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6XG5cdFx0XHRcdFx0XHRcdFx0KCBkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDAgPCAxMCA/IFwiMFwiIDogXCJcIiApICsgZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCIhXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmdldFRpbWUoKSAqIDEwMDAwICsgdGhpcy5fdGlja3NUbzE5NzA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdFx0aWYgKCBsb29rQWhlYWQoIFwiJ1wiICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IFwiJ1wiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fSxcblxuXHQvKiBFeHRyYWN0IGFsbCBwb3NzaWJsZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfcG9zc2libGVDaGFyczogZnVuY3Rpb24oIGZvcm1hdCApIHtcblx0XHR2YXIgaUZvcm1hdCxcblx0XHRcdGNoYXJzID0gXCJcIixcblx0XHRcdGxpdGVyYWwgPSBmYWxzZSxcblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICggaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKyAxICkgPT09IG1hdGNoICk7XG5cdFx0XHRcdGlmICggbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9O1xuXG5cdFx0Zm9yICggaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KysgKSB7XG5cdFx0XHRpZiAoIGxpdGVyYWwgKSB7XG5cdFx0XHRcdGlmICggZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApID09PSBcIidcIiAmJiAhbG9va0FoZWFkKCBcIidcIiApICkge1xuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGFycyArPSBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSApIHtcblx0XHRcdFx0XHRjYXNlIFwiZFwiOiBjYXNlIFwibVwiOiBjYXNlIFwieVwiOiBjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCIwMTIzNDU2Nzg5XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiRFwiOiBjYXNlIFwiTVwiOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAoIGxvb2tBaGVhZCggXCInXCIgKSApIHtcblx0XHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjaGFycyArPSBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNoYXJzO1xuXHR9LFxuXG5cdC8qIEdldCBhIHNldHRpbmcgdmFsdWUsIGRlZmF1bHRpbmcgaWYgbmVjZXNzYXJ5LiAqL1xuXHRfZ2V0OiBmdW5jdGlvbiggaW5zdCwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW5zdC5zZXR0aW5nc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0aW5zdC5zZXR0aW5nc1sgbmFtZSBdIDogdGhpcy5fZGVmYXVsdHNbIG5hbWUgXTtcblx0fSxcblxuXHQvKiBQYXJzZSBleGlzdGluZyBkYXRlIGFuZCBpbml0aWFsaXNlIGRhdGUgcGlja2VyLiAqL1xuXHRfc2V0RGF0ZUZyb21GaWVsZDogZnVuY3Rpb24oIGluc3QsIG5vRGVmYXVsdCApIHtcblx0XHRpZiAoIGluc3QuaW5wdXQudmFsKCkgPT09IGluc3QubGFzdFZhbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZGF0ZUZvcm1hdCA9IHRoaXMuX2dldCggaW5zdCwgXCJkYXRlRm9ybWF0XCIgKSxcblx0XHRcdGRhdGVzID0gaW5zdC5sYXN0VmFsID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsLFxuXHRcdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZSggaW5zdCApLFxuXHRcdFx0ZGF0ZSA9IGRlZmF1bHREYXRlLFxuXHRcdFx0c2V0dGluZ3MgPSB0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRkYXRlID0gdGhpcy5wYXJzZURhdGUoIGRhdGVGb3JtYXQsIGRhdGVzLCBzZXR0aW5ncyApIHx8IGRlZmF1bHREYXRlO1xuXHRcdH0gY2F0Y2ggKCBldmVudCApIHtcblx0XHRcdGRhdGVzID0gKCBub0RlZmF1bHQgPyBcIlwiIDogZGF0ZXMgKTtcblx0XHR9XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpbnN0LmN1cnJlbnREYXkgPSAoIGRhdGVzID8gZGF0ZS5nZXREYXRlKCkgOiAwICk7XG5cdFx0aW5zdC5jdXJyZW50TW9udGggPSAoIGRhdGVzID8gZGF0ZS5nZXRNb250aCgpIDogMCApO1xuXHRcdGluc3QuY3VycmVudFllYXIgPSAoIGRhdGVzID8gZGF0ZS5nZXRGdWxsWWVhcigpIDogMCApO1xuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKCBpbnN0ICk7XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGRlZmF1bHQgZGF0ZSBzaG93biBvbiBvcGVuaW5nLiAqL1xuXHRfZ2V0RGVmYXVsdERhdGU6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHJldHVybiB0aGlzLl9yZXN0cmljdE1pbk1heCggaW5zdCxcblx0XHRcdHRoaXMuX2RldGVybWluZURhdGUoIGluc3QsIHRoaXMuX2dldCggaW5zdCwgXCJkZWZhdWx0RGF0ZVwiICksIG5ldyBEYXRlKCkgKSApO1xuXHR9LFxuXG5cdC8qIEEgZGF0ZSBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGV4YWN0IHZhbHVlIG9yIGEgcmVsYXRpdmUgb25lLiAqL1xuXHRfZGV0ZXJtaW5lRGF0ZTogZnVuY3Rpb24oIGluc3QsIGRhdGUsIGRlZmF1bHREYXRlICkge1xuXHRcdHZhciBvZmZzZXROdW1lcmljID0gZnVuY3Rpb24oIG9mZnNldCApIHtcblx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoIGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0ICk7XG5cdFx0XHRcdHJldHVybiBkYXRlO1xuXHRcdFx0fSxcblx0XHRcdG9mZnNldFN0cmluZyA9IGZ1bmN0aW9uKCBvZmZzZXQgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApLFxuXHRcdFx0XHRcdFx0b2Zmc2V0LCAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyggaW5zdCApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gSWdub3JlXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZGF0ZSA9ICggb2Zmc2V0LnRvTG93ZXJDYXNlKCkubWF0Y2goIC9eYy8gKSA/XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nZXREYXRlKCBpbnN0ICkgOiBudWxsICkgfHwgbmV3IERhdGUoKSxcblx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpLFxuXHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpLFxuXHRcdFx0XHRcdHBhdHRlcm4gPSAvKFsrXFwtXT9bMC05XSspXFxzKihkfER8d3xXfG18TXx5fFkpPy9nLFxuXHRcdFx0XHRcdG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMoIG9mZnNldCApO1xuXG5cdFx0XHRcdHdoaWxlICggbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRzd2l0Y2ggKCBtYXRjaGVzWyAyIF0gfHwgXCJkXCIgKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZFwiIDogY2FzZSBcIkRcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludCggbWF0Y2hlc1sgMSBdLCAxMCApOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ3XCIgOiBjYXNlIFwiV1wiIDpcblx0XHRcdFx0XHRcdFx0ZGF5ICs9IHBhcnNlSW50KCBtYXRjaGVzWyAxIF0sIDEwICkgKiA3OyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJtXCIgOiBjYXNlIFwiTVwiIDpcblx0XHRcdFx0XHRcdFx0bW9udGggKz0gcGFyc2VJbnQoIG1hdGNoZXNbIDEgXSwgMTAgKTtcblx0XHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oIGRheSwgJC5kYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCggeWVhciwgbW9udGggKSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ5XCI6IGNhc2UgXCJZXCIgOlxuXHRcdFx0XHRcdFx0XHR5ZWFyICs9IHBhcnNlSW50KCBtYXRjaGVzWyAxIF0sIDEwICk7XG5cdFx0XHRcdFx0XHRcdGRheSA9IE1hdGgubWluKCBkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoIHllYXIsIG1vbnRoICkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMoIG9mZnNldCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZSggeWVhciwgbW9udGgsIGRheSApO1xuXHRcdFx0fSxcblx0XHRcdG5ld0RhdGUgPSAoIGRhdGUgPT0gbnVsbCB8fCBkYXRlID09PSBcIlwiID8gZGVmYXVsdERhdGUgOiAoIHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiID8gb2Zmc2V0U3RyaW5nKCBkYXRlICkgOlxuXHRcdFx0XHQoIHR5cGVvZiBkYXRlID09PSBcIm51bWJlclwiID8gKCBpc05hTiggZGF0ZSApID8gZGVmYXVsdERhdGUgOiBvZmZzZXROdW1lcmljKCBkYXRlICkgKSA6IG5ldyBEYXRlKCBkYXRlLmdldFRpbWUoKSApICkgKSApO1xuXG5cdFx0bmV3RGF0ZSA9ICggbmV3RGF0ZSAmJiBuZXdEYXRlLnRvU3RyaW5nKCkgPT09IFwiSW52YWxpZCBEYXRlXCIgPyBkZWZhdWx0RGF0ZSA6IG5ld0RhdGUgKTtcblx0XHRpZiAoIG5ld0RhdGUgKSB7XG5cdFx0XHRuZXdEYXRlLnNldEhvdXJzKCAwICk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbnV0ZXMoIDAgKTtcblx0XHRcdG5ld0RhdGUuc2V0U2Vjb25kcyggMCApO1xuXHRcdFx0bmV3RGF0ZS5zZXRNaWxsaXNlY29uZHMoIDAgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXdEYXRlICk7XG5cdH0sXG5cblx0LyogSGFuZGxlIHN3aXRjaCB0by9mcm9tIGRheWxpZ2h0IHNhdmluZy5cblx0ICogSG91cnMgbWF5IGJlIG5vbi16ZXJvIG9uIGRheWxpZ2h0IHNhdmluZyBjdXQtb3Zlcjpcblx0ICogPiAxMiB3aGVuIG1pZG5pZ2h0IGNoYW5nZW92ZXIsIGJ1dCB0aGVuIGNhbm5vdCBnZW5lcmF0ZVxuXHQgKiBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cblx0ICogQHBhcmFtICBkYXRlICAoRGF0ZSkgdGhlIGRhdGUgdG8gY2hlY2tcblx0ICogQHJldHVybiAgKERhdGUpIHRoZSBjb3JyZWN0ZWQgZGF0ZVxuXHQgKi9cblx0X2RheWxpZ2h0U2F2aW5nQWRqdXN0OiBmdW5jdGlvbiggZGF0ZSApIHtcblx0XHRpZiAoICFkYXRlICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGRhdGUuc2V0SG91cnMoIGRhdGUuZ2V0SG91cnMoKSA+IDEyID8gZGF0ZS5nZXRIb3VycygpICsgMiA6IDAgKTtcblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXG5cdF9zZXREYXRlOiBmdW5jdGlvbiggaW5zdCwgZGF0ZSwgbm9DaGFuZ2UgKSB7XG5cdFx0dmFyIGNsZWFyID0gIWRhdGUsXG5cdFx0XHRvcmlnTW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGgsXG5cdFx0XHRvcmlnWWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyLFxuXHRcdFx0bmV3RGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KCBpbnN0LCB0aGlzLl9kZXRlcm1pbmVEYXRlKCBpbnN0LCBkYXRlLCBuZXcgRGF0ZSgpICkgKTtcblxuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSBuZXdEYXRlLmdldERhdGUoKTtcblx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSBuZXdEYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0aWYgKCAoIG9yaWdNb250aCAhPT0gaW5zdC5zZWxlY3RlZE1vbnRoIHx8IG9yaWdZZWFyICE9PSBpbnN0LnNlbGVjdGVkWWVhciApICYmICFub0NoYW5nZSApIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZSggaW5zdCApO1xuXHRcdH1cblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZSggaW5zdCApO1xuXHRcdGlmICggaW5zdC5pbnB1dCApIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKCBjbGVhciA/IFwiXCIgOiB0aGlzLl9mb3JtYXREYXRlKCBpbnN0ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXG5cdF9nZXREYXRlOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHR2YXIgc3RhcnREYXRlID0gKCAhaW5zdC5jdXJyZW50WWVhciB8fCAoIGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC52YWwoKSA9PT0gXCJcIiApID8gbnVsbCA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoXG5cdFx0XHRpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5ICkgKSApO1xuXHRcdFx0cmV0dXJuIHN0YXJ0RGF0ZTtcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIG9ueHh4IGhhbmRsZXJzLiAgVGhlc2UgYXJlIGRlY2xhcmVkIHN0YXRpY2FsbHkgc29cblx0ICogdGhleSB3b3JrIHdpdGggc3RhdGljIGNvZGUgdHJhbnNmb3JtZXJzIGxpa2UgQ2FqYS5cblx0ICovXG5cdF9hdHRhY2hIYW5kbGVyczogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoIGluc3QsIFwic3RlcE1vbnRoc1wiICksXG5cdFx0XHRpZCA9IFwiI1wiICsgaW5zdC5pZC5yZXBsYWNlKCAvXFxcXFxcXFwvZywgXCJcXFxcXCIgKTtcblx0XHRpbnN0LmRwRGl2LmZpbmQoIFwiW2RhdGEtaGFuZGxlcl1cIiApLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHtcblx0XHRcdFx0cHJldjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBpZCwgLXN0ZXBNb250aHMsIFwiTVwiICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggaWQsICtzdGVwTW9udGhzLCBcIk1cIiApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvZGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheSggaWQgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0RGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheSggaWQsICt0aGlzLmdldEF0dHJpYnV0ZSggXCJkYXRhLW1vbnRoXCIgKSwgK3RoaXMuZ2V0QXR0cmlidXRlKCBcImRhdGEteWVhclwiICksIHRoaXMgKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdE1vbnRoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhciggaWQsIHRoaXMsIFwiTVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhciggaWQsIHRoaXMsIFwiWVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0JCggdGhpcyApLm9uKCB0aGlzLmdldEF0dHJpYnV0ZSggXCJkYXRhLWV2ZW50XCIgKSwgaGFuZGxlclsgdGhpcy5nZXRBdHRyaWJ1dGUoIFwiZGF0YS1oYW5kbGVyXCIgKSBdICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdC8qIEdlbmVyYXRlIHRoZSBIVE1MIGZvciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9nZW5lcmF0ZUhUTUw6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHZhciBtYXhEcmF3LCBwcmV2VGV4dCwgcHJldiwgbmV4dFRleHQsIG5leHQsIGN1cnJlbnRUZXh0LCBnb3RvRGF0ZSxcblx0XHRcdGNvbnRyb2xzLCBidXR0b25QYW5lbCwgZmlyc3REYXksIHNob3dXZWVrLCBkYXlOYW1lcywgZGF5TmFtZXNNaW4sXG5cdFx0XHRtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQsIGJlZm9yZVNob3dEYXksIHNob3dPdGhlck1vbnRocyxcblx0XHRcdHNlbGVjdE90aGVyTW9udGhzLCBkZWZhdWx0RGF0ZSwgaHRtbCwgZG93LCByb3csIGdyb3VwLCBjb2wsIHNlbGVjdGVkRGF0ZSxcblx0XHRcdGNvcm5lckNsYXNzLCBjYWxlbmRlciwgdGhlYWQsIGRheSwgZGF5c0luTW9udGgsIGxlYWREYXlzLCBjdXJSb3dzLCBudW1Sb3dzLFxuXHRcdFx0cHJpbnREYXRlLCBkUm93LCB0Ym9keSwgZGF5U2V0dGluZ3MsIG90aGVyTW9udGgsIHVuc2VsZWN0YWJsZSxcblx0XHRcdHRlbXBEYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdHRvZGF5ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoXG5cdFx0XHRcdG5ldyBEYXRlKCB0ZW1wRGF0ZS5nZXRGdWxsWWVhcigpLCB0ZW1wRGF0ZS5nZXRNb250aCgpLCB0ZW1wRGF0ZS5nZXREYXRlKCkgKSApLCAvLyBjbGVhciB0aW1lXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldCggaW5zdCwgXCJpc1JUTFwiICksXG5cdFx0XHRzaG93QnV0dG9uUGFuZWwgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd0J1dHRvblBhbmVsXCIgKSxcblx0XHRcdGhpZGVJZk5vUHJldk5leHQgPSB0aGlzLl9nZXQoIGluc3QsIFwiaGlkZUlmTm9QcmV2TmV4dFwiICksXG5cdFx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcIm5hdmlnYXRpb25Bc0RhdGVGb3JtYXRcIiApLFxuXHRcdFx0bnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoIGluc3QgKSxcblx0XHRcdHNob3dDdXJyZW50QXRQb3MgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd0N1cnJlbnRBdFBvc1wiICksXG5cdFx0XHRzdGVwTW9udGhzID0gdGhpcy5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApLFxuXHRcdFx0aXNNdWx0aU1vbnRoID0gKCBudW1Nb250aHNbIDAgXSAhPT0gMSB8fCBudW1Nb250aHNbIDEgXSAhPT0gMSApLFxuXHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggKCAhaW5zdC5jdXJyZW50RGF5ID8gbmV3IERhdGUoIDk5OTksIDksIDkgKSA6XG5cdFx0XHRcdG5ldyBEYXRlKCBpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5ICkgKSApLFxuXHRcdFx0bWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWluXCIgKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1heFwiICksXG5cdFx0XHRkcmF3TW9udGggPSBpbnN0LmRyYXdNb250aCAtIHNob3dDdXJyZW50QXRQb3MsXG5cdFx0XHRkcmF3WWVhciA9IGluc3QuZHJhd1llYXI7XG5cblx0XHRpZiAoIGRyYXdNb250aCA8IDAgKSB7XG5cdFx0XHRkcmF3TW9udGggKz0gMTI7XG5cdFx0XHRkcmF3WWVhci0tO1xuXHRcdH1cblx0XHRpZiAoIG1heERhdGUgKSB7XG5cdFx0XHRtYXhEcmF3ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBtYXhEYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0XHRcdG1heERhdGUuZ2V0TW9udGgoKSAtICggbnVtTW9udGhzWyAwIF0gKiBudW1Nb250aHNbIDEgXSApICsgMSwgbWF4RGF0ZS5nZXREYXRlKCkgKSApO1xuXHRcdFx0bWF4RHJhdyA9ICggbWluRGF0ZSAmJiBtYXhEcmF3IDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBtYXhEcmF3ICk7XG5cdFx0XHR3aGlsZSAoIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggZHJhd1llYXIsIGRyYXdNb250aCwgMSApICkgPiBtYXhEcmF3ICkge1xuXHRcdFx0XHRkcmF3TW9udGgtLTtcblx0XHRcdFx0aWYgKCBkcmF3TW9udGggPCAwICkge1xuXHRcdFx0XHRcdGRyYXdNb250aCA9IDExO1xuXHRcdFx0XHRcdGRyYXdZZWFyLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aW5zdC5kcmF3TW9udGggPSBkcmF3TW9udGg7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGRyYXdZZWFyO1xuXG5cdFx0cHJldlRleHQgPSB0aGlzLl9nZXQoIGluc3QsIFwicHJldlRleHRcIiApO1xuXHRcdHByZXZUZXh0ID0gKCAhbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IHByZXZUZXh0IDogdGhpcy5mb3JtYXREYXRlKCBwcmV2VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggZHJhd1llYXIsIGRyYXdNb250aCAtIHN0ZXBNb250aHMsIDEgKSApLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKCBpbnN0ICkgKSApO1xuXG5cdFx0cHJldiA9ICggdGhpcy5fY2FuQWRqdXN0TW9udGgoIGluc3QsIC0xLCBkcmF3WWVhciwgZHJhd01vbnRoICkgP1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0ncHJldicgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCIgdGl0bGU9J1wiICsgcHJldlRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJlXCIgOiBcIndcIiApICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KCBoaWRlSWZOb1ByZXZOZXh0ID8gXCJcIiA6IFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItcHJldiB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkJyB0aXRsZT0nXCIgKyBwcmV2VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcImVcIiA6IFwid1wiICkgKyBcIic+XCIgKyBwcmV2VGV4dCArIFwiPC9zcGFuPjwvYT5cIiApICk7XG5cblx0XHRuZXh0VGV4dCA9IHRoaXMuX2dldCggaW5zdCwgXCJuZXh0VGV4dFwiICk7XG5cdFx0bmV4dFRleHQgPSAoICFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gbmV4dFRleHQgOiB0aGlzLmZvcm1hdERhdGUoIG5leHRUZXh0LFxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBkcmF3WWVhciwgZHJhd01vbnRoICsgc3RlcE1vbnRocywgMSApICksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApICk7XG5cblx0XHRuZXh0ID0gKCB0aGlzLl9jYW5BZGp1c3RNb250aCggaW5zdCwgKzEsIGRyYXdZZWFyLCBkcmF3TW9udGggKSA/XG5cdFx0XHRcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLW5leHQgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSduZXh0JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIiB0aXRsZT0nXCIgKyBuZXh0VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcIndcIiA6IFwiZVwiICkgKyBcIic+XCIgKyBuZXh0VGV4dCArIFwiPC9zcGFuPjwvYT5cIiA6XG5cdFx0XHQoIGhpZGVJZk5vUHJldk5leHQgPyBcIlwiIDogXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcIiArIG5leHRUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwid1wiIDogXCJlXCIgKSArIFwiJz5cIiArIG5leHRUZXh0ICsgXCI8L3NwYW4+PC9hPlwiICkgKTtcblxuXHRcdGN1cnJlbnRUZXh0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImN1cnJlbnRUZXh0XCIgKTtcblx0XHRnb3RvRGF0ZSA9ICggdGhpcy5fZ2V0KCBpbnN0LCBcImdvdG9DdXJyZW50XCIgKSAmJiBpbnN0LmN1cnJlbnREYXkgPyBjdXJyZW50RGF0ZSA6IHRvZGF5ICk7XG5cdFx0Y3VycmVudFRleHQgPSAoICFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gY3VycmVudFRleHQgOlxuXHRcdFx0dGhpcy5mb3JtYXREYXRlKCBjdXJyZW50VGV4dCwgZ290b0RhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyggaW5zdCApICkgKTtcblxuXHRcdGNvbnRyb2xzID0gKCAhaW5zdC5pbmxpbmUgPyBcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0ndWktZGF0ZXBpY2tlci1jbG9zZSB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXByaW1hcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSdoaWRlJyBkYXRhLWV2ZW50PSdjbGljayc+XCIgK1xuXHRcdFx0dGhpcy5fZ2V0KCBpbnN0LCBcImNsb3NlVGV4dFwiICkgKyBcIjwvYnV0dG9uPlwiIDogXCJcIiApO1xuXG5cdFx0YnV0dG9uUGFuZWwgPSAoIHNob3dCdXR0b25QYW5lbCApID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQnPlwiICsgKCBpc1JUTCA/IGNvbnRyb2xzIDogXCJcIiApICtcblx0XHRcdCggdGhpcy5faXNJblJhbmdlKCBpbnN0LCBnb3RvRGF0ZSApID8gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY3VycmVudCB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXNlY29uZGFyeSB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3RvZGF5JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIj5cIiArIGN1cnJlbnRUZXh0ICsgXCI8L2J1dHRvbj5cIiA6IFwiXCIgKSArICggaXNSVEwgPyBcIlwiIDogY29udHJvbHMgKSArIFwiPC9kaXY+XCIgOiBcIlwiO1xuXG5cdFx0Zmlyc3REYXkgPSBwYXJzZUludCggdGhpcy5fZ2V0KCBpbnN0LCBcImZpcnN0RGF5XCIgKSwgMTAgKTtcblx0XHRmaXJzdERheSA9ICggaXNOYU4oIGZpcnN0RGF5ICkgPyAwIDogZmlyc3REYXkgKTtcblxuXHRcdHNob3dXZWVrID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dXZWVrXCIgKTtcblx0XHRkYXlOYW1lcyA9IHRoaXMuX2dldCggaW5zdCwgXCJkYXlOYW1lc1wiICk7XG5cdFx0ZGF5TmFtZXNNaW4gPSB0aGlzLl9nZXQoIGluc3QsIFwiZGF5TmFtZXNNaW5cIiApO1xuXHRcdG1vbnRoTmFtZXMgPSB0aGlzLl9nZXQoIGluc3QsIFwibW9udGhOYW1lc1wiICk7XG5cdFx0bW9udGhOYW1lc1Nob3J0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiICk7XG5cdFx0YmVmb3JlU2hvd0RheSA9IHRoaXMuX2dldCggaW5zdCwgXCJiZWZvcmVTaG93RGF5XCIgKTtcblx0XHRzaG93T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd090aGVyTW9udGhzXCIgKTtcblx0XHRzZWxlY3RPdGhlck1vbnRocyA9IHRoaXMuX2dldCggaW5zdCwgXCJzZWxlY3RPdGhlck1vbnRoc1wiICk7XG5cdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZSggaW5zdCApO1xuXHRcdGh0bWwgPSBcIlwiO1xuXG5cdFx0Zm9yICggcm93ID0gMDsgcm93IDwgbnVtTW9udGhzWyAwIF07IHJvdysrICkge1xuXHRcdFx0Z3JvdXAgPSBcIlwiO1xuXHRcdFx0dGhpcy5tYXhSb3dzID0gNDtcblx0XHRcdGZvciAoIGNvbCA9IDA7IGNvbCA8IG51bU1vbnRoc1sgMSBdOyBjb2wrKyApIHtcblx0XHRcdFx0c2VsZWN0ZWREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBkcmF3WWVhciwgZHJhd01vbnRoLCBpbnN0LnNlbGVjdGVkRGF5ICkgKTtcblx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItYWxsXCI7XG5cdFx0XHRcdGNhbGVuZGVyID0gXCJcIjtcblx0XHRcdFx0aWYgKCBpc011bHRpTW9udGggKSB7XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWdyb3VwXCI7XG5cdFx0XHRcdFx0aWYgKCBudW1Nb250aHNbIDEgXSA+IDEgKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCBjb2wgKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMDogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1maXJzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKCBpc1JUTCA/IFwicmlnaHRcIiA6IFwibGVmdFwiICk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIG51bU1vbnRoc1sgMSBdIC0gMTogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1sYXN0XCI7XG5cdFx0XHRcdFx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItXCIgKyAoIGlzUlRMID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtbWlkZGxlXCI7IGNvcm5lckNsYXNzID0gXCJcIjsgYnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiJz5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItaGVhZGVyIHVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4XCIgKyBjb3JuZXJDbGFzcyArIFwiJz5cIiArXG5cdFx0XHRcdFx0KCAvYWxsfGxlZnQvLnRlc3QoIGNvcm5lckNsYXNzICkgJiYgcm93ID09PSAwID8gKCBpc1JUTCA/IG5leHQgOiBwcmV2ICkgOiBcIlwiICkgK1xuXHRcdFx0XHRcdCggL2FsbHxyaWdodC8udGVzdCggY29ybmVyQ2xhc3MgKSAmJiByb3cgPT09IDAgPyAoIGlzUlRMID8gcHJldiA6IG5leHQgKSA6IFwiXCIgKSArXG5cdFx0XHRcdFx0dGhpcy5fZ2VuZXJhdGVNb250aFllYXJIZWFkZXIoIGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRcdFx0cm93ID4gMCB8fCBjb2wgPiAwLCBtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQgKSArIC8vIGRyYXcgbW9udGggaGVhZGVyc1xuXHRcdFx0XHRcdFwiPC9kaXY+PHRhYmxlIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNhbGVuZGFyJz48dGhlYWQ+XCIgK1xuXHRcdFx0XHRcdFwiPHRyPlwiO1xuXHRcdFx0XHR0aGVhZCA9ICggc2hvd1dlZWsgPyBcIjx0aCBjbGFzcz0ndWktZGF0ZXBpY2tlci13ZWVrLWNvbCc+XCIgKyB0aGlzLl9nZXQoIGluc3QsIFwid2Vla0hlYWRlclwiICkgKyBcIjwvdGg+XCIgOiBcIlwiICk7XG5cdFx0XHRcdGZvciAoIGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrICkgeyAvLyBkYXlzIG9mIHRoZSB3ZWVrXG5cdFx0XHRcdFx0ZGF5ID0gKCBkb3cgKyBmaXJzdERheSApICUgNztcblx0XHRcdFx0XHR0aGVhZCArPSBcIjx0aCBzY29wZT0nY29sJ1wiICsgKCAoIGRvdyArIGZpcnN0RGF5ICsgNiApICUgNyA+PSA1ID8gXCIgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1lbmQnXCIgOiBcIlwiICkgKyBcIj5cIiArXG5cdFx0XHRcdFx0XHRcIjxzcGFuIHRpdGxlPSdcIiArIGRheU5hbWVzWyBkYXkgXSArIFwiJz5cIiArIGRheU5hbWVzTWluWyBkYXkgXSArIFwiPC9zcGFuPjwvdGg+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gdGhlYWQgKyBcIjwvdHI+PC90aGVhZD48dGJvZHk+XCI7XG5cdFx0XHRcdGRheXNJbk1vbnRoID0gdGhpcy5fZ2V0RGF5c0luTW9udGgoIGRyYXdZZWFyLCBkcmF3TW9udGggKTtcblx0XHRcdFx0aWYgKCBkcmF3WWVhciA9PT0gaW5zdC5zZWxlY3RlZFllYXIgJiYgZHJhd01vbnRoID09PSBpbnN0LnNlbGVjdGVkTW9udGggKSB7XG5cdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IE1hdGgubWluKCBpbnN0LnNlbGVjdGVkRGF5LCBkYXlzSW5Nb250aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxlYWREYXlzID0gKCB0aGlzLl9nZXRGaXJzdERheU9mTW9udGgoIGRyYXdZZWFyLCBkcmF3TW9udGggKSAtIGZpcnN0RGF5ICsgNyApICUgNztcblx0XHRcdFx0Y3VyUm93cyA9IE1hdGguY2VpbCggKCBsZWFkRGF5cyArIGRheXNJbk1vbnRoICkgLyA3ICk7IC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gZ2VuZXJhdGVcblx0XHRcdFx0bnVtUm93cyA9ICggaXNNdWx0aU1vbnRoID8gdGhpcy5tYXhSb3dzID4gY3VyUm93cyA/IHRoaXMubWF4Um93cyA6IGN1clJvd3MgOiBjdXJSb3dzICk7IC8vSWYgbXVsdGlwbGUgbW9udGhzLCB1c2UgdGhlIGhpZ2hlciBudW1iZXIgb2Ygcm93cyAoc2VlICM3MDQzKVxuXHRcdFx0XHR0aGlzLm1heFJvd3MgPSBudW1Sb3dzO1xuXHRcdFx0XHRwcmludERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGRyYXdZZWFyLCBkcmF3TW9udGgsIDEgLSBsZWFkRGF5cyApICk7XG5cdFx0XHRcdGZvciAoIGRSb3cgPSAwOyBkUm93IDwgbnVtUm93czsgZFJvdysrICkgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgcm93c1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPHRyPlwiO1xuXHRcdFx0XHRcdHRib2R5ID0gKCAhc2hvd1dlZWsgPyBcIlwiIDogXCI8dGQgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICtcblx0XHRcdFx0XHRcdHRoaXMuX2dldCggaW5zdCwgXCJjYWxjdWxhdGVXZWVrXCIgKSggcHJpbnREYXRlICkgKyBcIjwvdGQ+XCIgKTtcblx0XHRcdFx0XHRmb3IgKCBkb3cgPSAwOyBkb3cgPCA3OyBkb3crKyApIHsgLy8gY3JlYXRlIGRhdGUgcGlja2VyIGRheXNcblx0XHRcdFx0XHRcdGRheVNldHRpbmdzID0gKCBiZWZvcmVTaG93RGF5ID9cblx0XHRcdFx0XHRcdFx0YmVmb3JlU2hvd0RheS5hcHBseSggKCBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFsgMCBdIDogbnVsbCApLCBbIHByaW50RGF0ZSBdICkgOiBbIHRydWUsIFwiXCIgXSApO1xuXHRcdFx0XHRcdFx0b3RoZXJNb250aCA9ICggcHJpbnREYXRlLmdldE1vbnRoKCkgIT09IGRyYXdNb250aCApO1xuXHRcdFx0XHRcdFx0dW5zZWxlY3RhYmxlID0gKCBvdGhlck1vbnRoICYmICFzZWxlY3RPdGhlck1vbnRocyApIHx8ICFkYXlTZXR0aW5nc1sgMCBdIHx8XG5cdFx0XHRcdFx0XHRcdCggbWluRGF0ZSAmJiBwcmludERhdGUgPCBtaW5EYXRlICkgfHwgKCBtYXhEYXRlICYmIHByaW50RGF0ZSA+IG1heERhdGUgKTtcblx0XHRcdFx0XHRcdHRib2R5ICs9IFwiPHRkIGNsYXNzPSdcIiArXG5cdFx0XHRcdFx0XHRcdCggKCBkb3cgKyBmaXJzdERheSArIDYgKSAlIDcgPj0gNSA/IFwiIHVpLWRhdGVwaWNrZXItd2Vlay1lbmRcIiA6IFwiXCIgKSArIC8vIGhpZ2hsaWdodCB3ZWVrZW5kc1xuXHRcdFx0XHRcdFx0XHQoIG90aGVyTW9udGggPyBcIiB1aS1kYXRlcGlja2VyLW90aGVyLW1vbnRoXCIgOiBcIlwiICkgKyAvLyBoaWdobGlnaHQgZGF5cyBmcm9tIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQoICggcHJpbnREYXRlLmdldFRpbWUoKSA9PT0gc2VsZWN0ZWREYXRlLmdldFRpbWUoKSAmJiBkcmF3TW9udGggPT09IGluc3Quc2VsZWN0ZWRNb250aCAmJiBpbnN0Ll9rZXlFdmVudCApIHx8IC8vIHVzZXIgcHJlc3NlZCBrZXlcblx0XHRcdFx0XHRcdFx0KCBkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHByaW50RGF0ZS5nZXRUaW1lKCkgJiYgZGVmYXVsdERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICkgP1xuXG5cdFx0XHRcdFx0XHRcdC8vIG9yIGRlZmF1bHREYXRlIGlzIGN1cnJlbnQgcHJpbnRlZERhdGUgYW5kIGRlZmF1bHREYXRlIGlzIHNlbGVjdGVkRGF0ZVxuXHRcdFx0XHRcdFx0XHRcIiBcIiArIHRoaXMuX2RheU92ZXJDbGFzcyA6IFwiXCIgKSArIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcblx0XHRcdFx0XHRcdFx0KCB1bnNlbGVjdGFibGUgPyBcIiBcIiArIHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzICsgXCIgdWktc3RhdGUtZGlzYWJsZWRcIiA6IFwiXCIgKSArICAvLyBoaWdobGlnaHQgdW5zZWxlY3RhYmxlIGRheXNcblx0XHRcdFx0XHRcdFx0KCBvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcIlwiIDogXCIgXCIgKyBkYXlTZXR0aW5nc1sgMSBdICsgLy8gaGlnaGxpZ2h0IGN1c3RvbSBkYXRlc1xuXHRcdFx0XHRcdFx0XHQoIHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIFwiICsgdGhpcy5fY3VycmVudENsYXNzIDogXCJcIiApICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQoIHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHRvZGF5LmdldFRpbWUoKSA/IFwiIHVpLWRhdGVwaWNrZXItdG9kYXlcIiA6IFwiXCIgKSApICsgXCInXCIgKyAvLyBoaWdobGlnaHQgdG9kYXkgKGlmIGRpZmZlcmVudClcblx0XHRcdFx0XHRcdFx0KCAoICFvdGhlck1vbnRoIHx8IHNob3dPdGhlck1vbnRocyApICYmIGRheVNldHRpbmdzWyAyIF0gPyBcIiB0aXRsZT0nXCIgKyBkYXlTZXR0aW5nc1sgMiBdLnJlcGxhY2UoIC8nL2csIFwiJiMzOTtcIiApICsgXCInXCIgOiBcIlwiICkgKyAvLyBjZWxsIHRpdGxlXG5cdFx0XHRcdFx0XHRcdCggdW5zZWxlY3RhYmxlID8gXCJcIiA6IFwiIGRhdGEtaGFuZGxlcj0nc2VsZWN0RGF5JyBkYXRhLWV2ZW50PSdjbGljaycgZGF0YS1tb250aD0nXCIgKyBwcmludERhdGUuZ2V0TW9udGgoKSArIFwiJyBkYXRhLXllYXI9J1wiICsgcHJpbnREYXRlLmdldEZ1bGxZZWFyKCkgKyBcIidcIiApICsgXCI+XCIgKyAvLyBhY3Rpb25zXG5cdFx0XHRcdFx0XHRcdCggb3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gXCImI3hhMDtcIiA6IC8vIGRpc3BsYXkgZm9yIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQoIHVuc2VsZWN0YWJsZSA/IFwiPHNwYW4gY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHQnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9zcGFuPlwiIDogXCI8YSBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdFwiICtcblx0XHRcdFx0XHRcdFx0KCBwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1zdGF0ZS1oaWdobGlnaHRcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0XHRcdCggcHJpbnREYXRlLmdldFRpbWUoKSA9PT0gY3VycmVudERhdGUuZ2V0VGltZSgpID8gXCIgdWktc3RhdGUtYWN0aXZlXCIgOiBcIlwiICkgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdCggb3RoZXJNb250aCA/IFwiIHVpLXByaW9yaXR5LXNlY29uZGFyeVwiIDogXCJcIiApICsgLy8gZGlzdGluZ3Vpc2ggZGF0ZXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0XCInIGhyZWY9JyMnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9hPlwiICkgKSArIFwiPC90ZD5cIjsgLy8gZGlzcGxheSBzZWxlY3RhYmxlIGRhdGVcblx0XHRcdFx0XHRcdHByaW50RGF0ZS5zZXREYXRlKCBwcmludERhdGUuZ2V0RGF0ZSgpICsgMSApO1xuXHRcdFx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIHByaW50RGF0ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxlbmRlciArPSB0Ym9keSArIFwiPC90cj5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkcmF3TW9udGgrKztcblx0XHRcdFx0aWYgKCBkcmF3TW9udGggPiAxMSApIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAwO1xuXHRcdFx0XHRcdGRyYXdZZWFyKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8L3Rib2R5PjwvdGFibGU+XCIgKyAoIGlzTXVsdGlNb250aCA/IFwiPC9kaXY+XCIgK1xuXHRcdFx0XHRcdFx0XHQoICggbnVtTW9udGhzWyAwIF0gPiAwICYmIGNvbCA9PT0gbnVtTW9udGhzWyAxIF0gLSAxICkgPyBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItcm93LWJyZWFrJz48L2Rpdj5cIiA6IFwiXCIgKSA6IFwiXCIgKTtcblx0XHRcdFx0Z3JvdXAgKz0gY2FsZW5kZXI7XG5cdFx0XHR9XG5cdFx0XHRodG1sICs9IGdyb3VwO1xuXHRcdH1cblx0XHRodG1sICs9IGJ1dHRvblBhbmVsO1xuXHRcdGluc3QuX2tleUV2ZW50ID0gZmFsc2U7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIG1vbnRoIGFuZCB5ZWFyIGhlYWRlci4gKi9cblx0X2dlbmVyYXRlTW9udGhZZWFySGVhZGVyOiBmdW5jdGlvbiggaW5zdCwgZHJhd01vbnRoLCBkcmF3WWVhciwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdHNlY29uZGFyeSwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0ICkge1xuXG5cdFx0dmFyIGluTWluWWVhciwgaW5NYXhZZWFyLCBtb250aCwgeWVhcnMsIHRoaXNZZWFyLCBkZXRlcm1pbmVZZWFyLCB5ZWFyLCBlbmRZZWFyLFxuXHRcdFx0Y2hhbmdlTW9udGggPSB0aGlzLl9nZXQoIGluc3QsIFwiY2hhbmdlTW9udGhcIiApLFxuXHRcdFx0Y2hhbmdlWWVhciA9IHRoaXMuX2dldCggaW5zdCwgXCJjaGFuZ2VZZWFyXCIgKSxcblx0XHRcdHNob3dNb250aEFmdGVyWWVhciA9IHRoaXMuX2dldCggaW5zdCwgXCJzaG93TW9udGhBZnRlclllYXJcIiApLFxuXHRcdFx0aHRtbCA9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci10aXRsZSc+XCIsXG5cdFx0XHRtb250aEh0bWwgPSBcIlwiO1xuXG5cdFx0Ly8gTW9udGggc2VsZWN0aW9uXG5cdFx0aWYgKCBzZWNvbmRhcnkgfHwgIWNoYW5nZU1vbnRoICkge1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNwYW4gY2xhc3M9J3VpLWRhdGVwaWNrZXItbW9udGgnPlwiICsgbW9udGhOYW1lc1sgZHJhd01vbnRoIF0gKyBcIjwvc3Bhbj5cIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5NaW5ZZWFyID0gKCBtaW5EYXRlICYmIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXIgKTtcblx0XHRcdGluTWF4WWVhciA9ICggbWF4RGF0ZSAmJiBtYXhEYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyICk7XG5cdFx0XHRtb250aEh0bWwgKz0gXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJyBkYXRhLWhhbmRsZXI9J3NlbGVjdE1vbnRoJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlwiO1xuXHRcdFx0Zm9yICggbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrICkge1xuXHRcdFx0XHRpZiAoICggIWluTWluWWVhciB8fCBtb250aCA+PSBtaW5EYXRlLmdldE1vbnRoKCkgKSAmJiAoICFpbk1heFllYXIgfHwgbW9udGggPD0gbWF4RGF0ZS5nZXRNb250aCgpICkgKSB7XG5cdFx0XHRcdFx0bW9udGhIdG1sICs9IFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyBtb250aCArIFwiJ1wiICtcblx0XHRcdFx0XHRcdCggbW9udGggPT09IGRyYXdNb250aCA/IFwiIHNlbGVjdGVkPSdzZWxlY3RlZCdcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIG1vbnRoTmFtZXNTaG9ydFsgbW9udGggXSArIFwiPC9vcHRpb24+XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1vbnRoSHRtbCArPSBcIjwvc2VsZWN0PlwiO1xuXHRcdH1cblxuXHRcdGlmICggIXNob3dNb250aEFmdGVyWWVhciApIHtcblx0XHRcdGh0bWwgKz0gbW9udGhIdG1sICsgKCBzZWNvbmRhcnkgfHwgISggY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhciApID8gXCImI3hhMDtcIiA6IFwiXCIgKTtcblx0XHR9XG5cblx0XHQvLyBZZWFyIHNlbGVjdGlvblxuXHRcdGlmICggIWluc3QueWVhcnNodG1sICkge1xuXHRcdFx0aW5zdC55ZWFyc2h0bWwgPSBcIlwiO1xuXHRcdFx0aWYgKCBzZWNvbmRhcnkgfHwgIWNoYW5nZVllYXIgKSB7XG5cdFx0XHRcdGh0bWwgKz0gXCI8c3BhbiBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJz5cIiArIGRyYXdZZWFyICsgXCI8L3NwYW4+XCI7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGRldGVybWluZSByYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5XG5cdFx0XHRcdHllYXJzID0gdGhpcy5fZ2V0KCBpbnN0LCBcInllYXJSYW5nZVwiICkuc3BsaXQoIFwiOlwiICk7XG5cdFx0XHRcdHRoaXNZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRkZXRlcm1pbmVZZWFyID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciB5ZWFyID0gKCB2YWx1ZS5tYXRjaCggL2NbK1xcLV0uKi8gKSA/IGRyYXdZZWFyICsgcGFyc2VJbnQoIHZhbHVlLnN1YnN0cmluZyggMSApLCAxMCApIDpcblx0XHRcdFx0XHRcdCggdmFsdWUubWF0Y2goIC9bK1xcLV0uKi8gKSA/IHRoaXNZZWFyICsgcGFyc2VJbnQoIHZhbHVlLCAxMCApIDpcblx0XHRcdFx0XHRcdHBhcnNlSW50KCB2YWx1ZSwgMTAgKSApICk7XG5cdFx0XHRcdFx0cmV0dXJuICggaXNOYU4oIHllYXIgKSA/IHRoaXNZZWFyIDogeWVhciApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR5ZWFyID0gZGV0ZXJtaW5lWWVhciggeWVhcnNbIDAgXSApO1xuXHRcdFx0XHRlbmRZZWFyID0gTWF0aC5tYXgoIHllYXIsIGRldGVybWluZVllYXIoIHllYXJzWyAxIF0gfHwgXCJcIiApICk7XG5cdFx0XHRcdHllYXIgPSAoIG1pbkRhdGUgPyBNYXRoLm1heCggeWVhciwgbWluRGF0ZS5nZXRGdWxsWWVhcigpICkgOiB5ZWFyICk7XG5cdFx0XHRcdGVuZFllYXIgPSAoIG1heERhdGUgPyBNYXRoLm1pbiggZW5kWWVhciwgbWF4RGF0ZS5nZXRGdWxsWWVhcigpICkgOiBlbmRZZWFyICk7XG5cdFx0XHRcdGluc3QueWVhcnNodG1sICs9IFwiPHNlbGVjdCBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJyBkYXRhLWhhbmRsZXI9J3NlbGVjdFllYXInIGRhdGEtZXZlbnQ9J2NoYW5nZSc+XCI7XG5cdFx0XHRcdGZvciAoIDsgeWVhciA8PSBlbmRZZWFyOyB5ZWFyKysgKSB7XG5cdFx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIHllYXIgKyBcIidcIiArXG5cdFx0XHRcdFx0XHQoIHllYXIgPT09IGRyYXdZZWFyID8gXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIiApICtcblx0XHRcdFx0XHRcdFwiPlwiICsgeWVhciArIFwiPC9vcHRpb24+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8L3NlbGVjdD5cIjtcblxuXHRcdFx0XHRodG1sICs9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aHRtbCArPSB0aGlzLl9nZXQoIGluc3QsIFwieWVhclN1ZmZpeFwiICk7XG5cdFx0aWYgKCBzaG93TW9udGhBZnRlclllYXIgKSB7XG5cdFx0XHRodG1sICs9ICggc2Vjb25kYXJ5IHx8ICEoIGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIgKSA/IFwiJiN4YTA7XCIgOiBcIlwiICkgKyBtb250aEh0bWw7XG5cdFx0fVxuXHRcdGh0bWwgKz0gXCI8L2Rpdj5cIjsgLy8gQ2xvc2UgZGF0ZXBpY2tlcl9oZWFkZXJcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHQvKiBBZGp1c3Qgb25lIG9mIHRoZSBkYXRlIHN1Yi1maWVsZHMuICovXG5cdF9hZGp1c3RJbnN0RGF0ZTogZnVuY3Rpb24oIGluc3QsIG9mZnNldCwgcGVyaW9kICkge1xuXHRcdHZhciB5ZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgKyAoIHBlcmlvZCA9PT0gXCJZXCIgPyBvZmZzZXQgOiAwICksXG5cdFx0XHRtb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCArICggcGVyaW9kID09PSBcIk1cIiA/IG9mZnNldCA6IDAgKSxcblx0XHRcdGRheSA9IE1hdGgubWluKCBpbnN0LnNlbGVjdGVkRGF5LCB0aGlzLl9nZXREYXlzSW5Nb250aCggeWVhciwgbW9udGggKSApICsgKCBwZXJpb2QgPT09IFwiRFwiID8gb2Zmc2V0IDogMCApLFxuXHRcdFx0ZGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KCBpbnN0LCB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIHllYXIsIG1vbnRoLCBkYXkgKSApICk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmICggcGVyaW9kID09PSBcIk1cIiB8fCBwZXJpb2QgPT09IFwiWVwiICkge1xuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEVuc3VyZSBhIGRhdGUgaXMgd2l0aGluIGFueSBtaW4vbWF4IGJvdW5kcy4gKi9cblx0X3Jlc3RyaWN0TWluTWF4OiBmdW5jdGlvbiggaW5zdCwgZGF0ZSApIHtcblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWluXCIgKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1heFwiICksXG5cdFx0XHRuZXdEYXRlID0gKCBtaW5EYXRlICYmIGRhdGUgPCBtaW5EYXRlID8gbWluRGF0ZSA6IGRhdGUgKTtcblx0XHRyZXR1cm4gKCBtYXhEYXRlICYmIG5ld0RhdGUgPiBtYXhEYXRlID8gbWF4RGF0ZSA6IG5ld0RhdGUgKTtcblx0fSxcblxuXHQvKiBOb3RpZnkgY2hhbmdlIG9mIG1vbnRoL3llYXIuICovXG5cdF9ub3RpZnlDaGFuZ2U6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHZhciBvbkNoYW5nZSA9IHRoaXMuX2dldCggaW5zdCwgXCJvbkNoYW5nZU1vbnRoWWVhclwiICk7XG5cdFx0aWYgKCBvbkNoYW5nZSApIHtcblx0XHRcdG9uQ2hhbmdlLmFwcGx5KCAoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WyAwIF0gOiBudWxsICksXG5cdFx0XHRcdFsgaW5zdC5zZWxlY3RlZFllYXIsIGluc3Quc2VsZWN0ZWRNb250aCArIDEsIGluc3QgXSApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBtb250aHMgdG8gc2hvdy4gKi9cblx0X2dldE51bWJlck9mTW9udGhzOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0KCBpbnN0LCBcIm51bWJlck9mTW9udGhzXCIgKTtcblx0XHRyZXR1cm4gKCBudW1Nb250aHMgPT0gbnVsbCA/IFsgMSwgMSBdIDogKCB0eXBlb2YgbnVtTW9udGhzID09PSBcIm51bWJlclwiID8gWyAxLCBudW1Nb250aHMgXSA6IG51bU1vbnRocyApICk7XG5cdH0sXG5cblx0LyogRGV0ZXJtaW5lIHRoZSBjdXJyZW50IG1heGltdW0gZGF0ZSAtIGVuc3VyZSBubyB0aW1lIGNvbXBvbmVudHMgYXJlIHNldC4gKi9cblx0X2dldE1pbk1heERhdGU6IGZ1bmN0aW9uKCBpbnN0LCBtaW5NYXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RldGVybWluZURhdGUoIGluc3QsIHRoaXMuX2dldCggaW5zdCwgbWluTWF4ICsgXCJEYXRlXCIgKSwgbnVsbCApO1xuXHR9LFxuXG5cdC8qIEZpbmQgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgZ2l2ZW4gbW9udGguICovXG5cdF9nZXREYXlzSW5Nb250aDogZnVuY3Rpb24oIHllYXIsIG1vbnRoICkge1xuXHRcdHJldHVybiAzMiAtIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggeWVhciwgbW9udGgsIDMyICkgKS5nZXREYXRlKCk7XG5cdH0sXG5cblx0LyogRmluZCB0aGUgZGF5IG9mIHRoZSB3ZWVrIG9mIHRoZSBmaXJzdCBvZiBhIG1vbnRoLiAqL1xuXHRfZ2V0Rmlyc3REYXlPZk1vbnRoOiBmdW5jdGlvbiggeWVhciwgbW9udGggKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKCB5ZWFyLCBtb250aCwgMSApLmdldERheSgpO1xuXHR9LFxuXG5cdC8qIERldGVybWluZXMgaWYgd2Ugc2hvdWxkIGFsbG93IGEgXCJuZXh0L3ByZXZcIiBtb250aCBkaXNwbGF5IGNoYW5nZS4gKi9cblx0X2NhbkFkanVzdE1vbnRoOiBmdW5jdGlvbiggaW5zdCwgb2Zmc2V0LCBjdXJZZWFyLCBjdXJNb250aCApIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoIGluc3QgKSxcblx0XHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGN1clllYXIsXG5cdFx0XHRjdXJNb250aCArICggb2Zmc2V0IDwgMCA/IG9mZnNldCA6IG51bU1vbnRoc1sgMCBdICogbnVtTW9udGhzWyAxIF0gKSwgMSApICk7XG5cblx0XHRpZiAoIG9mZnNldCA8IDAgKSB7XG5cdFx0XHRkYXRlLnNldERhdGUoIHRoaXMuX2dldERheXNJbk1vbnRoKCBkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSApICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pc0luUmFuZ2UoIGluc3QsIGRhdGUgKTtcblx0fSxcblxuXHQvKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgYWNjZXB0ZWQgcmFuZ2U/ICovXG5cdF9pc0luUmFuZ2U6IGZ1bmN0aW9uKCBpbnN0LCBkYXRlICkge1xuXHRcdHZhciB5ZWFyU3BsaXQsIGN1cnJlbnRZZWFyLFxuXHRcdFx0bWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWluXCIgKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1heFwiICksXG5cdFx0XHRtaW5ZZWFyID0gbnVsbCxcblx0XHRcdG1heFllYXIgPSBudWxsLFxuXHRcdFx0eWVhcnMgPSB0aGlzLl9nZXQoIGluc3QsIFwieWVhclJhbmdlXCIgKTtcblx0XHRcdGlmICggeWVhcnMgKSB7XG5cdFx0XHRcdHllYXJTcGxpdCA9IHllYXJzLnNwbGl0KCBcIjpcIiApO1xuXHRcdFx0XHRjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0bWluWWVhciA9IHBhcnNlSW50KCB5ZWFyU3BsaXRbIDAgXSwgMTAgKTtcblx0XHRcdFx0bWF4WWVhciA9IHBhcnNlSW50KCB5ZWFyU3BsaXRbIDEgXSwgMTAgKTtcblx0XHRcdFx0aWYgKCB5ZWFyU3BsaXRbIDAgXS5tYXRjaCggL1srXFwtXS4qLyApICkge1xuXHRcdFx0XHRcdG1pblllYXIgKz0gY3VycmVudFllYXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB5ZWFyU3BsaXRbIDEgXS5tYXRjaCggL1srXFwtXS4qLyApICkge1xuXHRcdFx0XHRcdG1heFllYXIgKz0gY3VycmVudFllYXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdHJldHVybiAoICggIW1pbkRhdGUgfHwgZGF0ZS5nZXRUaW1lKCkgPj0gbWluRGF0ZS5nZXRUaW1lKCkgKSAmJlxuXHRcdFx0KCAhbWF4RGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA8PSBtYXhEYXRlLmdldFRpbWUoKSApICYmXG5cdFx0XHQoICFtaW5ZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA+PSBtaW5ZZWFyICkgJiZcblx0XHRcdCggIW1heFllYXIgfHwgZGF0ZS5nZXRGdWxsWWVhcigpIDw9IG1heFllYXIgKSApO1xuXHR9LFxuXG5cdC8qIFByb3ZpZGUgdGhlIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGZvcm1hdHRpbmcvcGFyc2luZy4gKi9cblx0X2dldEZvcm1hdENvbmZpZzogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IHRoaXMuX2dldCggaW5zdCwgXCJzaG9ydFllYXJDdXRvZmZcIiApO1xuXHRcdHNob3J0WWVhckN1dG9mZiA9ICggdHlwZW9mIHNob3J0WWVhckN1dG9mZiAhPT0gXCJzdHJpbmdcIiA/IHNob3J0WWVhckN1dG9mZiA6XG5cdFx0XHRuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludCggc2hvcnRZZWFyQ3V0b2ZmLCAxMCApICk7XG5cdFx0cmV0dXJuIHsgc2hvcnRZZWFyQ3V0b2ZmOiBzaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRkYXlOYW1lc1Nob3J0OiB0aGlzLl9nZXQoIGluc3QsIFwiZGF5TmFtZXNTaG9ydFwiICksIGRheU5hbWVzOiB0aGlzLl9nZXQoIGluc3QsIFwiZGF5TmFtZXNcIiApLFxuXHRcdFx0bW9udGhOYW1lc1Nob3J0OiB0aGlzLl9nZXQoIGluc3QsIFwibW9udGhOYW1lc1Nob3J0XCIgKSwgbW9udGhOYW1lczogdGhpcy5fZ2V0KCBpbnN0LCBcIm1vbnRoTmFtZXNcIiApIH07XG5cdH0sXG5cblx0LyogRm9ybWF0IHRoZSBnaXZlbiBkYXRlIGZvciBkaXNwbGF5LiAqL1xuXHRfZm9ybWF0RGF0ZTogZnVuY3Rpb24oIGluc3QsIGRheSwgbW9udGgsIHllYXIgKSB7XG5cdFx0aWYgKCAhZGF5ICkge1xuXHRcdFx0aW5zdC5jdXJyZW50RGF5ID0gaW5zdC5zZWxlY3RlZERheTtcblx0XHRcdGluc3QuY3VycmVudE1vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoO1xuXHRcdFx0aW5zdC5jdXJyZW50WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyO1xuXHRcdH1cblx0XHR2YXIgZGF0ZSA9ICggZGF5ID8gKCB0eXBlb2YgZGF5ID09PSBcIm9iamVjdFwiID8gZGF5IDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggeWVhciwgbW9udGgsIGRheSApICkgKSA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkgKSApICk7XG5cdFx0cmV0dXJuIHRoaXMuZm9ybWF0RGF0ZSggdGhpcy5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApLCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApO1xuXHR9XG59ICk7XG5cbi8qXG4gKiBCaW5kIGhvdmVyIGV2ZW50cyBmb3IgZGF0ZXBpY2tlciBlbGVtZW50cy5cbiAqIERvbmUgdmlhIGRlbGVnYXRlIHNvIHRoZSBiaW5kaW5nIG9ubHkgb2NjdXJzIG9uY2UgaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBwYXJlbnQgZGl2LlxuICogR2xvYmFsIGRhdGVwaWNrZXJfaW5zdEFjdGl2ZSwgc2V0IGJ5IF91cGRhdGVEYXRlcGlja2VyIGFsbG93cyB0aGUgaGFuZGxlcnMgdG8gZmluZCB0aGVpciB3YXkgYmFjayB0byB0aGUgYWN0aXZlIHBpY2tlci5cbiAqL1xuZnVuY3Rpb24gZGF0ZXBpY2tlcl9iaW5kSG92ZXIoIGRwRGl2ICkge1xuXHR2YXIgc2VsZWN0b3IgPSBcImJ1dHRvbiwgLnVpLWRhdGVwaWNrZXItcHJldiwgLnVpLWRhdGVwaWNrZXItbmV4dCwgLnVpLWRhdGVwaWNrZXItY2FsZW5kYXIgdGQgYVwiO1xuXHRyZXR1cm4gZHBEaXYub24oIFwibW91c2VvdXRcIiwgc2VsZWN0b3IsIGZ1bmN0aW9uKCkge1xuXHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdGlmICggdGhpcy5jbGFzc05hbWUuaW5kZXhPZiggXCJ1aS1kYXRlcGlja2VyLXByZXZcIiApICE9PSAtMSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoIFwidWktZGF0ZXBpY2tlci1uZXh0XCIgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1kYXRlcGlja2VyLW5leHQtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5vbiggXCJtb3VzZW92ZXJcIiwgc2VsZWN0b3IsIGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyICk7XG59XG5cbmZ1bmN0aW9uIGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyKCkge1xuXHRpZiAoICEkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKCBkYXRlcGlja2VyX2luc3RBY3RpdmUuaW5saW5lID8gZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLmRwRGl2LnBhcmVudCgpWyAwIF0gOiBkYXRlcGlja2VyX2luc3RBY3RpdmUuaW5wdXRbIDAgXSApICkge1xuXHRcdCQoIHRoaXMgKS5wYXJlbnRzKCBcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIgKS5maW5kKCBcImFcIiApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdGlmICggdGhpcy5jbGFzc05hbWUuaW5kZXhPZiggXCJ1aS1kYXRlcGlja2VyLXByZXZcIiApICE9PSAtMSApIHtcblx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyggXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcIiApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoIFwidWktZGF0ZXBpY2tlci1uZXh0XCIgKSAhPT0gLTEgKSB7XG5cdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIgKTtcblx0XHR9XG5cdH1cbn1cblxuLyogalF1ZXJ5IGV4dGVuZCBub3cgaWdub3JlcyBudWxscyEgKi9cbmZ1bmN0aW9uIGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKCB0YXJnZXQsIHByb3BzICkge1xuXHQkLmV4dGVuZCggdGFyZ2V0LCBwcm9wcyApO1xuXHRmb3IgKCB2YXIgbmFtZSBpbiBwcm9wcyApIHtcblx0XHRpZiAoIHByb3BzWyBuYW1lIF0gPT0gbnVsbCApIHtcblx0XHRcdHRhcmdldFsgbmFtZSBdID0gcHJvcHNbIG5hbWUgXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSW52b2tlIHRoZSBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHkuXG4gICBAcGFyYW0gIG9wdGlvbnMgIHN0cmluZyAtIGEgY29tbWFuZCwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgb3Jcblx0XHRcdFx0XHRPYmplY3QgLSBzZXR0aW5ncyBmb3IgYXR0YWNoaW5nIG5ldyBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHlcbiAgIEByZXR1cm4gIGpRdWVyeSBvYmplY3QgKi9cbiQuZm4uZGF0ZXBpY2tlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8qIFZlcmlmeSBhbiBlbXB0eSBjb2xsZWN0aW9uIHdhc24ndCBwYXNzZWQgLSBGaXhlcyAjNjk3NiAqL1xuXHRpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRpZiAoICEkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgKSB7XG5cdFx0JCggZG9jdW1lbnQgKS5vbiggXCJtb3VzZWRvd25cIiwgJC5kYXRlcGlja2VyLl9jaGVja0V4dGVybmFsQ2xpY2sgKTtcblx0XHQkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHR9XG5cblx0LyogQXBwZW5kIGRhdGVwaWNrZXIgbWFpbiBjb250YWluZXIgdG8gYm9keSBpZiBub3QgZXhpc3QuICovXG5cdGlmICggJCggXCIjXCIgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCApLmxlbmd0aCA9PT0gMCApIHtcblx0XHQkKCBcImJvZHlcIiApLmFwcGVuZCggJC5kYXRlcGlja2VyLmRwRGl2ICk7XG5cdH1cblxuXHR2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICYmICggb3B0aW9ucyA9PT0gXCJpc0Rpc2FibGVkXCIgfHwgb3B0aW9ucyA9PT0gXCJnZXREYXRlXCIgfHwgb3B0aW9ucyA9PT0gXCJ3aWRnZXRcIiApICkge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbIFwiX1wiICsgb3B0aW9ucyArIFwiRGF0ZXBpY2tlclwiIF0uXG5cdFx0XHRhcHBseSggJC5kYXRlcGlja2VyLCBbIHRoaXNbIDAgXSBdLmNvbmNhdCggb3RoZXJBcmdzICkgKTtcblx0fVxuXHRpZiAoIG9wdGlvbnMgPT09IFwib3B0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWyAxIF0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlclsgXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCIgXS5cblx0XHRcdGFwcGx5KCAkLmRhdGVwaWNrZXIsIFsgdGhpc1sgMCBdIF0uY29uY2F0KCBvdGhlckFyZ3MgKSApO1xuXHR9XG5cdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRcdCQuZGF0ZXBpY2tlclsgXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCIgXS5cblx0XHRcdFx0YXBwbHkoICQuZGF0ZXBpY2tlciwgWyB0aGlzIF0uY29uY2F0KCBvdGhlckFyZ3MgKSApIDpcblx0XHRcdCQuZGF0ZXBpY2tlci5fYXR0YWNoRGF0ZXBpY2tlciggdGhpcywgb3B0aW9ucyApO1xuXHR9ICk7XG59O1xuXG4kLmRhdGVwaWNrZXIgPSBuZXcgRGF0ZXBpY2tlcigpOyAvLyBzaW5nbGV0b24gaW5zdGFuY2VcbiQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCA9IGZhbHNlO1xuJC5kYXRlcGlja2VyLnV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiQuZGF0ZXBpY2tlci52ZXJzaW9uID0gXCIxLjEyLjFcIjtcblxucmV0dXJuICQuZGF0ZXBpY2tlcjtcblxufSApICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0cy9kYXRlcGlja2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIvKiFcbiAqIGpRdWVyeSBVSSBTbGlkZXIgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNsaWRlclxuLy8+Pmdyb3VwOiBXaWRnZXRzXG4vLz4+ZGVzY3JpcHRpb246IERpc3BsYXlzIGEgZmxleGlibGUgc2xpZGVyIHdpdGggcmFuZ2VzIGFuZCBhY2Nlc3NpYmlsaXR5IHZpYSBrZXlib2FyZC5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zbGlkZXIvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vc2xpZGVyL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2Uvc2xpZGVyLmNzc1xuLy8+PmNzcy50aGVtZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGhlbWUuY3NzXG5cbiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbXG5cdFx0XHRcImpxdWVyeVwiLFxuXHRcdFx0XCIuL21vdXNlXCIsXG5cdFx0XHRcIi4uL2tleWNvZGVcIixcblx0XHRcdFwiLi4vdmVyc2lvblwiLFxuXHRcdFx0XCIuLi93aWRnZXRcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59KCBmdW5jdGlvbiggJCApIHtcblxucmV0dXJuICQud2lkZ2V0KCBcInVpLnNsaWRlclwiLCAkLnVpLm1vdXNlLCB7XG5cdHZlcnNpb246IFwiMS4xMi4xXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInNsaWRlXCIsXG5cblx0b3B0aW9uczoge1xuXHRcdGFuaW1hdGU6IGZhbHNlLFxuXHRcdGNsYXNzZXM6IHtcblx0XHRcdFwidWktc2xpZGVyXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXHRcdFx0XCJ1aS1zbGlkZXItaGFuZGxlXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXG5cdFx0XHQvLyBOb3RlOiB1aS13aWRnZXQtaGVhZGVyIGlzbid0IHRoZSBtb3N0IGZpdHRpbmdseSBzZW1hbnRpYyBmcmFtZXdvcmsgY2xhc3MgZm9yIHRoaXNcblx0XHRcdC8vIGVsZW1lbnQsIGJ1dCB3b3JrZWQgYmVzdCB2aXN1YWxseSB3aXRoIGEgdmFyaWV0eSBvZiB0aGVtZXNcblx0XHRcdFwidWktc2xpZGVyLXJhbmdlXCI6IFwidWktY29ybmVyLWFsbCB1aS13aWRnZXQtaGVhZGVyXCJcblx0XHR9LFxuXHRcdGRpc3RhbmNlOiAwLFxuXHRcdG1heDogMTAwLFxuXHRcdG1pbjogMCxcblx0XHRvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG5cdFx0cmFuZ2U6IGZhbHNlLFxuXHRcdHN0ZXA6IDEsXG5cdFx0dmFsdWU6IDAsXG5cdFx0dmFsdWVzOiBudWxsLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdHNsaWRlOiBudWxsLFxuXHRcdHN0YXJ0OiBudWxsLFxuXHRcdHN0b3A6IG51bGxcblx0fSxcblxuXHQvLyBOdW1iZXIgb2YgcGFnZXMgaW4gYSBzbGlkZXJcblx0Ly8gKGhvdyBtYW55IHRpbWVzIGNhbiB5b3UgcGFnZSB1cC9kb3duIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHJhbmdlKVxuXHRudW1QYWdlczogNSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9rZXlTbGlkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xuXHRcdHRoaXMuX2RldGVjdE9yaWVudGF0aW9uKCk7XG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cdFx0dGhpcy5fY2FsY3VsYXRlTmV3TWF4KCk7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1zbGlkZXIgdWktc2xpZGVyLVwiICsgdGhpcy5vcmllbnRhdGlvbixcblx0XHRcdFwidWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50XCIgKTtcblxuXHRcdHRoaXMuX3JlZnJlc2goKTtcblxuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0fSxcblxuXHRfcmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY3JlYXRlUmFuZ2UoKTtcblx0XHR0aGlzLl9jcmVhdGVIYW5kbGVzKCk7XG5cdFx0dGhpcy5fc2V0dXBFdmVudHMoKTtcblx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0fSxcblxuXHRfY3JlYXRlSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGksIGhhbmRsZUNvdW50LFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGV4aXN0aW5nSGFuZGxlcyA9IHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1zbGlkZXItaGFuZGxlXCIgKSxcblx0XHRcdGhhbmRsZSA9IFwiPHNwYW4gdGFiaW5kZXg9JzAnPjwvc3Bhbj5cIixcblx0XHRcdGhhbmRsZXMgPSBbXTtcblxuXHRcdGhhbmRsZUNvdW50ID0gKCBvcHRpb25zLnZhbHVlcyAmJiBvcHRpb25zLnZhbHVlcy5sZW5ndGggKSB8fCAxO1xuXG5cdFx0aWYgKCBleGlzdGluZ0hhbmRsZXMubGVuZ3RoID4gaGFuZGxlQ291bnQgKSB7XG5cdFx0XHRleGlzdGluZ0hhbmRsZXMuc2xpY2UoIGhhbmRsZUNvdW50ICkucmVtb3ZlKCk7XG5cdFx0XHRleGlzdGluZ0hhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuc2xpY2UoIDAsIGhhbmRsZUNvdW50ICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IGV4aXN0aW5nSGFuZGxlcy5sZW5ndGg7IGkgPCBoYW5kbGVDb3VudDsgaSsrICkge1xuXHRcdFx0aGFuZGxlcy5wdXNoKCBoYW5kbGUgKTtcblx0XHR9XG5cblx0XHR0aGlzLmhhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuYWRkKCAkKCBoYW5kbGVzLmpvaW4oIFwiXCIgKSApLmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKSApO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaGFuZGxlcywgXCJ1aS1zbGlkZXItaGFuZGxlXCIsIFwidWktc3RhdGUtZGVmYXVsdFwiICk7XG5cblx0XHR0aGlzLmhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSggMCApO1xuXG5cdFx0dGhpcy5oYW5kbGVzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0JCggdGhpcyApXG5cdFx0XHRcdC5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiwgaSApXG5cdFx0XHRcdC5hdHRyKCBcInRhYkluZGV4XCIsIDAgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0X2NyZWF0ZVJhbmdlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICggb3B0aW9ucy5yYW5nZSApIHtcblx0XHRcdGlmICggb3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy52YWx1ZXMgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBbIHRoaXMuX3ZhbHVlTWluKCksIHRoaXMuX3ZhbHVlTWluKCkgXTtcblx0XHRcdFx0fSBlbHNlIGlmICggb3B0aW9ucy52YWx1ZXMubGVuZ3RoICYmIG9wdGlvbnMudmFsdWVzLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0XHRvcHRpb25zLnZhbHVlcyA9IFsgb3B0aW9ucy52YWx1ZXNbIDAgXSwgb3B0aW9ucy52YWx1ZXNbIDAgXSBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAkLmlzQXJyYXkoIG9wdGlvbnMudmFsdWVzICkgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcy5zbGljZSggMCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXRoaXMucmFuZ2UgfHwgIXRoaXMucmFuZ2UubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlID0gJCggXCI8ZGl2PlwiIClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnJhbmdlLCBcInVpLXNsaWRlci1yYW5nZVwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5yYW5nZSwgXCJ1aS1zbGlkZXItcmFuZ2UtbWluIHVpLXNsaWRlci1yYW5nZS1tYXhcIiApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSByYW5nZSBzd2l0Y2hpbmcgZnJvbSB0cnVlIHRvIG1pbi9tYXhcblx0XHRcdFx0dGhpcy5yYW5nZS5jc3MoIHtcblx0XHRcdFx0XHRcImxlZnRcIjogXCJcIixcblx0XHRcdFx0XHRcImJvdHRvbVwiOiBcIlwiXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy5yYW5nZSA9PT0gXCJtaW5cIiB8fCBvcHRpb25zLnJhbmdlID09PSBcIm1heFwiICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5yYW5nZSwgXCJ1aS1zbGlkZXItcmFuZ2UtXCIgKyBvcHRpb25zLnJhbmdlICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdGhpcy5yYW5nZSApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmFuZ2UgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX29mZiggdGhpcy5oYW5kbGVzICk7XG5cdFx0dGhpcy5fb24oIHRoaXMuaGFuZGxlcywgdGhpcy5faGFuZGxlRXZlbnRzICk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCB0aGlzLmhhbmRsZXMgKTtcblx0XHR0aGlzLl9mb2N1c2FibGUoIHRoaXMuaGFuZGxlcyApO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhhbmRsZXMucmVtb3ZlKCk7XG5cdFx0aWYgKCB0aGlzLnJhbmdlICkge1xuXHRcdFx0dGhpcy5yYW5nZS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHBvc2l0aW9uLCBub3JtVmFsdWUsIGRpc3RhbmNlLCBjbG9zZXN0SGFuZGxlLCBpbmRleCwgYWxsb3dlZCwgb2Zmc2V0LCBtb3VzZU92ZXJIYW5kbGUsXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoIG8uZGlzYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50U2l6ZSA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdFx0dGhpcy5lbGVtZW50T2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXG5cdFx0cG9zaXRpb24gPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9O1xuXHRcdG5vcm1WYWx1ZSA9IHRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZSggcG9zaXRpb24gKTtcblx0XHRkaXN0YW5jZSA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICsgMTtcblx0XHR0aGlzLmhhbmRsZXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdGhpc0Rpc3RhbmNlID0gTWF0aC5hYnMoIG5vcm1WYWx1ZSAtIHRoYXQudmFsdWVzKCBpICkgKTtcblx0XHRcdGlmICggKCBkaXN0YW5jZSA+IHRoaXNEaXN0YW5jZSApIHx8XG5cdFx0XHRcdCggZGlzdGFuY2UgPT09IHRoaXNEaXN0YW5jZSAmJlxuXHRcdFx0XHRcdCggaSA9PT0gdGhhdC5fbGFzdENoYW5nZWRWYWx1ZSB8fCB0aGF0LnZhbHVlcyggaSApID09PSBvLm1pbiApICkgKSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gdGhpc0Rpc3RhbmNlO1xuXHRcdFx0XHRjbG9zZXN0SGFuZGxlID0gJCggdGhpcyApO1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0YWxsb3dlZCA9IHRoaXMuX3N0YXJ0KCBldmVudCwgaW5kZXggKTtcblx0XHRpZiAoIGFsbG93ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLl9tb3VzZVNsaWRpbmcgPSB0cnVlO1xuXG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBpbmRleDtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCBjbG9zZXN0SGFuZGxlLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0Y2xvc2VzdEhhbmRsZS50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblxuXHRcdG9mZnNldCA9IGNsb3Nlc3RIYW5kbGUub2Zmc2V0KCk7XG5cdFx0bW91c2VPdmVySGFuZGxlID0gISQoIGV2ZW50LnRhcmdldCApLnBhcmVudHMoKS5hZGRCYWNrKCkuaXMoIFwiLnVpLXNsaWRlci1oYW5kbGVcIiApO1xuXHRcdHRoaXMuX2NsaWNrT2Zmc2V0ID0gbW91c2VPdmVySGFuZGxlID8geyBsZWZ0OiAwLCB0b3A6IDAgfSA6IHtcblx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gb2Zmc2V0LmxlZnQgLSAoIGNsb3Nlc3RIYW5kbGUud2lkdGgoKSAvIDIgKSxcblx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSBvZmZzZXQudG9wIC1cblx0XHRcdFx0KCBjbG9zZXN0SGFuZGxlLmhlaWdodCgpIC8gMiApIC1cblx0XHRcdFx0KCBwYXJzZUludCggY2xvc2VzdEhhbmRsZS5jc3MoIFwiYm9yZGVyVG9wV2lkdGhcIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKCBcImJvcmRlckJvdHRvbVdpZHRoXCIgKSwgMTAgKSB8fCAwICkgK1xuXHRcdFx0XHQoIHBhcnNlSW50KCBjbG9zZXN0SGFuZGxlLmNzcyggXCJtYXJnaW5Ub3BcIiApLCAxMCApIHx8IDAgKVxuXHRcdH07XG5cblx0XHRpZiAoICF0aGlzLmhhbmRsZXMuaGFzQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApICkge1xuXHRcdFx0dGhpcy5fc2xpZGUoIGV2ZW50LCBpbmRleCwgbm9ybVZhbHVlICk7XG5cdFx0fVxuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfSxcblx0XHRcdG5vcm1WYWx1ZSA9IHRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZSggcG9zaXRpb24gKTtcblxuXHRcdHRoaXMuX3NsaWRlKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXgsIG5vcm1WYWx1ZSApO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5oYW5kbGVzLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9zdG9wKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXggKTtcblx0XHR0aGlzLl9jaGFuZ2UoIGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCApO1xuXG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xuXHRcdHRoaXMuX2NsaWNrT2Zmc2V0ID0gbnVsbDtcblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X2RldGVjdE9yaWVudGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm9yaWVudGF0aW9uID0gKCB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCI7XG5cdH0sXG5cblx0X25vcm1WYWx1ZUZyb21Nb3VzZTogZnVuY3Rpb24oIHBvc2l0aW9uICkge1xuXHRcdHZhciBwaXhlbFRvdGFsLFxuXHRcdFx0cGl4ZWxNb3VzZSxcblx0XHRcdHBlcmNlbnRNb3VzZSxcblx0XHRcdHZhbHVlVG90YWwsXG5cdFx0XHR2YWx1ZU1vdXNlO1xuXG5cdFx0aWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdHBpeGVsVG90YWwgPSB0aGlzLmVsZW1lbnRTaXplLndpZHRoO1xuXHRcdFx0cGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnggLSB0aGlzLmVsZW1lbnRPZmZzZXQubGVmdCAtXG5cdFx0XHRcdCggdGhpcy5fY2xpY2tPZmZzZXQgPyB0aGlzLl9jbGlja09mZnNldC5sZWZ0IDogMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwaXhlbFRvdGFsID0gdGhpcy5lbGVtZW50U2l6ZS5oZWlnaHQ7XG5cdFx0XHRwaXhlbE1vdXNlID0gcG9zaXRpb24ueSAtIHRoaXMuZWxlbWVudE9mZnNldC50b3AgLVxuXHRcdFx0XHQoIHRoaXMuX2NsaWNrT2Zmc2V0ID8gdGhpcy5fY2xpY2tPZmZzZXQudG9wIDogMCApO1xuXHRcdH1cblxuXHRcdHBlcmNlbnRNb3VzZSA9ICggcGl4ZWxNb3VzZSAvIHBpeGVsVG90YWwgKTtcblx0XHRpZiAoIHBlcmNlbnRNb3VzZSA+IDEgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAxO1xuXHRcdH1cblx0XHRpZiAoIHBlcmNlbnRNb3VzZSA8IDAgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAwO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdHBlcmNlbnRNb3VzZSA9IDEgLSBwZXJjZW50TW91c2U7XG5cdFx0fVxuXG5cdFx0dmFsdWVUb3RhbCA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdHZhbHVlTW91c2UgPSB0aGlzLl92YWx1ZU1pbigpICsgcGVyY2VudE1vdXNlICogdmFsdWVUb3RhbDtcblxuXHRcdHJldHVybiB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsdWVNb3VzZSApO1xuXHR9LFxuXG5cdF91aUhhc2g6IGZ1bmN0aW9uKCBpbmRleCwgdmFsdWUsIHZhbHVlcyApIHtcblx0XHR2YXIgdWlIYXNoID0ge1xuXHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHRoYW5kbGVJbmRleDogaW5kZXgsXG5cdFx0XHR2YWx1ZTogdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogdGhpcy52YWx1ZSgpXG5cdFx0fTtcblxuXHRcdGlmICggdGhpcy5faGFzTXVsdGlwbGVWYWx1ZXMoKSApIHtcblx0XHRcdHVpSGFzaC52YWx1ZSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0dWlIYXNoLnZhbHVlcyA9IHZhbHVlcyB8fCB0aGlzLnZhbHVlcygpO1xuXHRcdH1cblxuXHRcdHJldHVybiB1aUhhc2g7XG5cdH0sXG5cblx0X2hhc011bHRpcGxlVmFsdWVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aDtcblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggaW5kZXggKSApO1xuXHR9LFxuXG5cdF9zbGlkZTogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCwgbmV3VmFsICkge1xuXHRcdHZhciBhbGxvd2VkLCBvdGhlclZhbCxcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWUoKSxcblx0XHRcdG5ld1ZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cblx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHRvdGhlclZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCA/IDAgOiAxICk7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSB7XG5cdFx0XHRcdG5ld1ZhbCA9ICBpbmRleCA9PT0gMCA/IE1hdGgubWluKCBvdGhlclZhbCwgbmV3VmFsICkgOiBNYXRoLm1heCggb3RoZXJWYWwsIG5ld1ZhbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXdWYWx1ZXNbIGluZGV4IF0gPSBuZXdWYWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdWYWwgPT09IGN1cnJlbnRWYWx1ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRhbGxvd2VkID0gdGhpcy5fdHJpZ2dlciggXCJzbGlkZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCBpbmRleCwgbmV3VmFsLCBuZXdWYWx1ZXMgKSApO1xuXG5cdFx0Ly8gQSBzbGlkZSBjYW4gYmUgY2FuY2VsZWQgYnkgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlIHNsaWRlIGNhbGxiYWNrXG5cdFx0aWYgKCBhbGxvd2VkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHR0aGlzLnZhbHVlcyggaW5kZXgsIG5ld1ZhbCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnZhbHVlKCBuZXdWYWwgKTtcblx0XHR9XG5cdH0sXG5cblx0X3N0b3A6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzdG9wXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIGluZGV4ICkgKTtcblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdGlmICggIXRoaXMuX2tleVNsaWRpbmcgJiYgIXRoaXMuX21vdXNlU2xpZGluZyApIHtcblxuXHRcdFx0Ly9zdG9yZSB0aGUgbGFzdCBjaGFuZ2VkIHZhbHVlIGluZGV4IGZvciByZWZlcmVuY2Ugd2hlbiBoYW5kbGVzIG92ZXJsYXBcblx0XHRcdHRoaXMuX2xhc3RDaGFuZ2VkVmFsdWUgPSBpbmRleDtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIGluZGV4ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0dmFsdWU6IGZ1bmN0aW9uKCBuZXdWYWx1ZSApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggbmV3VmFsdWUgKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCAwICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlKCk7XG5cdH0sXG5cblx0dmFsdWVzOiBmdW5jdGlvbiggaW5kZXgsIG5ld1ZhbHVlICkge1xuXHRcdHZhciB2YWxzLFxuXHRcdFx0bmV3VmFsdWVzLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWVzWyBpbmRleCBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlICk7XG5cdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaW5kZXggKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoICQuaXNBcnJheSggYXJndW1lbnRzWyAwIF0gKSApIHtcblx0XHRcdFx0dmFscyA9IHRoaXMub3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdG5ld1ZhbHVlcyA9IGFyZ3VtZW50c1sgMCBdO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dmFsc1sgaSBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlc1sgaSBdICk7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlcyggaW5kZXggKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZXMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHR2YWxzTGVuZ3RoID0gMDtcblxuXHRcdGlmICgga2V5ID09PSBcInJhbmdlXCIgJiYgdGhpcy5vcHRpb25zLnJhbmdlID09PSB0cnVlICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJtaW5cIiApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdmFsdWVzKCAwICk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IFwibWF4XCIgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX3ZhbHVlcyggdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggLSAxICk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZXMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggJC5pc0FycmF5KCB0aGlzLm9wdGlvbnMudmFsdWVzICkgKSB7XG5cdFx0XHR2YWxzTGVuZ3RoID0gdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdHN3aXRjaCAoIGtleSApIHtcblx0XHRcdGNhc2UgXCJvcmllbnRhdGlvblwiOlxuXHRcdFx0XHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggXCJ1aS1zbGlkZXItaG9yaXpvbnRhbCB1aS1zbGlkZXItdmVydGljYWxcIiApXG5cdFx0XHRcdFx0Ll9hZGRDbGFzcyggXCJ1aS1zbGlkZXItXCIgKyB0aGlzLm9yaWVudGF0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yYW5nZSApIHtcblx0XHRcdFx0XHR0aGlzLl9yZWZyZXNoUmFuZ2UoIHZhbHVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbmluZyBmcm9tIHByZXZpb3VzIG9yaWVudGF0aW9uXG5cdFx0XHRcdHRoaXMuaGFuZGxlcy5jc3MoIHZhbHVlID09PSBcImhvcml6b250YWxcIiA/IFwiYm90dG9tXCIgOiBcImxlZnRcIiwgXCJcIiApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ2YWx1ZVwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgMCApO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInZhbHVlc1wiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cblx0XHRcdFx0Ly8gU3RhcnQgZnJvbSB0aGUgbGFzdCBoYW5kbGUgdG8gcHJldmVudCB1bnJlYWNoYWJsZSBoYW5kbGVzICgjOTA0Nilcblx0XHRcdFx0Zm9yICggaSA9IHZhbHNMZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInN0ZXBcIjpcblx0XHRcdGNhc2UgXCJtaW5cIjpcblx0XHRcdGNhc2UgXCJtYXhcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX2NhbGN1bGF0ZU5ld01heCgpO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJyYW5nZVwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uRGlzYWJsZWQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlciggdmFsdWUgKTtcblxuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKTtcblx0fSxcblxuXHQvL2ludGVybmFsIHZhbHVlIGdldHRlclxuXHQvLyBfdmFsdWUoKSByZXR1cm5zIHZhbHVlIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHRfdmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWwgPSB0aGlzLm9wdGlvbnMudmFsdWU7XG5cdFx0dmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbCApO1xuXG5cdFx0cmV0dXJuIHZhbDtcblx0fSxcblxuXHQvL2ludGVybmFsIHZhbHVlcyBnZXR0ZXJcblx0Ly8gX3ZhbHVlcygpIHJldHVybnMgYXJyYXkgb2YgdmFsdWVzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHQvLyBfdmFsdWVzKCBpbmRleCApIHJldHVybnMgc2luZ2xlIHZhbHVlIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHRfdmFsdWVzOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIHZhbCxcblx0XHRcdHZhbHMsXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dmFsID0gdGhpcy5vcHRpb25zLnZhbHVlc1sgaW5kZXggXTtcblx0XHRcdHZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWwgKTtcblxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLl9oYXNNdWx0aXBsZVZhbHVlcygpICkge1xuXG5cdFx0XHQvLyAuc2xpY2UoKSBjcmVhdGVzIGEgY29weSBvZiB0aGUgYXJyYXlcblx0XHRcdC8vIHRoaXMgY29weSBnZXRzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXggYW5kIHRoZW4gcmV0dXJuZWRcblx0XHRcdHZhbHMgPSB0aGlzLm9wdGlvbnMudmFsdWVzLnNsaWNlKCk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdHZhbHNbIGkgXSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWxzWyBpIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgc3RlcC1hbGlnbmVkIHZhbHVlIHRoYXQgdmFsIGlzIGNsb3Nlc3QgdG8sIGJldHdlZW4gKGluY2x1c2l2ZSkgbWluIGFuZCBtYXhcblx0X3RyaW1BbGlnblZhbHVlOiBmdW5jdGlvbiggdmFsICkge1xuXHRcdGlmICggdmFsIDw9IHRoaXMuX3ZhbHVlTWluKCkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHR9XG5cdFx0aWYgKCB2YWwgPj0gdGhpcy5fdmFsdWVNYXgoKSApIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZU1heCgpO1xuXHRcdH1cblx0XHR2YXIgc3RlcCA9ICggdGhpcy5vcHRpb25zLnN0ZXAgPiAwICkgPyB0aGlzLm9wdGlvbnMuc3RlcCA6IDEsXG5cdFx0XHR2YWxNb2RTdGVwID0gKCB2YWwgLSB0aGlzLl92YWx1ZU1pbigpICkgJSBzdGVwLFxuXHRcdFx0YWxpZ25WYWx1ZSA9IHZhbCAtIHZhbE1vZFN0ZXA7XG5cblx0XHRpZiAoIE1hdGguYWJzKCB2YWxNb2RTdGVwICkgKiAyID49IHN0ZXAgKSB7XG5cdFx0XHRhbGlnblZhbHVlICs9ICggdmFsTW9kU3RlcCA+IDAgKSA/IHN0ZXAgOiAoIC1zdGVwICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2luY2UgSmF2YVNjcmlwdCBoYXMgcHJvYmxlbXMgd2l0aCBsYXJnZSBmbG9hdHMsIHJvdW5kXG5cdFx0Ly8gdGhlIGZpbmFsIHZhbHVlIHRvIDUgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IChzZWUgIzQxMjQpXG5cdFx0cmV0dXJuIHBhcnNlRmxvYXQoIGFsaWduVmFsdWUudG9GaXhlZCggNSApICk7XG5cdH0sXG5cblx0X2NhbGN1bGF0ZU5ld01heDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1heCA9IHRoaXMub3B0aW9ucy5tYXgsXG5cdFx0XHRtaW4gPSB0aGlzLl92YWx1ZU1pbigpLFxuXHRcdFx0c3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwLFxuXHRcdFx0YWJvdmVNaW4gPSBNYXRoLnJvdW5kKCAoIG1heCAtIG1pbiApIC8gc3RlcCApICogc3RlcDtcblx0XHRtYXggPSBhYm92ZU1pbiArIG1pbjtcblx0XHRpZiAoIG1heCA+IHRoaXMub3B0aW9ucy5tYXggKSB7XG5cblx0XHRcdC8vSWYgbWF4IGlzIG5vdCBkaXZpc2libGUgYnkgc3RlcCwgcm91bmRpbmcgb2ZmIG1heSBpbmNyZWFzZSBpdHMgdmFsdWVcblx0XHRcdG1heCAtPSBzdGVwO1xuXHRcdH1cblx0XHR0aGlzLm1heCA9IHBhcnNlRmxvYXQoIG1heC50b0ZpeGVkKCB0aGlzLl9wcmVjaXNpb24oKSApICk7XG5cdH0sXG5cblx0X3ByZWNpc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMuc3RlcCApO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLm1pbiAhPT0gbnVsbCApIHtcblx0XHRcdHByZWNpc2lvbiA9IE1hdGgubWF4KCBwcmVjaXNpb24sIHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMubWluICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWNpc2lvbjtcblx0fSxcblxuXHRfcHJlY2lzaW9uT2Y6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0dmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxuXHRcdFx0ZGVjaW1hbCA9IHN0ci5pbmRleE9mKCBcIi5cIiApO1xuXHRcdHJldHVybiBkZWNpbWFsID09PSAtMSA/IDAgOiBzdHIubGVuZ3RoIC0gZGVjaW1hbCAtIDE7XG5cdH0sXG5cblx0X3ZhbHVlTWluOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pbjtcblx0fSxcblxuXHRfdmFsdWVNYXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1heDtcblx0fSxcblxuXHRfcmVmcmVzaFJhbmdlOiBmdW5jdGlvbiggb3JpZW50YXRpb24gKSB7XG5cdFx0aWYgKCBvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0dGhpcy5yYW5nZS5jc3MoIHsgXCJ3aWR0aFwiOiBcIlwiLCBcImxlZnRcIjogXCJcIiB9ICk7XG5cdFx0fVxuXHRcdGlmICggb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0dGhpcy5yYW5nZS5jc3MoIHsgXCJoZWlnaHRcIjogXCJcIiwgXCJib3R0b21cIjogXCJcIiB9ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZWZyZXNoVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0VmFsUGVyY2VudCwgdmFsUGVyY2VudCwgdmFsdWUsIHZhbHVlTWluLCB2YWx1ZU1heCxcblx0XHRcdG9SYW5nZSA9IHRoaXMub3B0aW9ucy5yYW5nZSxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdGFuaW1hdGUgPSAoICF0aGlzLl9hbmltYXRlT2ZmICkgPyBvLmFuaW1hdGUgOiBmYWxzZSxcblx0XHRcdF9zZXQgPSB7fTtcblxuXHRcdGlmICggdGhpcy5faGFzTXVsdGlwbGVWYWx1ZXMoKSApIHtcblx0XHRcdHRoaXMuaGFuZGxlcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0dmFsUGVyY2VudCA9ICggdGhhdC52YWx1ZXMoIGkgKSAtIHRoYXQuX3ZhbHVlTWluKCkgKSAvICggdGhhdC5fdmFsdWVNYXgoKSAtXG5cdFx0XHRcdFx0dGhhdC5fdmFsdWVNaW4oKSApICogMTAwO1xuXHRcdFx0XHRfc2V0WyB0aGF0Lm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwibGVmdFwiIDogXCJib3R0b21cIiBdID0gdmFsUGVyY2VudCArIFwiJVwiO1xuXHRcdFx0XHQkKCB0aGlzICkuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIF9zZXQsIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRpZiAoIHRoYXQub3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoYXQub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0XHRcdFx0bGVmdDogdmFsUGVyY2VudCArIFwiJVwiXG5cdFx0XHRcdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogKCB2YWxQZXJjZW50IC0gbGFzdFZhbFBlcmNlbnQgKSArIFwiJVwiXG5cdFx0XHRcdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRcdFx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IG8uYW5pbWF0ZVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSgge1xuXHRcdFx0XHRcdFx0XHRcdGJvdHRvbTogKCB2YWxQZXJjZW50ICkgKyBcIiVcIlxuXHRcdFx0XHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAoIHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCApICsgXCIlXCJcblx0XHRcdFx0XHRcdFx0fSwge1xuXHRcdFx0XHRcdFx0XHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogby5hbmltYXRlXG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdFZhbFBlcmNlbnQgPSB2YWxQZXJjZW50O1xuXHRcdFx0fSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmFsdWUoKTtcblx0XHRcdHZhbHVlTWluID0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHRcdHZhbHVlTWF4ID0gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHRcdHZhbFBlcmNlbnQgPSAoIHZhbHVlTWF4ICE9PSB2YWx1ZU1pbiApID9cblx0XHRcdFx0XHQoIHZhbHVlIC0gdmFsdWVNaW4gKSAvICggdmFsdWVNYXggLSB2YWx1ZU1pbiApICogMTAwIDpcblx0XHRcdFx0XHQwO1xuXHRcdFx0X3NldFsgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImxlZnRcIiA6IFwiYm90dG9tXCIgXSA9IHZhbFBlcmNlbnQgKyBcIiVcIjtcblx0XHRcdHRoaXMuaGFuZGxlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCBfc2V0LCBvLmFuaW1hdGUgKTtcblxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWluXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHR3aWR0aDogdmFsUGVyY2VudCArIFwiJVwiXG5cdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWF4XCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHR3aWR0aDogKCAxMDAgLSB2YWxQZXJjZW50ICkgKyBcIiVcIlxuXHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1pblwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSgge1xuXHRcdFx0XHRcdGhlaWdodDogdmFsUGVyY2VudCArIFwiJVwiXG5cdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWF4XCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0aGVpZ2h0OiAoIDEwMCAtIHZhbFBlcmNlbnQgKSArIFwiJVwiXG5cdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlRXZlbnRzOiB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGFsbG93ZWQsIGN1clZhbCwgbmV3VmFsLCBzdGVwLFxuXHRcdFx0XHRpbmRleCA9ICQoIGV2ZW50LnRhcmdldCApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiICk7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRpZiAoICF0aGlzLl9rZXlTbGlkaW5nICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQudGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0XHRcdGFsbG93ZWQgPSB0aGlzLl9zdGFydCggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGFsbG93ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXA7XG5cdFx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHRcdGN1clZhbCA9IG5ld1ZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VyVmFsID0gbmV3VmFsID0gdGhpcy52YWx1ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl92YWx1ZU1heCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKFxuXHRcdFx0XHRcdFx0Y3VyVmFsICsgKCAoIHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICkgLyB0aGlzLm51bVBhZ2VzIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoXG5cdFx0XHRcdFx0XHRjdXJWYWwgLSAoICggdGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkgKSAvIHRoaXMubnVtUGFnZXMgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWwgPT09IHRoaXMuX3ZhbHVlTWF4KCkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBjdXJWYWwgKyBzdGVwICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWwgPT09IHRoaXMuX3ZhbHVlTWluKCkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBjdXJWYWwgLSBzdGVwICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NsaWRlKCBldmVudCwgaW5kZXgsIG5ld1ZhbCApO1xuXHRcdH0sXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBpbmRleCA9ICQoIGV2ZW50LnRhcmdldCApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiICk7XG5cblx0XHRcdGlmICggdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9zdG9wKCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LnRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbn0gKSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3dpZGdldHMvc2xpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIvKiFcbiAqIGpRdWVyeSBVSSBNb3VzZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogTW91c2Vcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBBYnN0cmFjdHMgbW91c2UtYmFzZWQgaW50ZXJhY3Rpb25zIHRvIGFzc2lzdCBpbiBjcmVhdGluZyBjZXJ0YWluIHdpZGdldHMuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vbW91c2UvXG5cbiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbXG5cdFx0XHRcImpxdWVyeVwiLFxuXHRcdFx0XCIuLi9pZVwiLFxuXHRcdFx0XCIuLi92ZXJzaW9uXCIsXG5cdFx0XHRcIi4uL3dpZGdldFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oIGZ1bmN0aW9uKCAkICkge1xuXG52YXIgbW91c2VIYW5kbGVkID0gZmFsc2U7XG4kKCBkb2N1bWVudCApLm9uKCBcIm1vdXNldXBcIiwgZnVuY3Rpb24oKSB7XG5cdG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xufSApO1xuXG5yZXR1cm4gJC53aWRnZXQoIFwidWkubW91c2VcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTIuMVwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y2FuY2VsOiBcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3QsIG9wdGlvblwiLFxuXHRcdGRpc3RhbmNlOiAxLFxuXHRcdGRlbGF5OiAwXG5cdH0sXG5cdF9tb3VzZUluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0Lm9uKCBcIm1vdXNlZG93bi5cIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VEb3duKCBldmVudCApO1xuXHRcdFx0fSApXG5cdFx0XHQub24oIFwiY2xpY2suXCIgKyB0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCB0cnVlID09PSAkLmRhdGEoIGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiApICkge1xuXHRcdFx0XHRcdCQucmVtb3ZlRGF0YSggZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiICk7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHR0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUT0RPOiBtYWtlIHN1cmUgZGVzdHJveWluZyBvbmUgaW5zdGFuY2Ugb2YgbW91c2UgZG9lc24ndCBtZXNzIHdpdGhcblx0Ly8gb3RoZXIgaW5zdGFuY2VzIG9mIG1vdXNlXG5cdF9tb3VzZURlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5vZmYoIFwiLlwiICsgdGhpcy53aWRnZXROYW1lICk7XG5cdFx0aWYgKCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApIHtcblx0XHRcdHRoaXMuZG9jdW1lbnRcblx0XHRcdFx0Lm9mZiggXCJtb3VzZW1vdmUuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlIClcblx0XHRcdFx0Lm9mZiggXCJtb3VzZXVwLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUgKTtcblx0XHR9XG5cdH0sXG5cblx0X21vdXNlRG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gZG9uJ3QgbGV0IG1vcmUgdGhhbiBvbmUgd2lkZ2V0IGhhbmRsZSBtb3VzZVN0YXJ0XG5cdFx0aWYgKCBtb3VzZUhhbmRsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW91c2VNb3ZlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gV2UgbWF5IGhhdmUgbWlzc2VkIG1vdXNldXAgKG91dCBvZiB3aW5kb3cpXG5cdFx0KCB0aGlzLl9tb3VzZVN0YXJ0ZWQgJiYgdGhpcy5fbW91c2VVcCggZXZlbnQgKSApO1xuXG5cdFx0dGhpcy5fbW91c2VEb3duRXZlbnQgPSBldmVudDtcblxuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGJ0bklzTGVmdCA9ICggZXZlbnQud2hpY2ggPT09IDEgKSxcblxuXHRcdFx0Ly8gZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBJRSA4IHdpdGhcblx0XHRcdC8vIGRpc2FibGVkIGlucHV0cyAoIzc2MjApXG5cdFx0XHRlbElzQ2FuY2VsID0gKCB0eXBlb2YgdGhpcy5vcHRpb25zLmNhbmNlbCA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgP1xuXHRcdFx0XHQkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCB0aGlzLm9wdGlvbnMuY2FuY2VsICkubGVuZ3RoIDogZmFsc2UgKTtcblx0XHRpZiAoICFidG5Jc0xlZnQgfHwgZWxJc0NhbmNlbCB8fCAhdGhpcy5fbW91c2VDYXB0dXJlKCBldmVudCApICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb3VzZURlbGF5TWV0ID0gIXRoaXMub3B0aW9ucy5kZWxheTtcblx0XHRpZiAoICF0aGlzLm1vdXNlRGVsYXlNZXQgKSB7XG5cdFx0XHR0aGlzLl9tb3VzZURlbGF5VGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5tb3VzZURlbGF5TWV0ID0gdHJ1ZTtcblx0XHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fbW91c2VEaXN0YW5jZU1ldCggZXZlbnQgKSAmJiB0aGlzLl9tb3VzZURlbGF5TWV0KCBldmVudCApICkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID0gKCB0aGlzLl9tb3VzZVN0YXJ0KCBldmVudCApICE9PSBmYWxzZSApO1xuXHRcdFx0aWYgKCAhdGhpcy5fbW91c2VTdGFydGVkICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDbGljayBldmVudCBtYXkgbmV2ZXIgaGF2ZSBmaXJlZCAoR2Vja28gJiBPcGVyYSlcblx0XHRpZiAoIHRydWUgPT09ICQuZGF0YSggZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiICkgKSB7XG5cdFx0XHQkLnJlbW92ZURhdGEoIGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFRoZXNlIGRlbGVnYXRlcyBhcmUgcmVxdWlyZWQgdG8ga2VlcCBjb250ZXh0XG5cdFx0dGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VNb3ZlKCBldmVudCApO1xuXHRcdH07XG5cdFx0dGhpcy5fbW91c2VVcERlbGVnYXRlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlVXAoIGV2ZW50ICk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZG9jdW1lbnRcblx0XHRcdC5vbiggXCJtb3VzZW1vdmUuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlIClcblx0XHRcdC5vbiggXCJtb3VzZXVwLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUgKTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRtb3VzZUhhbmRsZWQgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZU1vdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE9ubHkgY2hlY2sgZm9yIG1vdXNldXBzIG91dHNpZGUgdGhlIGRvY3VtZW50IGlmIHlvdSd2ZSBtb3ZlZCBpbnNpZGUgdGhlIGRvY3VtZW50XG5cdFx0Ly8gYXQgbGVhc3Qgb25jZS4gVGhpcyBwcmV2ZW50cyB0aGUgZmlyaW5nIG9mIG1vdXNldXAgaW4gdGhlIGNhc2Ugb2YgSUU8OSwgd2hpY2ggd2lsbFxuXHRcdC8vIGZpcmUgYSBtb3VzZW1vdmUgZXZlbnQgaWYgY29udGVudCBpcyBwbGFjZWQgdW5kZXIgdGhlIGN1cnNvci4gU2VlICM3Nzc4XG5cdFx0Ly8gU3VwcG9ydDogSUUgPDlcblx0XHRpZiAoIHRoaXMuX21vdXNlTW92ZWQgKSB7XG5cblx0XHRcdC8vIElFIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIGhhcHBlbmVkIHdoZW4gbW91c2Ugd2FzIG91dCBvZiB3aW5kb3dcblx0XHRcdGlmICggJC51aS5pZSAmJiAoICFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgOSApICYmXG5cdFx0XHRcdFx0IWV2ZW50LmJ1dHRvbiApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoIGV2ZW50ICk7XG5cblx0XHRcdC8vIElmcmFtZSBtb3VzZXVwIGNoZWNrIC0gbW91c2V1cCBvY2N1cnJlZCBpbiBhbm90aGVyIGRvY3VtZW50XG5cdFx0XHR9IGVsc2UgaWYgKCAhZXZlbnQud2hpY2ggKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9OCAtIDlcblx0XHRcdFx0Ly8gU2FmYXJpIHNldHMgd2hpY2ggdG8gMCBpZiB5b3UgcHJlc3MgYW55IG9mIHRoZSBmb2xsb3dpbmcga2V5c1xuXHRcdFx0XHQvLyBkdXJpbmcgYSBkcmFnICgjMTQ0NjEpXG5cdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5jdHJsS2V5IHx8XG5cdFx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5zaGlmdEtleSApIHtcblx0XHRcdFx0XHR0aGlzLmlnbm9yZU1pc3NpbmdXaGljaCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoICF0aGlzLmlnbm9yZU1pc3NpbmdXaGljaCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fbW91c2VVcCggZXZlbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZXZlbnQud2hpY2ggfHwgZXZlbnQuYnV0dG9uICkge1xuXHRcdFx0dGhpcy5fbW91c2VNb3ZlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9tb3VzZVN0YXJ0ZWQgKSB7XG5cdFx0XHR0aGlzLl9tb3VzZURyYWcoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoIGV2ZW50ICkgJiYgdGhpcy5fbW91c2VEZWxheU1ldCggZXZlbnQgKSApIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9XG5cdFx0XHRcdCggdGhpcy5fbW91c2VTdGFydCggdGhpcy5fbW91c2VEb3duRXZlbnQsIGV2ZW50ICkgIT09IGZhbHNlICk7XG5cdFx0XHQoIHRoaXMuX21vdXNlU3RhcnRlZCA/IHRoaXMuX21vdXNlRHJhZyggZXZlbnQgKSA6IHRoaXMuX21vdXNlVXAoIGV2ZW50ICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIXRoaXMuX21vdXNlU3RhcnRlZDtcblx0fSxcblxuXHRfbW91c2VVcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuZG9jdW1lbnRcblx0XHRcdC5vZmYoIFwibW91c2Vtb3ZlLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApXG5cdFx0XHQub2ZmKCBcIm1vdXNldXAuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSApO1xuXG5cdFx0aWYgKCB0aGlzLl9tb3VzZVN0YXJ0ZWQgKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IHRoaXMuX21vdXNlRG93bkV2ZW50LnRhcmdldCApIHtcblx0XHRcdFx0JC5kYXRhKCBldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbW91c2VTdG9wKCBldmVudCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fbW91c2VEZWxheVRpbWVyICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl9tb3VzZURlbGF5VGltZXIgKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tb3VzZURlbGF5VGltZXI7XG5cdFx0fVxuXG5cdFx0dGhpcy5pZ25vcmVNaXNzaW5nV2hpY2ggPSBmYWxzZTtcblx0XHRtb3VzZUhhbmRsZWQgPSBmYWxzZTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdF9tb3VzZURpc3RhbmNlTWV0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0cmV0dXJuICggTWF0aC5tYXgoXG5cdFx0XHRcdE1hdGguYWJzKCB0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWCAtIGV2ZW50LnBhZ2VYICksXG5cdFx0XHRcdE1hdGguYWJzKCB0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWSAtIGV2ZW50LnBhZ2VZIClcblx0XHRcdCkgPj0gdGhpcy5vcHRpb25zLmRpc3RhbmNlXG5cdFx0KTtcblx0fSxcblxuXHRfbW91c2VEZWxheU1ldDogZnVuY3Rpb24oIC8qIGV2ZW50ICovICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlRGVsYXlNZXQ7XG5cdH0sXG5cblx0Ly8gVGhlc2UgYXJlIHBsYWNlaG9sZGVyIG1ldGhvZHMsIHRvIGJlIG92ZXJyaWRlbiBieSBleHRlbmRpbmcgcGx1Z2luXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbiggLyogZXZlbnQgKi8gKSB7fSxcblx0X21vdXNlRHJhZzogZnVuY3Rpb24oIC8qIGV2ZW50ICovICkge30sXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHt9LFxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiggLyogZXZlbnQgKi8gKSB7IHJldHVybiB0cnVlOyB9XG59ICk7XG5cbn0gKSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3dpZGdldHMvbW91c2UuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gNyIsIiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIsIFwiLi92ZXJzaW9uXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0gKCBmdW5jdGlvbiggJCApIHtcblxuLy8gVGhpcyBmaWxlIGlzIGRlcHJlY2F0ZWRcbnJldHVybiAkLnVpLmllID0gISEvbXNpZSBbXFx3Ll0rLy5leGVjKCBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgKTtcbn0gKSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL2llLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIvKiEgalF1ZXJ5IFRpbWVwaWNrZXIgQWRkb24gLSB2MS42LjMgLSAyMDE2LTA0LTIwXG4qIGh0dHA6Ly90cmVudHJpY2hhcmRzb24uY29tL2V4YW1wbGVzL3RpbWVwaWNrZXJcbiogQ29weXJpZ2h0IChjKSAyMDE2IFRyZW50IFJpY2hhcmRzb247IExpY2Vuc2VkIE1JVCAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cblx0Lypcblx0KiBMZXRzIG5vdCByZWRlZmluZSB0aW1lcGlja2VyLCBQcmV2ZW50IFwiVW5jYXVnaHQgUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIlxuXHQqL1xuXHQkLnVpLnRpbWVwaWNrZXIgPSAkLnVpLnRpbWVwaWNrZXIgfHwge307XG5cdGlmICgkLnVpLnRpbWVwaWNrZXIudmVyc2lvbikge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8qXG5cdCogRXh0ZW5kIGpRdWVyeVVJLCBnZXQgaXQgc3RhcnRlZCB3aXRoIG91ciB2ZXJzaW9uIG51bWJlclxuXHQqL1xuXHQkLmV4dGVuZCgkLnVpLCB7XG5cdFx0dGltZXBpY2tlcjoge1xuXHRcdFx0dmVyc2lvbjogXCIxLjYuM1wiXG5cdFx0fVxuXHR9KTtcblxuXHQvKlxuXHQqIFRpbWVwaWNrZXIgbWFuYWdlci5cblx0KiBVc2UgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLCAkLnRpbWVwaWNrZXIsIHRvIGludGVyYWN0IHdpdGggdGhlIHRpbWUgcGlja2VyLlxuXHQqIFNldHRpbmdzIGZvciAoZ3JvdXBzIG9mKSB0aW1lIHBpY2tlcnMgYXJlIG1haW50YWluZWQgaW4gYW4gaW5zdGFuY2Ugb2JqZWN0LFxuXHQqIGFsbG93aW5nIG11bHRpcGxlIGRpZmZlcmVudCBzZXR0aW5ncyBvbiB0aGUgc2FtZSBwYWdlLlxuXHQqL1xuXHR2YXIgVGltZXBpY2tlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnJlZ2lvbmFsID0gW107IC8vIEF2YWlsYWJsZSByZWdpb25hbCBzZXR0aW5ncywgaW5kZXhlZCBieSBsYW5ndWFnZSBjb2RlXG5cdFx0dGhpcy5yZWdpb25hbFsnJ10gPSB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3Ncblx0XHRcdGN1cnJlbnRUZXh0OiAnTm93Jyxcblx0XHRcdGNsb3NlVGV4dDogJ0RvbmUnLFxuXHRcdFx0YW1OYW1lczogWydBTScsICdBJ10sXG5cdFx0XHRwbU5hbWVzOiBbJ1BNJywgJ1AnXSxcblx0XHRcdHRpbWVGb3JtYXQ6ICdISDptbScsXG5cdFx0XHR0aW1lU3VmZml4OiAnJyxcblx0XHRcdHRpbWVPbmx5VGl0bGU6ICdDaG9vc2UgVGltZScsXG5cdFx0XHR0aW1lVGV4dDogJ1RpbWUnLFxuXHRcdFx0aG91clRleHQ6ICdIb3VyJyxcblx0XHRcdG1pbnV0ZVRleHQ6ICdNaW51dGUnLFxuXHRcdFx0c2Vjb25kVGV4dDogJ1NlY29uZCcsXG5cdFx0XHRtaWxsaXNlY1RleHQ6ICdNaWxsaXNlY29uZCcsXG5cdFx0XHRtaWNyb3NlY1RleHQ6ICdNaWNyb3NlY29uZCcsXG5cdFx0XHR0aW1lem9uZVRleHQ6ICdUaW1lIFpvbmUnLFxuXHRcdFx0aXNSVEw6IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLl9kZWZhdWx0cyA9IHsgLy8gR2xvYmFsIGRlZmF1bHRzIGZvciBhbGwgdGhlIGRhdGV0aW1lIHBpY2tlciBpbnN0YW5jZXNcblx0XHRcdHNob3dCdXR0b25QYW5lbDogdHJ1ZSxcblx0XHRcdHRpbWVPbmx5OiBmYWxzZSxcblx0XHRcdHRpbWVPbmx5U2hvd0RhdGU6IGZhbHNlLFxuXHRcdFx0c2hvd0hvdXI6IG51bGwsXG5cdFx0XHRzaG93TWludXRlOiBudWxsLFxuXHRcdFx0c2hvd1NlY29uZDogbnVsbCxcblx0XHRcdHNob3dNaWxsaXNlYzogbnVsbCxcblx0XHRcdHNob3dNaWNyb3NlYzogbnVsbCxcblx0XHRcdHNob3dUaW1lem9uZTogbnVsbCxcblx0XHRcdHNob3dUaW1lOiB0cnVlLFxuXHRcdFx0c3RlcEhvdXI6IDEsXG5cdFx0XHRzdGVwTWludXRlOiAxLFxuXHRcdFx0c3RlcFNlY29uZDogMSxcblx0XHRcdHN0ZXBNaWxsaXNlYzogMSxcblx0XHRcdHN0ZXBNaWNyb3NlYzogMSxcblx0XHRcdGhvdXI6IDAsXG5cdFx0XHRtaW51dGU6IDAsXG5cdFx0XHRzZWNvbmQ6IDAsXG5cdFx0XHRtaWxsaXNlYzogMCxcblx0XHRcdG1pY3Jvc2VjOiAwLFxuXHRcdFx0dGltZXpvbmU6IG51bGwsXG5cdFx0XHRob3VyTWluOiAwLFxuXHRcdFx0bWludXRlTWluOiAwLFxuXHRcdFx0c2Vjb25kTWluOiAwLFxuXHRcdFx0bWlsbGlzZWNNaW46IDAsXG5cdFx0XHRtaWNyb3NlY01pbjogMCxcblx0XHRcdGhvdXJNYXg6IDIzLFxuXHRcdFx0bWludXRlTWF4OiA1OSxcblx0XHRcdHNlY29uZE1heDogNTksXG5cdFx0XHRtaWxsaXNlY01heDogOTk5LFxuXHRcdFx0bWljcm9zZWNNYXg6IDk5OSxcblx0XHRcdG1pbkRhdGVUaW1lOiBudWxsLFxuXHRcdFx0bWF4RGF0ZVRpbWU6IG51bGwsXG5cdFx0XHRtYXhUaW1lOiBudWxsLFxuXHRcdFx0bWluVGltZTogbnVsbCxcblx0XHRcdG9uU2VsZWN0OiBudWxsLFxuXHRcdFx0aG91ckdyaWQ6IDAsXG5cdFx0XHRtaW51dGVHcmlkOiAwLFxuXHRcdFx0c2Vjb25kR3JpZDogMCxcblx0XHRcdG1pbGxpc2VjR3JpZDogMCxcblx0XHRcdG1pY3Jvc2VjR3JpZDogMCxcblx0XHRcdGFsd2F5c1NldFRpbWU6IHRydWUsXG5cdFx0XHRzZXBhcmF0b3I6ICcgJyxcblx0XHRcdGFsdEZpZWxkVGltZU9ubHk6IHRydWUsXG5cdFx0XHRhbHRUaW1lRm9ybWF0OiBudWxsLFxuXHRcdFx0YWx0U2VwYXJhdG9yOiBudWxsLFxuXHRcdFx0YWx0VGltZVN1ZmZpeDogbnVsbCxcblx0XHRcdGFsdFJlZGlyZWN0Rm9jdXM6IHRydWUsXG5cdFx0XHRwaWNrZXJUaW1lRm9ybWF0OiBudWxsLFxuXHRcdFx0cGlja2VyVGltZVN1ZmZpeDogbnVsbCxcblx0XHRcdHNob3dUaW1lcGlja2VyOiB0cnVlLFxuXHRcdFx0dGltZXpvbmVMaXN0OiBudWxsLFxuXHRcdFx0YWRkU2xpZGVyQWNjZXNzOiBmYWxzZSxcblx0XHRcdHNsaWRlckFjY2Vzc0FyZ3M6IG51bGwsXG5cdFx0XHRjb250cm9sVHlwZTogJ3NsaWRlcicsXG5cdFx0XHRvbmVMaW5lOiBmYWxzZSxcblx0XHRcdGRlZmF1bHRWYWx1ZTogbnVsbCxcblx0XHRcdHBhcnNlOiAnc3RyaWN0Jyxcblx0XHRcdGFmdGVySW5qZWN0OiBudWxsXG5cdFx0fTtcblx0XHQkLmV4dGVuZCh0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFsnJ10pO1xuXHR9O1xuXG5cdCQuZXh0ZW5kKFRpbWVwaWNrZXIucHJvdG90eXBlLCB7XG5cdFx0JGlucHV0OiBudWxsLFxuXHRcdCRhbHRJbnB1dDogbnVsbCxcblx0XHQkdGltZU9iajogbnVsbCxcblx0XHRpbnN0OiBudWxsLFxuXHRcdGhvdXJfc2xpZGVyOiBudWxsLFxuXHRcdG1pbnV0ZV9zbGlkZXI6IG51bGwsXG5cdFx0c2Vjb25kX3NsaWRlcjogbnVsbCxcblx0XHRtaWxsaXNlY19zbGlkZXI6IG51bGwsXG5cdFx0bWljcm9zZWNfc2xpZGVyOiBudWxsLFxuXHRcdHRpbWV6b25lX3NlbGVjdDogbnVsbCxcblx0XHRtYXhUaW1lOiBudWxsLFxuXHRcdG1pblRpbWU6IG51bGwsXG5cdFx0aG91cjogMCxcblx0XHRtaW51dGU6IDAsXG5cdFx0c2Vjb25kOiAwLFxuXHRcdG1pbGxpc2VjOiAwLFxuXHRcdG1pY3Jvc2VjOiAwLFxuXHRcdHRpbWV6b25lOiBudWxsLFxuXHRcdGhvdXJNaW5PcmlnaW5hbDogbnVsbCxcblx0XHRtaW51dGVNaW5PcmlnaW5hbDogbnVsbCxcblx0XHRzZWNvbmRNaW5PcmlnaW5hbDogbnVsbCxcblx0XHRtaWxsaXNlY01pbk9yaWdpbmFsOiBudWxsLFxuXHRcdG1pY3Jvc2VjTWluT3JpZ2luYWw6IG51bGwsXG5cdFx0aG91ck1heE9yaWdpbmFsOiBudWxsLFxuXHRcdG1pbnV0ZU1heE9yaWdpbmFsOiBudWxsLFxuXHRcdHNlY29uZE1heE9yaWdpbmFsOiBudWxsLFxuXHRcdG1pbGxpc2VjTWF4T3JpZ2luYWw6IG51bGwsXG5cdFx0bWljcm9zZWNNYXhPcmlnaW5hbDogbnVsbCxcblx0XHRhbXBtOiAnJyxcblx0XHRmb3JtYXR0ZWREYXRlOiAnJyxcblx0XHRmb3JtYXR0ZWRUaW1lOiAnJyxcblx0XHRmb3JtYXR0ZWREYXRlVGltZTogJycsXG5cdFx0dGltZXpvbmVMaXN0OiBudWxsLFxuXHRcdHVuaXRzOiBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlYycsICdtaWNyb3NlYyddLFxuXHRcdHN1cHBvcnQ6IHt9LFxuXHRcdGNvbnRyb2w6IG51bGwsXG5cblx0XHQvKlxuXHRcdCogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHRpbWUgcGlja2VyLlxuXHRcdCogQHBhcmFtICB7T2JqZWN0fSBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgYXMgZGVmYXVsdHMgKGFub255bW91cyBvYmplY3QpXG5cdFx0KiBAcmV0dXJuIHtPYmplY3R9IHRoZSBtYW5hZ2VyIG9iamVjdFxuXHRcdCovXG5cdFx0c2V0RGVmYXVsdHM6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuXHRcdFx0ZXh0ZW5kUmVtb3ZlKHRoaXMuX2RlZmF1bHRzLCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIENyZWF0ZSBhIG5ldyBUaW1lcGlja2VyIGluc3RhbmNlXG5cdFx0Ki9cblx0XHRfbmV3SW5zdDogZnVuY3Rpb24gKCRpbnB1dCwgb3B0cykge1xuXHRcdFx0dmFyIHRwX2luc3QgPSBuZXcgVGltZXBpY2tlcigpLFxuXHRcdFx0XHRpbmxpbmVTZXR0aW5ncyA9IHt9LFxuXHRcdFx0XHRmbnMgPSB7fSxcblx0XHRcdFx0b3ZlcnJpZGVzLCBpO1xuXG5cdFx0XHRmb3IgKHZhciBhdHRyTmFtZSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoYXR0ck5hbWUpKSB7XG5cdFx0XHRcdFx0dmFyIGF0dHJWYWx1ZSA9ICRpbnB1dC5hdHRyKCd0aW1lOicgKyBhdHRyTmFtZSk7XG5cdFx0XHRcdFx0aWYgKGF0dHJWYWx1ZSkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aW5saW5lU2V0dGluZ3NbYXR0ck5hbWVdID0gZXZhbChhdHRyVmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGlubGluZVNldHRpbmdzW2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0b3ZlcnJpZGVzID0ge1xuXHRcdFx0XHRiZWZvcmVTaG93OiBmdW5jdGlvbiAoaW5wdXQsIGRwX2luc3QpIHtcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLmJlZm9yZVNob3cpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHBfaW5zdC5fZGVmYXVsdHMuZXZudHMuYmVmb3JlU2hvdy5jYWxsKCRpbnB1dFswXSwgaW5wdXQsIGRwX2luc3QsIHRwX2luc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0b25DaGFuZ2VNb250aFllYXI6IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZHBfaW5zdCkge1xuXHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgdGltZSBhcyB3ZWxsIDogdGhpcyBwcmV2ZW50cyB0aGUgdGltZSBmcm9tIGRpc2FwcGVhcmluZyBmcm9tIHRoZSAkaW5wdXQgZmllbGQuXG5cdFx0XHRcdFx0Ly8gdHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoZHBfaW5zdCk7XG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbih0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNoYW5nZU1vbnRoWWVhcikpIHtcblx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLm9uQ2hhbmdlTW9udGhZZWFyLmNhbGwoJGlucHV0WzBdLCB5ZWFyLCBtb250aCwgZHBfaW5zdCwgdHBfaW5zdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRvbkNsb3NlOiBmdW5jdGlvbiAoZGF0ZVRleHQsIGRwX2luc3QpIHtcblx0XHRcdFx0XHRpZiAodHBfaW5zdC50aW1lRGVmaW5lZCA9PT0gdHJ1ZSAmJiAkaW5wdXQudmFsKCkgIT09ICcnKSB7XG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShkcF9pbnN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbih0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNsb3NlKSkge1xuXHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuZXZudHMub25DbG9zZS5jYWxsKCRpbnB1dFswXSwgZGF0ZVRleHQsIGRwX2luc3QsIHRwX2luc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGZvciAoaSBpbiBvdmVycmlkZXMpIHtcblx0XHRcdFx0aWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdGZuc1tpXSA9IG9wdHNbaV0gfHwgdGhpcy5fZGVmYXVsdHNbaV0gfHwgbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCB0aGlzLl9kZWZhdWx0cywgaW5saW5lU2V0dGluZ3MsIG9wdHMsIG92ZXJyaWRlcywge1xuXHRcdFx0XHRldm50czogZm5zLFxuXHRcdFx0XHR0aW1lcGlja2VyOiB0cF9pbnN0IC8vIGFkZCB0aW1lcGlja2VyIGFzIGEgcHJvcGVydHkgb2YgZGF0ZXBpY2tlcjogJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRcdH0pO1xuXHRcdFx0dHBfaW5zdC5hbU5hbWVzID0gJC5tYXAodHBfaW5zdC5fZGVmYXVsdHMuYW1OYW1lcywgZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHRcdHRwX2luc3QucG1OYW1lcyA9ICQubWFwKHRwX2luc3QuX2RlZmF1bHRzLnBtTmFtZXMsIGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIHZhbC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGRldGVjdCB3aGljaCB1bml0cyBhcmUgc3VwcG9ydGVkXG5cdFx0XHR0cF9pbnN0LnN1cHBvcnQgPSBkZXRlY3RTdXBwb3J0KFxuXHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQgK1xuXHRcdFx0XHRcdCh0cF9pbnN0Ll9kZWZhdWx0cy5waWNrZXJUaW1lRm9ybWF0ID8gdHBfaW5zdC5fZGVmYXVsdHMucGlja2VyVGltZUZvcm1hdCA6ICcnKSArXG5cdFx0XHRcdFx0KHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0IDogJycpKTtcblxuXHRcdFx0Ly8gY29udHJvbFR5cGUgaXMgc3RyaW5nIC0ga2V5IHRvIG91ciB0aGlzLl9jb250cm9sc1xuXHRcdFx0aWYgKHR5cGVvZih0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZSA9PT0gJ3NsaWRlcicgJiYgdHlwZW9mKCQudWkuc2xpZGVyKSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZSA9ICdzZWxlY3QnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRwX2luc3QuY29udHJvbCA9IHRwX2luc3QuX2NvbnRyb2xzW3RwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlXTtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnRyb2xUeXBlIGlzIGFuIG9iamVjdCBhbmQgbXVzdCBpbXBsZW1lbnQgY3JlYXRlLCBvcHRpb25zLCB2YWx1ZSBtZXRob2RzXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dHBfaW5zdC5jb250cm9sID0gdHBfaW5zdC5fZGVmYXVsdHMuY29udHJvbFR5cGU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZXAgdGhlIHRpbWV6b25lIG9wdGlvbnNcblx0XHRcdHZhciB0aW1lem9uZUxpc3QgPSBbLTcyMCwgLTY2MCwgLTYwMCwgLTU3MCwgLTU0MCwgLTQ4MCwgLTQyMCwgLTM2MCwgLTMwMCwgLTI3MCwgLTI0MCwgLTIxMCwgLTE4MCwgLTEyMCwgLTYwLFxuXHRcdFx0XHRcdDAsIDYwLCAxMjAsIDE4MCwgMjEwLCAyNDAsIDI3MCwgMzAwLCAzMzAsIDM0NSwgMzYwLCAzOTAsIDQyMCwgNDgwLCA1MjUsIDU0MCwgNTcwLCA2MDAsIDYzMCwgNjYwLCA2OTAsIDcyMCwgNzY1LCA3ODAsIDg0MF07XG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmVMaXN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWV6b25lTGlzdCA9IHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lTGlzdDtcblx0XHRcdH1cblx0XHRcdHZhciB0emwgPSB0aW1lem9uZUxpc3QubGVuZ3RoLCB0emkgPSAwLCB0enYgPSBudWxsO1xuXHRcdFx0aWYgKHR6bCA+IDAgJiYgdHlwZW9mIHRpbWV6b25lTGlzdFswXSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICg7IHR6aSA8IHR6bDsgdHppKyspIHtcblx0XHRcdFx0XHR0enYgPSB0aW1lem9uZUxpc3RbdHppXTtcblx0XHRcdFx0XHR0aW1lem9uZUxpc3RbdHppXSA9IHsgdmFsdWU6IHR6diwgbGFiZWw6ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZyh0enYsIHRwX2luc3Quc3VwcG9ydC5pc284NjAxKSB9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3QgPSB0aW1lem9uZUxpc3Q7XG5cblx0XHRcdC8vIHNldCB0aGUgZGVmYXVsdCB1bml0c1xuXHRcdFx0dHBfaW5zdC50aW1lem9uZSA9IHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lICE9PSBudWxsID8gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lKSA6XG5cdFx0XHRcdFx0XHRcdCgobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xKTtcblx0XHRcdHRwX2luc3QuaG91ciA9IHRwX2luc3QuX2RlZmF1bHRzLmhvdXIgPCB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyTWluID8gdHBfaW5zdC5fZGVmYXVsdHMuaG91ck1pbiA6XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLmhvdXIgPiB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMuaG91ck1heCA6IHRwX2luc3QuX2RlZmF1bHRzLmhvdXI7XG5cdFx0XHR0cF9pbnN0Lm1pbnV0ZSA9IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZSA8IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1pbiA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1pbiA6XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZSA+IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1heCA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1heCA6IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZTtcblx0XHRcdHRwX2luc3Quc2Vjb25kID0gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kIDwgdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWluID8gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWluIDpcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kID4gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kO1xuXHRcdFx0dHBfaW5zdC5taWxsaXNlYyA9IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjIDwgdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlY01pbiA6XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjID4gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWNNYXggPyB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlY01heCA6IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjO1xuXHRcdFx0dHBfaW5zdC5taWNyb3NlYyA9IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjIDwgdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWNNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01pbiA6XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjID4gdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWNNYXggPyB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01heCA6IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjO1xuXHRcdFx0dHBfaW5zdC5hbXBtID0gJyc7XG5cdFx0XHR0cF9pbnN0LiRpbnB1dCA9ICRpbnB1dDtcblxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmFsdEZpZWxkKSB7XG5cdFx0XHRcdHRwX2luc3QuJGFsdElucHV0ID0gJCh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZCk7XG5cdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRSZWRpcmVjdEZvY3VzID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dHBfaW5zdC4kYWx0SW5wdXQuY3NzKHtcblx0XHRcdFx0XHRcdGN1cnNvcjogJ3BvaW50ZXInXG5cdFx0XHRcdFx0fSkuZm9jdXMoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0JGlucHV0LnRyaWdnZXIoXCJmb2N1c1wiKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9PT0gMCB8fCB0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlVGltZSA9PT0gMCkge1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdH1cblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID09PSAwIHx8IHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lID09PSAwKSB7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkYXRlcGlja2VyIG5lZWRzIG1pbkRhdGUvbWF4RGF0ZSwgdGltZXBpY2tlciBuZWVkcyBtaW5EYXRlVGltZS9tYXhEYXRlVGltZS4uXG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lID0gbmV3IERhdGUodHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZS5nZXRUaW1lKCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lICE9PSB1bmRlZmluZWQgJiYgdHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlVGltZS5nZXRUaW1lKCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJiB0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZSA9IG5ldyBEYXRlKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUuZ2V0VGltZSgpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID0gbmV3IERhdGUodHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUuZ2V0VGltZSgpKTtcblx0XHRcdH1cblx0XHRcdHRwX2luc3QuJGlucHV0LmJpbmQoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0cF9pbnN0Ll9vbkZvY3VzKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHRwX2luc3Q7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBhZGQgb3VyIHNsaWRlcnMgdG8gdGhlIGNhbGVuZGFyXG5cdFx0Ki9cblx0XHRfYWRkVGltZVBpY2tlcjogZnVuY3Rpb24gKGRwX2luc3QpIHtcblx0XHRcdHZhciBjdXJyRFQgPSAkLnRyaW0oKHRoaXMuJGFsdElucHV0ICYmIHRoaXMuX2RlZmF1bHRzLmFsdEZpZWxkVGltZU9ubHkpID8gdGhpcy4kaW5wdXQudmFsKCkgKyAnICcgKyB0aGlzLiRhbHRJbnB1dC52YWwoKSA6IHRoaXMuJGlucHV0LnZhbCgpKTtcblxuXHRcdFx0dGhpcy50aW1lRGVmaW5lZCA9IHRoaXMuX3BhcnNlVGltZShjdXJyRFQpO1xuXHRcdFx0dGhpcy5fbGltaXRNaW5NYXhEYXRlVGltZShkcF9pbnN0LCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9pbmplY3RUaW1lUGlja2VyKCk7XG5cdFx0XHR0aGlzLl9hZnRlckluamVjdCgpO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogcGFyc2UgdGhlIHRpbWUgc3RyaW5nIGZyb20gaW5wdXQgdmFsdWUgb3IgX3NldFRpbWVcblx0XHQqL1xuXHRcdF9wYXJzZVRpbWU6IGZ1bmN0aW9uICh0aW1lU3RyaW5nLCB3aXRoRGF0ZSkge1xuXHRcdFx0aWYgKCF0aGlzLmluc3QpIHtcblx0XHRcdFx0dGhpcy5pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0WzBdKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHdpdGhEYXRlIHx8ICF0aGlzLl9kZWZhdWx0cy50aW1lT25seSkge1xuXHRcdFx0XHR2YXIgZHBfZGF0ZUZvcm1hdCA9ICQuZGF0ZXBpY2tlci5fZ2V0KHRoaXMuaW5zdCwgJ2RhdGVGb3JtYXQnKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgcGFyc2VSZXMgPSBwYXJzZURhdGVUaW1lSW50ZXJuYWwoZHBfZGF0ZUZvcm1hdCwgdGhpcy5fZGVmYXVsdHMudGltZUZvcm1hdCwgdGltZVN0cmluZywgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcodGhpcy5pbnN0KSwgdGhpcy5fZGVmYXVsdHMpO1xuXHRcdFx0XHRcdGlmICghcGFyc2VSZXMudGltZU9iaikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkLmV4dGVuZCh0aGlzLCBwYXJzZVJlcy50aW1lT2JqKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0JC50aW1lcGlja2VyLmxvZyhcIkVycm9yIHBhcnNpbmcgdGhlIGRhdGUvdGltZSBzdHJpbmc6IFwiICsgZXJyICtcblx0XHRcdFx0XHRcdFx0XHRcdFwiXFxuZGF0ZS90aW1lIHN0cmluZyA9IFwiICsgdGltZVN0cmluZyArXG5cdFx0XHRcdFx0XHRcdFx0XHRcIlxcbnRpbWVGb3JtYXQgPSBcIiArIHRoaXMuX2RlZmF1bHRzLnRpbWVGb3JtYXQgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG5kYXRlRm9ybWF0ID0gXCIgKyBkcF9kYXRlRm9ybWF0KTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdGltZU9iaiA9ICQuZGF0ZXBpY2tlci5wYXJzZVRpbWUodGhpcy5fZGVmYXVsdHMudGltZUZvcm1hdCwgdGltZVN0cmluZywgdGhpcy5fZGVmYXVsdHMpO1xuXHRcdFx0XHRpZiAoIXRpbWVPYmopIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5leHRlbmQodGhpcywgdGltZU9iaik7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogSGFuZGxlIGNhbGxiYWNrIG9wdGlvbiBhZnRlciBpbmplY3RpbmcgdGltZXBpY2tlclxuXHRcdCovXG5cdFx0X2FmdGVySW5qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvID0gdGhpcy5pbnN0LnNldHRpbmdzO1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbihvLmFmdGVySW5qZWN0KSkge1xuXHRcdFx0XHRvLmFmdGVySW5qZWN0LmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBnZW5lcmF0ZSBhbmQgaW5qZWN0IGh0bWwgZm9yIHRpbWVwaWNrZXIgaW50byB1aSBkYXRlcGlja2VyXG5cdFx0Ki9cblx0XHRfaW5qZWN0VGltZVBpY2tlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICRkcCA9IHRoaXMuaW5zdC5kcERpdixcblx0XHRcdFx0byA9IHRoaXMuaW5zdC5zZXR0aW5ncyxcblx0XHRcdFx0dHBfaW5zdCA9IHRoaXMsXG5cdFx0XHRcdGxpdGVtID0gJycsXG5cdFx0XHRcdHVpdGVtID0gJycsXG5cdFx0XHRcdHNob3cgPSBudWxsLFxuXHRcdFx0XHRtYXggPSB7fSxcblx0XHRcdFx0Z3JpZFNpemUgPSB7fSxcblx0XHRcdFx0c2l6ZSA9IG51bGwsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gMDtcblxuXHRcdFx0Ly8gUHJldmVudCBkaXNwbGF5aW5nIHR3aWNlXG5cdFx0XHRpZiAoJGRwLmZpbmQoXCJkaXYudWktdGltZXBpY2tlci1kaXZcIikubGVuZ3RoID09PSAwICYmIG8uc2hvd1RpbWVwaWNrZXIpIHtcblx0XHRcdFx0dmFyIG5vRGlzcGxheSA9ICcgdWlfdHBpY2tlcl91bml0X2hpZGUnLFxuXHRcdFx0XHRcdGh0bWwgPSAnPGRpdiBjbGFzcz1cInVpLXRpbWVwaWNrZXItZGl2JyArIChvLmlzUlRMID8gJyB1aS10aW1lcGlja2VyLXJ0bCcgOiAnJykgKyAoby5vbmVMaW5lICYmIG8uY29udHJvbFR5cGUgPT09ICdzZWxlY3QnID8gJyB1aS10aW1lcGlja2VyLW9uZUxpbmUnIDogJycpICsgJ1wiPjxkbD4nICsgJzxkdCBjbGFzcz1cInVpX3RwaWNrZXJfdGltZV9sYWJlbCcgKyAoKG8uc2hvd1RpbWUpID8gJycgOiBub0Rpc3BsYXkpICsgJ1wiPicgKyBvLnRpbWVUZXh0ICsgJzwvZHQ+JyArXG5cdFx0XHRcdFx0XHRcdFx0JzxkZCBjbGFzcz1cInVpX3RwaWNrZXJfdGltZSAnKyAoKG8uc2hvd1RpbWUpID8gJycgOiBub0Rpc3BsYXkpICsgJ1wiPjxpbnB1dCBjbGFzcz1cInVpX3RwaWNrZXJfdGltZV9pbnB1dFwiICcgKyAoby50aW1lSW5wdXQgPyAnJyA6ICdkaXNhYmxlZCcpICsgJy8+PC9kZD4nO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgbWFya3VwXG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLnVuaXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGxpdGVtID0gdGhpcy51bml0c1tpXTtcblx0XHRcdFx0XHR1aXRlbSA9IGxpdGVtLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgbGl0ZW0uc3Vic3RyKDEpO1xuXHRcdFx0XHRcdHNob3cgPSBvWydzaG93JyArIHVpdGVtXSAhPT0gbnVsbCA/IG9bJ3Nob3cnICsgdWl0ZW1dIDogdGhpcy5zdXBwb3J0W2xpdGVtXTtcblxuXHRcdFx0XHRcdC8vIEFkZGVkIGJ5IFBldGVyIE1lZGVpcm9zOlxuXHRcdFx0XHRcdC8vIC0gRmlndXJlIG91dCB3aGF0IHRoZSBob3VyL21pbnV0ZS9zZWNvbmQgbWF4IHNob3VsZCBiZSBiYXNlZCBvbiB0aGUgc3RlcCB2YWx1ZXMuXG5cdFx0XHRcdFx0Ly8gLSBFeGFtcGxlOiBpZiBzdGVwTWludXRlIGlzIDE1LCB0aGVuIG1pbk1heCBpcyA0NS5cblx0XHRcdFx0XHRtYXhbbGl0ZW1dID0gcGFyc2VJbnQoKG9bbGl0ZW0gKyAnTWF4J10gLSAoKG9bbGl0ZW0gKyAnTWF4J10gLSBvW2xpdGVtICsgJ01pbiddKSAlIG9bJ3N0ZXAnICsgdWl0ZW1dKSksIDEwKTtcblx0XHRcdFx0XHRncmlkU2l6ZVtsaXRlbV0gPSAwO1xuXG5cdFx0XHRcdFx0aHRtbCArPSAnPGR0IGNsYXNzPVwidWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnX2xhYmVsJyArIChzaG93ID8gJycgOiBub0Rpc3BsYXkpICsgJ1wiPicgKyBvW2xpdGVtICsgJ1RleHQnXSArICc8L2R0PicgK1xuXHRcdFx0XHRcdFx0XHRcdCc8ZGQgY2xhc3M9XCJ1aV90cGlja2VyXycgKyBsaXRlbSArIChzaG93ID8gJycgOiBub0Rpc3BsYXkpICsgJ1wiPjxkaXYgY2xhc3M9XCJ1aV90cGlja2VyXycgKyBsaXRlbSArICdfc2xpZGVyJyArIChzaG93ID8gJycgOiBub0Rpc3BsYXkpICsgJ1wiPjwvZGl2Pic7XG5cblx0XHRcdFx0XHRpZiAoc2hvdyAmJiBvW2xpdGVtICsgJ0dyaWQnXSA+IDApIHtcblx0XHRcdFx0XHRcdGh0bWwgKz0gJzxkaXYgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDFweFwiPjx0YWJsZSBjbGFzcz1cInVpLXRwaWNrZXItZ3JpZC1sYWJlbFwiPjx0cj4nO1xuXG5cdFx0XHRcdFx0XHRpZiAobGl0ZW0gPT09ICdob3VyJykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBoID0gb1tsaXRlbSArICdNaW4nXTsgaCA8PSBtYXhbbGl0ZW1dOyBoICs9IHBhcnNlSW50KG9bbGl0ZW0gKyAnR3JpZCddLCAxMCkpIHtcblx0XHRcdFx0XHRcdFx0XHRncmlkU2l6ZVtsaXRlbV0rKztcblx0XHRcdFx0XHRcdFx0XHR2YXIgdG1waCA9ICQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKHRoaXMuc3VwcG9ydC5hbXBtID8gJ2hodCcgOiAnSEgnLCB7aG91cjogaH0sIG8pO1xuXHRcdFx0XHRcdFx0XHRcdGh0bWwgKz0gJzx0ZCBkYXRhLWZvcj1cIicgKyBsaXRlbSArICdcIj4nICsgdG1waCArICc8L3RkPic7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gb1tsaXRlbSArICdNaW4nXTsgbSA8PSBtYXhbbGl0ZW1dOyBtICs9IHBhcnNlSW50KG9bbGl0ZW0gKyAnR3JpZCddLCAxMCkpIHtcblx0XHRcdFx0XHRcdFx0XHRncmlkU2l6ZVtsaXRlbV0rKztcblx0XHRcdFx0XHRcdFx0XHRodG1sICs9ICc8dGQgZGF0YS1mb3I9XCInICsgbGl0ZW0gKyAnXCI+JyArICgobSA8IDEwKSA/ICcwJyA6ICcnKSArIG0gKyAnPC90ZD4nO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGh0bWwgKz0gJzwvdHI+PC90YWJsZT48L2Rpdj4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRodG1sICs9ICc8L2RkPic7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaW1lem9uZVxuXHRcdFx0XHR2YXIgc2hvd1R6ID0gby5zaG93VGltZXpvbmUgIT09IG51bGwgPyBvLnNob3dUaW1lem9uZSA6IHRoaXMuc3VwcG9ydC50aW1lem9uZTtcblx0XHRcdFx0aHRtbCArPSAnPGR0IGNsYXNzPVwidWlfdHBpY2tlcl90aW1lem9uZV9sYWJlbCcgKyAoc2hvd1R6ID8gJycgOiBub0Rpc3BsYXkpICsgJ1wiPicgKyBvLnRpbWV6b25lVGV4dCArICc8L2R0Pic7XG5cdFx0XHRcdGh0bWwgKz0gJzxkZCBjbGFzcz1cInVpX3RwaWNrZXJfdGltZXpvbmUnICsgKHNob3dUeiA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48L2RkPic7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBlbGVtZW50cyBmcm9tIHN0cmluZ1xuXHRcdFx0XHRodG1sICs9ICc8L2RsPjwvZGl2Pic7XG5cdFx0XHRcdHZhciAkdHAgPSAkKGh0bWwpO1xuXG5cdFx0XHRcdC8vIGlmIHdlIG9ubHkgd2FudCB0aW1lIHBpY2tlci4uLlxuXHRcdFx0XHRpZiAoby50aW1lT25seSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdCR0cC5wcmVwZW5kKCc8ZGl2IGNsYXNzPVwidWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbFwiPicgKyAnPGRpdiBjbGFzcz1cInVpLWRhdGVwaWNrZXItdGl0bGVcIj4nICsgby50aW1lT25seVRpdGxlICsgJzwvZGl2PicgKyAnPC9kaXY+Jyk7XG5cdFx0XHRcdFx0JGRwLmZpbmQoJy51aS1kYXRlcGlja2VyLWhlYWRlciwgLnVpLWRhdGVwaWNrZXItY2FsZW5kYXInKS5oaWRlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhZGQgc2xpZGVycywgYWRqdXN0IGdyaWRzLCBhZGQgZXZlbnRzXG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSB0cF9pbnN0LnVuaXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGxpdGVtID0gdHBfaW5zdC51bml0c1tpXTtcblx0XHRcdFx0XHR1aXRlbSA9IGxpdGVtLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgbGl0ZW0uc3Vic3RyKDEpO1xuXHRcdFx0XHRcdHNob3cgPSBvWydzaG93JyArIHVpdGVtXSAhPT0gbnVsbCA/IG9bJ3Nob3cnICsgdWl0ZW1dIDogdGhpcy5zdXBwb3J0W2xpdGVtXTtcblxuXHRcdFx0XHRcdC8vIGFkZCB0aGUgc2xpZGVyXG5cdFx0XHRcdFx0dHBfaW5zdFtsaXRlbSArICdfc2xpZGVyJ10gPSB0cF9pbnN0LmNvbnRyb2wuY3JlYXRlKHRwX2luc3QsICR0cC5maW5kKCcudWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnX3NsaWRlcicpLCBsaXRlbSwgdHBfaW5zdFtsaXRlbV0sIG9bbGl0ZW0gKyAnTWluJ10sIG1heFtsaXRlbV0sIG9bJ3N0ZXAnICsgdWl0ZW1dKTtcblxuXHRcdFx0XHRcdC8vIGFkanVzdCB0aGUgZ3JpZCBhbmQgYWRkIGNsaWNrIGV2ZW50XG5cdFx0XHRcdFx0aWYgKHNob3cgJiYgb1tsaXRlbSArICdHcmlkJ10gPiAwKSB7XG5cdFx0XHRcdFx0XHRzaXplID0gMTAwICogZ3JpZFNpemVbbGl0ZW1dICogb1tsaXRlbSArICdHcmlkJ10gLyAobWF4W2xpdGVtXSAtIG9bbGl0ZW0gKyAnTWluJ10pO1xuXHRcdFx0XHRcdFx0JHRwLmZpbmQoJy51aV90cGlja2VyXycgKyBsaXRlbSArICcgdGFibGUnKS5jc3Moe1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogc2l6ZSArIFwiJVwiLFxuXHRcdFx0XHRcdFx0XHRtYXJnaW5MZWZ0OiBvLmlzUlRMID8gJzAnIDogKChzaXplIC8gKC0yICogZ3JpZFNpemVbbGl0ZW1dKSkgKyBcIiVcIiksXG5cdFx0XHRcdFx0XHRcdG1hcmdpblJpZ2h0OiBvLmlzUlRMID8gKChzaXplIC8gKC0yICogZ3JpZFNpemVbbGl0ZW1dKSkgKyBcIiVcIikgOiAnMCcsXG5cdFx0XHRcdFx0XHRcdGJvcmRlckNvbGxhcHNlOiAnY29sbGFwc2UnXG5cdFx0XHRcdFx0XHR9KS5maW5kKFwidGRcIikuY2xpY2soZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgJHQgPSAkKHRoaXMpLFxuXHRcdFx0XHRcdFx0XHRcdFx0aCA9ICR0Lmh0bWwoKSxcblx0XHRcdFx0XHRcdFx0XHRcdG4gPSBwYXJzZUludChoLnJlcGxhY2UoL1teMC05XS9nKSwgMTApLFxuXHRcdFx0XHRcdFx0XHRcdFx0YXAgPSBoLnJlcGxhY2UoL1teYXBtXS9pZyksXG5cdFx0XHRcdFx0XHRcdFx0XHRmID0gJHQuZGF0YSgnZm9yJyk7IC8vIGxvc2VzIHNjb3BlLCBzbyB3ZSB1c2UgZGF0YS1mb3JcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChmID09PSAnaG91cicpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChhcC5pbmRleE9mKCdwJykgIT09IC0xICYmIG4gPCAxMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRuICs9IDEyO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChhcC5pbmRleE9mKCdhJykgIT09IC0xICYmIG4gPT09IDEyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0biA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR0cF9pbnN0LmNvbnRyb2wudmFsdWUodHBfaW5zdCwgdHBfaW5zdFtmICsgJ19zbGlkZXInXSwgbGl0ZW0sIG4pO1xuXG5cdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25UaW1lQ2hhbmdlKCk7XG5cdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XG5cdFx0XHRcdFx0XHRcdH0pLmNzcyh7XG5cdFx0XHRcdFx0XHRcdFx0Y3Vyc29yOiAncG9pbnRlcicsXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6ICgxMDAgLyBncmlkU2l6ZVtsaXRlbV0pICsgJyUnLFxuXHRcdFx0XHRcdFx0XHRcdHRleHRBbGlnbjogJ2NlbnRlcicsXG5cdFx0XHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gLy8gZW5kIGlmIGdyaWQgPiAwXG5cdFx0XHRcdH0gLy8gZW5kIGZvciBsb29wXG5cblx0XHRcdFx0Ly8gQWRkIHRpbWV6b25lIG9wdGlvbnNcblx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QgPSAkdHAuZmluZCgnLnVpX3RwaWNrZXJfdGltZXpvbmUnKS5hcHBlbmQoJzxzZWxlY3Q+PC9zZWxlY3Q+JykuZmluZChcInNlbGVjdFwiKTtcblx0XHRcdFx0JC5mbi5hcHBlbmQuYXBwbHkodGhpcy50aW1lem9uZV9zZWxlY3QsXG5cdFx0XHRcdCQubWFwKG8udGltZXpvbmVMaXN0LCBmdW5jdGlvbiAodmFsLCBpZHgpIHtcblx0XHRcdFx0XHRyZXR1cm4gJChcIjxvcHRpb24gLz5cIikudmFsKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgPyB2YWwudmFsdWUgOiB2YWwpLnRleHQodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiA/IHZhbC5sYWJlbCA6IHZhbCk7XG5cdFx0XHRcdH0pKTtcblx0XHRcdFx0aWYgKHR5cGVvZih0aGlzLnRpbWV6b25lKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLnRpbWV6b25lICE9PSBudWxsICYmIHRoaXMudGltZXpvbmUgIT09IFwiXCIpIHtcblx0XHRcdFx0XHR2YXIgbG9jYWxfdGltZXpvbmUgPSAobmV3IERhdGUodGhpcy5pbnN0LnNlbGVjdGVkWWVhciwgdGhpcy5pbnN0LnNlbGVjdGVkTW9udGgsIHRoaXMuaW5zdC5zZWxlY3RlZERheSwgMTIpKS5nZXRUaW1lem9uZU9mZnNldCgpICogLTE7XG5cdFx0XHRcdFx0aWYgKGxvY2FsX3RpbWV6b25lID09PSB0aGlzLnRpbWV6b25lKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RMb2NhbFRpbWV6b25lKHRwX2luc3QpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRpbWV6b25lX3NlbGVjdC52YWwodGhpcy50aW1lem9uZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YodGhpcy5ob3VyKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLmhvdXIgIT09IG51bGwgJiYgdGhpcy5ob3VyICE9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRpbWV6b25lX3NlbGVjdC52YWwoby50aW1lem9uZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGVjdExvY2FsVGltZXpvbmUodHBfaW5zdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudGltZXpvbmVfc2VsZWN0LmNoYW5nZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dHBfaW5zdC5fb25UaW1lQ2hhbmdlKCk7XG5cdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XG5cdFx0XHRcdFx0dHBfaW5zdC5fYWZ0ZXJJbmplY3QoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIEVuZCB0aW1lem9uZSBvcHRpb25zXG5cblx0XHRcdFx0Ly8gaW5qZWN0IHRpbWVwaWNrZXIgaW50byBkYXRlcGlja2VyXG5cdFx0XHRcdHZhciAkYnV0dG9uUGFuZWwgPSAkZHAuZmluZCgnLnVpLWRhdGVwaWNrZXItYnV0dG9ucGFuZScpO1xuXHRcdFx0XHRpZiAoJGJ1dHRvblBhbmVsLmxlbmd0aCkge1xuXHRcdFx0XHRcdCRidXR0b25QYW5lbC5iZWZvcmUoJHRwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkZHAuYXBwZW5kKCR0cCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLiR0aW1lT2JqID0gJHRwLmZpbmQoJy51aV90cGlja2VyX3RpbWVfaW5wdXQnKTtcblx0XHRcdFx0dGhpcy4kdGltZU9iai5jaGFuZ2UoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciB0aW1lRm9ybWF0ID0gdHBfaW5zdC5pbnN0LnNldHRpbmdzLnRpbWVGb3JtYXQ7XG5cdFx0XHRcdFx0dmFyIHBhcnNlZFRpbWUgPSAkLmRhdGVwaWNrZXIucGFyc2VUaW1lKHRpbWVGb3JtYXQsIHRoaXMudmFsdWUpO1xuXHRcdFx0XHRcdHZhciB1cGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdGlmIChwYXJzZWRUaW1lKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUuc2V0SG91cnMocGFyc2VkVGltZS5ob3VyKTtcblx0XHRcdFx0XHRcdHVwZGF0ZS5zZXRNaW51dGVzKHBhcnNlZFRpbWUubWludXRlKTtcblx0XHRcdFx0XHRcdHVwZGF0ZS5zZXRTZWNvbmRzKHBhcnNlZFRpbWUuc2Vjb25kKTtcblx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2V0VGltZSh0cF9pbnN0Lmluc3QsIHVwZGF0ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0cF9pbnN0LmZvcm1hdHRlZFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICh0aGlzLmluc3QgIT09IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgdGltZURlZmluZWQgPSB0aGlzLnRpbWVEZWZpbmVkO1xuXHRcdFx0XHRcdHRoaXMuX29uVGltZUNoYW5nZSgpO1xuXHRcdFx0XHRcdHRoaXMudGltZURlZmluZWQgPSB0aW1lRGVmaW5lZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNsaWRlQWNjZXNzIGludGVncmF0aW9uOiBodHRwOi8vdHJlbnRyaWNoYXJkc29uLmNvbS8yMDExLzExLzExL2pxdWVyeS11aS1zbGlkZXJzLWFuZC10b3VjaC1hY2Nlc3NpYmlsaXR5L1xuXHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuYWRkU2xpZGVyQWNjZXNzKSB7XG5cdFx0XHRcdFx0dmFyIHNsaWRlckFjY2Vzc0FyZ3MgPSB0aGlzLl9kZWZhdWx0cy5zbGlkZXJBY2Nlc3NBcmdzLFxuXHRcdFx0XHRcdFx0cnRsID0gdGhpcy5fZGVmYXVsdHMuaXNSVEw7XG5cdFx0XHRcdFx0c2xpZGVyQWNjZXNzQXJncy5pc1JUTCA9IHJ0bDtcblxuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyAvLyBmaXggZm9yIGlubGluZSBtb2RlXG5cdFx0XHRcdFx0XHRpZiAoJHRwLmZpbmQoJy51aS1zbGlkZXItYWNjZXNzJykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdCR0cC5maW5kKCcudWktc2xpZGVyOnZpc2libGUnKS5zbGlkZXJBY2Nlc3Moc2xpZGVyQWNjZXNzQXJncyk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gZml4IGFueSBncmlkcyBzaW5jZSBzbGlkZXJzIGFyZSBzaG9ydGVyXG5cdFx0XHRcdFx0XHRcdHZhciBzbGlkZXJBY2Nlc3NXaWR0aCA9ICR0cC5maW5kKCcudWktc2xpZGVyLWFjY2VzczplcSgwKScpLm91dGVyV2lkdGgodHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChzbGlkZXJBY2Nlc3NXaWR0aCkge1xuXHRcdFx0XHRcdFx0XHRcdCR0cC5maW5kKCd0YWJsZTp2aXNpYmxlJykuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgJGcgPSAkKHRoaXMpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbGRXaWR0aCA9ICRnLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2xkTWFyZ2luTGVmdCA9ICRnLmNzcyhydGwgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkxlZnQnKS50b1N0cmluZygpLnJlcGxhY2UoJyUnLCAnJyksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ld1dpZHRoID0gb2xkV2lkdGggLSBzbGlkZXJBY2Nlc3NXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3TWFyZ2luTGVmdCA9ICgob2xkTWFyZ2luTGVmdCAqIG5ld1dpZHRoKSAvIG9sZFdpZHRoKSArICclJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3NzID0geyB3aWR0aDogbmV3V2lkdGgsIG1hcmdpblJpZ2h0OiAwLCBtYXJnaW5MZWZ0OiAwIH07XG5cdFx0XHRcdFx0XHRcdFx0XHRjc3NbcnRsID8gJ21hcmdpblJpZ2h0JyA6ICdtYXJnaW5MZWZ0J10gPSBuZXdNYXJnaW5MZWZ0O1xuXHRcdFx0XHRcdFx0XHRcdFx0JGcuY3NzKGNzcyk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCAxMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZW5kIHNsaWRlQWNjZXNzIGludGVncmF0aW9uXG5cblx0XHRcdFx0dHBfaW5zdC5fbGltaXRNaW5NYXhEYXRlVGltZSh0aGlzLmluc3QsIHRydWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogVGhpcyBmdW5jdGlvbiB0cmllcyB0byBsaW1pdCB0aGUgYWJpbGl0eSB0byBnbyBvdXRzaWRlIHRoZVxuXHRcdCogbWluL21heCBkYXRlIHJhbmdlXG5cdFx0Ki9cblx0XHRfbGltaXRNaW5NYXhEYXRlVGltZTogZnVuY3Rpb24gKGRwX2luc3QsIGFkanVzdFNsaWRlcnMpIHtcblx0XHRcdHZhciBvID0gdGhpcy5fZGVmYXVsdHMsXG5cdFx0XHRcdGRwX2RhdGUgPSBuZXcgRGF0ZShkcF9pbnN0LnNlbGVjdGVkWWVhciwgZHBfaW5zdC5zZWxlY3RlZE1vbnRoLCBkcF9pbnN0LnNlbGVjdGVkRGF5KTtcblxuXHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy5zaG93VGltZXBpY2tlcikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IC8vIE5vIHRpbWUgc28gbm90aGluZyB0byBjaGVjayBoZXJlXG5cblx0XHRcdGlmICgkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAnbWluRGF0ZVRpbWUnKSAhPT0gbnVsbCAmJiAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAnbWluRGF0ZVRpbWUnKSAhPT0gdW5kZWZpbmVkICYmIGRwX2RhdGUpIHtcblx0XHRcdFx0dmFyIG1pbkRhdGVUaW1lID0gJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJyksXG5cdFx0XHRcdFx0bWluRGF0ZVRpbWVEYXRlID0gbmV3IERhdGUobWluRGF0ZVRpbWUuZ2V0RnVsbFllYXIoKSwgbWluRGF0ZVRpbWUuZ2V0TW9udGgoKSwgbWluRGF0ZVRpbWUuZ2V0RGF0ZSgpLCAwLCAwLCAwLCAwKTtcblxuXHRcdFx0XHRpZiAodGhpcy5ob3VyTWluT3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5taW51dGVNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLnNlY29uZE1pbk9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWwgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLmhvdXJNaW5PcmlnaW5hbCA9IG8uaG91ck1pbjtcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZU1pbk9yaWdpbmFsID0gby5taW51dGVNaW47XG5cdFx0XHRcdFx0dGhpcy5zZWNvbmRNaW5PcmlnaW5hbCA9IG8uc2Vjb25kTWluO1xuXHRcdFx0XHRcdHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbCA9IG8ubWlsbGlzZWNNaW47XG5cdFx0XHRcdFx0dGhpcy5taWNyb3NlY01pbk9yaWdpbmFsID0gby5taWNyb3NlY01pbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcF9pbnN0LnNldHRpbmdzLnRpbWVPbmx5IHx8IG1pbkRhdGVUaW1lRGF0ZS5nZXRUaW1lKCkgPT09IGRwX2RhdGUuZ2V0VGltZSgpKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbiA9IG1pbkRhdGVUaW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaG91ciA8PSB0aGlzLl9kZWZhdWx0cy5ob3VyTWluKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmhvdXIgPSB0aGlzLl9kZWZhdWx0cy5ob3VyTWluO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluID0gbWluRGF0ZVRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubWludXRlIDw9IHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLm1pbnV0ZSA9IHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbjtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluID0gbWluRGF0ZVRpbWUuZ2V0U2Vjb25kcygpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5zZWNvbmQgPD0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWNvbmQgPSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW47XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSBtaW5EYXRlVGltZS5nZXRNaWxsaXNlY29uZHMoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5taWxsaXNlYyA8PSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5taWxsaXNlYyA9IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSBtaW5EYXRlVGltZS5nZXRNaWNyb3NlY29uZHMoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMubWljcm9zZWMgPCB0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjID0gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSB0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluID0gdGhpcy5taW51dGVNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiA9IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5ob3VyTWluID0gdGhpcy5ob3VyTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluID0gdGhpcy5taW51dGVNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4gPSB0aGlzLnNlY29uZE1pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICgkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAnbWF4RGF0ZVRpbWUnKSAhPT0gbnVsbCAmJiAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAnbWF4RGF0ZVRpbWUnKSAhPT0gdW5kZWZpbmVkICYmIGRwX2RhdGUpIHtcblx0XHRcdFx0dmFyIG1heERhdGVUaW1lID0gJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21heERhdGVUaW1lJyksXG5cdFx0XHRcdFx0bWF4RGF0ZVRpbWVEYXRlID0gbmV3IERhdGUobWF4RGF0ZVRpbWUuZ2V0RnVsbFllYXIoKSwgbWF4RGF0ZVRpbWUuZ2V0TW9udGgoKSwgbWF4RGF0ZVRpbWUuZ2V0RGF0ZSgpLCAwLCAwLCAwLCAwKTtcblxuXHRcdFx0XHRpZiAodGhpcy5ob3VyTWF4T3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5taW51dGVNYXhPcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLnNlY29uZE1heE9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuaG91ck1heE9yaWdpbmFsID0gby5ob3VyTWF4O1xuXHRcdFx0XHRcdHRoaXMubWludXRlTWF4T3JpZ2luYWwgPSBvLm1pbnV0ZU1heDtcblx0XHRcdFx0XHR0aGlzLnNlY29uZE1heE9yaWdpbmFsID0gby5zZWNvbmRNYXg7XG5cdFx0XHRcdFx0dGhpcy5taWxsaXNlY01heE9yaWdpbmFsID0gby5taWxsaXNlY01heDtcblx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWwgPSBvLm1pY3Jvc2VjTWF4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRwX2luc3Quc2V0dGluZ3MudGltZU9ubHkgfHwgbWF4RGF0ZVRpbWVEYXRlLmdldFRpbWUoKSA9PT0gZHBfZGF0ZS5nZXRUaW1lKCkpIHtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5ob3VyTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0SG91cnMoKTtcblx0XHRcdFx0XHRpZiAodGhpcy5ob3VyID49IHRoaXMuX2RlZmF1bHRzLmhvdXJNYXgpIHtcblx0XHRcdFx0XHRcdHRoaXMuaG91ciA9IHRoaXMuX2RlZmF1bHRzLmhvdXJNYXg7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXggPSBtYXhEYXRlVGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5taW51dGUgPj0gdGhpcy5fZGVmYXVsdHMubWludXRlTWF4KSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubWludXRlID0gdGhpcy5fZGVmYXVsdHMubWludXRlTWF4O1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXggPSBtYXhEYXRlVGltZS5nZXRTZWNvbmRzKCk7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlY29uZCA+PSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXgpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlY29uZCA9IHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCA9IG1heERhdGVUaW1lLmdldE1pbGxpc2Vjb25kcygpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbGxpc2VjID49IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pbGxpc2VjID0gdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXg7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IG1heERhdGVUaW1lLmdldE1pY3Jvc2Vjb25kcygpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5taWNyb3NlYyA+IHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWljcm9zZWMgPSB0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gdGhpcy5taWNyb3NlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCA9IHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4ID0gdGhpcy5zZWNvbmRNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gdGhpcy5taWNyb3NlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXggPSB0aGlzLm1pbnV0ZU1heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4ID0gdGhpcy5zZWNvbmRNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNYXggPSB0aGlzLmhvdXJNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXggPSB0aGlzLm1pbnV0ZU1heE9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGRwX2luc3Quc2V0dGluZ3MubWluVGltZSE9PW51bGwpIHtcblx0XHRcdFx0dmFyIHRlbXBNaW5UaW1lPW5ldyBEYXRlKFwiMDEvMDEvMTk3MCBcIiArIGRwX2luc3Quc2V0dGluZ3MubWluVGltZSk7XG5cdFx0XHRcdGlmICh0aGlzLmhvdXI8dGVtcE1pblRpbWUuZ2V0SG91cnMoKSkge1xuXHRcdFx0XHRcdHRoaXMuaG91cj10aGlzLl9kZWZhdWx0cy5ob3VyTWluPXRlbXBNaW5UaW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0dGhpcy5taW51dGU9dGhpcy5fZGVmYXVsdHMubWludXRlTWluPXRlbXBNaW5UaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmhvdXI9PT10ZW1wTWluVGltZS5nZXRIb3VycygpICYmIHRoaXMubWludXRlPHRlbXBNaW5UaW1lLmdldE1pbnV0ZXMoKSkge1xuXHRcdFx0XHRcdHRoaXMubWludXRlPXRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmhvdXJNaW48dGVtcE1pblRpbWUuZ2V0SG91cnMoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbj10ZW1wTWluVGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluPXRlbXBNaW5UaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2RlZmF1bHRzLmhvdXJNaW49PT10ZW1wTWluVGltZS5nZXRIb3VycygpPT09dGhpcy5ob3VyICYmIHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbjx0ZW1wTWluVGltZS5nZXRNaW51dGVzKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj0wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy5tYXhUaW1lIT09bnVsbCkge1xuXHRcdFx0XHR2YXIgdGVtcE1heFRpbWU9bmV3IERhdGUoXCIwMS8wMS8xOTcwIFwiICsgZHBfaW5zdC5zZXR0aW5ncy5tYXhUaW1lKTtcblx0XHRcdFx0aWYgKHRoaXMuaG91cj50ZW1wTWF4VGltZS5nZXRIb3VycygpKSB7XG5cdFx0XHRcdFx0dGhpcy5ob3VyPXRoaXMuX2RlZmF1bHRzLmhvdXJNYXg9dGVtcE1heFRpbWUuZ2V0SG91cnMoKTtcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuaG91cj09PXRlbXBNYXhUaW1lLmdldEhvdXJzKCkgJiYgdGhpcy5taW51dGU+dGVtcE1heFRpbWUuZ2V0TWludXRlcygpKSB7XG5cdFx0XHRcdFx0dGhpcy5taW51dGU9dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1heD50ZW1wTWF4VGltZS5nZXRIb3VycygpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5ob3VyTWF4PXRlbXBNYXhUaW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1heD09PXRlbXBNYXhUaW1lLmdldEhvdXJzKCk9PT10aGlzLmhvdXIgJiYgdGhpcy5fZGVmYXVsdHMubWludXRlTWF4PnRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PTU5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWRqdXN0U2xpZGVycyAhPT0gdW5kZWZpbmVkICYmIGFkanVzdFNsaWRlcnMgPT09IHRydWUpIHtcblx0XHRcdFx0dmFyIGhvdXJNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMuaG91ck1heCAtICgodGhpcy5fZGVmYXVsdHMuaG91ck1heCAtIHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcEhvdXIpKSwgMTApLFxuXHRcdFx0XHRcdG1pbk1heCA9IHBhcnNlSW50KCh0aGlzLl9kZWZhdWx0cy5taW51dGVNYXggLSAoKHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCAtIHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbikgJSB0aGlzLl9kZWZhdWx0cy5zdGVwTWludXRlKSksIDEwKSxcblx0XHRcdFx0XHRzZWNNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4IC0gKCh0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXggLSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcFNlY29uZCkpLCAxMCksXG5cdFx0XHRcdFx0bWlsbGlzZWNNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggLSAoKHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4IC0gdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbGxpc2VjKSksIDEwKSxcblx0XHRcdFx0XHRtaWNyb3NlY01heCA9IHBhcnNlSW50KCh0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCAtICgodGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggLSB0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbikgJSB0aGlzLl9kZWZhdWx0cy5zdGVwTWljcm9zZWMpKSwgMTApO1xuXG5cdFx0XHRcdGlmICh0aGlzLmhvdXJfc2xpZGVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLm9wdGlvbnModGhpcywgdGhpcy5ob3VyX3NsaWRlciwgJ2hvdXInLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMuaG91ck1pbiwgbWF4OiBob3VyTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwSG91ciB9KTtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5ob3VyX3NsaWRlciwgJ2hvdXInLCB0aGlzLmhvdXIgLSAodGhpcy5ob3VyICUgdGhpcy5fZGVmYXVsdHMuc3RlcEhvdXIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5taW51dGVfc2xpZGVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLm9wdGlvbnModGhpcywgdGhpcy5taW51dGVfc2xpZGVyLCAnbWludXRlJywgeyBtaW46IHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbiwgbWF4OiBtaW5NYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBNaW51dGUgfSk7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWludXRlX3NsaWRlciwgJ21pbnV0ZScsIHRoaXMubWludXRlIC0gKHRoaXMubWludXRlICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbnV0ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnNlY29uZF9zbGlkZXIpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLnNlY29uZF9zbGlkZXIsICdzZWNvbmQnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluLCBtYXg6IHNlY01heCwgc3RlcDogdGhpcy5fZGVmYXVsdHMuc3RlcFNlY29uZCB9KTtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5zZWNvbmRfc2xpZGVyLCAnc2Vjb25kJywgdGhpcy5zZWNvbmQgLSAodGhpcy5zZWNvbmQgJSB0aGlzLl9kZWZhdWx0cy5zdGVwU2Vjb25kKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMubWlsbGlzZWNfc2xpZGVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLm9wdGlvbnModGhpcywgdGhpcy5taWxsaXNlY19zbGlkZXIsICdtaWxsaXNlYycsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiwgbWF4OiBtaWxsaXNlY01heCwgc3RlcDogdGhpcy5fZGVmYXVsdHMuc3RlcE1pbGxpc2VjIH0pO1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pbGxpc2VjX3NsaWRlciwgJ21pbGxpc2VjJywgdGhpcy5taWxsaXNlYyAtICh0aGlzLm1pbGxpc2VjICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbGxpc2VjKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMubWljcm9zZWNfc2xpZGVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLm9wdGlvbnModGhpcywgdGhpcy5taWNyb3NlY19zbGlkZXIsICdtaWNyb3NlYycsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiwgbWF4OiBtaWNyb3NlY01heCwgc3RlcDogdGhpcy5fZGVmYXVsdHMuc3RlcE1pY3Jvc2VjIH0pO1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pY3Jvc2VjX3NsaWRlciwgJ21pY3Jvc2VjJywgdGhpcy5taWNyb3NlYyAtICh0aGlzLm1pY3Jvc2VjICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pY3Jvc2VjKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogd2hlbiBhIHNsaWRlciBtb3Zlcywgc2V0IHRoZSBpbnRlcm5hbCB0aW1lLi4uXG5cdFx0KiBvbiB0aW1lIGNoYW5nZSBpcyBhbHNvIGNhbGxlZCB3aGVuIHRoZSB0aW1lIGlzIHVwZGF0ZWQgaW4gdGhlIHRleHQgZmllbGRcblx0XHQqL1xuXHRcdF9vblRpbWVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5fZGVmYXVsdHMuc2hvd1RpbWVwaWNrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhvdXIgPSAodGhpcy5ob3VyX3NsaWRlcikgPyB0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5ob3VyX3NsaWRlciwgJ2hvdXInKSA6IGZhbHNlLFxuXHRcdFx0XHRtaW51dGUgPSAodGhpcy5taW51dGVfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pbnV0ZV9zbGlkZXIsICdtaW51dGUnKSA6IGZhbHNlLFxuXHRcdFx0XHRzZWNvbmQgPSAodGhpcy5zZWNvbmRfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLnNlY29uZF9zbGlkZXIsICdzZWNvbmQnKSA6IGZhbHNlLFxuXHRcdFx0XHRtaWxsaXNlYyA9ICh0aGlzLm1pbGxpc2VjX3NsaWRlcikgPyB0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taWxsaXNlY19zbGlkZXIsICdtaWxsaXNlYycpIDogZmFsc2UsXG5cdFx0XHRcdG1pY3Jvc2VjID0gKHRoaXMubWljcm9zZWNfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pY3Jvc2VjX3NsaWRlciwgJ21pY3Jvc2VjJykgOiBmYWxzZSxcblx0XHRcdFx0dGltZXpvbmUgPSAodGhpcy50aW1lem9uZV9zZWxlY3QpID8gdGhpcy50aW1lem9uZV9zZWxlY3QudmFsKCkgOiBmYWxzZSxcblx0XHRcdFx0byA9IHRoaXMuX2RlZmF1bHRzLFxuXHRcdFx0XHRwaWNrZXJUaW1lRm9ybWF0ID0gby5waWNrZXJUaW1lRm9ybWF0IHx8IG8udGltZUZvcm1hdCxcblx0XHRcdFx0cGlja2VyVGltZVN1ZmZpeCA9IG8ucGlja2VyVGltZVN1ZmZpeCB8fCBvLnRpbWVTdWZmaXg7XG5cblx0XHRcdGlmICh0eXBlb2YoaG91cikgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGhvdXIgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YobWludXRlKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0bWludXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKHNlY29uZCkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHNlY29uZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZihtaWxsaXNlYykgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdG1pbGxpc2VjID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKG1pY3Jvc2VjKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0bWljcm9zZWMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YodGltZXpvbmUpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0aW1lem9uZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaG91ciAhPT0gZmFsc2UpIHtcblx0XHRcdFx0aG91ciA9IHBhcnNlSW50KGhvdXIsIDEwKTtcblx0XHRcdH1cblx0XHRcdGlmIChtaW51dGUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG1pbnV0ZSA9IHBhcnNlSW50KG1pbnV0ZSwgMTApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHNlY29uZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0c2Vjb25kID0gcGFyc2VJbnQoc2Vjb25kLCAxMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWlsbGlzZWMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG1pbGxpc2VjID0gcGFyc2VJbnQobWlsbGlzZWMsIDEwKTtcblx0XHRcdH1cblx0XHRcdGlmIChtaWNyb3NlYyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0bWljcm9zZWMgPSBwYXJzZUludChtaWNyb3NlYywgMTApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpbWV6b25lICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aW1lem9uZSA9IHRpbWV6b25lLnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhbXBtID0gb1tob3VyIDwgMTIgPyAnYW1OYW1lcycgOiAncG1OYW1lcyddWzBdO1xuXG5cdFx0XHQvLyBJZiB0aGUgdXBkYXRlIHdhcyBkb25lIGluIHRoZSBpbnB1dCBmaWVsZCwgdGhlIGlucHV0IGZpZWxkIHNob3VsZCBub3QgYmUgdXBkYXRlZC5cblx0XHRcdC8vIElmIHRoZSB1cGRhdGUgd2FzIGRvbmUgdXNpbmcgdGhlIHNsaWRlcnMsIHVwZGF0ZSB0aGUgaW5wdXQgZmllbGQuXG5cdFx0XHR2YXIgaGFzQ2hhbmdlZCA9IChcblx0XHRcdFx0XHRcdGhvdXIgIT09IHBhcnNlSW50KHRoaXMuaG91ciwxMCkgfHwgLy8gc2xpZGVycyBzaG91bGQgYWxsIGJlIG51bWVyaWNcblx0XHRcdFx0XHRcdG1pbnV0ZSAhPT0gcGFyc2VJbnQodGhpcy5taW51dGUsMTApIHx8XG5cdFx0XHRcdFx0XHRzZWNvbmQgIT09IHBhcnNlSW50KHRoaXMuc2Vjb25kLDEwKSB8fFxuXHRcdFx0XHRcdFx0bWlsbGlzZWMgIT09IHBhcnNlSW50KHRoaXMubWlsbGlzZWMsMTApIHx8XG5cdFx0XHRcdFx0XHRtaWNyb3NlYyAhPT0gcGFyc2VJbnQodGhpcy5taWNyb3NlYywxMCkgfHxcblx0XHRcdFx0XHRcdCh0aGlzLmFtcG0ubGVuZ3RoID4gMCAmJiAoaG91ciA8IDEyKSAhPT0gKCQuaW5BcnJheSh0aGlzLmFtcG0udG9VcHBlckNhc2UoKSwgdGhpcy5hbU5hbWVzKSAhPT0gLTEpKSB8fFxuXHRcdFx0XHRcdFx0KHRoaXMudGltZXpvbmUgIT09IG51bGwgJiYgdGltZXpvbmUgIT09IHRoaXMudGltZXpvbmUudG9TdHJpbmcoKSkgLy8gY291bGQgYmUgbnVtZXJpYyBvciBcIkVTVFwiIGZvcm1hdCwgc28gdXNlIHRvU3RyaW5nKClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRpZiAoaGFzQ2hhbmdlZCkge1xuXG5cdFx0XHRcdGlmIChob3VyICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoaXMuaG91ciA9IGhvdXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pbnV0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZSA9IG1pbnV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2Vjb25kICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoaXMuc2Vjb25kID0gc2Vjb25kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtaWxsaXNlYyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLm1pbGxpc2VjID0gbWlsbGlzZWM7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pY3Jvc2VjICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoaXMubWljcm9zZWMgPSBtaWNyb3NlYztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZXpvbmUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy50aW1lem9uZSA9IHRpbWV6b25lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLmluc3QpIHtcblx0XHRcdFx0XHR0aGlzLmluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QodGhpcy4kaW5wdXRbMF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbGltaXRNaW5NYXhEYXRlVGltZSh0aGlzLmluc3QsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuc3VwcG9ydC5hbXBtKSB7XG5cdFx0XHRcdHRoaXMuYW1wbSA9IGFtcG07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZXMgdGhlIHRpbWUgd2l0aGluIHRoZSB0aW1lcGlja2VyXG5cdFx0XHR0aGlzLmZvcm1hdHRlZFRpbWUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0VGltZShvLnRpbWVGb3JtYXQsIHRoaXMsIG8pO1xuXHRcdFx0aWYgKHRoaXMuJHRpbWVPYmopIHtcblx0XHRcdFx0aWYgKHBpY2tlclRpbWVGb3JtYXQgPT09IG8udGltZUZvcm1hdCkge1xuXHRcdFx0XHRcdHRoaXMuJHRpbWVPYmoudmFsKHRoaXMuZm9ybWF0dGVkVGltZSArIHBpY2tlclRpbWVTdWZmaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuJHRpbWVPYmoudmFsKCQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKHBpY2tlclRpbWVGb3JtYXQsIHRoaXMsIG8pICsgcGlja2VyVGltZVN1ZmZpeCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuJHRpbWVPYmpbMF0uc2V0U2VsZWN0aW9uUmFuZ2UpIHtcblx0XHRcdFx0XHR2YXIgc1BvcyA9IHRoaXMuJHRpbWVPYmpbMF0uc2VsZWN0aW9uU3RhcnQ7XG5cdFx0XHRcdFx0dmFyIGVQb3MgPSB0aGlzLiR0aW1lT2JqWzBdLnNlbGVjdGlvbkVuZDtcblx0XHRcdFx0XHR0aGlzLiR0aW1lT2JqWzBdLnNldFNlbGVjdGlvblJhbmdlKHNQb3MsIGVQb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGltZURlZmluZWQgPSB0cnVlO1xuXHRcdFx0aWYgKGhhc0NoYW5nZWQpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlRGF0ZVRpbWUoKTtcblx0XHRcdFx0Ly90aGlzLiRpbnB1dC5mb2N1cygpOyAvLyBtYXkgYXV0b21hdGljYWxseSBvcGVuIHRoZSBwaWNrZXIgb24gc2V0RGF0ZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogY2FsbCBjdXN0b20gb25TZWxlY3QuXG5cdFx0KiBiaW5kIHRvIHNsaWRlcnMgc2xpZGVzdG9wLCBhbmQgZ3JpZCBjbGljay5cblx0XHQqL1xuXHRcdF9vblNlbGVjdEhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBvblNlbGVjdCA9IHRoaXMuX2RlZmF1bHRzLm9uU2VsZWN0IHx8IHRoaXMuaW5zdC5zZXR0aW5ncy5vblNlbGVjdDtcblx0XHRcdHZhciBpbnB1dEVsID0gdGhpcy4kaW5wdXQgPyB0aGlzLiRpbnB1dFswXSA6IG51bGw7XG5cdFx0XHRpZiAob25TZWxlY3QgJiYgaW5wdXRFbCkge1xuXHRcdFx0XHRvblNlbGVjdC5hcHBseShpbnB1dEVsLCBbdGhpcy5mb3JtYXR0ZWREYXRlVGltZSwgdGhpc10pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogdXBkYXRlIG91ciBpbnB1dCB3aXRoIHRoZSBuZXcgZGF0ZSB0aW1lLi5cblx0XHQqL1xuXHRcdF91cGRhdGVEYXRlVGltZTogZnVuY3Rpb24gKGRwX2luc3QpIHtcblx0XHRcdGRwX2luc3QgPSB0aGlzLmluc3QgfHwgZHBfaW5zdDtcblx0XHRcdHZhciBkdFRtcCA9IChkcF9pbnN0LmN1cnJlbnRZZWFyID4gMD9cblx0XHRcdFx0XHRcdFx0bmV3IERhdGUoZHBfaW5zdC5jdXJyZW50WWVhciwgZHBfaW5zdC5jdXJyZW50TW9udGgsIGRwX2luc3QuY3VycmVudERheSkgOlxuXHRcdFx0XHRcdFx0XHRuZXcgRGF0ZShkcF9pbnN0LnNlbGVjdGVkWWVhciwgZHBfaW5zdC5zZWxlY3RlZE1vbnRoLCBkcF9pbnN0LnNlbGVjdGVkRGF5KSksXG5cdFx0XHRcdGR0ID0gJC5kYXRlcGlja2VyLl9kYXlsaWdodFNhdmluZ0FkanVzdChkdFRtcCksXG5cdFx0XHRcdC8vZHQgPSAkLmRhdGVwaWNrZXIuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRwX2luc3Quc2VsZWN0ZWRZZWFyLCBkcF9pbnN0LnNlbGVjdGVkTW9udGgsIGRwX2luc3Quc2VsZWN0ZWREYXkpKSxcblx0XHRcdFx0Ly9kdCA9ICQuZGF0ZXBpY2tlci5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHBfaW5zdC5jdXJyZW50WWVhciwgZHBfaW5zdC5jdXJyZW50TW9udGgsIGRwX2luc3QuY3VycmVudERheSkpLFxuXHRcdFx0XHRkYXRlRm10ID0gJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ2RhdGVGb3JtYXQnKSxcblx0XHRcdFx0Zm9ybWF0Q2ZnID0gJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoZHBfaW5zdCksXG5cdFx0XHRcdHRpbWVBdmFpbGFibGUgPSBkdCAhPT0gbnVsbCAmJiB0aGlzLnRpbWVEZWZpbmVkO1xuXHRcdFx0dGhpcy5mb3JtYXR0ZWREYXRlID0gJC5kYXRlcGlja2VyLmZvcm1hdERhdGUoZGF0ZUZtdCwgKGR0ID09PSBudWxsID8gbmV3IERhdGUoKSA6IGR0KSwgZm9ybWF0Q2ZnKTtcblx0XHRcdHZhciBmb3JtYXR0ZWREYXRlVGltZSA9IHRoaXMuZm9ybWF0dGVkRGF0ZTtcblxuXHRcdFx0Ly8gaWYgYSBzbGlkZXIgd2FzIGNoYW5nZWQgYnV0IGRhdGVwaWNrZXIgZG9lc24ndCBoYXZlIGEgdmFsdWUgeWV0LCBzZXQgaXRcblx0XHRcdGlmIChkcF9pbnN0Lmxhc3RWYWwgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBkcF9pbnN0LmN1cnJlbnRZZWFyID0gZHBfaW5zdC5zZWxlY3RlZFllYXI7XG4gICAgICAgICAgICAgICAgZHBfaW5zdC5jdXJyZW50TW9udGggPSBkcF9pbnN0LnNlbGVjdGVkTW9udGg7XG4gICAgICAgICAgICAgICAgZHBfaW5zdC5jdXJyZW50RGF5ID0gZHBfaW5zdC5zZWxlY3RlZERheTtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0Lypcblx0XHRcdCogcmVtb3ZlIGZvbGxvd2luZyBsaW5lcyB0byBmb3JjZSBldmVyeSBjaGFuZ2VzIGluIGRhdGUgcGlja2VyIHRvIGNoYW5nZSB0aGUgaW5wdXQgdmFsdWVcblx0XHRcdCogQnVnIGRlc2NyaXB0aW9uczogd2hlbiBhbiBpbnB1dCBmaWVsZCBoYXMgYSBkZWZhdWx0IHZhbHVlLCBhbmQgY2xpY2sgb24gdGhlIGZpZWxkIHRvIHBvcCB1cCB0aGUgZGF0ZSBwaWNrZXIuXG5cdFx0XHQqIElmIHRoZSB1c2VyIG1hbnVhbGx5IGVtcHR5IHRoZSB2YWx1ZSBpbiB0aGUgaW5wdXQgZmllbGQsIHRoZSBkYXRlIHBpY2tlciB3aWxsIG5ldmVyIGNoYW5nZSBzZWxlY3RlZCB2YWx1ZS5cblx0XHRcdCovXG5cdFx0XHQvL2lmIChkcF9pbnN0Lmxhc3RWYWwgIT09IHVuZGVmaW5lZCAmJiAoZHBfaW5zdC5sYXN0VmFsLmxlbmd0aCA+IDAgJiYgdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoID09PSAwKSkge1xuXHRcdFx0Ly9cdHJldHVybjtcblx0XHRcdC8vfVxuXG5cdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMudGltZU9ubHkgPT09IHRydWUgJiYgdGhpcy5fZGVmYXVsdHMudGltZU9ubHlTaG93RGF0ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Zm9ybWF0dGVkRGF0ZVRpbWUgPSB0aGlzLmZvcm1hdHRlZFRpbWU7XG5cdFx0XHR9IGVsc2UgaWYgKCh0aGlzLl9kZWZhdWx0cy50aW1lT25seSAhPT0gdHJ1ZSAmJiAodGhpcy5fZGVmYXVsdHMuYWx3YXlzU2V0VGltZSB8fCB0aW1lQXZhaWxhYmxlKSkgfHwgKHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ID09PSB0cnVlICYmIHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5U2hvd0RhdGUgPT09IHRydWUpKSB7XG5cdFx0XHRcdGZvcm1hdHRlZERhdGVUaW1lICs9IHRoaXMuX2RlZmF1bHRzLnNlcGFyYXRvciArIHRoaXMuZm9ybWF0dGVkVGltZSArIHRoaXMuX2RlZmF1bHRzLnRpbWVTdWZmaXg7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZm9ybWF0dGVkRGF0ZVRpbWUgPSBmb3JtYXR0ZWREYXRlVGltZTtcblxuXHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy5zaG93VGltZXBpY2tlcikge1xuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwodGhpcy5mb3JtYXR0ZWREYXRlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy4kYWx0SW5wdXQgJiYgdGhpcy5fZGVmYXVsdHMudGltZU9ubHkgPT09IGZhbHNlICYmIHRoaXMuX2RlZmF1bHRzLmFsdEZpZWxkVGltZU9ubHkgPT09IHRydWUpIHtcblx0XHRcdFx0dGhpcy4kYWx0SW5wdXQudmFsKHRoaXMuZm9ybWF0dGVkVGltZSk7XG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbCh0aGlzLmZvcm1hdHRlZERhdGUpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLiRhbHRJbnB1dCkge1xuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwoZm9ybWF0dGVkRGF0ZVRpbWUpO1xuXHRcdFx0XHR2YXIgYWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSAnJyxcblx0XHRcdFx0XHRhbHRTZXBhcmF0b3IgPSB0aGlzLl9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgIT09IG51bGwgPyB0aGlzLl9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgOiB0aGlzLl9kZWZhdWx0cy5zZXBhcmF0b3IsXG5cdFx0XHRcdFx0YWx0VGltZVN1ZmZpeCA9IHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggIT09IG51bGwgPyB0aGlzLl9kZWZhdWx0cy5hbHRUaW1lU3VmZml4IDogdGhpcy5fZGVmYXVsdHMudGltZVN1ZmZpeDtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5KSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmFsdEZvcm1hdCkge1xuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0aGlzLl9kZWZhdWx0cy5hbHRGb3JtYXQsIChkdCA9PT0gbnVsbCA/IG5ldyBEYXRlKCkgOiBkdCksIGZvcm1hdENmZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSB0aGlzLmZvcm1hdHRlZERhdGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGFsdEZvcm1hdHRlZERhdGVUaW1lKSB7XG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSArPSBhbHRTZXBhcmF0b3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSArPSAkLmRhdGVwaWNrZXIuZm9ybWF0VGltZSh0aGlzLl9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0LCB0aGlzLCB0aGlzLl9kZWZhdWx0cykgKyBhbHRUaW1lU3VmZml4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lICs9IHRoaXMuZm9ybWF0dGVkVGltZSArIGFsdFRpbWVTdWZmaXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy4kYWx0SW5wdXQudmFsKGFsdEZvcm1hdHRlZERhdGVUaW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbChmb3JtYXR0ZWREYXRlVGltZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuJGlucHV0LnRyaWdnZXIoXCJjaGFuZ2VcIik7XG5cdFx0fSxcblxuXHRcdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXRoaXMuJGlucHV0LnZhbCgpICYmIHRoaXMuX2RlZmF1bHRzLmRlZmF1bHRWYWx1ZSkge1xuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwodGhpcy5fZGVmYXVsdHMuZGVmYXVsdFZhbHVlKTtcblx0XHRcdFx0dmFyIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QodGhpcy4kaW5wdXQuZ2V0KDApKSxcblx0XHRcdFx0XHR0cF9pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRcdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMudGltZU9ubHkgJiYgKGluc3QuaW5wdXQudmFsKCkgIT09IGluc3QubGFzdFZhbCkpIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKGVycik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBTbWFsbCBhYnN0cmFjdGlvbiB0byBjb250cm9sIHR5cGVzXG5cdFx0KiBXZSBjYW4gYWRkIG1vcmUsIGp1c3QgYmUgc3VyZSB0byBmb2xsb3cgdGhlIHBhdHRlcm46IGNyZWF0ZSwgb3B0aW9ucywgdmFsdWVcblx0XHQqL1xuXHRcdF9jb250cm9sczoge1xuXHRcdFx0Ly8gc2xpZGVyIG1ldGhvZHNcblx0XHRcdHNsaWRlcjoge1xuXHRcdFx0XHRjcmVhdGU6IGZ1bmN0aW9uICh0cF9pbnN0LCBvYmosIHVuaXQsIHZhbCwgbWluLCBtYXgsIHN0ZXApIHtcblx0XHRcdFx0XHR2YXIgcnRsID0gdHBfaW5zdC5fZGVmYXVsdHMuaXNSVEw7IC8vIGlmIHJ0bCBnbyAtNjAtPjAgaW5zdGVhZCBvZiAwLT42MFxuXHRcdFx0XHRcdHJldHVybiBvYmoucHJvcCgnc2xpZGUnLCBudWxsKS5zbGlkZXIoe1xuXHRcdFx0XHRcdFx0b3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHJ0bCA/IHZhbCAqIC0xIDogdmFsLFxuXHRcdFx0XHRcdFx0bWluOiBydGwgPyBtYXggKiAtMSA6IG1pbixcblx0XHRcdFx0XHRcdG1heDogcnRsID8gbWluICogLTEgOiBtYXgsXG5cdFx0XHRcdFx0XHRzdGVwOiBzdGVwLFxuXHRcdFx0XHRcdFx0c2xpZGU6IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5jb250cm9sLnZhbHVlKHRwX2luc3QsICQodGhpcyksIHVuaXQsIHJ0bCA/IHVpLnZhbHVlICogLTEgOiB1aS52YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHN0b3A6IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9wdGlvbnM6IGZ1bmN0aW9uICh0cF9pbnN0LCBvYmosIHVuaXQsIG9wdHMsIHZhbCkge1xuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5pc1JUTCkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihvcHRzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMgPT09ICdtaW4nIHx8IG9wdHMgPT09ICdtYXgnKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzLCB2YWwgKiAtMSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBNYXRoLmFicyhvYmouc2xpZGVyKG9wdHMpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBtaW4gPSBvcHRzLm1pbixcblx0XHRcdFx0XHRcdFx0bWF4ID0gb3B0cy5tYXg7XG5cdFx0XHRcdFx0XHRvcHRzLm1pbiA9IG9wdHMubWF4ID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRvcHRzLm1heCA9IG1pbiAqIC0xO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdG9wdHMubWluID0gbWF4ICogLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihvcHRzKSA9PT0gJ3N0cmluZycgJiYgdmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMsIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR2YWx1ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsKSB7XG5cdFx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmlzUlRMKSB7XG5cdFx0XHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIoJ3ZhbHVlJywgdmFsICogLTEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIE1hdGguYWJzKG9iai5zbGlkZXIoJ3ZhbHVlJykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKCd2YWx1ZScsIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKCd2YWx1ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ly8gc2VsZWN0IG1ldGhvZHNcblx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRjcmVhdGU6IGZ1bmN0aW9uICh0cF9pbnN0LCBvYmosIHVuaXQsIHZhbCwgbWluLCBtYXgsIHN0ZXApIHtcblx0XHRcdFx0XHR2YXIgc2VsID0gJzxzZWxlY3QgY2xhc3M9XCJ1aS10aW1lcGlja2VyLXNlbGVjdCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcIiBkYXRhLXVuaXQ9XCInICsgdW5pdCArICdcIiBkYXRhLW1pbj1cIicgKyBtaW4gKyAnXCIgZGF0YS1tYXg9XCInICsgbWF4ICsgJ1wiIGRhdGEtc3RlcD1cIicgKyBzdGVwICsgJ1wiPicsXG5cdFx0XHRcdFx0XHRmb3JtYXQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5waWNrZXJUaW1lRm9ybWF0IHx8IHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQ7XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpID0gbWluOyBpIDw9IG1heDsgaSArPSBzdGVwKSB7XG5cdFx0XHRcdFx0XHRzZWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIicgKyAoaSA9PT0gdmFsID8gJyBzZWxlY3RlZCcgOiAnJykgKyAnPic7XG5cdFx0XHRcdFx0XHRpZiAodW5pdCA9PT0gJ2hvdXInKSB7XG5cdFx0XHRcdFx0XHRcdHNlbCArPSAkLmRhdGVwaWNrZXIuZm9ybWF0VGltZSgkLnRyaW0oZm9ybWF0LnJlcGxhY2UoL1teaHQgXS9pZywgJycpKSwge2hvdXI6IGl9LCB0cF9pbnN0Ll9kZWZhdWx0cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh1bml0ID09PSAnbWlsbGlzZWMnIHx8IHVuaXQgPT09ICdtaWNyb3NlYycgfHwgaSA+PSAxMCkgeyBzZWwgKz0gaTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7c2VsICs9ICcwJyArIGkudG9TdHJpbmcoKTsgfVxuXHRcdFx0XHRcdFx0c2VsICs9ICc8L29wdGlvbj4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWwgKz0gJzwvc2VsZWN0Pic7XG5cblx0XHRcdFx0XHRvYmouY2hpbGRyZW4oJ3NlbGVjdCcpLnJlbW92ZSgpO1xuXG5cdFx0XHRcdFx0JChzZWwpLmFwcGVuZFRvKG9iaikuY2hhbmdlKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblRpbWVDaGFuZ2UoKTtcblx0XHRcdFx0XHRcdHRwX2luc3QuX29uU2VsZWN0SGFuZGxlcigpO1xuXHRcdFx0XHRcdFx0dHBfaW5zdC5fYWZ0ZXJJbmplY3QoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9wdGlvbnM6IGZ1bmN0aW9uICh0cF9pbnN0LCBvYmosIHVuaXQsIG9wdHMsIHZhbCkge1xuXHRcdFx0XHRcdHZhciBvID0ge30sXG5cdFx0XHRcdFx0XHQkdCA9IG9iai5jaGlsZHJlbignc2VsZWN0Jyk7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihvcHRzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJHQuZGF0YShvcHRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9bb3B0c10gPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyBvID0gb3B0czsgfVxuXHRcdFx0XHRcdHJldHVybiB0cF9pbnN0LmNvbnRyb2wuY3JlYXRlKHRwX2luc3QsIG9iaiwgJHQuZGF0YSgndW5pdCcpLCAkdC52YWwoKSwgby5taW4+PTAgPyBvLm1pbiA6ICR0LmRhdGEoJ21pbicpLCBvLm1heCB8fCAkdC5kYXRhKCdtYXgnKSwgby5zdGVwIHx8ICR0LmRhdGEoJ3N0ZXAnKSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbHVlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwpIHtcblx0XHRcdFx0XHR2YXIgJHQgPSBvYmouY2hpbGRyZW4oJ3NlbGVjdCcpO1xuXHRcdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICR0LnZhbCh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gJHQudmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IC8vIGVuZCBfY29udHJvbHNcblxuXHR9KTtcblxuXHQkLmZuLmV4dGVuZCh7XG5cdFx0Lypcblx0XHQqIHNob3J0aGFuZCBqdXN0IHRvIHVzZSB0aW1lcGlja2VyLlxuXHRcdCovXG5cdFx0dGltZXBpY2tlcjogZnVuY3Rpb24gKG8pIHtcblx0XHRcdG8gPSBvIHx8IHt9O1xuXHRcdFx0dmFyIHRtcF9hcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBvID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0bXBfYXJnc1swXSA9ICQuZXh0ZW5kKG8sIHtcblx0XHRcdFx0XHR0aW1lT25seTogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdCQuZm4uZGF0ZXRpbWVwaWNrZXIuYXBwbHkoJCh0aGlzKSwgdG1wX2FyZ3MpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBleHRlbmQgdGltZXBpY2tlciB0byBkYXRlcGlja2VyXG5cdFx0Ki9cblx0XHRkYXRldGltZXBpY2tlcjogZnVuY3Rpb24gKG8pIHtcblx0XHRcdG8gPSBvIHx8IHt9O1xuXHRcdFx0dmFyIHRtcF9hcmdzID0gYXJndW1lbnRzO1xuXG5cdFx0XHRpZiAodHlwZW9mKG8pID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAobyA9PT0gJ2dldERhdGUnICB8fCAobyA9PT0gJ29wdGlvbicgJiYgdG1wX2FyZ3MubGVuZ3RoID09PSAyICYmIHR5cGVvZiAodG1wX2FyZ3NbMV0pID09PSAnc3RyaW5nJykpIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5mbi5kYXRlcGlja2VyLmFwcGx5KCQodGhpc1swXSksIHRtcF9hcmdzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyk7XG5cdFx0XHRcdFx0XHQkdC5kYXRlcGlja2VyLmFwcGx5KCR0LCB0bXBfYXJncyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyk7XG5cdFx0XHRcdFx0JHQuZGF0ZXBpY2tlcigkLnRpbWVwaWNrZXIuX25ld0luc3QoJHQsIG8pLl9kZWZhdWx0cyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Lypcblx0KiBQdWJsaWMgVXRpbGl0eSB0byBwYXJzZSBkYXRlIGFuZCB0aW1lXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5wYXJzZURhdGVUaW1lID0gZnVuY3Rpb24gKGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIGRhdGVUaW1lU3RyaW5nLCBkYXRlU2V0dGluZ3MsIHRpbWVTZXR0aW5ncykge1xuXHRcdHZhciBwYXJzZVJlcyA9IHBhcnNlRGF0ZVRpbWVJbnRlcm5hbChkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCBkYXRlVGltZVN0cmluZywgZGF0ZVNldHRpbmdzLCB0aW1lU2V0dGluZ3MpO1xuXHRcdGlmIChwYXJzZVJlcy50aW1lT2JqKSB7XG5cdFx0XHR2YXIgdCA9IHBhcnNlUmVzLnRpbWVPYmo7XG5cdFx0XHRwYXJzZVJlcy5kYXRlLnNldEhvdXJzKHQuaG91ciwgdC5taW51dGUsIHQuc2Vjb25kLCB0Lm1pbGxpc2VjKTtcblx0XHRcdHBhcnNlUmVzLmRhdGUuc2V0TWljcm9zZWNvbmRzKHQubWljcm9zZWMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZVJlcy5kYXRlO1xuXHR9O1xuXG5cdC8qXG5cdCogUHVibGljIHV0aWxpdHkgdG8gcGFyc2UgdGltZVxuXHQqL1xuXHQkLmRhdGVwaWNrZXIucGFyc2VUaW1lID0gZnVuY3Rpb24gKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG9wdGlvbnMpIHtcblx0XHR2YXIgbyA9IGV4dGVuZFJlbW92ZShleHRlbmRSZW1vdmUoe30sICQudGltZXBpY2tlci5fZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KSxcblx0XHRcdGlzbzg2MDEgPSAodGltZUZvcm1hdC5yZXBsYWNlKC9cXCcuKj9cXCcvZywgJycpLmluZGV4T2YoJ1onKSAhPT0gLTEpO1xuXG5cdFx0Ly8gU3RyaWN0IHBhcnNlIHJlcXVpcmVzIHRoZSB0aW1lU3RyaW5nIHRvIG1hdGNoIHRoZSB0aW1lRm9ybWF0IGV4YWN0bHlcblx0XHR2YXIgc3RyaWN0UGFyc2UgPSBmdW5jdGlvbiAoZiwgcywgbykge1xuXG5cdFx0XHQvLyBwYXR0ZXJuIGZvciBzdGFuZGFyZCBhbmQgbG9jYWxpemVkIEFNL1BNIG1hcmtlcnNcblx0XHRcdHZhciBnZXRQYXR0ZXJuQW1wbSA9IGZ1bmN0aW9uIChhbU5hbWVzLCBwbU5hbWVzKSB7XG5cdFx0XHRcdHZhciBtYXJrZXJzID0gW107XG5cdFx0XHRcdGlmIChhbU5hbWVzKSB7XG5cdFx0XHRcdFx0JC5tZXJnZShtYXJrZXJzLCBhbU5hbWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocG1OYW1lcykge1xuXHRcdFx0XHRcdCQubWVyZ2UobWFya2VycywgcG1OYW1lcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWFya2VycyA9ICQubWFwKG1hcmtlcnMsIGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoL1suKis/fCgpXFxbXFxde31cXFxcXS9nLCAnXFxcXCQmJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gJygnICsgbWFya2Vycy5qb2luKCd8JykgKyAnKT8nO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZmlndXJlIG91dCBwb3NpdGlvbiBvZiB0aW1lIGVsZW1lbnRzLi4gY2F1c2UganMgY2FudCBkbyBuYW1lZCBjYXB0dXJlc1xuXHRcdFx0dmFyIGdldEZvcm1hdFBvc2l0aW9ucyA9IGZ1bmN0aW9uICh0aW1lRm9ybWF0KSB7XG5cdFx0XHRcdHZhciBmaW5kcyA9IHRpbWVGb3JtYXQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGh7MSwyfXxtezEsMn18c3sxLDJ9fGx7MX18Y3sxfXx0ezEsMn18enwnLio/JykvZyksXG5cdFx0XHRcdFx0b3JkZXJzID0ge1xuXHRcdFx0XHRcdFx0aDogLTEsXG5cdFx0XHRcdFx0XHRtOiAtMSxcblx0XHRcdFx0XHRcdHM6IC0xLFxuXHRcdFx0XHRcdFx0bDogLTEsXG5cdFx0XHRcdFx0XHRjOiAtMSxcblx0XHRcdFx0XHRcdHQ6IC0xLFxuXHRcdFx0XHRcdFx0ejogLTFcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmIChmaW5kcykge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmluZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChvcmRlcnNbZmluZHNbaV0udG9TdHJpbmcoKS5jaGFyQXQoMCldID09PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRvcmRlcnNbZmluZHNbaV0udG9TdHJpbmcoKS5jaGFyQXQoMCldID0gaSArIDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmRlcnM7XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcmVnc3RyID0gJ14nICsgZi50b1N0cmluZygpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyhbaEhdezEsMn18bW0/fHNzP3xbdFRdezEsMn18W3paXXxbbGNdfCcuKj8nKS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1sID0gbWF0Y2gubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKG1hdGNoLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBtbCA9PT0gMSA/ICcoXFxcXGQ/XFxcXGQpJyA6ICcoXFxcXGR7JyArIG1sICsgJ30pJztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG1sID09PSAxID8gJyhcXFxcZD9cXFxcZCknIDogJyhcXFxcZHsnICsgbWwgKyAnfSknO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAnKFxcXFxkP1xcXFxkP1xcXFxkKSc7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAnKFxcXFxkP1xcXFxkP1xcXFxkKSc7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3onOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAnKHp8Wy0rXVxcXFxkXFxcXGQ6P1xcXFxkXFxcXGR8XFxcXFMrKT8nO1xuXHRcdFx0XHRcdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0UGF0dGVybkFtcG0oby5hbU5hbWVzLCBvLnBtTmFtZXMpO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiAgICAvLyBsaXRlcmFsIGVzY2FwZWQgaW4gcXVvdGVzXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICcoJyArIG1hdGNoLnJlcGxhY2UoL1xcJy9nLCBcIlwiKS5yZXBsYWNlKC8oXFwufFxcJHxcXF58XFxcXHxcXC98XFwofFxcKXxcXFt8XFxdfFxcP3xcXCt8XFwqKS9nLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gXCJcXFxcXCIgKyBtOyB9KSArICcpPyc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xccy9nLCAnXFxcXHM/JykgK1xuXHRcdFx0XHRcdG8udGltZVN1ZmZpeCArICckJyxcblx0XHRcdFx0b3JkZXIgPSBnZXRGb3JtYXRQb3NpdGlvbnMoZiksXG5cdFx0XHRcdGFtcG0gPSAnJyxcblx0XHRcdFx0dHJlZztcblxuXHRcdFx0dHJlZyA9IHMubWF0Y2gobmV3IFJlZ0V4cChyZWdzdHIsICdpJykpO1xuXG5cdFx0XHR2YXIgcmVzVGltZSA9IHtcblx0XHRcdFx0aG91cjogMCxcblx0XHRcdFx0bWludXRlOiAwLFxuXHRcdFx0XHRzZWNvbmQ6IDAsXG5cdFx0XHRcdG1pbGxpc2VjOiAwLFxuXHRcdFx0XHRtaWNyb3NlYzogMFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRyZWcpIHtcblx0XHRcdFx0aWYgKG9yZGVyLnQgIT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRyZWdbb3JkZXIudF0gPT09IHVuZGVmaW5lZCB8fCB0cmVnW29yZGVyLnRdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0YW1wbSA9ICcnO1xuXHRcdFx0XHRcdFx0cmVzVGltZS5hbXBtID0gJyc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFtcG0gPSAkLmluQXJyYXkodHJlZ1tvcmRlci50XS50b1VwcGVyQ2FzZSgpLCAkLm1hcChvLmFtTmFtZXMsIGZ1bmN0aW9uICh4LGkpIHsgcmV0dXJuIHgudG9VcHBlckNhc2UoKTsgfSkpICE9PSAtMSA/ICdBTScgOiAnUE0nO1xuXHRcdFx0XHRcdFx0cmVzVGltZS5hbXBtID0gb1thbXBtID09PSAnQU0nID8gJ2FtTmFtZXMnIDogJ3BtTmFtZXMnXVswXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3JkZXIuaCAhPT0gLTEpIHtcblx0XHRcdFx0XHRpZiAoYW1wbSA9PT0gJ0FNJyAmJiB0cmVnW29yZGVyLmhdID09PSAnMTInKSB7XG5cdFx0XHRcdFx0XHRyZXNUaW1lLmhvdXIgPSAwOyAvLyAxMmFtID0gMCBob3VyXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChhbXBtID09PSAnUE0nICYmIHRyZWdbb3JkZXIuaF0gIT09ICcxMicpIHtcblx0XHRcdFx0XHRcdFx0cmVzVGltZS5ob3VyID0gcGFyc2VJbnQodHJlZ1tvcmRlci5oXSwgMTApICsgMTI7IC8vIDEycG0gPSAxMiBob3VyLCBhbnkgb3RoZXIgcG0gPSBob3VyICsgMTJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlc1RpbWUuaG91ciA9IE51bWJlcih0cmVnW29yZGVyLmhdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3JkZXIubSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXNUaW1lLm1pbnV0ZSA9IE51bWJlcih0cmVnW29yZGVyLm1dKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3JkZXIucyAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXNUaW1lLnNlY29uZCA9IE51bWJlcih0cmVnW29yZGVyLnNdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3JkZXIubCAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXNUaW1lLm1pbGxpc2VjID0gTnVtYmVyKHRyZWdbb3JkZXIubF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcmRlci5jICE9PSAtMSkge1xuXHRcdFx0XHRcdHJlc1RpbWUubWljcm9zZWMgPSBOdW1iZXIodHJlZ1tvcmRlci5jXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9yZGVyLnogIT09IC0xICYmIHRyZWdbb3JkZXIuel0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJlc1RpbWUudGltZXpvbmUgPSAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXROdW1iZXIodHJlZ1tvcmRlci56XSk7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdHJldHVybiByZXNUaW1lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07Ly8gZW5kIHN0cmljdFBhcnNlXG5cblx0XHQvLyBGaXJzdCB0cnkgSlMgRGF0ZSwgaWYgdGhhdCBmYWlscywgdXNlIHN0cmljdFBhcnNlXG5cdFx0dmFyIGxvb3NlUGFyc2UgPSBmdW5jdGlvbiAoZiwgcywgbykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSgnMjAxMi0wMS0wMSAnICsgcyk7XG5cdFx0XHRcdGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcblx0XHRcdFx0XHRkID0gbmV3IERhdGUoJzIwMTItMDEtMDFUJyArIHMpO1xuXHRcdFx0XHRcdGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcblx0XHRcdFx0XHRcdGQgPSBuZXcgRGF0ZSgnMDEvMDEvMjAxMiAnICsgcyk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IFwiVW5hYmxlIHRvIHBhcnNlIHRpbWUgd2l0aCBuYXRpdmUgRGF0ZTogXCIgKyBzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aG91cjogZC5nZXRIb3VycygpLFxuXHRcdFx0XHRcdG1pbnV0ZTogZC5nZXRNaW51dGVzKCksXG5cdFx0XHRcdFx0c2Vjb25kOiBkLmdldFNlY29uZHMoKSxcblx0XHRcdFx0XHRtaWxsaXNlYzogZC5nZXRNaWxsaXNlY29uZHMoKSxcblx0XHRcdFx0XHRtaWNyb3NlYzogZC5nZXRNaWNyb3NlY29uZHMoKSxcblx0XHRcdFx0XHR0aW1lem9uZTogZC5nZXRUaW1lem9uZU9mZnNldCgpICogLTFcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaWN0UGFyc2UoZiwgcywgbyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKFwiVW5hYmxlIHRvIHBhcnNlIFxcbnRpbWVTdHJpbmc6IFwiICsgcyArIFwiXFxudGltZUZvcm1hdDogXCIgKyBmKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07IC8vIGVuZCBsb29zZVBhcnNlXG5cblx0XHRpZiAodHlwZW9mIG8ucGFyc2UgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0cmV0dXJuIG8ucGFyc2UodGltZUZvcm1hdCwgdGltZVN0cmluZywgbyk7XG5cdFx0fVxuXHRcdGlmIChvLnBhcnNlID09PSAnbG9vc2UnKSB7XG5cdFx0XHRyZXR1cm4gbG9vc2VQYXJzZSh0aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCBvKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cmljdFBhcnNlKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG8pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQdWJsaWMgdXRpbGl0eSB0byBmb3JtYXQgdGhlIHRpbWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBmb3JtYXQgb2YgdGhlIHRpbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRpbWUgT2JqZWN0IG5vdCBhIERhdGUgZm9yIHRpbWV6b25lc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGVzc2VudGlhbGx5IHRoZSByZWdpb25hbFtdLi4gYW1OYW1lcywgcG1OYW1lcywgYW1wbVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZm9ybWF0dGVkIHRpbWVcblx0ICovXG5cdCQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lID0gZnVuY3Rpb24gKGZvcm1hdCwgdGltZSwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC50aW1lcGlja2VyLl9kZWZhdWx0cywgb3B0aW9ucyk7XG5cdFx0dGltZSA9ICQuZXh0ZW5kKHtcblx0XHRcdGhvdXI6IDAsXG5cdFx0XHRtaW51dGU6IDAsXG5cdFx0XHRzZWNvbmQ6IDAsXG5cdFx0XHRtaWxsaXNlYzogMCxcblx0XHRcdG1pY3Jvc2VjOiAwLFxuXHRcdFx0dGltZXpvbmU6IG51bGxcblx0XHR9LCB0aW1lKTtcblxuXHRcdHZhciB0bXB0aW1lID0gZm9ybWF0LFxuXHRcdFx0YW1wbU5hbWUgPSBvcHRpb25zLmFtTmFtZXNbMF0sXG5cdFx0XHRob3VyID0gcGFyc2VJbnQodGltZS5ob3VyLCAxMCk7XG5cblx0XHRpZiAoaG91ciA+IDExKSB7XG5cdFx0XHRhbXBtTmFtZSA9IG9wdGlvbnMucG1OYW1lc1swXTtcblx0XHR9XG5cblx0XHR0bXB0aW1lID0gdG1wdGltZS5yZXBsYWNlKC8oPzpISD98aGg/fG1tP3xzcz98W3RUXXsxLDJ9fFt6Wl18W2xjXXwnLio/JykvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG5cdFx0XHRzd2l0Y2ggKG1hdGNoKSB7XG5cdFx0XHRjYXNlICdISCc6XG5cdFx0XHRcdHJldHVybiAoJzAnICsgaG91cikuc2xpY2UoLTIpO1xuXHRcdFx0Y2FzZSAnSCc6XG5cdFx0XHRcdHJldHVybiBob3VyO1xuXHRcdFx0Y2FzZSAnaGgnOlxuXHRcdFx0XHRyZXR1cm4gKCcwJyArIGNvbnZlcnQyNHRvMTIoaG91cikpLnNsaWNlKC0yKTtcblx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0XHRyZXR1cm4gY29udmVydDI0dG8xMihob3VyKTtcblx0XHRcdGNhc2UgJ21tJzpcblx0XHRcdFx0cmV0dXJuICgnMCcgKyB0aW1lLm1pbnV0ZSkuc2xpY2UoLTIpO1xuXHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRcdHJldHVybiB0aW1lLm1pbnV0ZTtcblx0XHRcdGNhc2UgJ3NzJzpcblx0XHRcdFx0cmV0dXJuICgnMCcgKyB0aW1lLnNlY29uZCkuc2xpY2UoLTIpO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdHJldHVybiB0aW1lLnNlY29uZDtcblx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHRyZXR1cm4gKCcwMCcgKyB0aW1lLm1pbGxpc2VjKS5zbGljZSgtMyk7XG5cdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0cmV0dXJuICgnMDAnICsgdGltZS5taWNyb3NlYykuc2xpY2UoLTMpO1xuXHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdHJldHVybiAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcodGltZS50aW1lem9uZSA9PT0gbnVsbCA/IG9wdGlvbnMudGltZXpvbmUgOiB0aW1lLnRpbWV6b25lLCBmYWxzZSk7XG5cdFx0XHRjYXNlICdaJzpcblx0XHRcdFx0cmV0dXJuICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZyh0aW1lLnRpbWV6b25lID09PSBudWxsID8gb3B0aW9ucy50aW1lem9uZSA6IHRpbWUudGltZXpvbmUsIHRydWUpO1xuXHRcdFx0Y2FzZSAnVCc6XG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcblx0XHRcdGNhc2UgJ1RUJzpcblx0XHRcdFx0cmV0dXJuIGFtcG1OYW1lLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0cmV0dXJuIGFtcG1OYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y2FzZSAndHQnOlxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBtYXRjaC5yZXBsYWNlKC8nL2csIFwiXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRtcHRpbWU7XG5cdH07XG5cblx0Lypcblx0KiB0aGUgYmFkIGhhY2sgOi8gb3ZlcnJpZGUgZGF0ZXBpY2tlciBzbyBpdCBkb2Vzbid0IGNsb3NlIG9uIHNlbGVjdFxuXHQvLyBpbnNwaXJlZDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjUyNTEyL2pxdWVyeS1kYXRlcGlja2VyLXByZXZlbnQtY2xvc2luZy1waWNrZXItd2hlbi1jbGlja2luZy1hLWRhdGUvMTc2MjM3OCMxNzYyMzc4XG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9zZWxlY3REYXRlID0gJC5kYXRlcGlja2VyLl9zZWxlY3REYXRlO1xuXHQkLmRhdGVwaWNrZXIuX3NlbGVjdERhdGUgPSBmdW5jdGlvbiAoaWQsIGRhdGVTdHIpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoJChpZClbMF0pLFxuXHRcdFx0dHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpLFxuXHRcdFx0d2FzX2lubGluZTtcblxuXHRcdGlmICh0cF9pbnN0ICYmIGluc3Quc2V0dGluZ3Muc2hvd1RpbWVwaWNrZXIpIHtcblx0XHRcdHRwX2luc3QuX2xpbWl0TWluTWF4RGF0ZVRpbWUoaW5zdCwgdHJ1ZSk7XG5cdFx0XHR3YXNfaW5saW5lID0gaW5zdC5pbmxpbmU7XG5cdFx0XHRpbnN0LmlubGluZSA9IGluc3Quc3RheV9vcGVuID0gdHJ1ZTtcblx0XHRcdC8vVGhpcyB3YXkgdGhlIG9uU2VsZWN0IGhhbmRsZXIgY2FsbGVkIGZyb20gY2FsZW5kYXJwaWNrZXIgZ2V0IHRoZSBmdWxsIGRhdGVUaW1lXG5cdFx0XHR0aGlzLl9iYXNlX3NlbGVjdERhdGUoaWQsIGRhdGVTdHIpO1xuXHRcdFx0aW5zdC5pbmxpbmUgPSB3YXNfaW5saW5lO1xuXHRcdFx0aW5zdC5zdGF5X29wZW4gPSBmYWxzZTtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2Jhc2Vfc2VsZWN0RGF0ZShpZCwgZGF0ZVN0cik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCogc2Vjb25kIGJhZCBoYWNrIDovIG92ZXJyaWRlIGRhdGVwaWNrZXIgc28gaXQgdHJpZ2dlcnMgYW4gZXZlbnQgd2hlbiBjaGFuZ2luZyB0aGUgaW5wdXQgZmllbGRcblx0KiBhbmQgZG9lcyBub3QgcmVkcmF3IHRoZSBkYXRlcGlja2VyIG9uIGV2ZXJ5IHNlbGVjdERhdGUgZXZlbnRcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX3VwZGF0ZURhdGVwaWNrZXIgPSAkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXI7XG5cdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uIChpbnN0KSB7XG5cblx0XHQvLyBkb24ndCBwb3B1cCB0aGUgZGF0ZXBpY2tlciBpZiB0aGVyZSBpcyBhbm90aGVyIGluc3RhbmNlIGFscmVhZHkgb3BlbmVkXG5cdFx0dmFyIGlucHV0ID0gaW5zdC5pbnB1dFswXTtcblx0XHRpZiAoJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCAmJiAkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ICE9PSBpbnB1dCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YoaW5zdC5zdGF5X29wZW4pICE9PSAnYm9vbGVhbicgfHwgaW5zdC5zdGF5X29wZW4gPT09IGZhbHNlKSB7XG5cblx0XHRcdHRoaXMuX2Jhc2VfdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblxuXHRcdFx0Ly8gUmVsb2FkIHRoZSB0aW1lIGNvbnRyb2wgd2hlbiBjaGFuZ2luZyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHQgZmllbGQuXG5cdFx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdFx0dHBfaW5zdC5fYWRkVGltZVBpY2tlcihpbnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Lypcblx0KiB0aGlyZCBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IGFsbG93cyBzcGFjZXMgYW5kIGNvbG9uIGluIHRoZSBpbnB1dCBmaWVsZFxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZG9LZXlQcmVzcyA9ICQuZGF0ZXBpY2tlci5fZG9LZXlQcmVzcztcblx0JC5kYXRlcGlja2VyLl9kb0tleVByZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KSxcblx0XHRcdHRwX2luc3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdGlmICgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnY29uc3RyYWluSW5wdXQnKSkge1xuXHRcdFx0XHR2YXIgYW1wbSA9IHRwX2luc3Quc3VwcG9ydC5hbXBtLFxuXHRcdFx0XHRcdHR6ID0gdHBfaW5zdC5fZGVmYXVsdHMuc2hvd1RpbWV6b25lICE9PSBudWxsID8gdHBfaW5zdC5fZGVmYXVsdHMuc2hvd1RpbWV6b25lIDogdHBfaW5zdC5zdXBwb3J0LnRpbWV6b25lLFxuXHRcdFx0XHRcdGRhdGVDaGFycyA9ICQuZGF0ZXBpY2tlci5fcG9zc2libGVDaGFycygkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnZGF0ZUZvcm1hdCcpKSxcblx0XHRcdFx0XHRkYXRldGltZUNoYXJzID0gdHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdC50b1N0cmluZygpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1tobXNdL2csICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9UVC9nLCBhbXBtID8gJ0FQTScgOiAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVHQvZywgYW1wbSA/ICdBYVBwTW0nIDogJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL3RUL2csIGFtcG0gPyAnQWFQcE1tJyA6ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9UL2csIGFtcG0gPyAnQVAnIDogJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL3R0L2csIGFtcG0gPyAnYXBtJyA6ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC90L2csIGFtcG0gPyAnYXAnIDogJycpICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIiBcIiArIHRwX2luc3QuX2RlZmF1bHRzLnNlcGFyYXRvciArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMudGltZVN1ZmZpeCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KHR6ID8gdHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmVMaXN0LmpvaW4oJycpIDogJycpICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQodHBfaW5zdC5fZGVmYXVsdHMuYW1OYW1lcy5qb2luKCcnKSkgKyAodHBfaW5zdC5fZGVmYXVsdHMucG1OYW1lcy5qb2luKCcnKSkgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGVDaGFycyxcblx0XHRcdFx0XHRjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlID09PSB1bmRlZmluZWQgPyBldmVudC5rZXlDb2RlIDogZXZlbnQuY2hhckNvZGUpO1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQuY3RybEtleSB8fCAoY2hyIDwgJyAnIHx8ICFkYXRlQ2hhcnMgfHwgZGF0ZXRpbWVDaGFycy5pbmRleE9mKGNocikgPiAtMSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVByZXNzKGV2ZW50KTtcblx0fTtcblxuXHQvKlxuXHQqIEZvdXJ0aCBiYWQgaGFjayA6LyBvdmVycmlkZSBfdXBkYXRlQWx0ZXJuYXRlIGZ1bmN0aW9uIHVzZWQgaW4gaW5saW5lIG1vZGUgdG8gaW5pdCBhbHRGaWVsZFxuXHQqIFVwZGF0ZSBhbnkgYWx0ZXJuYXRlIGZpZWxkIHRvIHN5bmNocm9uaXNlIHdpdGggdGhlIG1haW4gZmllbGQuXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV91cGRhdGVBbHRlcm5hdGUgPSAkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZTtcblx0JC5kYXRlcGlja2VyLl91cGRhdGVBbHRlcm5hdGUgPSBmdW5jdGlvbiAoaW5zdCkge1xuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdHZhciBhbHRGaWVsZCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdEZpZWxkO1xuXHRcdFx0aWYgKGFsdEZpZWxkKSB7IC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXG5cdFx0XHRcdHZhciBhbHRGb3JtYXQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGb3JtYXQgfHwgdHBfaW5zdC5fZGVmYXVsdHMuZGF0ZUZvcm1hdCxcblx0XHRcdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZShpbnN0KSxcblx0XHRcdFx0XHRmb3JtYXRDZmcgPSAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSxcblx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICcnLFxuXHRcdFx0XHRcdGFsdFNlcGFyYXRvciA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdFNlcGFyYXRvciA/IHRwX2luc3QuX2RlZmF1bHRzLmFsdFNlcGFyYXRvciA6IHRwX2luc3QuX2RlZmF1bHRzLnNlcGFyYXRvcixcblx0XHRcdFx0XHRhbHRUaW1lU3VmZml4ID0gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZVN1ZmZpeCA/IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggOiB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lU3VmZml4LFxuXHRcdFx0XHRcdGFsdFRpbWVGb3JtYXQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0ICE9PSBudWxsID8gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCA6IHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQ7XG5cblx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUoYWx0VGltZUZvcm1hdCwgdHBfaW5zdCwgdHBfaW5zdC5fZGVmYXVsdHMpICsgYWx0VGltZVN1ZmZpeDtcblx0XHRcdFx0aWYgKCF0cF9pbnN0Ll9kZWZhdWx0cy50aW1lT25seSAmJiAhdHBfaW5zdC5fZGVmYXVsdHMuYWx0RmllbGRUaW1lT25seSAmJiBkYXRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmFsdEZvcm1hdCkge1xuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGb3JtYXQsIGRhdGUsIGZvcm1hdENmZykgKyBhbHRTZXBhcmF0b3IgKyBhbHRGb3JtYXR0ZWREYXRlVGltZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9IHRwX2luc3QuZm9ybWF0dGVkRGF0ZSArIGFsdFNlcGFyYXRvciArIGFsdEZvcm1hdHRlZERhdGVUaW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQkKGFsdEZpZWxkKS52YWwoIGluc3QuaW5wdXQudmFsKCkgPyBhbHRGb3JtYXR0ZWREYXRlVGltZSA6IFwiXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdCQuZGF0ZXBpY2tlci5fYmFzZV91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCogT3ZlcnJpZGUga2V5IHVwIGV2ZW50IHRvIHN5bmMgbWFudWFsIGlucHV0IGNoYW5nZXMuXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVVwID0gJC5kYXRlcGlja2VyLl9kb0tleVVwO1xuXHQkLmRhdGVwaWNrZXIuX2RvS2V5VXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpLFxuXHRcdFx0dHBfaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLnRpbWVPbmx5ICYmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJC5kYXRlcGlja2VyLl9iYXNlX2RvS2V5VXAoZXZlbnQpO1xuXHR9O1xuXG5cdC8qXG5cdCogb3ZlcnJpZGUgXCJUb2RheVwiIGJ1dHRvbiB0byBhbHNvIGdyYWIgdGhlIHRpbWUgYW5kIHNldCBpdCB0byBpbnB1dCBmaWVsZC5cblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX2dvdG9Ub2RheSA9ICQuZGF0ZXBpY2tlci5fZ290b1RvZGF5O1xuXHQkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheSA9IGZ1bmN0aW9uIChpZCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCgkKGlkKVswXSk7XG5cdFx0dGhpcy5fYmFzZV9nb3RvVG9kYXkoaWQpO1xuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0aWYgKCF0cF9pbnN0KSB7XG5cdFx0ICByZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHR6b2Zmc2V0ID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKHRwX2luc3QudGltZXpvbmUpO1xuXHRcdHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXHRcdG5vdy5zZXRNaW51dGVzKG5vdy5nZXRNaW51dGVzKCkgKyBub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSArIHBhcnNlSW50KHR6b2Zmc2V0LCAxMCkpO1xuXHRcdHRoaXMuX3NldFRpbWUoaW5zdCwgbm93KTtcblx0XHR0aGlzLl9zZXREYXRlKGluc3QsIG5vdyk7XG5cdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XG5cdH07XG5cblx0Lypcblx0KiBEaXNhYmxlICYgZW5hYmxlIHRoZSBUaW1lIGluIHRoZSBkYXRldGltZXBpY2tlclxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Rpc2FibGVUaW1lcGlja2VyRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdCQodGFyZ2V0KS5kYXRlcGlja2VyKCdnZXREYXRlJyk7IC8vIEluaXQgc2VsZWN0ZWRbWWVhcnxNb250aHxEYXldXG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdGluc3Quc2V0dGluZ3Muc2hvd1RpbWVwaWNrZXIgPSBmYWxzZTtcblx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyID0gZmFsc2U7XG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcblx0XHR9XG5cdH07XG5cblx0JC5kYXRlcGlja2VyLl9lbmFibGVUaW1lcGlja2VyRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdCQodGFyZ2V0KS5kYXRlcGlja2VyKCdnZXREYXRlJyk7IC8vIEluaXQgc2VsZWN0ZWRbWWVhcnxNb250aHxEYXldXG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdGluc3Quc2V0dGluZ3Muc2hvd1RpbWVwaWNrZXIgPSB0cnVlO1xuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuc2hvd1RpbWVwaWNrZXIgPSB0cnVlO1xuXHRcdFx0dHBfaW5zdC5fYWRkVGltZVBpY2tlcihpbnN0KTsgLy8gQ291bGQgYmUgZGlzYWJsZWQgb24gcGFnZSBsb2FkXG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcblx0XHR9XG5cdH07XG5cblx0Lypcblx0KiBDcmVhdGUgb3VyIG93biBzZXQgdGltZSBmdW5jdGlvblxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX3NldFRpbWUgPSBmdW5jdGlvbiAoaW5zdCwgZGF0ZSkge1xuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdHZhciBkZWZhdWx0cyA9IHRwX2luc3QuX2RlZmF1bHRzO1xuXG5cdFx0XHQvLyBjYWxsaW5nIF9zZXRUaW1lIHdpdGggbm8gZGF0ZSBzZXRzIHRpbWUgdG8gZGVmYXVsdHNcblx0XHRcdHRwX2luc3QuaG91ciA9IGRhdGUgPyBkYXRlLmdldEhvdXJzKCkgOiBkZWZhdWx0cy5ob3VyO1xuXHRcdFx0dHBfaW5zdC5taW51dGUgPSBkYXRlID8gZGF0ZS5nZXRNaW51dGVzKCkgOiBkZWZhdWx0cy5taW51dGU7XG5cdFx0XHR0cF9pbnN0LnNlY29uZCA9IGRhdGUgPyBkYXRlLmdldFNlY29uZHMoKSA6IGRlZmF1bHRzLnNlY29uZDtcblx0XHRcdHRwX2luc3QubWlsbGlzZWMgPSBkYXRlID8gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSA6IGRlZmF1bHRzLm1pbGxpc2VjO1xuXHRcdFx0dHBfaW5zdC5taWNyb3NlYyA9IGRhdGUgPyBkYXRlLmdldE1pY3Jvc2Vjb25kcygpIDogZGVmYXVsdHMubWljcm9zZWM7XG5cblx0XHRcdC8vY2hlY2sgaWYgd2l0aGluIG1pbi9tYXggdGltZXMuLlxuXHRcdFx0dHBfaW5zdC5fbGltaXRNaW5NYXhEYXRlVGltZShpbnN0LCB0cnVlKTtcblxuXHRcdFx0dHBfaW5zdC5fb25UaW1lQ2hhbmdlKCk7XG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcblx0XHR9XG5cdH07XG5cblx0Lypcblx0KiBDcmVhdGUgbmV3IHB1YmxpYyBtZXRob2QgdG8gc2V0IG9ubHkgdGltZSwgY2FsbGFibGUgYXMgJCgpLmRhdGVwaWNrZXIoJ3NldFRpbWUnLCBkYXRlKVxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX3NldFRpbWVEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCwgZGF0ZSwgd2l0aERhdGUpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdHRoaXMuX3NldERhdGVGcm9tRmllbGQoaW5zdCk7XG5cdFx0XHR2YXIgdHBfZGF0ZTtcblx0XHRcdGlmIChkYXRlKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHRwX2luc3QuX3BhcnNlVGltZShkYXRlLCB3aXRoRGF0ZSk7XG5cdFx0XHRcdFx0dHBfZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdFx0dHBfZGF0ZS5zZXRIb3Vycyh0cF9pbnN0LmhvdXIsIHRwX2luc3QubWludXRlLCB0cF9pbnN0LnNlY29uZCwgdHBfaW5zdC5taWxsaXNlYyk7XG5cdFx0XHRcdFx0dHBfZGF0ZS5zZXRNaWNyb3NlY29uZHModHBfaW5zdC5taWNyb3NlYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHBfZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcblx0XHRcdFx0XHR0cF9kYXRlLnNldE1pY3Jvc2Vjb25kcyhkYXRlLmdldE1pY3Jvc2Vjb25kcygpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHBfZGF0ZS50b1N0cmluZygpID09PSAnSW52YWxpZCBEYXRlJykge1xuXHRcdFx0XHRcdHRwX2RhdGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2V0VGltZShpbnN0LCB0cF9kYXRlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fTtcblxuXHQvKlxuXHQqIG92ZXJyaWRlIHNldERhdGUoKSB0byBhbGxvdyBzZXR0aW5nIHRpbWUgdG9vIHdpdGhpbiBEYXRlIG9iamVjdFxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2Vfc2V0RGF0ZURhdGVwaWNrZXIgPSAkLmRhdGVwaWNrZXIuX3NldERhdGVEYXRlcGlja2VyO1xuXHQkLmRhdGVwaWNrZXIuX3NldERhdGVEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCwgX2RhdGUpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHR2YXIgZGF0ZSA9IF9kYXRlO1xuXHRcdGlmICghaW5zdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YoX2RhdGUpID09PSAnc3RyaW5nJykge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKF9kYXRlKTtcblx0XHRcdGlmICghZGF0ZS5nZXRUaW1lKCkpIHtcblx0XHRcdFx0dGhpcy5fYmFzZV9zZXREYXRlRGF0ZXBpY2tlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRkYXRlID0gJCh0YXJnZXQpLmRhdGVwaWNrZXIoJ2dldERhdGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdHZhciB0cF9kYXRlO1xuXHRcdGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0dHBfZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcblx0XHRcdHRwX2RhdGUuc2V0TWljcm9zZWNvbmRzKGRhdGUuZ2V0TWljcm9zZWNvbmRzKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0cF9kYXRlID0gZGF0ZTtcblx0XHR9XG5cblx0XHQvLyBUaGlzIGlzIGltcG9ydGFudCBpZiB5b3UgYXJlIHVzaW5nIHRoZSB0aW1lem9uZSBvcHRpb24sIGphdmFzY3JpcHQncyBEYXRlXG5cdFx0Ly8gb2JqZWN0IHdpbGwgb25seSByZXR1cm4gdGhlIHRpbWV6b25lIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLCBzbyB3ZVxuXHRcdC8vIGFkanVzdCBpdCBhY2NvcmRpbmdseS4gIElmIG5vdCB1c2luZyB0aW1lem9uZSBvcHRpb24gdGhpcyB3b24ndCBtYXR0ZXIuLlxuXHRcdC8vIElmIGEgdGltZXpvbmUgaXMgZGlmZmVyZW50IGluIHRwLCBrZWVwIHRoZSB0aW1lem9uZSBhcyBpc1xuXHRcdGlmICh0cF9pbnN0ICYmIHRwX2RhdGUpIHtcblx0XHRcdC8vIGxvb2sgb3V0IGZvciBEU1QgaWYgdHogd2Fzbid0IHNwZWNpZmllZFxuXHRcdFx0aWYgKCF0cF9pbnN0LnN1cHBvcnQudGltZXpvbmUgJiYgdHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmUgPT09IG51bGwpIHtcblx0XHRcdFx0dHBfaW5zdC50aW1lem9uZSA9IHRwX2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xO1xuXHRcdFx0fVxuXHRcdFx0ZGF0ZSA9ICQudGltZXBpY2tlci50aW1lem9uZUFkanVzdChkYXRlLCAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcoLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSksIHRwX2luc3QudGltZXpvbmUpO1xuXHRcdFx0dHBfZGF0ZSA9ICQudGltZXBpY2tlci50aW1lem9uZUFkanVzdCh0cF9kYXRlLCAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcoLXRwX2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSksIHRwX2luc3QudGltZXpvbmUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0dGhpcy5fYmFzZV9zZXREYXRlRGF0ZXBpY2tlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NldFRpbWVEYXRlcGlja2VyKHRhcmdldCwgdHBfZGF0ZSwgdHJ1ZSk7XG5cdH07XG5cblx0Lypcblx0KiBvdmVycmlkZSBnZXREYXRlKCkgdG8gYWxsb3cgZ2V0dGluZyB0aW1lIHRvbyB3aXRoaW4gRGF0ZSBvYmplY3Rcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX2dldERhdGVEYXRlcGlja2VyID0gJC5kYXRlcGlja2VyLl9nZXREYXRlRGF0ZXBpY2tlcjtcblx0JC5kYXRlcGlja2VyLl9nZXREYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIG5vRGVmYXVsdCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmICghaW5zdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0Ly8gaWYgaXQgaGFzbid0IHlldCBiZWVuIGRlZmluZWQsIGdyYWIgZnJvbSBmaWVsZFxuXHRcdFx0aWYgKGluc3QubGFzdFZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3NldERhdGVGcm9tRmllbGQoaW5zdCwgbm9EZWZhdWx0KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl9nZXREYXRlKGluc3QpO1xuXG5cdFx0XHR2YXIgY3VyckRUID0gbnVsbDtcblxuXHRcdFx0aWYgKHRwX2luc3QuJGFsdElucHV0ICYmIHRwX2luc3QuX2RlZmF1bHRzLmFsdEZpZWxkVGltZU9ubHkpIHtcblx0XHRcdFx0Y3VyckRUID0gdHBfaW5zdC4kaW5wdXQudmFsKCkgKyAnICcgKyB0cF9pbnN0LiRhbHRJbnB1dC52YWwoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRwX2luc3QuJGlucHV0LmdldCgwKS50YWdOYW1lICE9PSAnSU5QVVQnICYmIHRwX2luc3QuJGFsdElucHV0KSB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBpbiBjYXNlIHRoZSBkYXRldGltZXBpY2tlciBoYXMgYmVlbiBhcHBsaWVkIHRvIGEgbm9uLWlucHV0IHRhZyBmb3IgaW5saW5lIFVJLFxuXHRcdFx0XHQgKiBhbmQgdGhlIHVzZXIgaGFzIG5vdCBjb25maWd1cmVkIHRoZSBwbHVnaW4gdG8gZGlzcGxheSBvbmx5IHRpbWUgaW4gYWx0SW5wdXQsXG5cdFx0XHRcdCAqIHBpY2sgY3VycmVudCBkYXRlIHRpbWUgZnJvbSB0aGUgYWx0SW5wdXQgKGFuZCBob3BlIGZvciB0aGUgYmVzdCwgZm9yIG5vdywgdW50aWwgXCJFUjFcIiBpcyBhcHBsaWVkKVxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAdG9kbyBFUjEuIFNpbmNlIGFsdElucHV0IGNhbiBoYXZlIGEgdG90YWxseSBkaWZmZXJlbmNlIGZvcm1hdCwgY29udmVydCBpdCB0byBzdGFuZGFyZCBmb3JtYXQgYnkgcmVhZGluZyBpbnB1dCBmb3JtYXQgZnJvbSBcImFsdEZvcm1hdFwiIGFuZCBcImFsdFRpbWVGb3JtYXRcIiBvcHRpb24gdmFsdWVzXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRjdXJyRFQgPSB0cF9pbnN0LiRhbHRJbnB1dC52YWwoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjdXJyRFQgPSB0cF9pbnN0LiRpbnB1dC52YWwoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGUgJiYgdHBfaW5zdC5fcGFyc2VUaW1lKGN1cnJEVCwgIWluc3Quc2V0dGluZ3MudGltZU9ubHkpKSB7XG5cdFx0XHRcdGRhdGUuc2V0SG91cnModHBfaW5zdC5ob3VyLCB0cF9pbnN0Lm1pbnV0ZSwgdHBfaW5zdC5zZWNvbmQsIHRwX2luc3QubWlsbGlzZWMpO1xuXHRcdFx0XHRkYXRlLnNldE1pY3Jvc2Vjb25kcyh0cF9pbnN0Lm1pY3Jvc2VjKTtcblxuXHRcdFx0XHQvLyBUaGlzIGlzIGltcG9ydGFudCBpZiB5b3UgYXJlIHVzaW5nIHRoZSB0aW1lem9uZSBvcHRpb24sIGphdmFzY3JpcHQncyBEYXRlXG5cdFx0XHRcdC8vIG9iamVjdCB3aWxsIG9ubHkgcmV0dXJuIHRoZSB0aW1lem9uZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IGxvY2FsZSwgc28gd2Vcblx0XHRcdFx0Ly8gYWRqdXN0IGl0IGFjY29yZGluZ2x5LiAgSWYgbm90IHVzaW5nIHRpbWV6b25lIG9wdGlvbiB0aGlzIHdvbid0IG1hdHRlci4uXG5cdFx0XHRcdGlmICh0cF9pbnN0LnRpbWV6b25lICE9IG51bGwpIHtcblx0XHRcdFx0XHQvLyBsb29rIG91dCBmb3IgRFNUIGlmIHR6IHdhc24ndCBzcGVjaWZpZWRcblx0XHRcdFx0XHRpZiAoIXRwX2luc3Quc3VwcG9ydC50aW1lem9uZSAmJiB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dHBfaW5zdC50aW1lem9uZSA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRlID0gJC50aW1lcGlja2VyLnRpbWV6b25lQWRqdXN0KGRhdGUsIHRwX2luc3QudGltZXpvbmUsICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZygtZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fYmFzZV9nZXREYXRlRGF0ZXBpY2tlcih0YXJnZXQsIG5vRGVmYXVsdCk7XG5cdH07XG5cblx0Lypcblx0KiBvdmVycmlkZSBwYXJzZURhdGUoKSBiZWNhdXNlIFVJIDEuOC4xNCB0aHJvd3MgYW4gZXJyb3IgYWJvdXQgXCJFeHRyYSBjaGFyYWN0ZXJzXCJcblx0KiBBbiBvcHRpb24gaW4gZGF0YXBpY2tlciB0byBpZ25vcmUgZXh0cmEgZm9ybWF0IGNoYXJhY3RlcnMgd291bGQgYmUgbmljZXIuXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9wYXJzZURhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlO1xuXHQkLmRhdGVwaWNrZXIucGFyc2VEYXRlID0gZnVuY3Rpb24gKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XG5cdFx0dmFyIGRhdGU7XG5cdFx0dHJ5IHtcblx0XHRcdGRhdGUgPSB0aGlzLl9iYXNlX3BhcnNlRGF0ZShmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncyk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHQvLyBIYWNrISAgVGhlIGVycm9yIG1lc3NhZ2UgZW5kcyB3aXRoIGEgY29sb24sIGEgc3BhY2UsIGFuZFxuXHRcdFx0Ly8gdGhlIFwiZXh0cmFcIiBjaGFyYWN0ZXJzLiAgV2UgcmVseSBvbiB0aGF0IGluc3RlYWQgb2Zcblx0XHRcdC8vIGF0dGVtcHRpbmcgdG8gcGVyZmVjdGx5IHJlcHJvZHVjZSB0aGUgcGFyc2luZyBhbGdvcml0aG0uXG5cdFx0XHRpZiAoZXJyLmluZGV4T2YoXCI6XCIpID49IDApIHtcblx0XHRcdFx0ZGF0ZSA9IHRoaXMuX2Jhc2VfcGFyc2VEYXRlKGZvcm1hdCwgdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIChlcnIubGVuZ3RoIC0gZXJyLmluZGV4T2YoJzonKSAtIDIpKSwgc2V0dGluZ3MpO1xuXHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKFwiRXJyb3IgcGFyc2luZyB0aGUgZGF0ZSBzdHJpbmc6IFwiICsgZXJyICsgXCJcXG5kYXRlIHN0cmluZyA9IFwiICsgdmFsdWUgKyBcIlxcbmRhdGUgZm9ybWF0ID0gXCIgKyBmb3JtYXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGF0ZTtcblx0fTtcblxuXHQvKlxuXHQqIG92ZXJyaWRlIGZvcm1hdERhdGUgdG8gc2V0IGRhdGUgd2l0aCB0aW1lIHRvIHRoZSBpbnB1dFxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZm9ybWF0RGF0ZSA9ICQuZGF0ZXBpY2tlci5fZm9ybWF0RGF0ZTtcblx0JC5kYXRlcGlja2VyLl9mb3JtYXREYXRlID0gZnVuY3Rpb24gKGluc3QsIGRheSwgbW9udGgsIHllYXIpIHtcblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcblx0XHRcdHJldHVybiB0cF9pbnN0LiRpbnB1dC52YWwoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2Jhc2VfZm9ybWF0RGF0ZShpbnN0KTtcblx0fTtcblxuXHQvKlxuXHQqIG92ZXJyaWRlIG9wdGlvbnMgc2V0dGVyIHRvIGFkZCB0aW1lIHRvIG1heERhdGUoVGltZSkgYW5kIG1pbkRhdGUoVGltZSkuIE1heERhdGVcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX29wdGlvbkRhdGVwaWNrZXIgPSAkLmRhdGVwaWNrZXIuX29wdGlvbkRhdGVwaWNrZXI7XG5cdCQuZGF0ZXBpY2tlci5fb3B0aW9uRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCksXG5cdFx0XHRuYW1lX2Nsb25lO1xuXHRcdGlmICghaW5zdCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0dmFyIG1pbiA9IG51bGwsXG5cdFx0XHRcdG1heCA9IG51bGwsXG5cdFx0XHRcdG9uc2VsZWN0ID0gbnVsbCxcblx0XHRcdFx0b3ZlcnJpZGVzID0gdHBfaW5zdC5fZGVmYXVsdHMuZXZudHMsXG5cdFx0XHRcdGZucyA9IHt9LFxuXHRcdFx0XHRwcm9wLFxuXHRcdFx0XHRyZXQsXG5cdFx0XHRcdG9sZFZhbCxcblx0XHRcdFx0JHRhcmdldDtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHsgLy8gaWYgbWluL21heCB3YXMgc2V0IHdpdGggdGhlIHN0cmluZ1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ21pbkRhdGUnIHx8IG5hbWUgPT09ICdtaW5EYXRlVGltZScpIHtcblx0XHRcdFx0XHRtaW4gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChuYW1lID09PSAnbWF4RGF0ZScgfHwgbmFtZSA9PT0gJ21heERhdGVUaW1lJykge1xuXHRcdFx0XHRcdG1heCA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUgPT09ICdvblNlbGVjdCcpIHtcblx0XHRcdFx0XHRvbnNlbGVjdCA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvdmVycmlkZXNbbmFtZV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZuc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHRcdG5hbWVfY2xvbmUgPSB7fTsgLy9lbXB0eSByZXN1bHRzIGluIGV4aXRpbmcgZnVuY3Rpb24gYWZ0ZXIgb3ZlcnJpZGVzIHVwZGF0ZWRcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHsgLy9pZiBtaW4vbWF4IHdhcyBzZXQgd2l0aCB0aGUgSlNPTlxuXHRcdFx0XHRpZiAobmFtZS5taW5EYXRlKSB7XG5cdFx0XHRcdFx0bWluID0gbmFtZS5taW5EYXRlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUubWluRGF0ZVRpbWUpIHtcblx0XHRcdFx0XHRtaW4gPSBuYW1lLm1pbkRhdGVUaW1lO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUubWF4RGF0ZSkge1xuXHRcdFx0XHRcdG1heCA9IG5hbWUubWF4RGF0ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChuYW1lLm1heERhdGVUaW1lKSB7XG5cdFx0XHRcdFx0bWF4ID0gbmFtZS5tYXhEYXRlVGltZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHByb3AgaW4gb3ZlcnJpZGVzKSB7XG5cdFx0XHRcdFx0aWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBuYW1lW3Byb3BdKSB7XG5cdFx0XHRcdFx0XHRmbnNbcHJvcF0gPSBuYW1lW3Byb3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChwcm9wIGluIGZucykge1xuXHRcdFx0XHRpZiAoZm5zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdFx0b3ZlcnJpZGVzW3Byb3BdID0gZm5zW3Byb3BdO1xuXHRcdFx0XHRcdGlmICghbmFtZV9jbG9uZSkgeyBuYW1lX2Nsb25lID0gJC5leHRlbmQoe30sIG5hbWUpOyB9XG5cdFx0XHRcdFx0ZGVsZXRlIG5hbWVfY2xvbmVbcHJvcF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChuYW1lX2Nsb25lICYmIGlzRW1wdHlPYmplY3QobmFtZV9jbG9uZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRpZiAobWluKSB7IC8vaWYgbWluIHdhcyBzZXRcblx0XHRcdFx0aWYgKG1pbiA9PT0gMCkge1xuXHRcdFx0XHRcdG1pbiA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWluID0gbmV3IERhdGUobWluKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlID0gbWluO1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlVGltZSA9IG1pbjtcblx0XHRcdH0gZWxzZSBpZiAobWF4KSB7IC8vaWYgbWF4IHdhcyBzZXRcblx0XHRcdFx0aWYgKG1heCA9PT0gMCkge1xuXHRcdFx0XHRcdG1heCA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWF4ID0gbmV3IERhdGUobWF4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID0gbWF4O1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZSA9IG1heDtcblx0XHRcdH0gZWxzZSBpZiAob25zZWxlY3QpIHtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMub25TZWxlY3QgPSBvbnNlbGVjdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGF0ZXBpY2tlciB3aWxsIG92ZXJyaWRlIG91ciBkYXRlIHdoZW4gd2UgY2FsbCBfYmFzZV9vcHRpb25EYXRlcGlja2VyIHdoZW5cblx0XHRcdC8vIGNhbGxpbmcgbWluRGF0ZS9tYXhEYXRlLCBzbyB3ZSB3aWxsIGZpcnN0IGdyYWIgdGhlIHZhbHVlLCBjYWxsXG5cdFx0XHQvLyBfYmFzZV9vcHRpb25EYXRlcGlja2VyLCB0aGVuIHNldCBvdXIgdmFsdWUgYmFjay5cblx0XHRcdGlmKG1pbiB8fCBtYXgpe1xuXHRcdFx0XHQkdGFyZ2V0ID0gJCh0YXJnZXQpO1xuXHRcdFx0XHRvbGRWYWwgPSAkdGFyZ2V0LmRhdGV0aW1lcGlja2VyKCdnZXREYXRlJyk7XG5cdFx0XHRcdHJldCA9IHRoaXMuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlci5jYWxsKCQuZGF0ZXBpY2tlciwgdGFyZ2V0LCBuYW1lX2Nsb25lIHx8IG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0JHRhcmdldC5kYXRldGltZXBpY2tlcignc2V0RGF0ZScsIG9sZFZhbCk7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYmFzZV9vcHRpb25EYXRlcGlja2VyLmNhbGwoJC5kYXRlcGlja2VyLCB0YXJnZXQsIG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fYmFzZV9vcHRpb25EYXRlcGlja2VyLmNhbGwoJC5kYXRlcGlja2VyLCB0YXJnZXQsIG5hbWVfY2xvbmUgfHwgbmFtZSwgdmFsdWUpO1xuXHR9O1xuXG5cdC8qXG5cdCogalF1ZXJ5IGlzRW1wdHlPYmplY3QgZG9lcyBub3QgY2hlY2sgaGFzT3duUHJvcGVydHkgLSBpZiBzb21lb25lIGhhcyBhZGRlZCB0byB0aGUgb2JqZWN0IHByb3RvdHlwZSxcblx0KiBpdCB3aWxsIHJldHVybiBmYWxzZSBmb3IgYWxsIG9iamVjdHNcblx0Ki9cblx0dmFyIGlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0dmFyIHByb3A7XG5cdFx0Zm9yIChwcm9wIGluIG9iaikge1xuXHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qXG5cdCogalF1ZXJ5IGV4dGVuZCBub3cgaWdub3JlcyBudWxscyFcblx0Ki9cblx0dmFyIGV4dGVuZFJlbW92ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XG5cdFx0JC5leHRlbmQodGFyZ2V0LCBwcm9wcyk7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuXHRcdFx0aWYgKHByb3BzW25hbWVdID09PSBudWxsIHx8IHByb3BzW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGFyZ2V0W25hbWVdID0gcHJvcHNbbmFtZV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0Lypcblx0KiBEZXRlcm1pbmUgYnkgdGhlIHRpbWUgZm9ybWF0IHdoaWNoIHVuaXRzIGFyZSBzdXBwb3J0ZWRcblx0KiBSZXR1cm5zIGFuIG9iamVjdCBvZiBib29sZWFucyBmb3IgZWFjaCB1bml0XG5cdCovXG5cdHZhciBkZXRlY3RTdXBwb3J0ID0gZnVuY3Rpb24gKHRpbWVGb3JtYXQpIHtcblx0XHR2YXIgdGYgPSB0aW1lRm9ybWF0LnJlcGxhY2UoLycuKj8nL2csICcnKS50b0xvd2VyQ2FzZSgpLCAvLyByZW1vdmVzIGxpdGVyYWxzXG5cdFx0XHRpc0luID0gZnVuY3Rpb24gKGYsIHQpIHsgLy8gZG9lcyB0aGUgZm9ybWF0IGNvbnRhaW4gdGhlIHRva2VuP1xuXHRcdFx0XHRcdHJldHVybiBmLmluZGV4T2YodCkgIT09IC0xID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRcdGhvdXI6IGlzSW4odGYsICdoJyksXG5cdFx0XHRcdG1pbnV0ZTogaXNJbih0ZiwgJ20nKSxcblx0XHRcdFx0c2Vjb25kOiBpc0luKHRmLCAncycpLFxuXHRcdFx0XHRtaWxsaXNlYzogaXNJbih0ZiwgJ2wnKSxcblx0XHRcdFx0bWljcm9zZWM6IGlzSW4odGYsICdjJyksXG5cdFx0XHRcdHRpbWV6b25lOiBpc0luKHRmLCAneicpLFxuXHRcdFx0XHRhbXBtOiBpc0luKHRmLCAndCcpICYmIGlzSW4odGltZUZvcm1hdCwgJ2gnKSxcblx0XHRcdFx0aXNvODYwMTogaXNJbih0aW1lRm9ybWF0LCAnWicpXG5cdFx0XHR9O1xuXHR9O1xuXG5cdC8qXG5cdCogQ29udmVydHMgMjQgaG91ciBmb3JtYXQgaW50byAxMiBob3VyXG5cdCogUmV0dXJucyAxMiBob3VyIHdpdGhvdXQgbGVhZGluZyAwXG5cdCovXG5cdHZhciBjb252ZXJ0MjR0bzEyID0gZnVuY3Rpb24gKGhvdXIpIHtcblx0XHRob3VyICU9IDEyO1xuXG5cdFx0aWYgKGhvdXIgPT09IDApIHtcblx0XHRcdGhvdXIgPSAxMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gU3RyaW5nKGhvdXIpO1xuXHR9O1xuXG5cdHZhciBjb21wdXRlRWZmZWN0aXZlU2V0dGluZyA9IGZ1bmN0aW9uIChzZXR0aW5ncywgcHJvcGVydHkpIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgJiYgc2V0dGluZ3NbcHJvcGVydHldID8gc2V0dGluZ3NbcHJvcGVydHldIDogJC50aW1lcGlja2VyLl9kZWZhdWx0c1twcm9wZXJ0eV07XG5cdH07XG5cblx0Lypcblx0KiBTcGxpdHMgZGF0ZXRpbWUgc3RyaW5nIGludG8gZGF0ZSBhbmQgdGltZSBzdWJzdHJpbmdzLlxuXHQqIFRocm93cyBleGNlcHRpb24gd2hlbiBkYXRlIGNhbid0IGJlIHBhcnNlZFxuXHQqIFJldHVybnMge2RhdGVTdHJpbmc6IGRhdGVTdHJpbmcsIHRpbWVTdHJpbmc6IHRpbWVTdHJpbmd9XG5cdCovXG5cdHZhciBzcGxpdERhdGVUaW1lID0gZnVuY3Rpb24gKGRhdGVUaW1lU3RyaW5nLCB0aW1lU2V0dGluZ3MpIHtcblx0XHQvLyBUaGUgaWRlYSBpcyB0byBnZXQgdGhlIG51bWJlciBzZXBhcmF0b3Igb2NjdXJyZW5jZXMgaW4gZGF0ZXRpbWUgYW5kIHRoZSB0aW1lIGZvcm1hdCByZXF1ZXN0ZWQgKHNpbmNlIHRpbWUgaGFzXG5cdFx0Ly8gZmV3ZXIgdW5rbm93bnMsIG1vc3RseSBudW1iZXJzIGFuZCBhbS9wbSkuIFdlIHdpbGwgdXNlIHRoZSB0aW1lIHBhdHRlcm4gdG8gc3BsaXQuXG5cdFx0dmFyIHNlcGFyYXRvciA9IGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nKHRpbWVTZXR0aW5ncywgJ3NlcGFyYXRvcicpLFxuXHRcdFx0Zm9ybWF0ID0gY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcodGltZVNldHRpbmdzLCAndGltZUZvcm1hdCcpLFxuXHRcdFx0dGltZVBhcnRzID0gZm9ybWF0LnNwbGl0KHNlcGFyYXRvciksIC8vIGhvdyBtYW55IG9jY3VycmVuY2VzIG9mIHNlcGFyYXRvciBtYXkgYmUgaW4gb3VyIGZvcm1hdD9cblx0XHRcdHRpbWVQYXJ0c0xlbiA9IHRpbWVQYXJ0cy5sZW5ndGgsXG5cdFx0XHRhbGxQYXJ0cyA9IGRhdGVUaW1lU3RyaW5nLnNwbGl0KHNlcGFyYXRvciksXG5cdFx0XHRhbGxQYXJ0c0xlbiA9IGFsbFBhcnRzLmxlbmd0aDtcblxuXHRcdGlmIChhbGxQYXJ0c0xlbiA+IDEpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGVTdHJpbmc6IGFsbFBhcnRzLnNwbGljZSgwLCBhbGxQYXJ0c0xlbiAtIHRpbWVQYXJ0c0xlbikuam9pbihzZXBhcmF0b3IpLFxuXHRcdFx0XHR0aW1lU3RyaW5nOiBhbGxQYXJ0cy5zcGxpY2UoMCwgdGltZVBhcnRzTGVuKS5qb2luKHNlcGFyYXRvcilcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGVTdHJpbmc6IGRhdGVUaW1lU3RyaW5nLFxuXHRcdFx0dGltZVN0cmluZzogJydcblx0XHR9O1xuXHR9O1xuXG5cdC8qXG5cdCogSW50ZXJuYWwgZnVuY3Rpb24gdG8gcGFyc2UgZGF0ZXRpbWUgaW50ZXJ2YWxcblx0KiBSZXR1cm5zOiB7ZGF0ZTogRGF0ZSwgdGltZU9iajogT2JqZWN0fSwgd2hlcmVcblx0KiAgIGRhdGUgLSBwYXJzZWQgZGF0ZSB3aXRob3V0IHRpbWUgKHR5cGUgRGF0ZSlcblx0KiAgIHRpbWVPYmogPSB7aG91cjogLCBtaW51dGU6ICwgc2Vjb25kOiAsIG1pbGxpc2VjOiAsIG1pY3Jvc2VjOiB9IC0gcGFyc2VkIHRpbWUuIE9wdGlvbmFsXG5cdCovXG5cdHZhciBwYXJzZURhdGVUaW1lSW50ZXJuYWwgPSBmdW5jdGlvbiAoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKSB7XG5cdFx0dmFyIGRhdGUsXG5cdFx0XHRwYXJ0cyxcblx0XHRcdHBhcnNlZFRpbWU7XG5cblx0XHRwYXJ0cyA9IHNwbGl0RGF0ZVRpbWUoZGF0ZVRpbWVTdHJpbmcsIHRpbWVTZXR0aW5ncyk7XG5cdFx0ZGF0ZSA9ICQuZGF0ZXBpY2tlci5fYmFzZV9wYXJzZURhdGUoZGF0ZUZvcm1hdCwgcGFydHMuZGF0ZVN0cmluZywgZGF0ZVNldHRpbmdzKTtcblxuXHRcdGlmIChwYXJ0cy50aW1lU3RyaW5nID09PSAnJykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0ZTogZGF0ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRwYXJzZWRUaW1lID0gJC5kYXRlcGlja2VyLnBhcnNlVGltZSh0aW1lRm9ybWF0LCBwYXJ0cy50aW1lU3RyaW5nLCB0aW1lU2V0dGluZ3MpO1xuXG5cdFx0aWYgKCFwYXJzZWRUaW1lKSB7XG5cdFx0XHR0aHJvdyAnV3JvbmcgdGltZSBmb3JtYXQnO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRlOiBkYXRlLFxuXHRcdFx0dGltZU9iajogcGFyc2VkVGltZVxuXHRcdH07XG5cdH07XG5cblx0Lypcblx0KiBJbnRlcm5hbCBmdW5jdGlvbiB0byBzZXQgdGltZXpvbmVfc2VsZWN0IHRvIHRoZSBsb2NhbCB0aW1lem9uZVxuXHQqL1xuXHR2YXIgc2VsZWN0TG9jYWxUaW1lem9uZSA9IGZ1bmN0aW9uICh0cF9pbnN0LCBkYXRlKSB7XG5cdFx0aWYgKHRwX2luc3QgJiYgdHBfaW5zdC50aW1lem9uZV9zZWxlY3QpIHtcblx0XHRcdHZhciBub3cgPSBkYXRlIHx8IG5ldyBEYXRlKCk7XG5cdFx0XHR0cF9pbnN0LnRpbWV6b25lX3NlbGVjdC52YWwoLW5vdy5nZXRUaW1lem9uZU9mZnNldCgpKTtcblx0XHR9XG5cdH07XG5cblx0Lypcblx0KiBDcmVhdGUgYSBTaW5nbGV0b24gSW5zdGFuY2Vcblx0Ki9cblx0JC50aW1lcGlja2VyID0gbmV3IFRpbWVwaWNrZXIoKTtcblxuXHQvKipcblx0ICogR2V0IHRoZSB0aW1lem9uZSBvZmZzZXQgYXMgc3RyaW5nIGZyb20gYSBkYXRlIG9iamVjdCAoZWcgJyswNTMwJyBmb3IgVVRDKzUuNSlcblx0ICogQHBhcmFtIHtudW1iZXJ9IHR6TWludXRlcyBpZiBub3QgYSBudW1iZXIsIGxlc3MgdGhhbiAtNzIwICgtMTIwMCksIG9yIGdyZWF0ZXIgdGhhbiA4NDAgKCsxNDAwKSB0aGlzIHZhbHVlIGlzIHJldHVybmVkXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNvODYwMSBpZiB0cnVlIGZvcm1hdHMgaW4gYWNjb3JkYW5jZSB0byBpc284NjAxIFwiKzEyOjQ1XCJcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0JC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nID0gZnVuY3Rpb24gKHR6TWludXRlcywgaXNvODYwMSkge1xuXHRcdGlmIChpc05hTih0ek1pbnV0ZXMpIHx8IHR6TWludXRlcyA+IDg0MCB8fCB0ek1pbnV0ZXMgPCAtNzIwKSB7XG5cdFx0XHRyZXR1cm4gdHpNaW51dGVzO1xuXHRcdH1cblxuXHRcdHZhciBvZmYgPSB0ek1pbnV0ZXMsXG5cdFx0XHRtaW51dGVzID0gb2ZmICUgNjAsXG5cdFx0XHRob3VycyA9IChvZmYgLSBtaW51dGVzKSAvIDYwLFxuXHRcdFx0aXNvID0gaXNvODYwMSA/ICc6JyA6ICcnLFxuXHRcdFx0dHogPSAob2ZmID49IDAgPyAnKycgOiAnLScpICsgKCcwJyArIE1hdGguYWJzKGhvdXJzKSkuc2xpY2UoLTIpICsgaXNvICsgKCcwJyArIE1hdGguYWJzKG1pbnV0ZXMpKS5zbGljZSgtMik7XG5cblx0XHRpZiAodHogPT09ICcrMDA6MDAnKSB7XG5cdFx0XHRyZXR1cm4gJ1onO1xuXHRcdH1cblx0XHRyZXR1cm4gdHo7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIGluIG1pbnV0ZXMgdGhhdCByZXByZXNlbnRzIGEgdGltZXpvbmUgc3RyaW5nXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdHpTdHJpbmcgZm9ybWF0dGVkIGxpa2UgXCIrMDUwMFwiLCBcIi0xMjQ1XCIsIFwiWlwiXG5cdCAqIEByZXR1cm4ge251bWJlcn0gdGhlIG9mZnNldCBtaW51dGVzIG9yIHRoZSBvcmlnaW5hbCBzdHJpbmcgaWYgaXQgZG9lc24ndCBtYXRjaCBleHBlY3RhdGlvbnNcblx0ICovXG5cdCQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlciA9IGZ1bmN0aW9uICh0elN0cmluZykge1xuXHRcdHZhciBub3JtYWxpemVkID0gdHpTdHJpbmcudG9TdHJpbmcoKS5yZXBsYWNlKCc6JywgJycpOyAvLyBleGN1c2UgYW55IGlzbzg2MDEsIGVuZCB1cCB3aXRoIFwiKzEyNDVcIlxuXG5cdFx0aWYgKG5vcm1hbGl6ZWQudG9VcHBlckNhc2UoKSA9PT0gJ1onKSB7IC8vIGlmIGlzbzg2MDEgd2l0aCBaLCBpdHMgMCBtaW51dGUgb2Zmc2V0XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRpZiAoIS9eKFxcLXxcXCspXFxkezR9JC8udGVzdChub3JtYWxpemVkKSkgeyAvLyBwb3NzaWJseSBhIHVzZXIgZGVmaW5lZCB0eiwgc28ganVzdCBnaXZlIGl0IGJhY2tcblx0XHRcdHJldHVybiBwYXJzZUludCh0elN0cmluZywgMTApO1xuXHRcdH1cblxuXHRcdHJldHVybiAoKG5vcm1hbGl6ZWQuc3Vic3RyKDAsIDEpID09PSAnLScgPyAtMSA6IDEpICogLy8gcGx1cyBvciBtaW51c1xuXHRcdFx0XHRcdCgocGFyc2VJbnQobm9ybWFsaXplZC5zdWJzdHIoMSwgMiksIDEwKSAqIDYwKSArIC8vIGhvdXJzIChjb252ZXJ0ZWQgdG8gbWludXRlcylcblx0XHRcdFx0XHRwYXJzZUludChub3JtYWxpemVkLnN1YnN0cigzLCAyKSwgMTApKSk7IC8vIG1pbnV0ZXNcblx0fTtcblxuXHQvKipcblx0ICogTm8gd2F5IHRvIHNldCB0aW1lem9uZSBpbiBqcyBEYXRlLCBzbyB3ZSBtdXN0IGFkanVzdCB0aGUgbWludXRlcyB0byBjb21wZW5zYXRlLiAodGhpbmsgc2V0RGF0ZSwgZ2V0RGF0ZSlcblx0ICogQHBhcmFtICB7RGF0ZX0gZGF0ZVxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGZyb21UaW1lem9uZSBmb3JtYXR0ZWQgbGlrZSBcIiswNTAwXCIsIFwiLTEyNDVcIlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHRvVGltZXpvbmUgZm9ybWF0dGVkIGxpa2UgXCIrMDUwMFwiLCBcIi0xMjQ1XCJcblx0ICogQHJldHVybiB7RGF0ZX1cblx0ICovXG5cdCQudGltZXBpY2tlci50aW1lem9uZUFkanVzdCA9IGZ1bmN0aW9uIChkYXRlLCBmcm9tVGltZXpvbmUsIHRvVGltZXpvbmUpIHtcblx0XHR2YXIgZnJvbVR6ID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKGZyb21UaW1lem9uZSk7XG5cdFx0dmFyIHRvVHogPSAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXROdW1iZXIodG9UaW1lem9uZSk7XG5cdFx0aWYgKCFpc05hTih0b1R6KSkge1xuXHRcdFx0ZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgKC1mcm9tVHopIC0gKC10b1R6KSk7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxscyBgdGltZXBpY2tlcigpYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xuXHQgKiBlbmZvcmNlIGRhdGUgcmFuZ2UgbGltaXRzLlxuXHQgKiBuLmIuIFRoZSBpbnB1dCB2YWx1ZSBtdXN0IGJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgKHJlZm9ybWF0dGluZyBpcyBub3Qgc3VwcG9ydGVkKVxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcblx0ICogQHBhcmFtICB7RWxlbWVudH0gZW5kVGltZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRpbWVwaWNrZXIoKSBjYWxsXG5cdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0ICovXG5cdCQudGltZXBpY2tlci50aW1lUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuICQudGltZXBpY2tlci5oYW5kbGVSYW5nZSgndGltZXBpY2tlcicsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxzIGBkYXRldGltZXBpY2tlcmAgb24gdGhlIGBzdGFydFRpbWVgIGFuZCBgZW5kVGltZWAgZWxlbWVudHMsIGFuZCBjb25maWd1cmVzIHRoZW0gdG9cblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cblx0ICogQHBhcmFtICB7RWxlbWVudH0gc3RhcnRUaW1lXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IGVuZFRpbWVcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBgdGltZXBpY2tlcigpYCBjYWxsLiBBbHNvIHN1cHBvcnRzIGByZWZvcm1hdGAsXG5cdCAqICAgYSBib29sZWFuIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmb3JtYXQgdGhlIGlucHV0IHZhbHVlcyB0byB0aGUgYGRhdGVGb3JtYXRgLlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZCBDYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSB0eXBlIG9mIHBpY2tlciB0byBiZSBhZGRlZFxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIuZGF0ZXRpbWVSYW5nZSA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpIHtcblx0XHQkLnRpbWVwaWNrZXIuaGFuZGxlUmFuZ2UoJ2RhdGV0aW1lcGlja2VyJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbHMgYGRhdGVwaWNrZXJgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IHN0YXJ0VGltZVxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYHRpbWVwaWNrZXIoKWAgY2FsbC4gQWxzbyBzdXBwb3J0cyBgcmVmb3JtYXRgLFxuXHQgKiAgIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZm9ybWF0IHRoZSBpbnB1dCB2YWx1ZXMgdG8gdGhlIGBkYXRlRm9ybWF0YC5cblx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHQgKi9cblx0JC50aW1lcGlja2VyLmRhdGVSYW5nZSA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpIHtcblx0XHQkLnRpbWVwaWNrZXIuaGFuZGxlUmFuZ2UoJ2RhdGVwaWNrZXInLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxscyBgbWV0aG9kYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xuXHQgKiBlbmZvcmNlIGRhdGUgcmFuZ2UgbGltaXRzLlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZCBDYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSB0eXBlIG9mIHBpY2tlciB0byBiZSBhZGRlZFxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcblx0ICogQHBhcmFtICB7RWxlbWVudH0gZW5kVGltZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGB0aW1lcGlja2VyKClgIGNhbGwuIEFsc28gc3VwcG9ydHMgYHJlZm9ybWF0YCxcblx0ICogICBhIGJvb2xlYW4gdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWVzIHRvIHRoZSBgZGF0ZUZvcm1hdGAuXG5cdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0ICovXG5cdCQudGltZXBpY2tlci5oYW5kbGVSYW5nZSA9IGZ1bmN0aW9uIChtZXRob2QsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwge1xuXHRcdFx0bWluSW50ZXJ2YWw6IDAsIC8vIG1pbiBhbGxvd2VkIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuXHRcdFx0bWF4SW50ZXJ2YWw6IDAsIC8vIG1heCBhbGxvd2VkIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuXHRcdFx0c3RhcnQ6IHt9LCAgICAgIC8vIG9wdGlvbnMgZm9yIHN0YXJ0IHBpY2tlclxuXHRcdFx0ZW5kOiB7fSAgICAgICAgIC8vIG9wdGlvbnMgZm9yIGVuZCBwaWNrZXJcblx0XHR9LCBvcHRpb25zKTtcblxuXHRcdC8vIGZvciB0aGUgbWVhbiB0aW1lIHRoaXMgZml4ZXMgYW4gaXNzdWUgd2l0aCBjYWxsaW5nIGdldERhdGUgd2l0aCB0aW1lcGlja2VyKClcblx0XHR2YXIgdGltZU9ubHkgPSBmYWxzZTtcblx0XHRpZihtZXRob2QgPT09ICd0aW1lcGlja2VyJyl7XG5cdFx0XHR0aW1lT25seSA9IHRydWU7XG5cdFx0XHRtZXRob2QgPSAnZGF0ZXRpbWVwaWNrZXInO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrRGF0ZXMoY2hhbmdlZCwgb3RoZXIpIHtcblx0XHRcdHZhciBzdGFydGR0ID0gc3RhcnRUaW1lW21ldGhvZF0oJ2dldERhdGUnKSxcblx0XHRcdFx0ZW5kZHQgPSBlbmRUaW1lW21ldGhvZF0oJ2dldERhdGUnKSxcblx0XHRcdFx0Y2hhbmdlZGR0ID0gY2hhbmdlZFttZXRob2RdKCdnZXREYXRlJyk7XG5cblx0XHRcdGlmIChzdGFydGR0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhciBtaW5EYXRlID0gbmV3IERhdGUoc3RhcnRkdC5nZXRUaW1lKCkpLFxuXHRcdFx0XHRcdG1heERhdGUgPSBuZXcgRGF0ZShzdGFydGR0LmdldFRpbWUoKSk7XG5cblx0XHRcdFx0bWluRGF0ZS5zZXRNaWxsaXNlY29uZHMobWluRGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG9wdGlvbnMubWluSW50ZXJ2YWwpO1xuXHRcdFx0XHRtYXhEYXRlLnNldE1pbGxpc2Vjb25kcyhtYXhEYXRlLmdldE1pbGxpc2Vjb25kcygpICsgb3B0aW9ucy5tYXhJbnRlcnZhbCk7XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMubWluSW50ZXJ2YWwgPiAwICYmIG1pbkRhdGUgPiBlbmRkdCkgeyAvLyBtaW5JbnRlcnZhbCBjaGVja1xuXHRcdFx0XHRcdGVuZFRpbWVbbWV0aG9kXSgnc2V0RGF0ZScsIG1pbkRhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKG9wdGlvbnMubWF4SW50ZXJ2YWwgPiAwICYmIG1heERhdGUgPCBlbmRkdCkgeyAvLyBtYXggaW50ZXJ2YWwgY2hlY2tcblx0XHRcdFx0XHRlbmRUaW1lW21ldGhvZF0oJ3NldERhdGUnLCBtYXhEYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChzdGFydGR0ID4gZW5kZHQpIHtcblx0XHRcdFx0XHRvdGhlclttZXRob2RdKCdzZXREYXRlJywgY2hhbmdlZGR0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNlbGVjdGVkKGNoYW5nZWQsIG90aGVyLCBvcHRpb24pIHtcblx0XHRcdGlmICghY2hhbmdlZC52YWwoKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZGF0ZSA9IGNoYW5nZWRbbWV0aG9kXS5jYWxsKGNoYW5nZWQsICdnZXREYXRlJyk7XG5cdFx0XHRpZiAoZGF0ZSAhPT0gbnVsbCAmJiBvcHRpb25zLm1pbkludGVydmFsID4gMCkge1xuXHRcdFx0XHRpZiAob3B0aW9uID09PSAnbWluRGF0ZScpIHtcblx0XHRcdFx0XHRkYXRlLnNldE1pbGxpc2Vjb25kcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpICsgb3B0aW9ucy5taW5JbnRlcnZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdGlvbiA9PT0gJ21heERhdGUnKSB7XG5cdFx0XHRcdFx0ZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAtIG9wdGlvbnMubWluSW50ZXJ2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRlLmdldFRpbWUpIHtcblx0XHRcdFx0b3RoZXJbbWV0aG9kXS5jYWxsKG90aGVyLCAnb3B0aW9uJywgb3B0aW9uLCBkYXRlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQkLmZuW21ldGhvZF0uY2FsbChzdGFydFRpbWUsICQuZXh0ZW5kKHtcblx0XHRcdHRpbWVPbmx5OiB0aW1lT25seSxcblx0XHRcdG9uQ2xvc2U6IGZ1bmN0aW9uIChkYXRlVGV4dCwgaW5zdCkge1xuXHRcdFx0XHRjaGVja0RhdGVzKCQodGhpcyksIGVuZFRpbWUpO1xuXHRcdFx0fSxcblx0XHRcdG9uU2VsZWN0OiBmdW5jdGlvbiAoc2VsZWN0ZWREYXRlVGltZSkge1xuXHRcdFx0XHRzZWxlY3RlZCgkKHRoaXMpLCBlbmRUaW1lLCAnbWluRGF0ZScpO1xuXHRcdFx0fVxuXHRcdH0sIG9wdGlvbnMsIG9wdGlvbnMuc3RhcnQpKTtcblx0XHQkLmZuW21ldGhvZF0uY2FsbChlbmRUaW1lLCAkLmV4dGVuZCh7XG5cdFx0XHR0aW1lT25seTogdGltZU9ubHksXG5cdFx0XHRvbkNsb3NlOiBmdW5jdGlvbiAoZGF0ZVRleHQsIGluc3QpIHtcblx0XHRcdFx0Y2hlY2tEYXRlcygkKHRoaXMpLCBzdGFydFRpbWUpO1xuXHRcdFx0fSxcblx0XHRcdG9uU2VsZWN0OiBmdW5jdGlvbiAoc2VsZWN0ZWREYXRlVGltZSkge1xuXHRcdFx0XHRzZWxlY3RlZCgkKHRoaXMpLCBzdGFydFRpbWUsICdtYXhEYXRlJyk7XG5cdFx0XHR9XG5cdFx0fSwgb3B0aW9ucywgb3B0aW9ucy5lbmQpKTtcblxuXHRcdGNoZWNrRGF0ZXMoc3RhcnRUaW1lLCBlbmRUaW1lKTtcblxuXHRcdHNlbGVjdGVkKHN0YXJ0VGltZSwgZW5kVGltZSwgJ21pbkRhdGUnKTtcblx0XHRzZWxlY3RlZChlbmRUaW1lLCBzdGFydFRpbWUsICdtYXhEYXRlJyk7XG5cblx0XHRyZXR1cm4gJChbc3RhcnRUaW1lLmdldCgwKSwgZW5kVGltZS5nZXQoMCldKTtcblx0fTtcblxuXHQvKipcblx0ICogTG9nIGVycm9yIG9yIGRhdGEgdG8gdGhlIGNvbnNvbGUgZHVyaW5nIGVycm9yIG9yIGRlYnVnZ2luZ1xuXHQgKiBAcGFyYW0gIHtPYmplY3R9IGVyciBwYXNzIGFueSB0eXBlIG9iamVjdCB0byBsb2cgdG8gdGhlIGNvbnNvbGUgZHVyaW5nIGVycm9yIG9yIGRlYnVnZ2luZ1xuXHQgKiBAcmV0dXJuIHt2b2lkfVxuXHQgKi9cblx0JC50aW1lcGlja2VyLmxvZyA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBPbGRlciBJRSAoOSwgbWF5YmUgMTApIHRocm93IGVycm9yIG9uIGFjY2Vzc2luZyBgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5YCwgc28gY2hlY2sgZmlyc3QuXG5cdFx0aWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZyAmJiB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkpIHtcblx0XHRcdHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseSh3aW5kb3cuY29uc29sZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCAqIEFkZCB1dGlsIG9iamVjdCB0byBhbGxvdyBhY2Nlc3MgdG8gcHJpdmF0ZSBtZXRob2RzIGZvciB0ZXN0YWJpbGl0eS5cblx0ICovXG5cdCQudGltZXBpY2tlci5fdXRpbCA9IHtcblx0XHRfZXh0ZW5kUmVtb3ZlOiBleHRlbmRSZW1vdmUsXG5cdFx0X2lzRW1wdHlPYmplY3Q6IGlzRW1wdHlPYmplY3QsXG5cdFx0X2NvbnZlcnQyNHRvMTI6IGNvbnZlcnQyNHRvMTIsXG5cdFx0X2RldGVjdFN1cHBvcnQ6IGRldGVjdFN1cHBvcnQsXG5cdFx0X3NlbGVjdExvY2FsVGltZXpvbmU6IHNlbGVjdExvY2FsVGltZXpvbmUsXG5cdFx0X2NvbXB1dGVFZmZlY3RpdmVTZXR0aW5nOiBjb21wdXRlRWZmZWN0aXZlU2V0dGluZyxcblx0XHRfc3BsaXREYXRlVGltZTogc3BsaXREYXRlVGltZSxcblx0XHRfcGFyc2VEYXRlVGltZUludGVybmFsOiBwYXJzZURhdGVUaW1lSW50ZXJuYWxcblx0fTtcblxuXHQvKlxuXHQqIE1pY3Jvc2Vjb25kIHN1cHBvcnRcblx0Ki9cblx0aWYgKCFEYXRlLnByb3RvdHlwZS5nZXRNaWNyb3NlY29uZHMpIHtcblx0XHREYXRlLnByb3RvdHlwZS5taWNyb3NlY29uZHMgPSAwO1xuXHRcdERhdGUucHJvdG90eXBlLmdldE1pY3Jvc2Vjb25kcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWljcm9zZWNvbmRzOyB9O1xuXHRcdERhdGUucHJvdG90eXBlLnNldE1pY3Jvc2Vjb25kcyA9IGZ1bmN0aW9uIChtKSB7XG5cdFx0XHR0aGlzLnNldE1pbGxpc2Vjb25kcyh0aGlzLmdldE1pbGxpc2Vjb25kcygpICsgTWF0aC5mbG9vcihtIC8gMTAwMCkpO1xuXHRcdFx0dGhpcy5taWNyb3NlY29uZHMgPSBtICUgMTAwMDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH1cblxuXHQvKlxuXHQqIEtlZXAgdXAgd2l0aCB0aGUgdmVyc2lvblxuXHQqL1xuXHQkLnRpbWVwaWNrZXIudmVyc2lvbiA9IFwiMS42LjNcIjtcblxufSkod2luZG93LmpRdWVyeSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvZnJvbnRlbmQvanMvdmVuZG9yL2pxdWVyeS11aS10aW1lcGlja2VyLWFkZG9uLmpzIiwiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xMS4wXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLlBvcHBlciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIG5hdGl2ZUhpbnRzID0gWyduYXRpdmUgY29kZScsICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZCBuYXRpdmVseSAoYXMgb3Bwb3NlZCB0byBhIHBvbHlmaWxsKS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RnVuY3Rpb24gfCB1bmRlZmluZWR9IGZuIHRoZSBmdW5jdGlvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbnZhciBpc05hdGl2ZSA9IChmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG5hdGl2ZUhpbnRzLnNvbWUoZnVuY3Rpb24gKGhpbnQpIHtcbiAgICByZXR1cm4gKGZuIHx8ICcnKS50b1N0cmluZygpLmluZGV4T2YoaGludCkgPiAtMTtcbiAgfSk7XG59KTtcblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBpID0gMDtcbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3Igc2NoZWR1bGluZyBtaWNyb3Rhc2tzLCB3aGljaFxuICAvLyBhcmUgc2NoZWR1bGVkICpiZWZvcmUqIHRoZSBuZXh0IHRhc2suIFRoaXMgZ2l2ZXMgdXMgYSB3YXkgdG8gZGVib3VuY2VcbiAgLy8gYSBmdW5jdGlvbiBidXQgZW5zdXJlIGl0J3MgY2FsbGVkICpiZWZvcmUqIHRoZSBuZXh0IHBhaW50LlxuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgZm4oKTtcbiAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgfSk7XG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4LWluZGV4JywgaSk7XG4gICAgICBpID0gaSArIDE7IC8vIGRvbid0IHVzZSBjb21wdW5kICgrPSkgYmVjYXVzZSBpdCBkb2Vzbid0IGdldCBvcHRpbWl6ZWQgaW4gVjhcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gSXQncyBjb21tb24gZm9yIE11dGF0aW9uT2JzZXJ2ZXIgcG9seWZpbGxzIHRvIGJlIHNlZW4gaW4gdGhlIHdpbGQsIGhvd2V2ZXJcbi8vIHRoZXNlIHJlbHkgb24gTXV0YXRpb24gRXZlbnRzIHdoaWNoIG9ubHkgb2NjdXIgd2hlbiBhbiBlbGVtZW50IGlzIGNvbm5lY3RlZFxuLy8gdG8gdGhlIERPTS4gVGhlIGFsZ29yaXRobSB1c2VkIGluIHRoaXMgbW9kdWxlIGRvZXMgbm90IHVzZSBhIGNvbm5lY3RlZCBlbGVtZW50LFxuLy8gYW5kIHNvIHdlIG11c3QgZW5zdXJlIHRoYXQgYSAqbmF0aXZlKiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cbnZhciBzdXBwb3J0c05hdGl2ZU11dGF0aW9uT2JzZXJ2ZXIgPSBpc0Jyb3dzZXIgJiYgaXNOYXRpdmUod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNOYXRpdmVNdXRhdGlvbk9ic2VydmVyID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50IHx8IFsnSFRNTCcsICdCT0RZJywgJyNkb2N1bWVudCddLmluZGV4T2YoZWxlbWVudC5ub2RlTmFtZSkgIT09IC0xKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGwpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gK3N0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10uc3BsaXQoJ3B4JylbMF0gKyArc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXS5zcGxpdCgncHgnKVswXTtcbn1cblxuLyoqXG4gKiBUZWxscyBpZiB5b3UgYXJlIHJ1bm5pbmcgSW50ZXJuZXQgRXhwbG9yZXIgMTBcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFMTBcbiAqL1xudmFyIGlzSUUxMCA9IHVuZGVmaW5lZDtcblxudmFyIGlzSUUxMCQxID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaXNJRTEwID09PSB1bmRlZmluZWQpIHtcbiAgICBpc0lFMTAgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDEwJykgIT09IC0xO1xuICB9XG4gIHJldHVybiBpc0lFMTA7XG59O1xuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGlzSUUxMCQxKCkgPyBodG1sWydvZmZzZXQnICsgYXhpc10gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcygpIHtcbiAgdmFyIGJvZHkgPSB3aW5kb3cuZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUxMCQxKCkgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgaWYgKGlzSUUxMCQxKCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0gZWxzZSB7XG4gICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoKSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5ib3R0b20gLSByZXN1bHQudG9wO1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgaXNJRTEwID0gaXNJRTEwJDEoKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSArc3R5bGVzLmJvcmRlclRvcFdpZHRoLnNwbGl0KCdweCcpWzBdO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gK3N0eWxlcy5ib3JkZXJMZWZ0V2lkdGguc3BsaXQoJ3B4JylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSArc3R5bGVzLm1hcmdpblRvcC5zcGxpdCgncHgnKVswXTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9ICtzdHlsZXMubWFyZ2luTGVmdC5zcGxpdCgncHgnKVswXTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGh0bWwgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGh0bWwpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChodG1sLCAnbGVmdCcpO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocG9wcGVyKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50KTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcygpLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRXaW5kb3dTaXplcy5oZWlnaHQsXG4gICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgYm91bmRhcmllcy5sZWZ0ICs9IHBhZGRpbmc7XG4gIGJvdW5kYXJpZXMudG9wICs9IHBhZGRpbmc7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gcGFkZGluZztcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gcGFkZGluZztcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0KTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXIuZnVuY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXIuZnVuY3Rpb24gfHwgbW9kaWZpZXIuZm47XG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0eSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyB3aW5kb3cgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBvblVwZGF0ZSBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIHRoZSBhcnJvdyBzdHlsZSBoYXMgYmVlbiBjb21wdXRlZCwgYXBwbHkgdGhlIGFycm93IHN0eWxlXG4gIGlmIChkYXRhLm9mZnNldHMuYXJyb3cpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEub2Zmc2V0cy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgLy8gZmxvb3Igc2lkZXMgdG8gYXZvaWQgYmx1cnJ5IHRleHRcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgbGVmdDogTWF0aC5mbG9vcihwb3BwZXIubGVmdCksXG4gICAgdG9wOiBNYXRoLmZsb29yKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogTWF0aC5mbG9vcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogTWF0aC5mbG9vcihwb3BwZXIucmlnaHQpXG4gIH07XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYXR0cmlidXRlcyBhbmQgc3R5bGVzIG9mIGBkYXRhYFxuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdWN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcilbc2lkZV07XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IHt9O1xuICBkYXRhLm9mZnNldHMuYXJyb3dbc2lkZV0gPSBNYXRoLnJvdW5kKHNpZGVWYWx1ZSk7XG4gIGRhdGEub2Zmc2V0cy5hcnJvd1thbHRTaWRlXSA9ICcnOyAvLyBtYWtlIHN1cmUgdG8gdW5zZXQgYW55IGV2ZW50dWFsIGFsdFNpZGUgdmFsdWUgZnJvbSB0aGUgRE9NIG5vZGVcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tcmlnaHRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIHZhciBjaGVjayA9IHtcbiAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW3BsYWNlbWVudF07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNlY29uZGFyeTogZnVuY3Rpb24gc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcjtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIHNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcblxuICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtwbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdGxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGhlaWdodC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBbiBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyIHRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGhhcyBhbHdheXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllciwgY2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaG90aGVyc1xuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEV4cGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGFzc3VyZSBpdCB0byBwb2ludCB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMsIHlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1Y3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKS5cbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbixcbiAgICAgKiB0aGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYga2VlcFRvZ2V0aGVyIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3Ugb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzZCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbnMgdXNlZCBieSBQb3BwZXIuanNcbiAqIHRoaXMgb2JqZWN0IGdldCBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsIGl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhcyAzcmQgYXJndW1lbnQgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGlzIG9iamVjdCwgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnRcbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQsIHRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qc1xuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhbiB1cGRhdGUsIGl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGVcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbnJldHVybiBQb3BwZXI7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Zyb250ZW5kL2pzL3ZlbmRvci9wb3BwZXIuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gNyIsIi8qIVxuICogQm9vdHN0cmFwIHY0LjAuMC1iZXRhIChodHRwczovL2dldGJvb3RzdHJhcC5jb20pXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE3IFRoZSBCb290c3RyYXAgQXV0aG9ycyAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2dyYXBocy9jb250cmlidXRvcnMpXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5cbmlmICh0eXBlb2YgalF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkuIGpRdWVyeSBtdXN0IGJlIGluY2x1ZGVkIGJlZm9yZSBCb290c3RyYXBcXCdzIEphdmFTY3JpcHQuJylcbn1cblxuKGZ1bmN0aW9uICgkKSB7XG4gIHZhciB2ZXJzaW9uID0gJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpXG4gIGlmICgodmVyc2lvblswXSA8IDIgJiYgdmVyc2lvblsxXSA8IDkpIHx8ICh2ZXJzaW9uWzBdID09IDEgJiYgdmVyc2lvblsxXSA9PSA5ICYmIHZlcnNpb25bMl0gPCAxKSB8fCAodmVyc2lvblswXSA+PSA0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGF0IGxlYXN0IGpRdWVyeSB2MS45LjEgYnV0IGxlc3MgdGhhbiB2NC4wLjAnKVxuICB9XG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24gKCkge1xudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWJldGEpOiB1dGlsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgVXRpbCA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBQcml2YXRlIFRyYW5zaXRpb25FbmQgSGVscGVyc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIHRyYW5zaXRpb24gPSBmYWxzZTtcblxuICB2YXIgTUFYX1VJRCA9IDEwMDAwMDA7XG5cbiAgdmFyIFRyYW5zaXRpb25FbmRFdmVudCA9IHtcbiAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgTW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnLFxuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xuXG4gICAgLy8gc2hvdXRvdXQgQW5ndXNDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxuICB9O2Z1bmN0aW9uIHRvVHlwZShvYmopIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJpbmRUeXBlOiB0cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogdHJhbnNpdGlvbi5lbmQsXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgICAgICBpZiAoJChldmVudC50YXJnZXQpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZFRlc3QoKSB7XG4gICAgaWYgKHdpbmRvdy5RVW5pdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBUcmFuc2l0aW9uRW5kRXZlbnQpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZW5kOiBUcmFuc2l0aW9uRW5kRXZlbnRbbmFtZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kRW11bGF0b3IoZHVyYXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgJCh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZChfdGhpcyk7XG4gICAgICB9XG4gICAgfSwgZHVyYXRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpIHtcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZFRlc3QoKTtcblxuICAgICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kRW11bGF0b3I7XG5cbiAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgJC5ldmVudC5zcGVjaWFsW1V0aWwuVFJBTlNJVElPTl9FTkRdID0gZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBQdWJsaWMgVXRpbCBBcGlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIFV0aWwgPSB7XG5cbiAgICBUUkFOU0lUSU9OX0VORDogJ2JzVHJhbnNpdGlvbkVuZCcsXG5cbiAgICBnZXRVSUQ6IGZ1bmN0aW9uIGdldFVJRChwcmVmaXgpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTsgLy8gXCJ+flwiIGFjdHMgbGlrZSBhIGZhc3RlciBNYXRoLmZsb29yKCkgaGVyZVxuICAgICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XG4gICAgICByZXR1cm4gcHJlZml4O1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudDogZnVuY3Rpb24gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKTtcbiAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgICAgICBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciAkc2VsZWN0b3IgPSAkKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuICRzZWxlY3Rvci5sZW5ndGggPiAwID8gc2VsZWN0b3IgOiBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfSxcbiAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCkge1xuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKHRyYW5zaXRpb24uZW5kKTtcbiAgICB9LFxuICAgIHN1cHBvcnRzVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odHJhbnNpdGlvbik7XG4gICAgfSxcbiAgICB0eXBlQ2hlY2tDb25maWc6IGZ1bmN0aW9uIHR5cGVDaGVja0NvbmZpZyhjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBjb25maWdUeXBlcykge1xuICAgICAgICBpZiAoY29uZmlnVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV07XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29uZmlnW3Byb3BlcnR5XTtcbiAgICAgICAgICB2YXIgdmFsdWVUeXBlID0gdmFsdWUgJiYgaXNFbGVtZW50KHZhbHVlKSA/ICdlbGVtZW50JyA6IHRvVHlwZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpICsgJzogJyArICgnT3B0aW9uIFwiJyArIHByb3BlcnR5ICsgJ1wiIHByb3ZpZGVkIHR5cGUgXCInICsgdmFsdWVUeXBlICsgJ1wiICcpICsgKCdidXQgZXhwZWN0ZWQgdHlwZSBcIicgKyBleHBlY3RlZFR5cGVzICsgJ1wiLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKTtcblxuICByZXR1cm4gVXRpbDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IGFsZXJ0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgQWxlcnQgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdhbGVydCc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuYWxlcnQnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwO1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBESVNNSVNTOiAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBDTE9TRTogJ2Nsb3NlJyArIEVWRU5UX0tFWSxcbiAgICBDTE9TRUQ6ICdjbG9zZWQnICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gIH07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBBTEVSVDogJ2FsZXJ0JyxcbiAgICBGQURFOiAnZmFkZScsXG4gICAgU0hPVzogJ3Nob3cnXG5cbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgfTtcbiAgdmFyIEFsZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsZXJ0KGVsZW1lbnQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbGVydCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgQWxlcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudDtcblxuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB2YXIgY3VzdG9tRXZlbnQgPSB0aGlzLl90cmlnZ2VyQ2xvc2VFdmVudChyb290RWxlbWVudCk7XG5cbiAgICAgIGlmIChjdXN0b21FdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIEFsZXJ0LnByb3RvdHlwZS5fZ2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdmFyIHBhcmVudCA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcGFyZW50ID0gJChzZWxlY3RvcilbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9ICQoZWxlbWVudCkuY2xvc2VzdCgnLicgKyBDbGFzc05hbWUuQUxFUlQpWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuX3RyaWdnZXJDbG9zZUV2ZW50ID0gZnVuY3Rpb24gX3RyaWdnZXJDbG9zZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBjbG9zZUV2ZW50ID0gJC5FdmVudChFdmVudC5DTE9TRSk7XG5cbiAgICAgICQoZWxlbWVudCkudHJpZ2dlcihjbG9zZUV2ZW50KTtcbiAgICAgIHJldHVybiBjbG9zZUV2ZW50O1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuX3JlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIGlmICghVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSB8fCAhJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgJChlbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQsIGV2ZW50KTtcbiAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pO1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuX2Rlc3Ryb3lFbGVtZW50ID0gZnVuY3Rpb24gX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICQoZWxlbWVudCkuZGV0YWNoKCkudHJpZ2dlcihFdmVudC5DTE9TRUQpLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBBbGVydCh0aGlzKTtcbiAgICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBBbGVydC5faGFuZGxlRGlzbWlzcyA9IGZ1bmN0aW9uIF9oYW5kbGVEaXNtaXNzKGFsZXJ0SW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFsZXJ0SW5zdGFuY2UuY2xvc2UodGhpcyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWxlcnQsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWxlcnQ7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuRElTTUlTUywgQWxlcnQuX2hhbmRsZURpc21pc3MobmV3IEFsZXJ0KCkpKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBBbGVydDtcbiAgJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgcmV0dXJuIEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIEFsZXJ0O1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogYnV0dG9uLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgQnV0dG9uID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAnYnV0dG9uJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYmV0YSc7XG4gIHZhciBEQVRBX0tFWSA9ICdicy5idXR0b24nO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBBQ1RJVkU6ICdhY3RpdmUnLFxuICAgIEJVVFRPTjogJ2J0bicsXG4gICAgRk9DVVM6ICdmb2N1cydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgREFUQV9UT0dHTEVfQ0FSUk9UOiAnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsXG4gICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyxcbiAgICBJTlBVVDogJ2lucHV0JyxcbiAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcbiAgICBCVVRUT046ICcuYnRuJ1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBDTElDS19EQVRBX0FQSTogJ2NsaWNrJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICBGT0NVU19CTFVSX0RBVEFfQVBJOiAnZm9jdXMnICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZICsgJyAnICsgKCdibHVyJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSlcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvbihlbGVtZW50KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcblxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gZ2V0dGVyc1xuXG4gICAgLy8gcHVibGljXG5cbiAgICBCdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIHZhciB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlO1xuICAgICAgdmFyIGFkZEFyaWFQcmVzc2VkID0gdHJ1ZTtcbiAgICAgIHZhciByb290RWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5EQVRBX1RPR0dMRSlbMF07XG5cbiAgICAgIGlmIChyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgaW5wdXQgPSAkKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuSU5QVVQpWzBdO1xuXG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAmJiAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5BQ1RJVkUpKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2VFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSAkKHJvb3RFbGVtZW50KS5maW5kKFNlbGVjdG9yLkFDVElWRSlbMF07XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAkKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpIHx8IHJvb3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dC5jaGVja2VkID0gISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICAgICAkKGlucHV0KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgIGFkZEFyaWFQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFkZEFyaWFQcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCAhJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQnV0dG9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBCdXR0b24uX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKEJ1dHRvbiwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCdXR0b247XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICghJChidXR0b24pLmhhc0NsYXNzKENsYXNzTmFtZS5CVVRUT04pKSB7XG4gICAgICBidXR0b24gPSAkKGJ1dHRvbikuY2xvc2VzdChTZWxlY3Rvci5CVVRUT04pO1xuICAgIH1cblxuICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChidXR0b24pLCAndG9nZ2xlJyk7XG4gIH0pLm9uKEV2ZW50LkZPQ1VTX0JMVVJfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFX0NBUlJPVCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yLkJVVFRPTilbMF07XG4gICAgJChidXR0b24pLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5GT0NVUywgL15mb2N1cyhpbik/JC8udGVzdChldmVudC50eXBlKSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBCdXR0b247XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gQnV0dG9uO1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogY2Fyb3VzZWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ2Nhcm91c2VsJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYmV0YSc7XG4gIHZhciBEQVRBX0tFWSA9ICdicy5jYXJvdXNlbCc7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbiAgdmFyIFRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDA7XG4gIHZhciBBUlJPV19MRUZUX0tFWUNPREUgPSAzNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgbGVmdCBhcnJvdyBrZXlcbiAgdmFyIEFSUk9XX1JJR0hUX0tFWUNPREUgPSAzOTsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgcmlnaHQgYXJyb3cga2V5XG4gIHZhciBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcblxuICB2YXIgRGVmYXVsdCA9IHtcbiAgICBpbnRlcnZhbDogNTAwMCxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzbGlkZTogZmFsc2UsXG4gICAgcGF1c2U6ICdob3ZlcicsXG4gICAgd3JhcDogdHJ1ZVxuICB9O1xuXG4gIHZhciBEZWZhdWx0VHlwZSA9IHtcbiAgICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gICAgc2xpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHdyYXA6ICdib29sZWFuJ1xuICB9O1xuXG4gIHZhciBEaXJlY3Rpb24gPSB7XG4gICAgTkVYVDogJ25leHQnLFxuICAgIFBSRVY6ICdwcmV2JyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgUklHSFQ6ICdyaWdodCdcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgU0xJREU6ICdzbGlkZScgKyBFVkVOVF9LRVksXG4gICAgU0xJRDogJ3NsaWQnICsgRVZFTlRfS0VZLFxuICAgIEtFWURPV046ICdrZXlkb3duJyArIEVWRU5UX0tFWSxcbiAgICBNT1VTRUVOVEVSOiAnbW91c2VlbnRlcicgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VMRUFWRTogJ21vdXNlbGVhdmUnICsgRVZFTlRfS0VZLFxuICAgIFRPVUNIRU5EOiAndG91Y2hlbmQnICsgRVZFTlRfS0VZLFxuICAgIExPQURfREFUQV9BUEk6ICdsb2FkJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICBDTElDS19EQVRBX0FQSTogJ2NsaWNrJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICB9O1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgQ0FST1VTRUw6ICdjYXJvdXNlbCcsXG4gICAgQUNUSVZFOiAnYWN0aXZlJyxcbiAgICBTTElERTogJ3NsaWRlJyxcbiAgICBSSUdIVDogJ2Nhcm91c2VsLWl0ZW0tcmlnaHQnLFxuICAgIExFRlQ6ICdjYXJvdXNlbC1pdGVtLWxlZnQnLFxuICAgIE5FWFQ6ICdjYXJvdXNlbC1pdGVtLW5leHQnLFxuICAgIFBSRVY6ICdjYXJvdXNlbC1pdGVtLXByZXYnLFxuICAgIElURU06ICdjYXJvdXNlbC1pdGVtJ1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcbiAgICBBQ1RJVkVfSVRFTTogJy5hY3RpdmUuY2Fyb3VzZWwtaXRlbScsXG4gICAgSVRFTTogJy5jYXJvdXNlbC1pdGVtJyxcbiAgICBORVhUX1BSRVY6ICcuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2JyxcbiAgICBJTkRJQ0FUT1JTOiAnLmNhcm91c2VsLWluZGljYXRvcnMnLFxuICAgIERBVEFfU0xJREU6ICdbZGF0YS1zbGlkZV0sIFtkYXRhLXNsaWRlLXRvXScsXG4gICAgREFUQV9SSURFOiAnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJ1xuXG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gIH07XG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXJvdXNlbChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbCk7XG5cbiAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gJChlbGVtZW50KVswXTtcbiAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLklORElDQVRPUlMpWzBdO1xuXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgdGhpcy5fc2xpZGUoRGlyZWN0aW9uLk5FWFQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUubmV4dFdoZW5WaXNpYmxlID0gZnVuY3Rpb24gbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gcHJldigpIHtcbiAgICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlKERpcmVjdGlvbi5QUkVWKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoZXZlbnQpIHtcbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLk5FWFRfUFJFVilbMF0gJiYgVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgICBVdGlsLnRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLmN5Y2xlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmN5Y2xlID0gZnVuY3Rpb24gY3ljbGUoZXZlbnQpIHtcbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuaW50ZXJ2YWwgJiYgIXRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKHRoaXMpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byhpbmRleCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSAkKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFX0lURU0pWzBdO1xuXG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7XG5cbiAgICAgIGlmIChpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShFdmVudC5TTElELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy50byhpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBEaXJlY3Rpb24uTkVYVCA6IERpcmVjdGlvbi5QUkVWO1xuXG4gICAgICB0aGlzLl9zbGlkZShkaXJlY3Rpb24sIHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSk7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IG51bGw7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5LRVlET1dOLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0Ll9rZXlkb3duKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5NT1VTRUVOVEVSLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnBhdXNlKGV2ZW50KTtcbiAgICAgICAgfSkub24oRXZlbnQuTU9VU0VMRUFWRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5jeWNsZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgLy8gaWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcbiAgICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LlRPVUNIRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQucGF1c2UoKTtcbiAgICAgICAgICAgIGlmIChfdGhpczQudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpczQudG91Y2hUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNC50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0LmN5Y2xlKGV2ZW50KTtcbiAgICAgICAgICAgIH0sIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyBfdGhpczQuX2NvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9rZXlkb3duID0gZnVuY3Rpb24gX2tleWRvd24oZXZlbnQpIHtcbiAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcbiAgICAgICAgY2FzZSBBUlJPV19MRUZUX0tFWUNPREU6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnByZXYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBUlJPV19SSUdIVF9LRVlDT0RFOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldEl0ZW1JbmRleCA9IGZ1bmN0aW9uIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgICAgdGhpcy5faXRlbXMgPSAkLm1ha2VBcnJheSgkKGVsZW1lbnQpLnBhcmVudCgpLmZpbmQoU2VsZWN0b3IuSVRFTSkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoZWxlbWVudCk7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0SXRlbUJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBpc05leHREaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5ORVhUO1xuICAgICAgdmFyIGlzUHJldkRpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlBSRVY7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XG4gICAgICB2YXIgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaXNHb2luZ1RvV3JhcCA9IGlzUHJldkRpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gMCB8fCBpc05leHREaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IGxhc3RJdGVtSW5kZXg7XG5cbiAgICAgIGlmIChpc0dvaW5nVG9XcmFwICYmICF0aGlzLl9jb25maWcud3JhcCkge1xuICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUFJFViA/IC0xIDogMTtcbiAgICAgIHZhciBpdGVtSW5kZXggPSAoYWN0aXZlSW5kZXggKyBkZWx0YSkgJSB0aGlzLl9pdGVtcy5sZW5ndGg7XG5cbiAgICAgIHJldHVybiBpdGVtSW5kZXggPT09IC0xID8gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV0gOiB0aGlzLl9pdGVtc1tpdGVtSW5kZXhdO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3RyaWdnZXJTbGlkZUV2ZW50ID0gZnVuY3Rpb24gX3RyaWdnZXJTbGlkZUV2ZW50KHJlbGF0ZWRUYXJnZXQsIGV2ZW50RGlyZWN0aW9uTmFtZSkge1xuICAgICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCgkKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFX0lURU0pWzBdKTtcbiAgICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5TTElERSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgICBkaXJlY3Rpb246IGV2ZW50RGlyZWN0aW9uTmFtZSxcbiAgICAgICAgZnJvbTogZnJvbUluZGV4LFxuICAgICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICAgIH0pO1xuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZGVFdmVudCk7XG5cbiAgICAgIHJldHVybiBzbGlkZUV2ZW50O1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQgPSBmdW5jdGlvbiBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgICAgJCh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkuZmluZChTZWxlY3Rvci5BQ1RJVkUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuXG4gICAgICAgIHZhciBuZXh0SW5kaWNhdG9yID0gdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQuY2hpbGRyZW5bdGhpcy5fZ2V0SXRlbUluZGV4KGVsZW1lbnQpXTtcblxuICAgICAgICBpZiAobmV4dEluZGljYXRvcikge1xuICAgICAgICAgICQobmV4dEluZGljYXRvcikuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zbGlkZSA9IGZ1bmN0aW9uIF9zbGlkZShkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgYWN0aXZlRWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuZmluZChTZWxlY3Rvci5BQ1RJVkVfSVRFTSlbMF07XG4gICAgICB2YXIgYWN0aXZlRWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBhY3RpdmVFbGVtZW50ICYmIHRoaXMuX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpO1xuICAgICAgdmFyIGlzQ3ljbGluZyA9IEJvb2xlYW4odGhpcy5faW50ZXJ2YWwpO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgb3JkZXJDbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgZXZlbnREaXJlY3Rpb25OYW1lID0gdm9pZCAwO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTkVYVCkge1xuICAgICAgICBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IENsYXNzTmFtZS5MRUZUO1xuICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5ORVhUO1xuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uTEVGVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLlJJR0hUO1xuICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5QUkVWO1xuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uUklHSFQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0RWxlbWVudCAmJiAkKG5leHRFbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSkge1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpO1xuICAgICAgaWYgKHNsaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XG4gICAgICAgIC8vIHNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KTtcblxuICAgICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0xJRCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICAgIGZyb206IGFjdGl2ZUVsZW1lbnRJbmRleCxcbiAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TTElERSkpIHtcblxuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhvcmRlckNsYXNzTmFtZSk7XG5cbiAgICAgICAgVXRpbC5yZWZsb3cobmV4dEVsZW1lbnQpO1xuXG4gICAgICAgICQoYWN0aXZlRWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG5cbiAgICAgICAgJChhY3RpdmVFbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQobmV4dEVsZW1lbnQpLnJlbW92ZUNsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lICsgJyAnICsgb3JkZXJDbGFzc05hbWUpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFICsgJyAnICsgb3JkZXJDbGFzc05hbWUgKyAnICcgKyBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG5cbiAgICAgICAgICBfdGhpczUuX2lzU2xpZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJChfdGhpczUuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZEV2ZW50KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcblxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgdmFyIF9jb25maWcgPSAkLmV4dGVuZCh7fSwgRGVmYXVsdCwgJCh0aGlzKS5kYXRhKCkpO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGNvbmZpZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZmlnKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgJC5leHRlbmQoX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGU7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbYWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBhY3Rpb24gKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVthY3Rpb25dKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnRlcnZhbCkge1xuICAgICAgICAgIGRhdGEucGF1c2UoKTtcbiAgICAgICAgICBkYXRhLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5fZGF0YUFwaUNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XG5cbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gJChzZWxlY3RvcilbMF07XG5cbiAgICAgIGlmICghdGFyZ2V0IHx8ICEkKHRhcmdldCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkNBUk9VU0VMKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25maWcgPSAkLmV4dGVuZCh7fSwgJCh0YXJnZXQpLmRhdGEoKSwgJCh0aGlzKS5kYXRhKCkpO1xuICAgICAgdmFyIHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGlkZS10bycpO1xuXG4gICAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnKTtcblxuICAgICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICAgJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpLnRvKHNsaWRlSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWwsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2Fyb3VzZWw7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9TTElERSwgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIpO1xuXG4gICQod2luZG93KS5vbihFdmVudC5MT0FEX0RBVEFfQVBJLCBmdW5jdGlvbiAoKSB7XG4gICAgJChTZWxlY3Rvci5EQVRBX1JJREUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRjYXJvdXNlbCA9ICQodGhpcyk7XG4gICAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQ2Fyb3VzZWw7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBDYXJvdXNlbDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdjb2xsYXBzZSc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuY29sbGFwc2UnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gNjAwO1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICBwYXJlbnQ6ICcnXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nLFxuICAgIHBhcmVudDogJ3N0cmluZydcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgU0hPVzogJ3Nob3cnICsgRVZFTlRfS0VZLFxuICAgIFNIT1dOOiAnc2hvd24nICsgRVZFTlRfS0VZLFxuICAgIEhJREU6ICdoaWRlJyArIEVWRU5UX0tFWSxcbiAgICBISURERU46ICdoaWRkZW4nICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gIH07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBTSE9XOiAnc2hvdycsXG4gICAgQ09MTEFQU0U6ICdjb2xsYXBzZScsXG4gICAgQ09MTEFQU0lORzogJ2NvbGxhcHNpbmcnLFxuICAgIENPTExBUFNFRDogJ2NvbGxhcHNlZCdcbiAgfTtcblxuICB2YXIgRGltZW5zaW9uID0ge1xuICAgIFdJRFRIOiAnd2lkdGgnLFxuICAgIEhFSUdIVDogJ2hlaWdodCdcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgQUNUSVZFUzogJy5zaG93LCAuY29sbGFwc2luZycsXG4gICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXSdcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sbGFwc2UoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGFwc2UpO1xuXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSAkLm1ha2VBcnJheSgkKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXSwnICsgKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMnICsgZWxlbWVudC5pZCArICdcIl0nKSkpO1xuICAgICAgdmFyIHRhYlRvZ2dsZXMgPSAkKFNlbGVjdG9yLkRBVEFfVE9HR0xFKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFiVG9nZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbSA9IHRhYlRvZ2dsZXNbaV07XG4gICAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKTtcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmICQoc2VsZWN0b3IpLmZpbHRlcihlbGVtZW50KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbDtcblxuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhY3RpdmVzID0gdm9pZCAwO1xuICAgICAgdmFyIGFjdGl2ZXNEYXRhID0gdm9pZCAwO1xuXG4gICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgIGFjdGl2ZXMgPSAkLm1ha2VBcnJheSgkKHRoaXMuX3BhcmVudCkuY2hpbGRyZW4oKS5jaGlsZHJlbihTZWxlY3Rvci5BQ1RJVkVTKSk7XG4gICAgICAgIGlmICghYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY3RpdmVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlcykge1xuICAgICAgICBhY3RpdmVzRGF0YSA9ICQoYWN0aXZlcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudC5TSE9XKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQoYWN0aXZlcyksICdoaWRlJyk7XG4gICAgICAgIGlmICghYWN0aXZlc0RhdGEpIHtcbiAgICAgICAgICAkKGFjdGl2ZXMpLmRhdGEoREFUQV9LRVksIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcblxuICAgICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgJCh0aGlzLl90cmlnZ2VyQXJyYXkpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTRUQpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgJChfdGhpczYuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKS5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgICBfdGhpczYuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuXG4gICAgICAgIF90aGlzNi5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcblxuICAgICAgICAkKF90aGlzNi5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5TSE9XTik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIVV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcbiAgICAgIHZhciBzY3JvbGxTaXplID0gJ3Njcm9sbCcgKyBjYXBpdGFsaXplZERpbWVuc2lvbjtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSB0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdICsgJ3B4JztcbiAgICB9O1xuXG4gICAgQ29sbGFwc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUpO1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHN0YXJ0RXZlbnQpO1xuICAgICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXSArICdweCc7XG5cbiAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJBcnJheVtpXTtcbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodHJpZ2dlcik7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmICghJGVsZW0uaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgICAgICAgICQodHJpZ2dlcikuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgX3RoaXM3LnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xuICAgICAgICAkKF90aGlzNy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNJTkcpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSkudHJpZ2dlcihFdmVudC5ISURERU4pO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG5cbiAgICAgIGlmICghVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICB9O1xuXG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnNldFRyYW5zaXRpb25pbmcgPSBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gaXNUcmFuc2l0aW9uaW5nO1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIGNvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gX2dldERpbWVuc2lvbigpIHtcbiAgICAgIHZhciBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRGltZW5zaW9uLldJRFRIKTtcbiAgICAgIHJldHVybiBoYXNXaWR0aCA/IERpbWVuc2lvbi5XSURUSCA6IERpbWVuc2lvbi5IRUlHSFQ7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0UGFyZW50ID0gZnVuY3Rpb24gX2dldFBhcmVudCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyZW50ID0gJCh0aGlzLl9jb25maWcucGFyZW50KVswXTtcbiAgICAgIHZhciBzZWxlY3RvciA9ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLl9jb25maWcucGFyZW50ICsgJ1wiXSc7XG5cbiAgICAgICQocGFyZW50KS5maW5kKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIF90aGlzOC5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSwgW2VsZW1lbnRdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZWxlbWVudCwgdHJpZ2dlckFycmF5KSB7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgaXNPcGVuID0gJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICAgaWYgKHRyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAkKHRyaWdnZXJBcnJheSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCwgIWlzT3BlbikuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3Blbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBDb2xsYXBzZS5fZ2V0VGFyZ2V0RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gJChzZWxlY3RvcilbMF0gOiBudWxsO1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCAkdGhpcy5kYXRhKCksICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSA9PT0gJ29iamVjdCcgJiYgY29uZmlnKTtcblxuICAgICAgICBpZiAoIWRhdGEgJiYgX2NvbmZpZy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJHRoaXMuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyArIGNvbmZpZyArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhDb2xsYXBzZSwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb2xsYXBzZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQoZG9jdW1lbnQpLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgJHRyaWdnZXIgPSAkKHRoaXMpO1xuICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcbiAgICAkKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKTtcbiAgICAgIHZhciBkYXRhID0gJHRhcmdldC5kYXRhKERBVEFfS0VZKTtcbiAgICAgIHZhciBjb25maWcgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKCk7XG4gICAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHRhcmdldCwgY29uZmlnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQ29sbGFwc2U7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBDb2xsYXBzZTtcbn0oalF1ZXJ5KTtcblxuLyogZ2xvYmFsIFBvcHBlciAqL1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogZHJvcGRvd24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBEcm9wZG93biA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBQb3BwZXIgZGVwZW5kZW5jeVxuICAgKiBQb3BwZXIgLSBodHRwczovL3BvcHBlci5qcy5vcmdcbiAgICovXG4gIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwIGRyb3Bkb3duIHJlcXVpcmUgUG9wcGVyLmpzIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAnZHJvcGRvd24nO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1iZXRhJztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLmRyb3Bkb3duJztcbiAgdmFyIEVWRU5UX0tFWSA9ICcuJyArIERBVEFfS0VZO1xuICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuICB2YXIgRVNDQVBFX0tFWUNPREUgPSAyNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuICB2YXIgU1BBQ0VfS0VZQ09ERSA9IDMyOyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBzcGFjZSBrZXlcbiAgdmFyIFRBQl9LRVlDT0RFID0gOTsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdGFiIGtleVxuICB2YXIgQVJST1dfVVBfS0VZQ09ERSA9IDM4OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB1cCBhcnJvdyBrZXlcbiAgdmFyIEFSUk9XX0RPV05fS0VZQ09ERSA9IDQwOyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBkb3duIGFycm93IGtleVxuICB2YXIgUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIID0gMzsgLy8gTW91c2VFdmVudC53aGljaCB2YWx1ZSBmb3IgdGhlIHJpZ2h0IGJ1dHRvbiAoYXNzdW1pbmcgYSByaWdodC1oYW5kZWQgbW91c2UpXG4gIHZhciBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoQVJST1dfVVBfS0VZQ09ERSArICd8JyArIEFSUk9XX0RPV05fS0VZQ09ERSArICd8JyArIEVTQ0FQRV9LRVlDT0RFKTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgSElERTogJ2hpZGUnICsgRVZFTlRfS0VZLFxuICAgIEhJRERFTjogJ2hpZGRlbicgKyBFVkVOVF9LRVksXG4gICAgU0hPVzogJ3Nob3cnICsgRVZFTlRfS0VZLFxuICAgIFNIT1dOOiAnc2hvd24nICsgRVZFTlRfS0VZLFxuICAgIENMSUNLOiAnY2xpY2snICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZLFxuICAgIEtFWURPV05fREFUQV9BUEk6ICdrZXlkb3duJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICBLRVlVUF9EQVRBX0FQSTogJ2tleXVwJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICB9O1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0hPVzogJ3Nob3cnLFxuICAgIERST1BVUDogJ2Ryb3B1cCcsXG4gICAgTUVOVVJJR0hUOiAnZHJvcGRvd24tbWVudS1yaWdodCcsXG4gICAgTUVOVUxFRlQ6ICdkcm9wZG93bi1tZW51LWxlZnQnXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLFxuICAgIEZPUk1fQ0hJTEQ6ICcuZHJvcGRvd24gZm9ybScsXG4gICAgTUVOVTogJy5kcm9wZG93bi1tZW51JyxcbiAgICBOQVZCQVJfTkFWOiAnLm5hdmJhci1uYXYnLFxuICAgIFZJU0lCTEVfSVRFTVM6ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKSdcbiAgfTtcblxuICB2YXIgQXR0YWNobWVudE1hcCA9IHtcbiAgICBUT1A6ICd0b3Atc3RhcnQnLFxuICAgIFRPUEVORDogJ3RvcC1lbmQnLFxuICAgIEJPVFRPTTogJ2JvdHRvbS1zdGFydCcsXG4gICAgQk9UVE9NRU5EOiAnYm90dG9tLWVuZCdcbiAgfTtcblxuICB2YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6IEF0dGFjaG1lbnRNYXAuQk9UVE9NLFxuICAgIG9mZnNldDogMCxcbiAgICBmbGlwOiB0cnVlXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIHBsYWNlbWVudDogJ3N0cmluZycsXG4gICAgb2Zmc2V0OiAnKG51bWJlcnxzdHJpbmcpJyxcbiAgICBmbGlwOiAnYm9vbGVhbidcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcGRvd24oZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpO1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcblxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgdmFyIGlzQWN0aXZlID0gJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIERyb3Bkb3duLl9jbGVhck1lbnVzKCk7XG5cbiAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICQocGFyZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XG5cbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAvLyBmb3IgZHJvcHVwIHdpdGggYWxpZ25tZW50IHdlIHVzZSB0aGUgcGFyZW50IGFzIHBvcHBlciBjb250YWluZXJcbiAgICAgIGlmICgkKHBhcmVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BVUCkpIHtcbiAgICAgICAgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLk1FTlVMRUZUKSB8fCAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICAgICAgZWxlbWVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcihlbGVtZW50LCB0aGlzLl9tZW51LCB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSk7XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkKHBhcmVudCkuY2xvc2VzdChTZWxlY3Rvci5OQVZCQVJfTkFWKS5sZW5ndGgpIHtcbiAgICAgICAgJCgnYm9keScpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG5cbiAgICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuICAgICAgJChwYXJlbnQpLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5TSE9XKS50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuU0hPV04sIHJlbGF0ZWRUYXJnZXQpKTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX21lbnUgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0ssIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgX3RoaXM5LnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIHZhciBlbGVtZW50RGF0YSA9ICQodGhpcy5fZWxlbWVudCkuZGF0YSgpO1xuICAgICAgaWYgKGVsZW1lbnREYXRhLnBsYWNlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnREYXRhLnBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXBbZWxlbWVudERhdGEucGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xuICAgICAgfVxuXG4gICAgICBjb25maWcgPSAkLmV4dGVuZCh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCAkKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSwgY29uZmlnKTtcblxuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9nZXRNZW51RWxlbWVudCA9IGZ1bmN0aW9uIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5fbWVudSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9tZW51ID0gJChwYXJlbnQpLmZpbmQoU2VsZWN0b3IuTUVOVSlbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbWVudTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9nZXRQbGFjZW1lbnQgPSBmdW5jdGlvbiBfZ2V0UGxhY2VtZW50KCkge1xuICAgICAgdmFyICRwYXJlbnREcm9wZG93biA9ICQodGhpcy5fZWxlbWVudCkucGFyZW50KCk7XG4gICAgICB2YXIgcGxhY2VtZW50ID0gdGhpcy5fY29uZmlnLnBsYWNlbWVudDtcblxuICAgICAgLy8gSGFuZGxlIGRyb3B1cFxuICAgICAgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUFVQKSB8fCB0aGlzLl9jb25maWcucGxhY2VtZW50ID09PSBBdHRhY2htZW50TWFwLlRPUCkge1xuICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUDtcbiAgICAgICAgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLk1FTlVSSUdIVCkpIHtcbiAgICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUEVORDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuQk9UVE9NRU5EO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9kZXRlY3ROYXZiYXIgPSBmdW5jdGlvbiBfZGV0ZWN0TmF2YmFyKCkge1xuICAgICAgcmV0dXJuICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdCgnLm5hdmJhcicpLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fZ2V0UG9wcGVyQ29uZmlnID0gZnVuY3Rpb24gX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICAgIHZhciBwb3BwZXJDb25maWcgPSB7XG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9jb25maWcub2Zmc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0aGlzLl9jb25maWcuZmxpcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGUgUG9wcGVyLmpzIGZvciBEcm9wZG93biBpbiBOYXZiYXJcbiAgICAgIH07aWYgKHRoaXMuX2luTmF2YmFyKSB7XG4gICAgICAgIHBvcHBlckNvbmZpZy5tb2RpZmllcnMuYXBwbHlTdHlsZSA9IHtcbiAgICAgICAgICBlbmFibGVkOiAhdGhpcy5faW5OYXZiYXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3BwZXJDb25maWc7XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24uX2NsZWFyTWVudXMgPSBmdW5jdGlvbiBfY2xlYXJNZW51cyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50ICYmIChldmVudC53aGljaCA9PT0gUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQud2hpY2ggIT09IFRBQl9LRVlDT0RFKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2dnbGVzID0gJC5tYWtlQXJyYXkoJChTZWxlY3Rvci5EQVRBX1RPR0dMRSkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2dnbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodG9nZ2xlc1tpXSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gJCh0b2dnbGVzW2ldKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogdG9nZ2xlc1tpXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyb3Bkb3duTWVudSA9IGNvbnRleHQuX21lbnU7XG4gICAgICAgIGlmICghJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQud2hpY2ggPT09IFRBQl9LRVlDT0RFKSAmJiAkLmNvbnRhaW5zKHBhcmVudCwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQuSElERSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgICQocGFyZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XG4gICAgICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAkKCdib2R5JykuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICQoZHJvcGRvd25NZW51KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG4gICAgICAgICQocGFyZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVykudHJpZ2dlcigkLkV2ZW50KEV2ZW50LkhJRERFTiwgcmVsYXRlZFRhcmdldCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHBhcmVudCA9ICQoc2VsZWN0b3IpWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50IHx8IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGlmICghUkVHRVhQX0tFWURPV04udGVzdChldmVudC53aGljaCkgfHwgL2J1dHRvbi9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpICYmIGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFIHx8IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAkKHRoaXMpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpO1xuICAgICAgdmFyIGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgaWYgKCFpc0FjdGl2ZSAmJiAoZXZlbnQud2hpY2ggIT09IEVTQ0FQRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoICE9PSBTUEFDRV9LRVlDT0RFKSB8fCBpc0FjdGl2ZSAmJiAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFKSkge1xuXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgICB2YXIgdG9nZ2xlID0gJChwYXJlbnQpLmZpbmQoU2VsZWN0b3IuREFUQV9UT0dHTEUpWzBdO1xuICAgICAgICAgICQodG9nZ2xlKS50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtcyA9ICQocGFyZW50KS5maW5kKFNlbGVjdG9yLlZJU0lCTEVfSVRFTVMpLmdldCgpO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KTtcblxuICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19VUF9LRVlDT0RFICYmIGluZGV4ID4gMCkge1xuICAgICAgICAvLyB1cFxuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEFSUk9XX0RPV05fS0VZQ09ERSAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gZG93blxuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaXRlbXNbaW5kZXhdLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhEcm9wZG93biwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHRUeXBlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERyb3Bkb3duO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJChkb2N1bWVudCkub24oRXZlbnQuS0VZRE9XTl9EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKEV2ZW50LktFWURPV05fREFUQV9BUEksIFNlbGVjdG9yLk1FTlUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJICsgJyAnICsgRXZlbnQuS0VZVVBfREFUQV9BUEksIERyb3Bkb3duLl9jbGVhck1lbnVzKS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICd0b2dnbGUnKTtcbiAgfSkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkZPUk1fQ0hJTEQsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gRHJvcGRvd247XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBEcm9wZG93bjtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IG1vZGFsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgTW9kYWwgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdtb2RhbCc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMubW9kYWwnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwO1xuICB2YXIgQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MDtcbiAgdmFyIEVTQ0FQRV9LRVlDT0RFID0gMjc7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcblxuICB2YXIgRGVmYXVsdCA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgICBmb2N1czogJ2Jvb2xlYW4nLFxuICAgIHNob3c6ICdib29sZWFuJ1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNJTjogJ2ZvY3VzaW4nICsgRVZFTlRfS0VZLFxuICAgIFJFU0laRTogJ3Jlc2l6ZScgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0tfRElTTUlTUzogJ2NsaWNrLmRpc21pc3MnICsgRVZFTlRfS0VZLFxuICAgIEtFWURPV05fRElTTUlTUzogJ2tleWRvd24uZGlzbWlzcycgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VVUF9ESVNNSVNTOiAnbW91c2V1cC5kaXNtaXNzJyArIEVWRU5UX0tFWSxcbiAgICBNT1VTRURPV05fRElTTUlTUzogJ21vdXNlZG93bi5kaXNtaXNzJyArIEVWRU5UX0tFWSxcbiAgICBDTElDS19EQVRBX0FQSTogJ2NsaWNrJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICB9O1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgU0NST0xMQkFSX01FQVNVUkVSOiAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnLFxuICAgIEJBQ0tEUk9QOiAnbW9kYWwtYmFja2Ryb3AnLFxuICAgIE9QRU46ICdtb2RhbC1vcGVuJyxcbiAgICBGQURFOiAnZmFkZScsXG4gICAgU0hPVzogJ3Nob3cnXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIERJQUxPRzogJy5tb2RhbC1kaWFsb2cnLFxuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLFxuICAgIERBVEFfRElTTUlTUzogJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsXG4gICAgRklYRURfQ09OVEVOVDogJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnLFxuICAgIE5BVkJBUl9UT0dHTEVSOiAnLm5hdmJhci10b2dnbGVyJ1xuXG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gIH07XG4gIHZhciBNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RhbChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbCk7XG5cbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9kaWFsb2cgPSAkKGVsZW1lbnQpLmZpbmQoU2VsZWN0b3IuRElBTE9HKVswXTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gMDtcbiAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gMDtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5faXNTaG93biB8fCBzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fY2hlY2tTY3JvbGxiYXIoKTtcbiAgICAgIHRoaXMuX3NldFNjcm9sbGJhcigpO1xuXG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKENsYXNzTmFtZS5PUEVOKTtcblxuICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcbiAgICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0tfRElTTUlTUywgU2VsZWN0b3IuREFUQV9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAuaGlkZShldmVudCk7XG4gICAgICB9KTtcblxuICAgICAgJCh0aGlzLl9kaWFsb2cpLm9uKEV2ZW50Lk1PVVNFRE9XTl9ESVNNSVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoX3RoaXMxMC5fZWxlbWVudCkub25lKEV2ZW50Lk1PVVNFVVBfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyhfdGhpczEwLl9lbGVtZW50KSkge1xuICAgICAgICAgICAgX3RoaXMxMC5faWdub3JlQmFja2Ryb3BDbGljayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb24gPSBVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFKTtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XG5cbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KCk7XG4gICAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpO1xuXG4gICAgICAkKGRvY3VtZW50KS5vZmYoRXZlbnQuRk9DVVNJTik7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudC5DTElDS19ESVNNSVNTKTtcbiAgICAgICQodGhpcy5fZGlhbG9nKS5vZmYoRXZlbnQuTU9VU0VET1dOX0RJU01JU1MpO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczExLl9oaWRlTW9kYWwoZXZlbnQpO1xuICAgICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpZGVNb2RhbCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICAkKHdpbmRvdywgZG9jdW1lbnQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2JhY2tkcm9wKS5vZmYoRVZFTlRfS0VZKTtcblxuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fZGlhbG9nID0gbnVsbDtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBudWxsO1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBudWxsO1xuICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IG51bGw7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiBoYW5kbGVVcGRhdGUoKSB7XG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgTW9kYWwucHJvdG90eXBlLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gJC5leHRlbmQoe30sIERlZmF1bHQsIGNvbmZpZyk7XG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2hvd0VsZW1lbnQgPSBmdW5jdGlvbiBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSk7XG5cbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPV04sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uQ29tcGxldGUgPSBmdW5jdGlvbiB0cmFuc2l0aW9uQ29tcGxldGUoKSB7XG4gICAgICAgIGlmIChfdGhpczEyLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgICBfdGhpczEyLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMxMi5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgICQoX3RoaXMxMi5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICQodGhpcy5fZGlhbG9nKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgdHJhbnNpdGlvbkNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2VuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICAgICQoZG9jdW1lbnQpLm9mZihFdmVudC5GT0NVU0lOKSAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbihFdmVudC5GT0NVU0lOLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiYgX3RoaXMxMy5fZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICEkKF90aGlzMTMuX2VsZW1lbnQpLmhhcyhldmVudC50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzMTMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0RXNjYXBlRXZlbnQgPSBmdW5jdGlvbiBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LktFWURPV05fRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzMTQuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LktFWURPV05fRElTTUlTUyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0UmVzaXplRXZlbnQgPSBmdW5jdGlvbiBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgICQod2luZG93KS5vbihFdmVudC5SRVNJWkUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczE1LmhhbmRsZVVwZGF0ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZihFdmVudC5SRVNJWkUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2hpZGVNb2RhbCA9IGZ1bmN0aW9uIF9oaWRlTW9kYWwoKSB7XG4gICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5PUEVOKTtcbiAgICAgICAgX3RoaXMxNi5fcmVzZXRBZGp1c3RtZW50cygpO1xuICAgICAgICBfdGhpczE2Ll9yZXNldFNjcm9sbGJhcigpO1xuICAgICAgICAkKF90aGlzMTYuX2VsZW1lbnQpLnRyaWdnZXIoRXZlbnQuSElEREVOKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX3JlbW92ZUJhY2tkcm9wID0gZnVuY3Rpb24gX3JlbW92ZUJhY2tkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wKSB7XG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2hvd0JhY2tkcm9wID0gZnVuY3Rpb24gX3Nob3dCYWNrZHJvcChjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMTcgPSB0aGlzO1xuXG4gICAgICB2YXIgYW5pbWF0ZSA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpID8gQ2xhc3NOYW1lLkZBREUgOiAnJztcblxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgIHZhciBkb0FuaW1hdGUgPSBVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmIGFuaW1hdGU7XG5cbiAgICAgICAgdGhpcy5fYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NOYW1lID0gQ2xhc3NOYW1lLkJBQ0tEUk9QO1xuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoYW5pbWF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcblxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LkNMSUNLX0RJU01JU1MsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczE3Ll9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgICBfdGhpczE3Ll9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzMTcuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIF90aGlzMTcuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMxNy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZG9BbmltYXRlKSB7XG4gICAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fYmFja2Ryb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRvQW5pbWF0ZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNhbGxiYWNrKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChCQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uIGNhbGxiYWNrUmVtb3ZlKCkge1xuICAgICAgICAgIF90aGlzMTcuX3JlbW92ZUJhY2tkcm9wKCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgICAgICQodGhpcy5fYmFja2Ryb3ApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFja1JlbW92ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2tSZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgICAvLyB0b2RvIChmYXQpOiB0aGVzZSBzaG91bGQgcHJvYmFibHkgYmUgcmVmYWN0b3JlZCBvdXQgb2YgbW9kYWwuanNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2FkanVzdERpYWxvZyA9IGZ1bmN0aW9uIF9hZGp1c3REaWFsb2coKSB7XG4gICAgICB2YXIgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBpZiAoIXRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuX3Njcm9sbGJhcldpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLl9yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2NoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gX2NoZWNrU2Nyb2xsYmFyKCkge1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IHRoaXMuX2dldFNjcm9sbGJhcldpZHRoKCk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gX3NldFNjcm9sbGJhcigpIHtcbiAgICAgIHZhciBfdGhpczE4ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICAgIC8vIE5vdGU6IERPTU5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0IHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSBvciAnJyBpZiBub3Qgc2V0XG4gICAgICAgIC8vICAgd2hpbGUgJChET01Ob2RlKS5jc3MoJ3BhZGRpbmctcmlnaHQnKSByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHZhbHVlIG9yIDAgaWYgbm90IHNldFxuXG4gICAgICAgIC8vIEFkanVzdCBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICAgICAgJChTZWxlY3Rvci5GSVhFRF9DT05URU5UKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgIHZhciBhY3R1YWxQYWRkaW5nID0gJChlbGVtZW50KVswXS5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYWRkaW5nID0gJChlbGVtZW50KS5jc3MoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgICAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBwYXJzZUZsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIF90aGlzMTguX3Njcm9sbGJhcldpZHRoICsgJ3B4Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkanVzdCBuYXZiYXItdG9nZ2xlciBtYXJnaW5cbiAgICAgICAgJChTZWxlY3Rvci5OQVZCQVJfVE9HR0xFUikuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYWN0dWFsTWFyZ2luID0gJChlbGVtZW50KVswXS5zdHlsZS5tYXJnaW5SaWdodDtcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZE1hcmdpbiA9ICQoZWxlbWVudCkuY3NzKCdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgICAkKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcsIGFjdHVhbE1hcmdpbikuY3NzKCdtYXJnaW4tcmlnaHQnLCBwYXJzZUZsb2F0KGNhbGN1bGF0ZWRNYXJnaW4pICsgX3RoaXMxOC5fc2Nyb2xsYmFyV2lkdGggKyAncHgnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRqdXN0IGJvZHkgcGFkZGluZ1xuICAgICAgICB2YXIgYWN0dWFsUGFkZGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICB2YXIgY2FsY3VsYXRlZFBhZGRpbmcgPSAkKCdib2R5JykuY3NzKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgICQoJ2JvZHknKS5kYXRhKCdwYWRkaW5nLXJpZ2h0JywgYWN0dWFsUGFkZGluZykuY3NzKCdwYWRkaW5nLXJpZ2h0JywgcGFyc2VGbG9hdChjYWxjdWxhdGVkUGFkZGluZykgKyB0aGlzLl9zY3JvbGxiYXJXaWR0aCArICdweCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX3Jlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gX3Jlc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgLy8gUmVzdG9yZSBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICAgICQoU2VsZWN0b3IuRklYRURfQ09OVEVOVCkuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWRkaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICQoZWxlbWVudCkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgcGFkZGluZykucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzdG9yZSBuYXZiYXItdG9nZ2xlciBtYXJnaW5cbiAgICAgICQoU2VsZWN0b3IuTkFWQkFSX1RPR0dMRVIpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBtYXJnaW4gPSAkKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcmdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0JywgbWFyZ2luKS5yZW1vdmVEYXRhKCdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYm9keSBwYWRkaW5nXG4gICAgICB2YXIgcGFkZGluZyA9ICQoJ2JvZHknKS5kYXRhKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICBpZiAodHlwZW9mIHBhZGRpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICQoJ2JvZHknKS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBwYWRkaW5nKS5yZW1vdmVEYXRhKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fZ2V0U2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAvLyB0aHggZC53YWxzaFxuICAgICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IENsYXNzTmFtZS5TQ1JPTExCQVJfTUVBU1VSRVI7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgTW9kYWwuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5EZWZhdWx0LCAkKHRoaXMpLmRhdGEoKSwgKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyAmJiBjb25maWcpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgTW9kYWwodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uZmlnLnNob3cpIHtcbiAgICAgICAgICBkYXRhLnNob3cocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoTW9kYWwsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTW9kYWw7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpczE5ID0gdGhpcztcblxuICAgIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB0YXJnZXQgPSAkKHNlbGVjdG9yKVswXTtcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0gJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7fSwgJCh0YXJnZXQpLmRhdGEoKSwgJCh0aGlzKS5kYXRhKCkpO1xuXG4gICAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ0EnIHx8IHRoaXMudGFnTmFtZSA9PT0gJ0FSRUEnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciAkdGFyZ2V0ID0gJCh0YXJnZXQpLm9uZShFdmVudC5TSE9XLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAkdGFyZ2V0Lm9uZShFdmVudC5ISURERU4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCQoX3RoaXMxOSkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICBfdGhpczE5LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTW9kYWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnLCB0aGlzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gTW9kYWw7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBNb2RhbDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IHNjcm9sbHNweS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIFNjcm9sbFNweSA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ3Njcm9sbHNweSc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuc2Nyb2xsc3B5JztcbiAgdmFyIEVWRU5UX0tFWSA9ICcuJyArIERBVEFfS0VZO1xuICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIG9mZnNldDogMTAsXG4gICAgbWV0aG9kOiAnYXV0bycsXG4gICAgdGFyZ2V0OiAnJ1xuICB9O1xuXG4gIHZhciBEZWZhdWx0VHlwZSA9IHtcbiAgICBvZmZzZXQ6ICdudW1iZXInLFxuICAgIG1ldGhvZDogJ3N0cmluZycsXG4gICAgdGFyZ2V0OiAnKHN0cmluZ3xlbGVtZW50KSdcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgQUNUSVZBVEU6ICdhY3RpdmF0ZScgKyBFVkVOVF9LRVksXG4gICAgU0NST0xMOiAnc2Nyb2xsJyArIEVWRU5UX0tFWSxcbiAgICBMT0FEX0RBVEFfQVBJOiAnbG9hZCcgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIERST1BET1dOX0lURU06ICdkcm9wZG93bi1pdGVtJyxcbiAgICBEUk9QRE9XTl9NRU5VOiAnZHJvcGRvd24tbWVudScsXG4gICAgQUNUSVZFOiAnYWN0aXZlJ1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBEQVRBX1NQWTogJ1tkYXRhLXNweT1cInNjcm9sbFwiXScsXG4gICAgQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgTkFWX0xJU1RfR1JPVVA6ICcubmF2LCAubGlzdC1ncm91cCcsXG4gICAgTkFWX0xJTktTOiAnLm5hdi1saW5rJyxcbiAgICBMSVNUX0lURU1TOiAnLmxpc3QtZ3JvdXAtaXRlbScsXG4gICAgRFJPUERPV046ICcuZHJvcGRvd24nLFxuICAgIERST1BET1dOX0lURU1TOiAnLmRyb3Bkb3duLWl0ZW0nLFxuICAgIERST1BET1dOX1RPR0dMRTogJy5kcm9wZG93bi10b2dnbGUnXG4gIH07XG5cbiAgdmFyIE9mZnNldE1ldGhvZCA9IHtcbiAgICBPRkZTRVQ6ICdvZmZzZXQnLFxuICAgIFBPU0lUSU9OOiAncG9zaXRpb24nXG5cbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgfTtcbiAgdmFyIFNjcm9sbFNweSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMyMCA9IHRoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGxTcHkpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBlbGVtZW50LnRhZ05hbWUgPT09ICdCT0RZJyA/IHdpbmRvdyA6IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX3NlbGVjdG9yID0gdGhpcy5fY29uZmlnLnRhcmdldCArICcgJyArIFNlbGVjdG9yLk5BVl9MSU5LUyArICcsJyArICh0aGlzLl9jb25maWcudGFyZ2V0ICsgJyAnICsgU2VsZWN0b3IuTElTVF9JVEVNUyArICcsJykgKyAodGhpcy5fY29uZmlnLnRhcmdldCArICcgJyArIFNlbGVjdG9yLkRST1BET1dOX0lURU1TKTtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xuXG4gICAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKEV2ZW50LlNDUk9MTCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIwLl9wcm9jZXNzKGV2ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMyMSA9IHRoaXM7XG5cbiAgICAgIHZhciBhdXRvTWV0aG9kID0gdGhpcy5fc2Nyb2xsRWxlbWVudCAhPT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBPZmZzZXRNZXRob2QuUE9TSVRJT04gOiBPZmZzZXRNZXRob2QuT0ZGU0VUO1xuXG4gICAgICB2YXIgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2Q7XG5cbiAgICAgIHZhciBvZmZzZXRCYXNlID0gb2Zmc2V0TWV0aG9kID09PSBPZmZzZXRNZXRob2QuUE9TSVRJT04gPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG5cbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcblxuICAgICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG5cbiAgICAgIHZhciB0YXJnZXRzID0gJC5tYWtlQXJyYXkoJCh0aGlzLl9zZWxlY3RvcikpO1xuXG4gICAgICB0YXJnZXRzLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICB2YXIgdGFyZ2V0U2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFNlbGVjdG9yKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gJCh0YXJnZXRTZWxlY3RvcilbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIHRhcmdldEJDUiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAodGFyZ2V0QkNSLndpZHRoIHx8IHRhcmdldEJDUi5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gKGZhdCk6IHJlbW92ZSBza2V0Y2ggcmVsaWFuY2Ugb24galF1ZXJ5IHBvc2l0aW9uL29mZnNldFxuICAgICAgICAgICAgcmV0dXJuIFskKHRhcmdldClbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsIHRhcmdldFNlbGVjdG9yXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgX3RoaXMyMS5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xuICAgICAgICBfdGhpczIxLl90YXJnZXRzLnB1c2goaXRlbVsxXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG4gICAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9mZihFVkVOVF9LRVkpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX3NlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBudWxsO1xuICAgICAgdGhpcy5fdGFyZ2V0cyA9IG51bGw7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpZCA9ICQoY29uZmlnLnRhcmdldCkuYXR0cignaWQnKTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgIGlkID0gVXRpbC5nZXRVSUQoTkFNRSk7XG4gICAgICAgICAgJChjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcudGFyZ2V0ID0gJyMnICsgaWQ7XG4gICAgICB9XG5cbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpO1xuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICBTY3JvbGxTcHkucHJvdG90eXBlLl9nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcbiAgICB9O1xuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCk7XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX2dldE9mZnNldEhlaWdodCA9IGZ1bmN0aW9uIF9nZXRPZmZzZXRIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiBfcHJvY2VzcygpIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQ7XG4gICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG4gICAgICB2YXIgbWF4U2Nyb2xsID0gdGhpcy5fY29uZmlnLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuX2dldE9mZnNldEhlaWdodCgpO1xuXG4gICAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1swXSAmJiB0aGlzLl9vZmZzZXRzWzBdID4gMCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiYgc2Nyb2xsVG9wID49IHRoaXMuX29mZnNldHNbaV0gJiYgKHRoaXMuX29mZnNldHNbaSArIDFdID09PSB1bmRlZmluZWQgfHwgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1tpICsgMV0pO1xuXG4gICAgICAgIGlmIChpc0FjdGl2ZVRhcmdldCkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX2FjdGl2YXRlID0gZnVuY3Rpb24gX2FjdGl2YXRlKHRhcmdldCkge1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgICB2YXIgcXVlcmllcyA9IHRoaXMuX3NlbGVjdG9yLnNwbGl0KCcsJyk7XG4gICAgICBxdWVyaWVzID0gcXVlcmllcy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvciArICdbZGF0YS10YXJnZXQ9XCInICsgdGFyZ2V0ICsgJ1wiXSwnICsgKHNlbGVjdG9yICsgJ1tocmVmPVwiJyArIHRhcmdldCArICdcIl0nKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgJGxpbmsgPSAkKHF1ZXJpZXMuam9pbignLCcpKTtcblxuICAgICAgaWYgKCRsaW5rLmhhc0NsYXNzKENsYXNzTmFtZS5EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgICAkbGluay5jbG9zZXN0KFNlbGVjdG9yLkRST1BET1dOKS5maW5kKFNlbGVjdG9yLkRST1BET1dOX1RPR0dMRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICRsaW5rLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxuICAgICAgICAkbGluay5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxuICAgICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgICAgJGxpbmsucGFyZW50cyhTZWxlY3Rvci5OQVZfTElTVF9HUk9VUCkucHJldihTZWxlY3Rvci5OQVZfTElOS1MgKyAnLCAnICsgU2VsZWN0b3IuTElTVF9JVEVNUykuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fc2Nyb2xsRWxlbWVudCkudHJpZ2dlcihFdmVudC5BQ1RJVkFURSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTY3JvbGxTcHkucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uIF9jbGVhcigpIHtcbiAgICAgICQodGhpcy5fc2VsZWN0b3IpLmZpbHRlcihTZWxlY3Rvci5BQ1RJVkUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyAmJiBjb25maWc7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFNjcm9sbFNweSwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTY3JvbGxTcHk7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKHdpbmRvdykub24oRXZlbnQuTE9BRF9EQVRBX0FQSSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY3JvbGxTcHlzID0gJC5tYWtlQXJyYXkoJChTZWxlY3Rvci5EQVRBX1NQWSkpO1xuXG4gICAgZm9yICh2YXIgaSA9IHNjcm9sbFNweXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgJHNweSA9ICQoc2Nyb2xsU3B5c1tpXSk7XG4gICAgICBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRzcHksICRzcHkuZGF0YSgpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBTY3JvbGxTcHk7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsU3B5O1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgVGFiID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAndGFiJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYmV0YSc7XG4gIHZhciBEQVRBX0tFWSA9ICdicy50YWInO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwO1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0tfREFUQV9BUEk6ICdjbGljaycgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIERST1BET1dOX01FTlU6ICdkcm9wZG93bi1tZW51JyxcbiAgICBBQ1RJVkU6ICdhY3RpdmUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEZBREU6ICdmYWRlJyxcbiAgICBTSE9XOiAnc2hvdydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgRFJPUERPV046ICcuZHJvcGRvd24nLFxuICAgIE5BVl9MSVNUX0dST1VQOiAnLm5hdiwgLmxpc3QtZ3JvdXAnLFxuICAgIEFDVElWRTogJy5hY3RpdmUnLFxuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS10b2dnbGU9XCJsaXN0XCJdJyxcbiAgICBEUk9QRE9XTl9UT0dHTEU6ICcuZHJvcGRvd24tdG9nZ2xlJyxcbiAgICBEUk9QRE9XTl9BQ1RJVkVfQ0hJTEQ6ICc+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnXG5cbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgfTtcbiAgdmFyIFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWIoZWxlbWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYik7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgVGFiLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpczIyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91cyA9IHZvaWQgMDtcbiAgICAgIHZhciBsaXN0RWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5OQVZfTElTVF9HUk9VUClbMF07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIGlmIChsaXN0RWxlbWVudCkge1xuICAgICAgICBwcmV2aW91cyA9ICQubWFrZUFycmF5KCQobGlzdEVsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFKSk7XG4gICAgICAgIHByZXZpb3VzID0gcHJldmlvdXNbcHJldmlvdXMubGVuZ3RoIC0gMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgJChwcmV2aW91cykudHJpZ2dlcihoaWRlRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcblxuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdGFyZ2V0ID0gJChzZWxlY3RvcilbMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX2VsZW1lbnQsIGxpc3RFbGVtZW50KTtcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIHZhciBoaWRkZW5FdmVudCA9ICQuRXZlbnQoRXZlbnQuSElEREVOLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogX3RoaXMyMi5fZWxlbWVudFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPV04sIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgICB9KTtcblxuICAgICAgICAkKHByZXZpb3VzKS50cmlnZ2VyKGhpZGRlbkV2ZW50KTtcbiAgICAgICAgJChfdGhpczIyLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlLCBjb21wbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUYWIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBUYWIucHJvdG90eXBlLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uIF9hY3RpdmF0ZShlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyMyA9IHRoaXM7XG5cbiAgICAgIHZhciBhY3RpdmUgPSAkKGNvbnRhaW5lcikuZmluZChTZWxlY3Rvci5BQ1RJVkUpWzBdO1xuICAgICAgdmFyIGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgYWN0aXZlICYmICQoYWN0aXZlKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSk7XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyMy5fdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgaXNUcmFuc2l0aW9uaW5nLCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAkKGFjdGl2ZSkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgJChhY3RpdmUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFiLnByb3RvdHlwZS5fdHJhbnNpdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGlzVHJhbnNpdGlvbmluZywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgJChhY3RpdmUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuXG4gICAgICAgIHZhciBkcm9wZG93bkNoaWxkID0gJChhY3RpdmUucGFyZW50Tm9kZSkuZmluZChTZWxlY3Rvci5EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQpWzBdO1xuXG4gICAgICAgIGlmIChkcm9wZG93bkNoaWxkKSB7XG4gICAgICAgICAgJChkcm9wZG93bkNoaWxkKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGl2ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICBpZiAoaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIFV0aWwucmVmbG93KGVsZW1lbnQpO1xuICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkZBREUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmICQoZWxlbWVudC5wYXJlbnROb2RlKS5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUERPV05fTUVOVSkpIHtcblxuICAgICAgICB2YXIgZHJvcGRvd25FbGVtZW50ID0gJChlbGVtZW50KS5jbG9zZXN0KFNlbGVjdG9yLkRST1BET1dOKVswXTtcbiAgICAgICAgaWYgKGRyb3Bkb3duRWxlbWVudCkge1xuICAgICAgICAgICQoZHJvcGRvd25FbGVtZW50KS5maW5kKFNlbGVjdG9yLkRST1BET1dOX1RPR0dMRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkdGhpcy5kYXRhKERBVEFfS0VZKTtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IFRhYih0aGlzKTtcbiAgICAgICAgICAkdGhpcy5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFRhYiwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUYWI7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgVGFiLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRoaXMpLCAnc2hvdycpO1xuICB9KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IFRhYi5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVGFiO1xuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICByZXR1cm4gVGFiLl9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIFRhYjtcbn0oalF1ZXJ5KTtcblxuLyogZ2xvYmFsIFBvcHBlciAqL1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1iZXRhKTogdG9vbHRpcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgUG9wcGVyIGRlcGVuZGVuY3lcbiAgICogUG9wcGVyIC0gaHR0cHM6Ly9wb3BwZXIuanMub3JnXG4gICAqL1xuICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcCB0b29sdGlwcyByZXF1aXJlIFBvcHBlci5qcyAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ3Rvb2x0aXAnO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1iZXRhJztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLnRvb2x0aXAnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuICB2YXIgVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MDtcbiAgdmFyIENMQVNTX1BSRUZJWCA9ICdicy10b29sdGlwJztcbiAgdmFyIEJTQ0xTX1BSRUZJWF9SRUdFWCA9IG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBDTEFTU19QUkVGSVggKyAnXFxcXFMrJywgJ2cnKTtcblxuICB2YXIgRGVmYXVsdFR5cGUgPSB7XG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gICAgdGVtcGxhdGU6ICdzdHJpbmcnLFxuICAgIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gICAgdHJpZ2dlcjogJ3N0cmluZycsXG4gICAgZGVsYXk6ICcobnVtYmVyfG9iamVjdCknLFxuICAgIGh0bWw6ICdib29sZWFuJyxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBvZmZzZXQ6ICcobnVtYmVyfHN0cmluZyknLFxuICAgIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gICAgZmFsbGJhY2tQbGFjZW1lbnQ6ICcoc3RyaW5nfGFycmF5KSdcbiAgfTtcblxuICB2YXIgQXR0YWNobWVudE1hcCA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgVE9QOiAndG9wJyxcbiAgICBSSUdIVDogJ3JpZ2h0JyxcbiAgICBCT1RUT006ICdib3R0b20nLFxuICAgIExFRlQ6ICdsZWZ0J1xuICB9O1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIG9mZnNldDogMCxcbiAgICBjb250YWluZXI6IGZhbHNlLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50OiAnZmxpcCdcbiAgfTtcblxuICB2YXIgSG92ZXJTdGF0ZSA9IHtcbiAgICBTSE9XOiAnc2hvdycsXG4gICAgT1VUOiAnb3V0J1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgSU5TRVJURUQ6ICdpbnNlcnRlZCcgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0s6ICdjbGljaycgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNJTjogJ2ZvY3VzaW4nICsgRVZFTlRfS0VZLFxuICAgIEZPQ1VTT1VUOiAnZm9jdXNvdXQnICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFRU5URVI6ICdtb3VzZWVudGVyJyArIEVWRU5UX0tFWSxcbiAgICBNT1VTRUxFQVZFOiAnbW91c2VsZWF2ZScgKyBFVkVOVF9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIEZBREU6ICdmYWRlJyxcbiAgICBTSE9XOiAnc2hvdydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgVE9PTFRJUDogJy50b29sdGlwJyxcbiAgICBUT09MVElQX0lOTkVSOiAnLnRvb2x0aXAtaW5uZXInLFxuICAgIEFSUk9XOiAnLmFycm93J1xuICB9O1xuXG4gIHZhciBUcmlnZ2VyID0ge1xuICAgIEhPVkVSOiAnaG92ZXInLFxuICAgIEZPQ1VTOiAnZm9jdXMnLFxuICAgIENMSUNLOiAnY2xpY2snLFxuICAgIE1BTlVBTDogJ21hbnVhbCdcblxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICB9O1xuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xuXG4gICAgICAvLyBwcml2YXRlXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fdGltZW91dCA9IDA7XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gJyc7XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuXG4gICAgICAvLyBwcm90ZWN0ZWRcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiB0b2dnbGVFbmFibGVkKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuICAgICAgICB2YXIgY29udGV4dCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KTtcblxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuXG4gICAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XG4gICAgICAkKHRoaXMuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub2ZmKCdoaWRlLmJzLm1vZGFsJyk7XG5cbiAgICAgIGlmICh0aGlzLnRpcCkge1xuICAgICAgICAkKHRoaXMudGlwKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNFbmFibGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLnRpcCA9IG51bGw7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzMjQgPSB0aGlzO1xuXG4gICAgICBpZiAoJCh0aGlzLmVsZW1lbnQpLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO1xuICAgICAgaWYgKHRoaXMuaXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICAgIHZhciBpc0luVGhlRG9tID0gJC5jb250YWlucyh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaXNJblRoZURvbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICAgICAgdmFyIHRpcElkID0gVXRpbC5nZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcblxuICAgICAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcElkKTtcblxuICAgICAgICB0aGlzLnNldENvbnRlbnQoKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5GQURFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5jb25maWcucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID8gdGhpcy5jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLmVsZW1lbnQpIDogdGhpcy5jb25maWcucGxhY2VtZW50O1xuXG4gICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5fZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpO1xuICAgICAgICB0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KTtcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiAkKHRoaXMuY29uZmlnLmNvbnRhaW5lcik7XG5cbiAgICAgICAgJCh0aXApLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy50aXApKSB7XG4gICAgICAgICAgJCh0aXApLmFwcGVuZFRvKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKTtcblxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBuZXcgUG9wcGVyKHRoaXMuZWxlbWVudCwgdGlwLCB7XG4gICAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgIG9mZnNldDogdGhpcy5jb25maWcub2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxpcDoge1xuICAgICAgICAgICAgICBiZWhhdmlvcjogdGhpcy5jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcnJvdzoge1xuICAgICAgICAgICAgICBlbGVtZW50OiBTZWxlY3Rvci5BUlJPV1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLm9yaWdpbmFsUGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgICBfdGhpczI0Ll9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMyNC5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgJCgnYm9keScpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyNC5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBfdGhpczI0Ll9maXhUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IF90aGlzMjQuX2hvdmVyU3RhdGU7XG4gICAgICAgICAgX3RoaXMyNC5faG92ZXJTdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAkKF90aGlzMjQuZWxlbWVudCkudHJpZ2dlcihfdGhpczI0LmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKTtcblxuICAgICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICAgIF90aGlzMjQuX2xlYXZlKG51bGwsIF90aGlzMjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMudGlwKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgICAkKHRoaXMudGlwKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuX1RSQU5TSVRJT05fRFVSQVRJT04pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczI1ID0gdGhpcztcblxuICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKTtcbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBpZiAoX3RoaXMyNS5faG92ZXJTdGF0ZSAhPT0gSG92ZXJTdGF0ZS5TSE9XICYmIHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMjUuX2NsZWFuVGlwQ2xhc3MoKTtcbiAgICAgICAgX3RoaXMyNS5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuICAgICAgICAkKF90aGlzMjUuZWxlbWVudCkudHJpZ2dlcihfdGhpczI1LmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XG4gICAgICAgIGlmIChfdGhpczI1Ll9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczI1Ll9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAkKCdib2R5JykuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5DTElDS10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5GT0NVU10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5IT1ZFUl0gPSBmYWxzZTtcblxuICAgICAgaWYgKFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG5cbiAgICAgICAgJCh0aXApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gJyc7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByb3RlY3RlZFxuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaXNXaXRoQ29udGVudCA9IGZ1bmN0aW9uIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldFRpdGxlKCkpO1xuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5hZGRBdHRhY2htZW50Q2xhc3MgPSBmdW5jdGlvbiBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgICAgJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoQ0xBU1NfUFJFRklYICsgJy0nICsgYXR0YWNobWVudCk7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmdldFRpcEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRUaXBFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlwID0gdGhpcy50aXAgfHwgJCh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF07XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50KCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNlbGVjdG9yLlRPT0xUSVBfSU5ORVIpLCB0aGlzLmdldFRpdGxlKCkpO1xuICAgICAgJHRpcC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSArICcgJyArIENsYXNzTmFtZS5TSE9XKTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuc2V0RWxlbWVudENvbnRlbnQgPSBmdW5jdGlvbiBzZXRFbGVtZW50Q29udGVudCgkZWxlbWVudCwgY29udGVudCkge1xuICAgICAgdmFyIGh0bWwgPSB0aGlzLmNvbmZpZy5odG1sO1xuICAgICAgaWYgKCh0eXBlb2YgY29udGVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29udGVudCkpID09PSAnb2JqZWN0JyAmJiAoY29udGVudC5ub2RlVHlwZSB8fCBjb250ZW50LmpxdWVyeSkpIHtcbiAgICAgICAgLy8gY29udGVudCBpcyBhIERPTSBub2RlIG9yIGEgalF1ZXJ5XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaWYgKCEkKGNvbnRlbnQpLnBhcmVudCgpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICAgJGVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRlbGVtZW50LnRleHQoJChjb250ZW50KS50ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWxlbWVudFtodG1sID8gJ2h0bWwnIDogJ3RleHQnXShjb250ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHZhciB0aXRsZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKTtcblxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICB0aXRsZSA9IHR5cGVvZiB0aGlzLmNvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLnRpdGxlLmNhbGwodGhpcy5lbGVtZW50KSA6IHRoaXMuY29uZmlnLnRpdGxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGl0bGU7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9nZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9zZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfc2V0TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMjYgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLmNvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XG5cbiAgICAgIHRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAkKF90aGlzMjYuZWxlbWVudCkub24oX3RoaXMyNi5jb25zdHJ1Y3Rvci5FdmVudC5DTElDSywgX3RoaXMyNi5jb25maWcuc2VsZWN0b3IsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMjYudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUcmlnZ2VyLk1BTlVBTCkge1xuICAgICAgICAgIHZhciBldmVudEluID0gdHJpZ2dlciA9PT0gVHJpZ2dlci5IT1ZFUiA/IF90aGlzMjYuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IF90aGlzMjYuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTjtcbiAgICAgICAgICB2YXIgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUcmlnZ2VyLkhPVkVSID8gX3RoaXMyNi5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogX3RoaXMyNi5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcblxuICAgICAgICAgICQoX3RoaXMyNi5lbGVtZW50KS5vbihldmVudEluLCBfdGhpczI2LmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5fZW50ZXIoZXZlbnQpO1xuICAgICAgICAgIH0pLm9uKGV2ZW50T3V0LCBfdGhpczI2LmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5fbGVhdmUoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgJChfdGhpczI2LmVsZW1lbnQpLmNsb3Nlc3QoJy5tb2RhbCcpLm9uKCdoaWRlLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczI2LmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gJC5leHRlbmQoe30sIHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgICAgc2VsZWN0b3I6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZml4VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2ZpeFRpdGxlID0gZnVuY3Rpb24gX2ZpeFRpdGxlKCkge1xuICAgICAgdmFyIHRpdGxlVHlwZSA9IF90eXBlb2YodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpKTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgJycpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsICcnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2VudGVyID0gZnVuY3Rpb24gX2VudGVyKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgICB2YXIgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XG5cbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KTtcblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUcmlnZ2VyLkZPQ1VTIDogVHJpZ2dlci5IT1ZFUl0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJChjb250ZXh0LmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpIHx8IGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuU0hPVykge1xuICAgICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5TSE9XO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KTtcblxuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhvdmVyU3RhdGUuU0hPVztcblxuICAgICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLlNIT1cpIHtcbiAgICAgICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuc2hvdyk7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9sZWF2ZSA9IGZ1bmN0aW9uIF9sZWF2ZShldmVudCwgY29udGV4dCkge1xuICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRyaWdnZXIuRk9DVVMgOiBUcmlnZ2VyLkhPVkVSXSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuXG4gICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5PVVQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpIHtcbiAgICAgICAgY29udGV4dC5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICBjb250ZXh0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSk7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyID0gZnVuY3Rpb24gX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgICBmb3IgKHZhciB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gJC5leHRlbmQoe30sIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCwgJCh0aGlzLmVsZW1lbnQpLmRhdGEoKSwgY29uZmlnKTtcblxuICAgICAgaWYgKGNvbmZpZy5kZWxheSAmJiB0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxuICAgICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLnRpdGxlICYmIHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmNvbnRlbnQgJiYgdHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9nZXREZWxlZ2F0ZUNvbmZpZyA9IGZ1bmN0aW9uIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdGhpcy5jb25maWdba2V5XSkge1xuICAgICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLmNvbmZpZ1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5fY2xlYW5UaXBDbGFzcyA9IGZ1bmN0aW9uIF9jbGVhblRpcENsYXNzKCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgIHZhciB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpO1xuICAgICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UgPSBmdW5jdGlvbiBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpIHtcbiAgICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKTtcbiAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQoZGF0YS5wbGFjZW1lbnQpKTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2ZpeFRyYW5zaXRpb24gPSBmdW5jdGlvbiBfZml4VHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICAgIHZhciBpbml0Q29uZmlnQW5pbWF0aW9uID0gdGhpcy5jb25maWcuYW5pbWF0aW9uO1xuICAgICAgaWYgKHRpcC5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgJCh0aXApLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5GQURFKTtcbiAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGluaXRDb25maWdBbmltYXRpb247XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyAmJiBjb25maWc7XG5cbiAgICAgICAgaWYgKCFkYXRhICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBjb25maWcgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ05BTUUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBOQU1FO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RBVEFfS0VZJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gREFUQV9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRXZlbnQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFdmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdFVkVOVF9LRVknLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFVkVOVF9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRGVmYXVsdFR5cGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVG9vbHRpcDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVG9vbHRpcDtcbiAgJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgcmV0dXJuIFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYmV0YSk6IHBvcG92ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBQb3BvdmVyID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAncG9wb3Zlcic7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWJldGEnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMucG9wb3Zlcic7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBDTEFTU19QUkVGSVggPSAnYnMtcG9wb3Zlcic7XG4gIHZhciBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgQ0xBU1NfUFJFRklYICsgJ1xcXFxTKycsICdnJyk7XG5cbiAgdmFyIERlZmF1bHQgPSAkLmV4dGVuZCh7fSwgVG9vbHRpcC5EZWZhdWx0LCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj48L2Rpdj4nXG4gIH0pO1xuXG4gIHZhciBEZWZhdWx0VHlwZSA9ICQuZXh0ZW5kKHt9LCBUb29sdGlwLkRlZmF1bHRUeXBlLCB7XG4gICAgY29udGVudDogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG4gIH0pO1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgRkFERTogJ2ZhZGUnLFxuICAgIFNIT1c6ICdzaG93J1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBUSVRMRTogJy5wb3BvdmVyLWhlYWRlcicsXG4gICAgQ09OVEVOVDogJy5wb3BvdmVyLWJvZHknXG4gIH07XG5cbiAgdmFyIEV2ZW50ID0ge1xuICAgIEhJREU6ICdoaWRlJyArIEVWRU5UX0tFWSxcbiAgICBISURERU46ICdoaWRkZW4nICsgRVZFTlRfS0VZLFxuICAgIFNIT1c6ICdzaG93JyArIEVWRU5UX0tFWSxcbiAgICBTSE9XTjogJ3Nob3duJyArIEVWRU5UX0tFWSxcbiAgICBJTlNFUlRFRDogJ2luc2VydGVkJyArIEVWRU5UX0tFWSxcbiAgICBDTElDSzogJ2NsaWNrJyArIEVWRU5UX0tFWSxcbiAgICBGT0NVU0lOOiAnZm9jdXNpbicgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNPVVQ6ICdmb2N1c291dCcgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VFTlRFUjogJ21vdXNlZW50ZXInICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFTEVBVkU6ICdtb3VzZWxlYXZlJyArIEVWRU5UX0tFWVxuXG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gIH07XG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKF9Ub29sdGlwKSB7XG4gICAgX2luaGVyaXRzKFBvcG92ZXIsIF9Ub29sdGlwKTtcblxuICAgIGZ1bmN0aW9uIFBvcG92ZXIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wb3Zlcik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVG9vbHRpcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZXNcblxuICAgIFBvcG92ZXIucHJvdG90eXBlLmlzV2l0aENvbnRlbnQgPSBmdW5jdGlvbiBpc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gICAgfTtcblxuICAgIFBvcG92ZXIucHJvdG90eXBlLmFkZEF0dGFjaG1lbnRDbGFzcyA9IGZ1bmN0aW9uIGFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XG4gICAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhDTEFTU19QUkVGSVggKyAnLScgKyBhdHRhY2htZW50KTtcbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQoKSB7XG4gICAgICB2YXIgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpO1xuXG4gICAgICAvLyB3ZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5USVRMRSksIHRoaXMuZ2V0VGl0bGUoKSk7XG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5DT05URU5UKSwgdGhpcy5fZ2V0Q29udGVudCgpKTtcblxuICAgICAgJHRpcC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSArICcgJyArIENsYXNzTmFtZS5TSE9XKTtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2dldENvbnRlbnQgPSBmdW5jdGlvbiBfZ2V0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRlbnQnKSB8fCAodHlwZW9mIHRoaXMuY29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy5jb250ZW50LmNhbGwodGhpcy5lbGVtZW50KSA6IHRoaXMuY29uZmlnLmNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fY2xlYW5UaXBDbGFzcyA9IGZ1bmN0aW9uIF9jbGVhblRpcENsYXNzKCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgIHZhciB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpO1xuICAgICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0YXRpY1xuXG4gICAgUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFkYXRhICYmIC9kZXN0cm95fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgUG9wb3Zlcih0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBjb25maWcgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoUG9wb3ZlciwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuXG5cbiAgICAgIC8vIGdldHRlcnNcblxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ05BTUUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBOQU1FO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RBVEFfS0VZJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gREFUQV9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRXZlbnQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFdmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdFVkVOVF9LRVknLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFVkVOVF9LRVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRGVmYXVsdFR5cGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUG9wb3ZlcjtcbiAgfShUb29sdGlwKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZTtcbiAgJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFBvcG92ZXI7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIFBvcG92ZXI7XG59KGpRdWVyeSk7XG5cblxufSkoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvZnJvbnRlbmQvanMvdmVuZG9yL2Jvb3RzdHJhcC5qcyIsIiEgZnVuY3Rpb24oZSwgdCkge1xuICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1wianF1ZXJ5XCJdLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB0KGUpXG4gICAgfSkgOiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA9IHQocmVxdWlyZShcImpxdWVyeVwiKSkgOiB0KGUualF1ZXJ5KVxufSh0aGlzLCBmdW5jdGlvbihlKSB7XG4gICAgISBmdW5jdGlvbihlKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgIGZ1bmN0aW9uIHQodCkge1xuICAgICAgICAgICAgdmFyIGkgPSBbe1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEMwLVxceEM2XS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIkFcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEUwLVxceEU2XS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcImFcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEM4LVxceENCXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIkVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEU4LVxceEVCXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcImVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceENDLVxceENGXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIklcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEVDLVxceEVGXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcImlcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEQyLVxceEQ2XS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIk9cIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEYyLVxceEY2XS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIm9cIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEQ5LVxceERDXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIlVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEY5LVxceEZDXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcInVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEM3LVxceEU3XS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcImNcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEQxXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIk5cIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlOiAvW1xceEYxXS9nLFxuICAgICAgICAgICAgICAgIGNoOiBcIm5cIlxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICByZXR1cm4gZS5lYWNoKGksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHQgPSB0ID8gdC5yZXBsYWNlKHRoaXMucmUsIHRoaXMuY2gpIDogXCJcIlxuICAgICAgICAgICAgfSksIHRcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGkodCkge1xuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgbiA9IHQ7XG4gICAgICAgICAgICBbXS5zaGlmdC5hcHBseShpKTtcbiAgICAgICAgICAgIHZhciBzLCBvID0gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodC5pcyhcInNlbGVjdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHQuZGF0YShcInNlbGVjdHBpY2tlclwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBcIm9iamVjdFwiID09IHR5cGVvZiBuICYmIG47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsIGluIGEpIGEuaGFzT3duUHJvcGVydHkobCkgJiYgKG8ub3B0aW9uc1tsXSA9IGFbbF0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZXh0ZW5kKHt9LCBoLkRFRkFVTFRTLCBlLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cyB8fCB7fSwgdC5kYXRhKCksIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgci50ZW1wbGF0ZSA9IGUuZXh0ZW5kKHt9LCBoLkRFRkFVTFRTLnRlbXBsYXRlLCBlLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cyA/IGUuZm4uc2VsZWN0cGlja2VyLmRlZmF1bHRzLnRlbXBsYXRlIDoge30sIHQuZGF0YSgpLnRlbXBsYXRlLCBhLnRlbXBsYXRlKSwgdC5kYXRhKFwic2VsZWN0cGlja2VyXCIsIG8gPSBuZXcgaCh0aGlzLCByKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiBuICYmIChzID0gb1tuXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gb1tuXS5hcHBseShvLCBpKSA6IG8ub3B0aW9uc1tuXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzID8gcyA6IG9cbiAgICAgICAgfVxuICAgICAgICBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzIHx8ICEgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHt9LnRvU3RyaW5nLFxuICAgICAgICAgICAgICAgIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdChlLCBlLCBlKSAmJiB0XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG4pIHt9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfSgpLFxuICAgICAgICAgICAgICAgIGkgPSBcIlwiLmluZGV4T2YsXG4gICAgICAgICAgICAgICAgbiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gdGhpcykgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBTdHJpbmcodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIFwiW29iamVjdCBSZWdFeHBdXCIgPT0gZS5jYWxsKHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IFN0cmluZyh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBvLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBsID8gTnVtYmVyKGwpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgciAhPSByICYmIChyID0gMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gTWF0aC5taW4oTWF0aC5tYXgociwgMCksIHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSArIGQgPiBzID8gITEgOiAtMSAhPSBpLmNhbGwobiwgbywgcilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdCA/IHQoU3RyaW5nLnByb3RvdHlwZSwgXCJpbmNsdWRlc1wiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICAgIH0pIDogU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyA9IG5cbiAgICAgICAgfSgpLCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggfHwgISBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHQoZSwgZSwgZSkgJiYgdFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChuKSB7fVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgICAgIH0oKSxcbiAgICAgICAgICAgICAgICB0ID0ge30udG9TdHJpbmcsXG4gICAgICAgICAgICAgICAgaSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gdGhpcykgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBTdHJpbmcodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIFwiW29iamVjdCBSZWdFeHBdXCIgPT0gdC5jYWxsKGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IFN0cmluZyhlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBhID8gTnVtYmVyKGEpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgbCAhPSBsICYmIChsID0gMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5taW4oTWF0aC5tYXgobCwgMCksIG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobyArIHIgPiBuKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAtMTsgKytkIDwgbzspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5jaGFyQ29kZUF0KHIgKyBkKSAhPSBzLmNoYXJDb2RlQXQoZCkpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGUgPyBlKFN0cmluZy5wcm90b3R5cGUsIFwic3RhcnRzV2l0aFwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICAgIH0pIDogU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gaVxuICAgICAgICB9KCksIE9iamVjdC5rZXlzIHx8IChPYmplY3Qua2V5cyA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgIGkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodCBpbiBlKSBpLmhhc093blByb3BlcnR5LmNhbGwoZSwgdCkgJiYgaS5wdXNoKHQpO1xuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuID0ge1xuICAgICAgICAgICAgdXNlRGVmYXVsdDogITEsXG4gICAgICAgICAgICBfc2V0OiBlLnZhbEhvb2tzLnNlbGVjdC5zZXRcbiAgICAgICAgfTtcbiAgICAgICAgZS52YWxIb29rcy5zZWxlY3Quc2V0ID0gZnVuY3Rpb24odCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgJiYgIW4udXNlRGVmYXVsdCAmJiBlKHQpLmRhdGEoXCJzZWxlY3RlZFwiLCAhMCksIG4uX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzID0gbnVsbDtcbiAgICAgICAgZS5mbi50cmlnZ2VyTmF0aXZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpc1swXTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihlKVxuICAgICAgICB9LCBlLmV4cHIucHNldWRvcy5pY29udGFpbnMgPSBmdW5jdGlvbih0LCBpLCBuKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGUodCkuZmluZChcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKSxcbiAgICAgICAgICAgICAgICBvID0gKHMuZGF0YShcInRva2Vuc1wiKSB8fCBzLnRleHQoKSkudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG8uaW5jbHVkZXMoblszXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICB9LCBlLmV4cHIucHNldWRvcy5pYmVnaW5zID0gZnVuY3Rpb24odCwgaSwgbikge1xuICAgICAgICAgICAgdmFyIHMgPSBlKHQpLmZpbmQoXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIiksXG4gICAgICAgICAgICAgICAgbyA9IChzLmRhdGEoXCJ0b2tlbnNcIikgfHwgcy50ZXh0KCkpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBvLnN0YXJ0c1dpdGgoblszXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICB9LCBlLmV4cHIucHNldWRvcy5haWNvbnRhaW5zID0gZnVuY3Rpb24odCwgaSwgbikge1xuICAgICAgICAgICAgdmFyIHMgPSBlKHQpLmZpbmQoXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIiksXG4gICAgICAgICAgICAgICAgbyA9IChzLmRhdGEoXCJ0b2tlbnNcIikgfHwgcy5kYXRhKFwibm9ybWFsaXplZFRleHRcIikgfHwgcy50ZXh0KCkpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBvLmluY2x1ZGVzKG5bM10udG9VcHBlckNhc2UoKSlcbiAgICAgICAgfSwgZS5leHByLnBzZXVkb3MuYWliZWdpbnMgPSBmdW5jdGlvbih0LCBpLCBuKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGUodCkuZmluZChcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKSxcbiAgICAgICAgICAgICAgICBvID0gKHMuZGF0YShcInRva2Vuc1wiKSB8fCBzLmRhdGEoXCJub3JtYWxpemVkVGV4dFwiKSB8fCBzLnRleHQoKSkudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG8uc3RhcnRzV2l0aChuWzNdLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgICAgICAgICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgICAgICAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICAgICAgICAgICAnXCInOiBcIiZxdW90O1wiLFxuICAgICAgICAgICAgICAgIFwiJ1wiOiBcIiYjeDI3O1wiLFxuICAgICAgICAgICAgICAgIFwiYFwiOiBcIiYjeDYwO1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYSA9IHtcbiAgICAgICAgICAgICAgICBcIiZhbXA7XCI6IFwiJlwiLFxuICAgICAgICAgICAgICAgIFwiJmx0O1wiOiBcIjxcIixcbiAgICAgICAgICAgICAgICBcIiZndDtcIjogXCI+XCIsXG4gICAgICAgICAgICAgICAgXCImcXVvdDtcIjogJ1wiJyxcbiAgICAgICAgICAgICAgICBcIiYjeDI3O1wiOiBcIidcIixcbiAgICAgICAgICAgICAgICBcIiYjeDYwO1wiOiBcImBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGwgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVt0XVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpID0gXCIoPzpcIiArIE9iamVjdC5rZXlzKGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gICAgICAgICAgICAgICAgICAgIG4gPSBSZWdFeHAoaSksXG4gICAgICAgICAgICAgICAgICAgIHMgPSBSZWdFeHAoaSwgXCJnXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gbnVsbCA9PSBlID8gXCJcIiA6IFwiXCIgKyBlLCBuLnRlc3QoZSkgPyBlLnJlcGxhY2UocywgdCkgOiBlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHIgPSBsKG8pLFxuICAgICAgICAgICAgZCA9IGwoYSksXG4gICAgICAgICAgICBoID0gZnVuY3Rpb24odCwgaSkge1xuICAgICAgICAgICAgICAgIG4udXNlRGVmYXVsdCB8fCAoZS52YWxIb29rcy5zZWxlY3Quc2V0ID0gbi5fc2V0LCBuLnVzZURlZmF1bHQgPSAhMCksIHRoaXMuJGVsZW1lbnQgPSBlKHQpLCB0aGlzLiRuZXdFbGVtZW50ID0gbnVsbCwgdGhpcy4kYnV0dG9uID0gbnVsbCwgdGhpcy4kbWVudSA9IG51bGwsIHRoaXMuJGxpcyA9IG51bGwsIHRoaXMub3B0aW9ucyA9IGksIG51bGwgPT09IHRoaXMub3B0aW9ucy50aXRsZSAmJiAodGhpcy5vcHRpb25zLnRpdGxlID0gdGhpcy4kZWxlbWVudC5hdHRyKFwidGl0bGVcIikpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5vcHRpb25zLndpbmRvd1BhZGRpbmc7XG4gICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2YgcyAmJiAodGhpcy5vcHRpb25zLndpbmRvd1BhZGRpbmcgPSBbcywgcywgcywgc10pLCB0aGlzLnZhbCA9IGgucHJvdG90eXBlLnZhbCwgdGhpcy5yZW5kZXIgPSBoLnByb3RvdHlwZS5yZW5kZXIsIHRoaXMucmVmcmVzaCA9IGgucHJvdG90eXBlLnJlZnJlc2gsIHRoaXMuc2V0U3R5bGUgPSBoLnByb3RvdHlwZS5zZXRTdHlsZSwgdGhpcy5zZWxlY3RBbGwgPSBoLnByb3RvdHlwZS5zZWxlY3RBbGwsIHRoaXMuZGVzZWxlY3RBbGwgPSBoLnByb3RvdHlwZS5kZXNlbGVjdEFsbCwgdGhpcy5kZXN0cm95ID0gaC5wcm90b3R5cGUuZGVzdHJveSwgdGhpcy5yZW1vdmUgPSBoLnByb3RvdHlwZS5yZW1vdmUsIHRoaXMuc2hvdyA9IGgucHJvdG90eXBlLnNob3csIHRoaXMuaGlkZSA9IGgucHJvdG90eXBlLmhpZGUsIHRoaXMuaW5pdCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICBoLlZFUlNJT04gPSBcIjEuMTIuMlwiLCBoLkRFRkFVTFRTID0ge1xuICAgICAgICAgICAgbm9uZVNlbGVjdGVkVGV4dDogXCJOb3RoaW5nIHNlbGVjdGVkXCIsXG4gICAgICAgICAgICBub25lUmVzdWx0c1RleHQ6IFwiTm8gcmVzdWx0cyBtYXRjaGVkIHswfVwiLFxuICAgICAgICAgICAgY291bnRTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSA9PSBlID8gXCJ7MH0gaXRlbSBzZWxlY3RlZFwiIDogXCJ7MH0gaXRlbXMgc2VsZWN0ZWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heE9wdGlvbnNUZXh0OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsxID09IGUgPyBcIkxpbWl0IHJlYWNoZWQgKHtufSBpdGVtIG1heClcIiA6IFwiTGltaXQgcmVhY2hlZCAoe259IGl0ZW1zIG1heClcIiwgMSA9PSB0ID8gXCJHcm91cCBsaW1pdCByZWFjaGVkICh7bn0gaXRlbSBtYXgpXCIgOiBcIkdyb3VwIGxpbWl0IHJlYWNoZWQgKHtufSBpdGVtcyBtYXgpXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0QWxsVGV4dDogXCJTZWxlY3QgQWxsXCIsXG4gICAgICAgICAgICBkZXNlbGVjdEFsbFRleHQ6IFwiRGVzZWxlY3QgQWxsXCIsXG4gICAgICAgICAgICBkb25lQnV0dG9uOiAhMSxcbiAgICAgICAgICAgIGRvbmVCdXR0b25UZXh0OiBcIkNsb3NlXCIsXG4gICAgICAgICAgICBtdWx0aXBsZVNlcGFyYXRvcjogXCIsIFwiLFxuICAgICAgICAgICAgc3R5bGVCYXNlOiBcImJ0blwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiYnRuLWRlZmF1bHQgYnRuLWxpZ2h0XCIsXG4gICAgICAgICAgICBzaXplOiBcImF1dG9cIixcbiAgICAgICAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0ZWRUZXh0Rm9ybWF0OiBcInZhbHVlc1wiLFxuICAgICAgICAgICAgd2lkdGg6ICExLFxuICAgICAgICAgICAgY29udGFpbmVyOiAhMSxcbiAgICAgICAgICAgIGhpZGVEaXNhYmxlZDogITEsXG4gICAgICAgICAgICBzaG93U3VidGV4dDogITEsXG4gICAgICAgICAgICBzaG93SWNvbjogITAsXG4gICAgICAgICAgICBzaG93Q29udGVudDogITAsXG4gICAgICAgICAgICBkcm9wdXBBdXRvOiAhMCxcbiAgICAgICAgICAgIGhlYWRlcjogITEsXG4gICAgICAgICAgICBsaXZlU2VhcmNoOiAhMSxcbiAgICAgICAgICAgIGxpdmVTZWFyY2hQbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgICAgIGxpdmVTZWFyY2hOb3JtYWxpemU6ICExLFxuICAgICAgICAgICAgbGl2ZVNlYXJjaFN0eWxlOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICBhY3Rpb25zQm94OiAhMSxcbiAgICAgICAgICAgIGljb25CYXNlOiBcImZhXCIsXG4gICAgICAgICAgICB0aWNrSWNvbjogXCJmYS1jaGVja1wiLFxuICAgICAgICAgICAgc2hvd1RpY2s6ICExLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgICAgICAgICBjYXJldDogJzxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heE9wdGlvbnM6ICExLFxuICAgICAgICAgICAgbW9iaWxlOiAhMSxcbiAgICAgICAgICAgIHNlbGVjdE9uVGFiOiAhMSxcbiAgICAgICAgICAgIGRyb3Bkb3duQWxpZ25SaWdodDogITEsXG4gICAgICAgICAgICB3aW5kb3dQYWRkaW5nOiAwXG4gICAgICAgIH0sIGgucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IGgsXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiRlbGVtZW50LmF0dHIoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiYnMtc2VsZWN0LWhpZGRlblwiKSwgdGhpcy5saU9iaiA9IHt9LCB0aGlzLm11bHRpcGxlID0gdGhpcy4kZWxlbWVudC5wcm9wKFwibXVsdGlwbGVcIiksIHRoaXMuYXV0b2ZvY3VzID0gdGhpcy4kZWxlbWVudC5wcm9wKFwiYXV0b2ZvY3VzXCIpLCB0aGlzLiRuZXdFbGVtZW50ID0gdGhpcy5jcmVhdGVWaWV3KCksIHRoaXMuJGVsZW1lbnQuYWZ0ZXIodGhpcy4kbmV3RWxlbWVudCkuYXBwZW5kVG8odGhpcy4kbmV3RWxlbWVudCksIHRoaXMuJGJ1dHRvbiA9IHRoaXMuJG5ld0VsZW1lbnQuY2hpbGRyZW4oXCJidXR0b25cIiksIHRoaXMuJG1lbnUgPSB0aGlzLiRuZXdFbGVtZW50LmNoaWxkcmVuKFwiLmRyb3Bkb3duLW1lbnVcIiksIHRoaXMuJG1lbnVJbm5lciA9IHRoaXMuJG1lbnUuY2hpbGRyZW4oXCIuaW5uZXJcIiksIHRoaXMuJHNlYXJjaGJveCA9IHRoaXMuJG1lbnUuZmluZChcImlucHV0XCIpLCB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiYnMtc2VsZWN0LWhpZGRlblwiKSwgdGhpcy5vcHRpb25zLmRyb3Bkb3duQWxpZ25SaWdodCA9PT0gITAgJiYgdGhpcy4kbWVudS5hZGRDbGFzcyhcImRyb3Bkb3duLW1lbnUtcmlnaHRcIiksIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGkgJiYgKHRoaXMuJGJ1dHRvbi5hdHRyKFwiZGF0YS1pZFwiLCBpKSwgZSgnbGFiZWxbZm9yPVwiJyArIGkgKyAnXCJdJykuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIHQuJGJ1dHRvbi5mb2N1cygpXG4gICAgICAgICAgICAgICAgfSkpLCB0aGlzLmNoZWNrRGlzYWJsZWQoKSwgdGhpcy5jbGlja0xpc3RlbmVyKCksIHRoaXMub3B0aW9ucy5saXZlU2VhcmNoICYmIHRoaXMubGl2ZVNlYXJjaExpc3RlbmVyKCksIHRoaXMucmVuZGVyKCksIHRoaXMuc2V0U3R5bGUoKSwgdGhpcy5zZXRXaWR0aCgpLCB0aGlzLm9wdGlvbnMuY29udGFpbmVyICYmIHRoaXMuc2VsZWN0UG9zaXRpb24oKSwgdGhpcy4kbWVudS5kYXRhKFwidGhpc1wiLCB0aGlzKSwgdGhpcy4kbmV3RWxlbWVudC5kYXRhKFwidGhpc1wiLCB0aGlzKSwgdGhpcy5vcHRpb25zLm1vYmlsZSAmJiB0aGlzLm1vYmlsZSgpLCB0aGlzLiRuZXdFbGVtZW50Lm9uKHtcbiAgICAgICAgICAgICAgICAgICAgXCJoaWRlLmJzLmRyb3Bkb3duXCI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuJG1lbnVJbm5lci5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCAhMSksIHQuJGVsZW1lbnQudHJpZ2dlcihcImhpZGUuYnMuc2VsZWN0XCIsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZGVuLmJzLmRyb3Bkb3duXCI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuJGVsZW1lbnQudHJpZ2dlcihcImhpZGRlbi5icy5zZWxlY3RcIiwgZSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzaG93LmJzLmRyb3Bkb3duXCI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuJG1lbnVJbm5lci5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCAhMCksIHQuJGVsZW1lbnQudHJpZ2dlcihcInNob3cuYnMuc2VsZWN0XCIsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic2hvd24uYnMuZHJvcGRvd25cIjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC4kZWxlbWVudC50cmlnZ2VyKFwic2hvd24uYnMuc2VsZWN0XCIsIGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgdC4kZWxlbWVudFswXS5oYXNBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiKSAmJiB0aGlzLiRlbGVtZW50Lm9uKFwiaW52YWxpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC4kYnV0dG9uLmFkZENsYXNzKFwiYnMtaW52YWxpZFwiKS5mb2N1cygpLCB0LiRlbGVtZW50Lm9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9jdXMuYnMuc2VsZWN0XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuJGJ1dHRvbi5mb2N1cygpLCB0LiRlbGVtZW50Lm9mZihcImZvY3VzLmJzLnNlbGVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2hvd24uYnMuc2VsZWN0XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuJGVsZW1lbnQudmFsKHQuJGVsZW1lbnQudmFsKCkpLm9mZihcInNob3duLmJzLnNlbGVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVuZGVyZWQuYnMuc2VsZWN0XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRpdHkudmFsaWQgJiYgdC4kYnV0dG9uLnJlbW92ZUNsYXNzKFwiYnMtaW52YWxpZFwiKSwgdC4kZWxlbWVudC5vZmYoXCJyZW5kZXJlZC5icy5zZWxlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KSwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC4kZWxlbWVudC50cmlnZ2VyKFwibG9hZGVkLmJzLnNlbGVjdFwiKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlRHJvcGRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5tdWx0aXBsZSB8fCB0aGlzLm9wdGlvbnMuc2hvd1RpY2sgPyBcIiBzaG93LXRpY2tcIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKFwiaW5wdXQtZ3JvdXBcIikgPyBcIiBpbnB1dC1ncm91cC1idG5cIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLmF1dG9mb2N1cyA/IFwiIGF1dG9mb2N1c1wiIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgcyA9IHRoaXMub3B0aW9ucy5oZWFkZXIgPyAnPGRpdiBjbGFzcz1cInBvcG92ZXItdGl0bGVcIj48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvYnV0dG9uPicgKyB0aGlzLm9wdGlvbnMuaGVhZGVyICsgXCI8L2Rpdj5cIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCA/ICc8ZGl2IGNsYXNzPVwiYnMtc2VhcmNoYm94XCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBhdXRvY29tcGxldGU9XCJvZmZcIicgKyAobnVsbCA9PT0gdGhpcy5vcHRpb25zLmxpdmVTZWFyY2hQbGFjZWhvbGRlciA/IFwiXCIgOiAnIHBsYWNlaG9sZGVyPVwiJyArIHIodGhpcy5vcHRpb25zLmxpdmVTZWFyY2hQbGFjZWhvbGRlcikgKyAnXCInKSArICcgcm9sZT1cInRleHRib3hcIiBhcmlhLWxhYmVsPVwiU2VhcmNoXCI+PC9kaXY+JyA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5hY3Rpb25zQm94ID8gJzxkaXYgY2xhc3M9XCJicy1hY3Rpb25zYm94XCI+PGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtc20gYnRuLWJsb2NrXCI+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJhY3Rpb25zLWJ0biBicy1zZWxlY3QtYWxsIGJ0biBidG4tZGVmYXVsdCBidG4tbGlnaHRcIj4nICsgdGhpcy5vcHRpb25zLnNlbGVjdEFsbFRleHQgKyAnPC9idXR0b24+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJhY3Rpb25zLWJ0biBicy1kZXNlbGVjdC1hbGwgYnRuIGJ0bi1kZWZhdWx0IGJ0bi1saWdodFwiPicgKyB0aGlzLm9wdGlvbnMuZGVzZWxlY3RBbGxUZXh0ICsgXCI8L2J1dHRvbj48L2Rpdj48L2Rpdj5cIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGwgPSB0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5kb25lQnV0dG9uID8gJzxkaXYgY2xhc3M9XCJicy1kb25lYnV0dG9uXCI+PGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tYmxvY2tcIj48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc20gYnRuLWRlZmF1bHQgYnRuLWxpZ2h0XCI+JyArIHRoaXMub3B0aW9ucy5kb25lQnV0dG9uVGV4dCArIFwiPC9idXR0b24+PC9kaXY+PC9kaXY+XCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBkID0gJzxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYm9vdHN0cmFwLXNlbGVjdCcgKyB0ICsgaSArICdcIj48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIicgKyB0aGlzLm9wdGlvbnMuc3R5bGVCYXNlICsgJyBkcm9wZG93bi10b2dnbGVcIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCInICsgbiArICcgcm9sZT1cImJ1dHRvblwiPjxzcGFuIGNsYXNzPVwiZmlsdGVyLW9wdGlvbiBwdWxsLWxlZnRcIj48L3NwYW4+Jm5ic3A7PHNwYW4gY2xhc3M9XCJicy1jYXJldFwiPicgKyB0aGlzLm9wdGlvbnMudGVtcGxhdGUuY2FyZXQgKyAnPC9zcGFuPjwvYnV0dG9uPjxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IG9wZW5cIiByb2xlPVwiY29tYm9ib3hcIj4nICsgcyArIG8gKyBhICsgJzxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGlubmVyXCIgcm9sZT1cImxpc3Rib3hcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj48L2Rpdj4nICsgbCArIFwiPC9kaXY+PC9kaXY+XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUoZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuY3JlYXRlRHJvcGRvd24oKSxcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMuY3JlYXRlTGkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5maW5kKFwiZGl2LmlubmVyXCIpWzBdLmlubmVySFRNTCA9IHQsIGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxvYWRMaTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNyZWF0ZUxpKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kbWVudUlubmVyWzBdLmlubmVySFRNTCA9IGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVMaTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBuID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHMgPSAwLFxuICAgICAgICAgICAgICAgICAgICBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSxcbiAgICAgICAgICAgICAgICAgICAgYSA9IC0xLFxuICAgICAgICAgICAgICAgICAgICBsID0gZnVuY3Rpb24oZSwgdCwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPSBcImRyb3Bkb3duLWl0ZW0gXCIgKyAoaSB8fCBcIlwiKSwgXCI8YVwiICsgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGkgJiYgXCJcIiAhPT0gaSA/ICcgY2xhc3M9XCInICsgaSArICdcIicgOiBcIlwiKSArIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0ICYmIG51bGwgIT09IHQgPyAnIGRhdGEtb3JpZ2luYWwtaW5kZXg9XCInICsgdCArICdcIicgOiBcIlwiKSArIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBuICYmIG51bGwgIT09IG4gPyAnZGF0YS1vcHRncm91cD1cIicgKyBuICsgJ1wiJyA6IFwiXCIpICsgXCI+XCIgKyBlICsgXCI8L2E+XCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGZ1bmN0aW9uKG4sIHMsIG8sIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzID0gXCJkcm9wZG93bi1pdGVtLWlubmVyIFwiICsgKHMgfHwgXCJcIiksICc8c3BhbiB0YWJpbmRleD1cIjBcIicgKyAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgcyA/ICcgY2xhc3M9XCInICsgcyArICdcIicgOiBcIlwiKSArIChvID8gJyBzdHlsZT1cIicgKyBvICsgJ1wiJyA6IFwiXCIpICsgKGkub3B0aW9ucy5saXZlU2VhcmNoTm9ybWFsaXplID8gJyBkYXRhLW5vcm1hbGl6ZWQtdGV4dD1cIicgKyB0KHIoZShuKS5odG1sKCkpKSArICdcIicgOiBcIlwiKSArIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhIHx8IG51bGwgIT09IGEgPyAnIGRhdGEtdG9rZW5zPVwiJyArIGEgKyAnXCInIDogXCJcIikgKyAnIHJvbGU9XCJvcHRpb25cIj4nICsgbiArICc8c3BhbiBjbGFzcz1cIicgKyBpLm9wdGlvbnMuaWNvbkJhc2UgKyBcIiBcIiArIGkub3B0aW9ucy50aWNrSWNvbiArICcgY2hlY2stbWFya1wiPjwvc3Bhbj48L3NwYW4+J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGl0bGUgJiYgIXRoaXMubXVsdGlwbGUgJiYgKGEtLSwgIXRoaXMuJGVsZW1lbnQuZmluZChcIi5icy10aXRsZS1vcHRpb25cIikubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuJGVsZW1lbnRbMF07XG4gICAgICAgICAgICAgICAgICAgIG8uY2xhc3NOYW1lID0gXCJicy10aXRsZS1vcHRpb25cIiwgby5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMudGl0bGUsIG8udmFsdWUgPSBcIlwiLCBoLmluc2VydEJlZm9yZShvLCBoLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGUoaC5vcHRpb25zW2guc2VsZWN0ZWRJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGMuYXR0cihcInNlbGVjdGVkXCIpICYmIHZvaWQgMCA9PT0gdGhpcy4kZWxlbWVudC5kYXRhKFwic2VsZWN0ZWRcIikgJiYgKG8uc2VsZWN0ZWQgPSAhMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuZWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGErKywgIW8uaGFzQ2xhc3MoXCJicy10aXRsZS1vcHRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoLCBjID0gdGhpcy5jbGFzc05hbWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gcih0aGlzLnN0eWxlLmNzc1RleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBvLmRhdGEoXCJjb250ZW50XCIpID8gby5kYXRhKFwiY29udGVudFwiKSA6IG8uaHRtbCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBvLmRhdGEoXCJ0b2tlbnNcIikgPyBvLmRhdGEoXCJ0b2tlbnNcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBvLmRhdGEoXCJzdWJ0ZXh0XCIpID8gJzxzbWFsbCBjbGFzcz1cInRleHQtbXV0ZWRcIj4nICsgby5kYXRhKFwic3VidGV4dFwiKSArIFwiPC9zbWFsbD5cIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG8uZGF0YShcImljb25cIikgPyAnPHNwYW4gY2xhc3M9XCInICsgaS5vcHRpb25zLmljb25CYXNlICsgXCIgXCIgKyBvLmRhdGEoXCJpY29uXCIpICsgJ1wiPjwvc3Bhbj4gJyA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IG8ucGFyZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCA9IFwiT1BUR1JPVVBcIiA9PT0gdlswXS50YWdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSAkICYmIHZbMF0uZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHRoaXMuZGlzYWJsZWQgfHwgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlwiICE9PSBiICYmIHcgJiYgKGIgPSBcIjxzcGFuPlwiICsgYiArIFwiPC9zcGFuPlwiKSwgaS5vcHRpb25zLmhpZGVEaXNhYmxlZCAmJiAodyAmJiAhJCB8fCB4KSkgcmV0dXJuIGggPSBvLmRhdGEoXCJwcmV2SGlkZGVuSW5kZXhcIiksIG8ubmV4dCgpLmRhdGEoXCJwcmV2SGlkZGVuSW5kZXhcIiwgdm9pZCAwICE9PSBoID8gaCA6IHQpLCB2b2lkIGEtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmRhdGEoXCJjb250ZW50XCIpIHx8IChmID0gYiArICc8c3BhbiBjbGFzcz1cInRleHRcIj4nICsgZiArIGcgKyBcIjwvc3Bhbj5cIiksICQgJiYgby5kYXRhKFwiZGl2aWRlclwiKSAhPT0gITApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5vcHRpb25zLmhpZGVEaXNhYmxlZCAmJiB3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHYuZGF0YShcImFsbE9wdGlvbnNEaXNhYmxlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSB2LmNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmRhdGEoXCJhbGxPcHRpb25zRGlzYWJsZWRcIiwgeS5maWx0ZXIoXCI6ZGlzYWJsZWRcIikubGVuZ3RoID09PSB5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5kYXRhKFwiYWxsT3B0aW9uc0Rpc2FibGVkXCIpKSByZXR1cm4gdm9pZCBhLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEMgPSBcIiBcIiArIHZbMF0uY2xhc3NOYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8uaW5kZXgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBTID0gdlswXS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB2LmRhdGEoXCJzdWJ0ZXh0XCIpID8gJzxzbWFsbCBjbGFzcz1cInRleHQtbXV0ZWRcIj4nICsgdi5kYXRhKFwic3VidGV4dFwiKSArIFwiPC9zbWFsbD5cIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJID0gdi5kYXRhKFwiaWNvblwiKSA/ICc8c3BhbiBjbGFzcz1cIicgKyBpLm9wdGlvbnMuaWNvbkJhc2UgKyBcIiBcIiArIHYuZGF0YShcImljb25cIikgKyAnXCI+PC9zcGFuPiAnIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUyA9IEkgKyAnPHNwYW4gY2xhc3M9XCJ0ZXh0XCI+JyArIHIoUykgKyBrICsgXCI8L3NwYW4+XCIsIDAgIT09IHQgJiYgbi5sZW5ndGggPiAwICYmIChhKyssIG4ucHVzaChsKFwiXCIsIG51bGwsIFwiZGl2aWRlclwiLCBzICsgXCJkaXZcIikpKSwgYSsrLCBuLnB1c2gobChTLCBudWxsLCBcImRyb3Bkb3duLWhlYWRlclwiICsgQywgcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLm9wdGlvbnMuaGlkZURpc2FibGVkICYmIHcpIHJldHVybiB2b2lkIGEtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnB1c2gobChkKGYsIFwib3B0IFwiICsgYyArIEMsIHUsIG0pLCB0LCBcIlwiLCBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoby5kYXRhKFwiZGl2aWRlclwiKSA9PT0gITApIG4ucHVzaChsKFwiXCIsIHQsIFwiZGl2aWRlclwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvLmRhdGEoXCJoaWRkZW5cIikgPT09ICEwKSBoID0gby5kYXRhKFwicHJldkhpZGRlbkluZGV4XCIpLCBvLm5leHQoKS5kYXRhKFwicHJldkhpZGRlbkluZGV4XCIsIHZvaWQgMCAhPT0gaCA/IGggOiB0KSwgbi5wdXNoKGwoZChmLCBjLCB1LCBtKSwgdCwgXCJoaWRkZW4gaXMtaGlkZGVuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUID0gdGhpcy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIFwiT1BUR1JPVVBcIiA9PT0gdGhpcy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnRhZ05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUICYmIGkub3B0aW9ucy5oaWRlRGlzYWJsZWQgJiYgKGggPSBvLmRhdGEoXCJwcmV2SGlkZGVuSW5kZXhcIiksIHZvaWQgMCAhPT0gaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEUgPSBwLmVxKGgpWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUgJiYgXCJPUFRHUk9VUFwiID09PSBFLnRhZ05hbWUgJiYgIUUuZGlzYWJsZWQgJiYgKFQgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVCAmJiAoYSsrLCBuLnB1c2gobChcIlwiLCBudWxsLCBcImRpdmlkZXJcIiwgcyArIFwiZGl2XCIpKSksIG4ucHVzaChsKGQoZiwgYywgdSwgbSksIHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaS5saU9ialt0XSA9IGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLm11bHRpcGxlIHx8IDAgIT09IHRoaXMuJGVsZW1lbnQuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKS5sZW5ndGggfHwgdGhpcy5vcHRpb25zLnRpdGxlIHx8IHRoaXMuJGVsZW1lbnQuZmluZChcIm9wdGlvblwiKS5lcSgwKS5wcm9wKFwic2VsZWN0ZWRcIiwgITApLmF0dHIoXCJzZWxlY3RlZFwiLCBcInNlbGVjdGVkXCIpLCBuLmpvaW4oXCJcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5kTGlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSB0aGlzLiRsaXMgJiYgKHRoaXMuJGxpcyA9IHRoaXMuJG1lbnUuZmluZChcImFcIikpLCB0aGlzLiRsaXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgICAgdCAhPT0gITEgJiYgcy5lYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuLmZpbmRMaXMoKS5lcShuLmxpT2JqW2VdKTtcbiAgICAgICAgICAgICAgICAgICAgbi5zZXREaXNhYmxlZChlLCB0aGlzLmRpc2FibGVkIHx8IFwiT1BUR1JPVVBcIiA9PT0gdGhpcy5wYXJlbnROb2RlLnRhZ05hbWUgJiYgdGhpcy5wYXJlbnROb2RlLmRpc2FibGVkLCB0KSwgbi5zZXRTZWxlY3RlZChlLCB0aGlzLnNlbGVjdGVkLCB0KVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLnRvZ2dsZVBsYWNlaG9sZGVyKCksIHRoaXMudGFiSW5kZXgoKTtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHMubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5vcHRpb25zLmhpZGVEaXNhYmxlZCAmJiAodGhpcy5kaXNhYmxlZCB8fCBcIk9QVEdST1VQXCIgPT09IHRoaXMucGFyZW50Tm9kZS50YWdOYW1lICYmIHRoaXMucGFyZW50Tm9kZS5kaXNhYmxlZCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCwgaSA9IGUodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBpLmRhdGEoXCJpY29uXCIpICYmIG4ub3B0aW9ucy5zaG93SWNvbiA/ICc8aSBjbGFzcz1cIicgKyBuLm9wdGlvbnMuaWNvbkJhc2UgKyBcIiBcIiArIGkuZGF0YShcImljb25cIikgKyAnXCI+PC9pPiAnIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA9IG4ub3B0aW9ucy5zaG93U3VidGV4dCAmJiBpLmRhdGEoXCJzdWJ0ZXh0XCIpICYmICFuLm11bHRpcGxlID8gJyA8c21hbGwgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+JyArIGkuZGF0YShcInN1YnRleHRcIikgKyBcIjwvc21hbGw+XCIgOiBcIlwiLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBpLmF0dHIoXCJ0aXRsZVwiKSA/IGkuYXR0cihcInRpdGxlXCIpIDogaS5kYXRhKFwiY29udGVudFwiKSAmJiBuLm9wdGlvbnMuc2hvd0NvbnRlbnQgPyBpLmRhdGEoXCJjb250ZW50XCIpLnRvU3RyaW5nKCkgOiBzICsgaS5odG1sKCkgKyB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMubXVsdGlwbGUgPyBvLmpvaW4odGhpcy5vcHRpb25zLm11bHRpcGxlU2VwYXJhdG9yKSA6IG9bMF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUgJiYgdGhpcy5vcHRpb25zLnNlbGVjdGVkVGV4dEZvcm1hdC5pbmRleE9mKFwiY291bnRcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQuc3BsaXQoXCI+XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobC5sZW5ndGggPiAxICYmIG8ubGVuZ3RoID4gbFsxXSB8fCAxID09IGwubGVuZ3RoICYmIG8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLm9wdGlvbnMuaGlkZURpc2FibGVkID8gXCIsIFtkaXNhYmxlZF1cIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHMubm90KCdbZGF0YS1kaXZpZGVyPVwidHJ1ZVwiXSwgW2RhdGEtaGlkZGVuPVwidHJ1ZVwiXScgKyBpKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRpb25zLmNvdW50U2VsZWN0ZWRUZXh0ID8gdGhpcy5vcHRpb25zLmNvdW50U2VsZWN0ZWRUZXh0KG8ubGVuZ3RoLCByKSA6IHRoaXMub3B0aW9ucy5jb3VudFNlbGVjdGVkVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBoLnJlcGxhY2UoXCJ7MH1cIiwgby5sZW5ndGgudG9TdHJpbmcoKSkucmVwbGFjZShcInsxfVwiLCByLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdm9pZCAwID09IHRoaXMub3B0aW9ucy50aXRsZSAmJiAodGhpcy5vcHRpb25zLnRpdGxlID0gdGhpcy4kZWxlbWVudC5hdHRyKFwidGl0bGVcIikpLCBcInN0YXRpY1wiID09IHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQgJiYgKGEgPSB0aGlzLm9wdGlvbnMudGl0bGUpLCBhIHx8IChhID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdGhpcy5vcHRpb25zLnRpdGxlID8gdGhpcy5vcHRpb25zLnRpdGxlIDogdGhpcy5vcHRpb25zLm5vbmVTZWxlY3RlZFRleHQpLCB0aGlzLiRidXR0b24uYXR0cihcInRpdGxlXCIsIGQoZS50cmltKGEucmVwbGFjZSgvPFtePl0qPj8vZywgXCJcIikpKSksIHRoaXMuJGJ1dHRvbi5jaGlsZHJlbihcIi5maWx0ZXItb3B0aW9uXCIpLmh0bWwoYSksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInJlbmRlcmVkLmJzLnNlbGVjdFwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFN0eWxlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKFwiY2xhc3NcIikgJiYgdGhpcy4kbmV3RWxlbWVudC5hZGRDbGFzcyh0aGlzLiRlbGVtZW50LmF0dHIoXCJjbGFzc1wiKS5yZXBsYWNlKC9zZWxlY3RwaWNrZXJ8bW9iaWxlLWRldmljZXxicy1zZWxlY3QtaGlkZGVufHZhbGlkYXRlXFxbLipcXF0vZ2ksIFwiXCIpKTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGUgPyBlIDogdGhpcy5vcHRpb25zLnN0eWxlO1xuICAgICAgICAgICAgICAgIFwiYWRkXCIgPT0gdCA/IHRoaXMuJGJ1dHRvbi5hZGRDbGFzcyhpKSA6IFwicmVtb3ZlXCIgPT0gdCA/IHRoaXMuJGJ1dHRvbi5yZW1vdmVDbGFzcyhpKSA6ICh0aGlzLiRidXR0b24ucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnN0eWxlKSwgdGhpcy4kYnV0dG9uLmFkZENsYXNzKGkpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpSGVpZ2h0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHQgfHwgdGhpcy5vcHRpb25zLnNpemUgIT09ICExICYmICF0aGlzLnNpemVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLm9wdGlvbnMuaGVhZGVyICYmIHRoaXMuJG1lbnUuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKVswXS5jbG9uZU5vZGUoITApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSB0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMub3B0aW9ucy5hY3Rpb25zQm94ICYmIHRoaXMubXVsdGlwbGUgJiYgdGhpcy4kbWVudS5maW5kKFwiLmJzLWFjdGlvbnNib3hcIikubGVuZ3RoID4gMCA/IHRoaXMuJG1lbnUuZmluZChcIi5icy1hY3Rpb25zYm94XCIpWzBdLmNsb25lTm9kZSghMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMub3B0aW9ucy5kb25lQnV0dG9uICYmIHRoaXMubXVsdGlwbGUgJiYgdGhpcy4kbWVudS5maW5kKFwiLmJzLWRvbmVidXR0b25cIikubGVuZ3RoID4gMCA/IHRoaXMuJG1lbnUuZmluZChcIi5icy1kb25lYnV0dG9uXCIpWzBdLmNsb25lTm9kZSghMCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoci5jbGFzc05hbWUgPSBcInRleHRcIiwgaS5jbGFzc05hbWUgPSB0aGlzLiRtZW51WzBdLnBhcmVudE5vZGUuY2xhc3NOYW1lICsgXCIgc2hvdyBvcGVuXCIsIG4uY2xhc3NOYW1lID0gXCJkcm9wZG93bi1tZW51IG9wZW4gc2hvd1wiLCBzLmNsYXNzTmFtZSA9IFwiZHJvcGRvd24tbWVudSBpbm5lclwiLCBvLmNsYXNzTmFtZSA9IFwiZGl2aWRlclwiLCBsLmNsYXNzTmFtZSA9IFwiZHJvcGRvd24taXRlbS1pbm5lclwiLCByLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiSW5uZXIgdGV4dFwiKSksIGwuYXBwZW5kQ2hpbGQociksIGEuYXBwZW5kQ2hpbGQobCksIHMuYXBwZW5kQ2hpbGQoYSksIHMuYXBwZW5kQ2hpbGQobyksIGQgJiYgbi5hcHBlbmRDaGlsZChkKSwgaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBoLmNsYXNzTmFtZSA9IFwiYnMtc2VhcmNoYm94XCIsIHUuY2xhc3NOYW1lID0gXCJmb3JtLWNvbnRyb2xcIiwgaC5hcHBlbmRDaGlsZCh1KSwgbi5hcHBlbmRDaGlsZChoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMgJiYgbi5hcHBlbmRDaGlsZChjKSwgbi5hcHBlbmRDaGlsZChzKSwgcCAmJiBuLmFwcGVuZENoaWxkKHApLCBpLmFwcGVuZENoaWxkKG4pLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGwub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IGQgPyBkLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gaCA/IGgub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjID8gYy5vZmZzZXRIZWlnaHQgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHAgPyBwLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAkID0gZShvKS5vdXRlckhlaWdodCghMCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShuKSA6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHggPyBudWxsIDogZShuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydDogcGFyc2VJbnQoeCA/IHgucGFkZGluZ1RvcCA6IHcuY3NzKFwicGFkZGluZ1RvcFwiKSkgKyBwYXJzZUludCh4ID8geC5wYWRkaW5nQm90dG9tIDogdy5jc3MoXCJwYWRkaW5nQm90dG9tXCIpKSArIHBhcnNlSW50KHggPyB4LmJvcmRlclRvcFdpZHRoIDogdy5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSkgKyBwYXJzZUludCh4ID8geC5ib3JkZXJCb3R0b21XaWR0aCA6IHcuY3NzKFwiYm9yZGVyQm90dG9tV2lkdGhcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6OiBwYXJzZUludCh4ID8geC5wYWRkaW5nTGVmdCA6IHcuY3NzKFwicGFkZGluZ0xlZnRcIikpICsgcGFyc2VJbnQoeCA/IHgucGFkZGluZ1JpZ2h0IDogdy5jc3MoXCJwYWRkaW5nUmlnaHRcIikpICsgcGFyc2VJbnQoeCA/IHguYm9yZGVyTGVmdFdpZHRoIDogdy5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIikpICsgcGFyc2VJbnQoeCA/IHguYm9yZGVyUmlnaHRXaWR0aCA6IHcuY3NzKFwiYm9yZGVyUmlnaHRXaWR0aFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBDID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnQ6IHkudmVydCArIHBhcnNlSW50KHggPyB4Lm1hcmdpblRvcCA6IHcuY3NzKFwibWFyZ2luVG9wXCIpKSArIHBhcnNlSW50KHggPyB4Lm1hcmdpbkJvdHRvbSA6IHcuY3NzKFwibWFyZ2luQm90dG9tXCIpKSArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXo6IHkuaG9yaXogKyBwYXJzZUludCh4ID8geC5tYXJnaW5MZWZ0IDogdy5jc3MoXCJtYXJnaW5MZWZ0XCIpKSArIHBhcnNlSW50KHggPyB4Lm1hcmdpblJpZ2h0IDogdy5jc3MoXCJtYXJnaW5SaWdodFwiKSkgKyAyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGkpLCB0aGlzLnNpemVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlIZWlnaHQ6IGYsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQ6IG0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hIZWlnaHQ6IGcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zSGVpZ2h0OiBiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZUJ1dHRvbkhlaWdodDogdixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmlkZXJIZWlnaHQ6ICQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51UGFkZGluZzogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVFeHRyYXM6IENcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kTGlzKCksIHRoaXMubGlIZWlnaHQoKSwgdGhpcy5vcHRpb25zLmhlYWRlciAmJiB0aGlzLiRtZW51LmNzcyhcInBhZGRpbmctdG9wXCIsIDApLCB0aGlzLm9wdGlvbnMuc2l6ZSAhPT0gITEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQsIGksIG4sIHMsIG8sIGEsIGwsIHIsIGQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHRoaXMuJG1lbnUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy4kbWVudUlubmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGUod2luZG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB0aGlzLiRuZXdFbGVtZW50WzBdLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSB0aGlzLiRuZXdFbGVtZW50WzBdLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHRoaXMuc2l6ZUluZm8ubGlIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gdGhpcy5zaXplSW5mby5oZWFkZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5zaXplSW5mby5zZWFyY2hIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5zaXplSW5mby5hY3Rpb25zSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJCA9IHRoaXMuc2l6ZUluZm8uZG9uZUJ1dHRvbkhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnNpemVJbmZvLmRpdmlkZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gdGhpcy5zaXplSW5mby5tZW51UGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBDID0gdGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCA/IFwiLmRpc2FibGVkXCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgUyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0LCBpID0gZC4kbmV3RWxlbWVudC5vZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGUoZC5vcHRpb25zLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5vcHRpb25zLmNvbnRhaW5lciAmJiAhbi5pcyhcImJvZHlcIikgPyAodCA9IG4ub2Zmc2V0KCksIHQudG9wICs9IHBhcnNlSW50KG4uY3NzKFwiYm9yZGVyVG9wV2lkdGhcIikpLCB0LmxlZnQgKz0gcGFyc2VJbnQobi5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIikpKSA6IHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBkLm9wdGlvbnMud2luZG93UGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gaS50b3AgLSB0LnRvcCAtIHAuc2Nyb2xsVG9wKCksIGEgPSBwLmhlaWdodCgpIC0gbyAtIHUgLSB0LnRvcCAtIHNbMl0sIGwgPSBpLmxlZnQgLSB0LmxlZnQgLSBwLnNjcm9sbExlZnQoKSwgciA9IHAud2lkdGgoKSAtIGwgLSBmIC0gdC5sZWZ0IC0gc1sxXSwgbyAtPSBzWzBdLCBsIC09IHNbM11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChTKCksIFwiYXV0b1wiID09PSB0aGlzLm9wdGlvbnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCwgdSA9IGZ1bmN0aW9uKHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPyBuLmNsYXNzTGlzdCA/IG4uY2xhc3NMaXN0LmNvbnRhaW5zKHQpIDogZShuKS5oYXNDbGFzcyh0KSA6ICEobi5jbGFzc0xpc3QgPyBuLmNsYXNzTGlzdC5jb250YWlucyh0KSA6IGUobikuaGFzQ2xhc3ModCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkLiRtZW51SW5uZXJbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDID0gQXJyYXkucHJvdG90eXBlLmZpbHRlciA/IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh4LCB1KFwiaGlkZGVuXCIsICExKSkgOiBkLiRsaXMubm90KFwiLmhpZGRlblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPyBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoQywgdShcImRyb3Bkb3duLWhlYWRlclwiLCAhMCkpIDogQy5maWx0ZXIoXCIuZHJvcGRvd24taGVhZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMoKSwgdCA9IGEgLSB5LnZlcnQsIGkgPSByIC0geS5ob3JpeiwgZC5vcHRpb25zLmNvbnRhaW5lciA/IChoLmRhdGEoXCJoZWlnaHRcIikgfHwgaC5kYXRhKFwiaGVpZ2h0XCIsIGguaGVpZ2h0KCkpLCBuID0gaC5kYXRhKFwiaGVpZ2h0XCIpLCBoLmRhdGEoXCJ3aWR0aFwiKSB8fCBoLmRhdGEoXCJ3aWR0aFwiLCBoLndpZHRoKCkpLCBzID0gaC5kYXRhKFwid2lkdGhcIikpIDogKG4gPSBoLmhlaWdodCgpLCBzID0gaC53aWR0aCgpKSwgZC5vcHRpb25zLmRyb3B1cEF1dG8gJiYgZC4kbmV3RWxlbWVudC50b2dnbGVDbGFzcyhcImRyb3B1cFwiLCBvID4gYSAmJiB0IC0geS52ZXJ0IDwgbiksIGQuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoXCJkcm9wdXBcIikgJiYgKHQgPSBvIC0geS52ZXJ0KSwgXCJhdXRvXCIgPT09IGQub3B0aW9ucy5kcm9wZG93bkFsaWduUmlnaHQgJiYgaC50b2dnbGVDbGFzcyhcImRyb3Bkb3duLW1lbnUtcmlnaHRcIiwgbCA+IHIgJiYgaSAtIHkuaG9yaXogPCBzIC0gZiksIHAgPSBDLmxlbmd0aCArIGsubGVuZ3RoID4gMyA/IDMgKiBtICsgeS52ZXJ0IC0gMiA6IDAsIGguY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtaGVpZ2h0XCI6IHQgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbi1oZWlnaHRcIjogcCArIGcgKyBiICsgdiArICQgKyBcInB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgYy5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1heC1oZWlnaHRcIjogdCAtIGcgLSBiIC0gdiAtICQgLSB3LnZlcnQgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3ZlcmZsb3cteVwiOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW4taGVpZ2h0XCI6IE1hdGgubWF4KHAgLSB3LnZlcnQsIDApICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBrKCksIHRoaXMuJHNlYXJjaGJveC5vZmYoXCJpbnB1dC5nZXRTaXplIHByb3BlcnR5Y2hhbmdlLmdldFNpemVcIikub24oXCJpbnB1dC5nZXRTaXplIHByb3BlcnR5Y2hhbmdlLmdldFNpemVcIiwgayksIHAub2ZmKFwicmVzaXplLmdldFNpemUgc2Nyb2xsLmdldFNpemVcIikub24oXCJyZXNpemUuZ2V0U2l6ZSBzY3JvbGwuZ2V0U2l6ZVwiLCBrKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zaXplICYmIFwiYXV0b1wiICE9IHRoaXMub3B0aW9ucy5zaXplICYmIHRoaXMuJGxpcy5ub3QoQykubGVuZ3RoID4gdGhpcy5vcHRpb25zLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBJID0gdGhpcy4kbGlzLm5vdChcIi5kaXZpZGVyXCIpLm5vdChDKS5jaGlsZHJlbigpLnNsaWNlKDAsIHRoaXMub3B0aW9ucy5zaXplKS5sYXN0KCkucGFyZW50KCkuaW5kZXgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUID0gdGhpcy4kbGlzLnNsaWNlKDAsIEkgKyAxKS5maWx0ZXIoXCIuZGl2aWRlclwiKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gbSAqIHRoaXMub3B0aW9ucy5zaXplICsgVCAqIHggKyB3LnZlcnQsIGQub3B0aW9ucy5jb250YWluZXIgPyAoaC5kYXRhKFwiaGVpZ2h0XCIpIHx8IGguZGF0YShcImhlaWdodFwiLCBoLmhlaWdodCgpKSwgbiA9IGguZGF0YShcImhlaWdodFwiKSkgOiBuID0gaC5oZWlnaHQoKSwgZC5vcHRpb25zLmRyb3B1cEF1dG8gJiYgdGhpcy4kbmV3RWxlbWVudC50b2dnbGVDbGFzcyhcImRyb3B1cFwiLCBvID4gYSAmJiB0IC0geS52ZXJ0IDwgbiksIGguY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1heC1oZWlnaHRcIjogdCArIGcgKyBiICsgdiArICQgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW4taGVpZ2h0XCI6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtaGVpZ2h0XCI6IHQgLSB3LnZlcnQgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyZmxvdy15XCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWluLWhlaWdodFwiOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJhdXRvXCIgPT09IHRoaXMub3B0aW9ucy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRtZW51LmNzcyhcIm1pbi13aWR0aFwiLCBcIjBcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy4kbWVudS5wYXJlbnQoKS5jbG9uZSgpLmFwcGVuZFRvKFwiYm9keVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID8gdGhpcy4kbmV3RWxlbWVudC5jbG9uZSgpLmFwcGVuZFRvKFwiYm9keVwiKSA6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZS5jaGlsZHJlbihcIi5kcm9wZG93bi1tZW51XCIpLm91dGVyV2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0LmNzcyhcIndpZHRoXCIsIFwiYXV0b1wiKS5jaGlsZHJlbihcImJ1dHRvblwiKS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlKCksIHQucmVtb3ZlKCksIHRoaXMuJG5ld0VsZW1lbnQuY3NzKFwid2lkdGhcIiwgTWF0aC5tYXgoaSwgbikgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIFwiZml0XCIgPT09IHRoaXMub3B0aW9ucy53aWR0aCA/ICh0aGlzLiRtZW51LmNzcyhcIm1pbi13aWR0aFwiLCBcIlwiKSwgdGhpcy4kbmV3RWxlbWVudC5jc3MoXCJ3aWR0aFwiLCBcIlwiKS5hZGRDbGFzcyhcImZpdC13aWR0aFwiKSkgOiB0aGlzLm9wdGlvbnMud2lkdGggPyAodGhpcy4kbWVudS5jc3MoXCJtaW4td2lkdGhcIiwgXCJcIiksIHRoaXMuJG5ld0VsZW1lbnQuY3NzKFwid2lkdGhcIiwgdGhpcy5vcHRpb25zLndpZHRoKSkgOiAodGhpcy4kbWVudS5jc3MoXCJtaW4td2lkdGhcIiwgXCJcIiksIHRoaXMuJG5ld0VsZW1lbnQuY3NzKFwid2lkdGhcIiwgXCJcIikpO1xuICAgICAgICAgICAgICAgIHRoaXMuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoXCJmaXQtd2lkdGhcIikgJiYgXCJmaXRcIiAhPT0gdGhpcy5vcHRpb25zLndpZHRoICYmIHRoaXMuJG5ld0VsZW1lbnQucmVtb3ZlQ2xhc3MoXCJmaXQtd2lkdGhcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYnNDb250YWluZXIgPSBlKCc8ZGl2IGNsYXNzPVwiYnMtY29udGFpbmVyXCIgLz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgdCwgaSwgbiwgcyA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG8gPSBlKHRoaXMub3B0aW9ucy5jb250YWluZXIpLFxuICAgICAgICAgICAgICAgICAgICBhID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy4kYnNDb250YWluZXIuYWRkQ2xhc3MoZS5hdHRyKFwiY2xhc3NcIikucmVwbGFjZSgvZm9ybS1jb250cm9sfGZpdC13aWR0aC9naSwgXCJcIikpLnRvZ2dsZUNsYXNzKFwiZHJvcHVwXCIsIGUuaGFzQ2xhc3MoXCJkcm9wdXBcIikpLCB0ID0gZS5vZmZzZXQoKSwgby5pcyhcImJvZHlcIikgPyBpID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogKGkgPSBvLm9mZnNldCgpLCBpLnRvcCArPSBwYXJzZUludChvLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpKSAtIG8uc2Nyb2xsVG9wKCksIGkubGVmdCArPSBwYXJzZUludChvLmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSkgLSBvLnNjcm9sbExlZnQoKSksIG4gPSBlLmhhc0NsYXNzKFwiZHJvcHVwXCIpID8gMCA6IGVbMF0ub2Zmc2V0SGVpZ2h0LCBzLiRic0NvbnRhaW5lci5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogdC50b3AgLSBpLnRvcCArIG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdC5sZWZ0IC0gaS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlWzBdLm9mZnNldFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuJGJ1dHRvbi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHMuaXNEaXNhYmxlZCgpIHx8IChhKHMuJG5ld0VsZW1lbnQpLCBzLiRic0NvbnRhaW5lci5hcHBlbmRUbyhzLm9wdGlvbnMuY29udGFpbmVyKS50b2dnbGVDbGFzcyhcIm9wZW5cIiwgIXQuaGFzQ2xhc3MoXCJvcGVuXCIpKS5hcHBlbmQocy4kbWVudSkpXG4gICAgICAgICAgICAgICAgfSksIGUod2luZG93KS5vbihcInJlc2l6ZSBzY3JvbGxcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGEocy4kbmV3RWxlbWVudClcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kZWxlbWVudC5vbihcImhpZGUuYnMuc2VsZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzLiRtZW51LmRhdGEoXCJoZWlnaHRcIiwgcy4kbWVudS5oZWlnaHQoKSksIHMuJGJzQ29udGFpbmVyLmRldGFjaCgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgIGkgfHwgKHRoaXMudG9nZ2xlUGxhY2Vob2xkZXIoKSwgaSA9IHRoaXMuZmluZExpcygpLmVxKHRoaXMubGlPYmpbZV0pKSwgaS50b2dnbGVDbGFzcyhcInNlbGVjdGVkXCIsIHQpLmZpbmQoXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIikuYXR0cihcImFyaWEtc2VsZWN0ZWRcIiwgdClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXREaXNhYmxlZDogZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgIGkgfHwgKGkgPSB0aGlzLmZpbmRMaXMoKS5lcSh0aGlzLmxpT2JqW2VdKSksIHQgPyBpLmFkZENsYXNzKFwiZGlzYWJsZWRcIikuY2hpbGRyZW4oXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIikuYXR0cihcImhyZWZcIiwgXCIjXCIpLmF0dHIoXCJ0YWJpbmRleFwiLCAtMSkuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITApIDogaS5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpLmNoaWxkcmVuKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLnJlbW92ZUF0dHIoXCJocmVmXCIpLmF0dHIoXCJ0YWJpbmRleFwiLCAwKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCAhMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudFswXS5kaXNhYmxlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoZWNrRGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlzYWJsZWQoKSA/ICh0aGlzLiRuZXdFbGVtZW50LmFkZENsYXNzKFwiZGlzYWJsZWRcIiksIHRoaXMuJGJ1dHRvbi5hZGRDbGFzcyhcImRpc2FibGVkXCIpLmF0dHIoXCJ0YWJpbmRleFwiLCAtMSkuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITApKSA6ICh0aGlzLiRidXR0b24uaGFzQ2xhc3MoXCJkaXNhYmxlZFwiKSAmJiAodGhpcy4kbmV3RWxlbWVudC5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpLCB0aGlzLiRidXR0b24ucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCAhMSkpLCAtMSAhPSB0aGlzLiRidXR0b24uYXR0cihcInRhYmluZGV4XCIpIHx8IHRoaXMuJGVsZW1lbnQuZGF0YShcInRhYmluZGV4XCIpIHx8IHRoaXMuJGJ1dHRvbi5yZW1vdmVBdHRyKFwidGFiaW5kZXhcIikpLCB0aGlzLiRidXR0b24uY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZS5pc0Rpc2FibGVkKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuJGVsZW1lbnQudmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kYnV0dG9uLnRvZ2dsZUNsYXNzKFwiYnMtcGxhY2Vob2xkZXJcIiwgbnVsbCA9PT0gZSB8fCBcIlwiID09PSBlIHx8IGUuY29uc3RydWN0b3IgPT09IEFycmF5ICYmIDAgPT09IGUubGVuZ3RoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhYkluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmRhdGEoXCJ0YWJpbmRleFwiKSAhPT0gdGhpcy4kZWxlbWVudC5hdHRyKFwidGFiaW5kZXhcIikgJiYgLTk4ICE9PSB0aGlzLiRlbGVtZW50LmF0dHIoXCJ0YWJpbmRleFwiKSAmJiBcIi05OFwiICE9PSB0aGlzLiRlbGVtZW50LmF0dHIoXCJ0YWJpbmRleFwiKSAmJiAodGhpcy4kZWxlbWVudC5kYXRhKFwidGFiaW5kZXhcIiwgdGhpcy4kZWxlbWVudC5hdHRyKFwidGFiaW5kZXhcIikpLCB0aGlzLiRidXR0b24uYXR0cihcInRhYmluZGV4XCIsIHRoaXMuJGVsZW1lbnQuZGF0YShcInRhYmluZGV4XCIpKSksIHRoaXMuJGVsZW1lbnQuYXR0cihcInRhYmluZGV4XCIsIC05OClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGlja0xpc3RlbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBlKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBpLmRhdGEoXCJzcGFjZVNlbGVjdFwiLCAhMSksIHRoaXMuJGJ1dHRvbi5vbihcImtleXVwXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLygzMikvLnRlc3QoZS5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgJiYgaS5kYXRhKFwic3BhY2VTZWxlY3RcIikgJiYgKGUucHJldmVudERlZmF1bHQoKSwgaS5kYXRhKFwic3BhY2VTZWxlY3RcIiwgITEpKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRidXR0b24ub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5zZXRTaXplKClcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kZWxlbWVudC5vbihcInNob3duLmJzLnNlbGVjdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQub3B0aW9ucy5saXZlU2VhcmNoIHx8IHQubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdC5saU9ialt0LiRlbGVtZW50WzBdLnNlbGVjdGVkSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiBlIHx8IHQub3B0aW9ucy5zaXplID09PSAhMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdC4kbGlzLmVxKGUpWzBdLm9mZnNldFRvcCAtIHQuJG1lbnVJbm5lclswXS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkgLSB0LiRtZW51SW5uZXJbMF0ub2Zmc2V0SGVpZ2h0IC8gMiArIHQuc2l6ZUluZm8ubGlIZWlnaHQgLyAyLCB0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wID0gaVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdC4kbWVudUlubmVyLmZpbmQoXCIuc2VsZWN0ZWQgYVwiKS5mb2N1cygpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuJG1lbnVJbm5lci5vbihcImNsaWNrXCIsIFwiYSBzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIiwgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gbi5wYXJlbnQoKS5kYXRhKFwib3JpZ2luYWxJbmRleFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB0LiRlbGVtZW50LnZhbCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHQuJGVsZW1lbnQucHJvcChcInNlbGVjdGVkSW5kZXhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0Lm11bHRpcGxlICYmIDEgIT09IHQub3B0aW9ucy5tYXhPcHRpb25zICYmIGkuc3RvcFByb3BhZ2F0aW9uKCksIGkucHJldmVudERlZmF1bHQoKSwgIXQuaXNEaXNhYmxlZCgpICYmICFuLnBhcmVudCgpLmhhc0NsYXNzKFwiZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gdC4kZWxlbWVudC5maW5kKFwib3B0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBkLmVxKG8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBoLnByb3AoXCJzZWxlY3RlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gaC5wYXJlbnQoXCJvcHRncm91cFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdC5vcHRpb25zLm1heE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHAuZGF0YShcIm1heE9wdGlvbnNcIikgfHwgITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoLnByb3AoXCJzZWxlY3RlZFwiLCAhYyksIHQuc2V0U2VsZWN0ZWQobywgIWMpLCBuLmJsdXIoKSwgdSAhPT0gITEgfHwgZiAhPT0gITEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB1IDwgZC5maWx0ZXIoXCI6c2VsZWN0ZWRcIikubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGYgPCBwLmZpbmQoXCJvcHRpb246c2VsZWN0ZWRcIikubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodSAmJiBtIHx8IGYgJiYgZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1ICYmIDEgPT0gdSkgZC5wcm9wKFwic2VsZWN0ZWRcIiwgITEpLCBoLnByb3AoXCJzZWxlY3RlZFwiLCAhMCksIHQuJG1lbnVJbm5lci5maW5kKFwiLnNlbGVjdGVkXCIpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWRcIiksIHQuc2V0U2VsZWN0ZWQobywgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZiAmJiAxID09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKS5wcm9wKFwic2VsZWN0ZWRcIiwgITEpLCBoLnByb3AoXCJzZWxlY3RlZFwiLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG4ucGFyZW50KCkuZGF0YShcIm9wdGdyb3VwXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC4kbWVudUlubmVyLmZpbmQoJ1tkYXRhLW9wdGdyb3VwPVwiJyArIGIgKyAnXCJdJykucmVtb3ZlQ2xhc3MoXCJzZWxlY3RlZFwiKSwgdC5zZXRTZWxlY3RlZChvLCAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0ID8gW3Qub3B0aW9ucy5tYXhPcHRpb25zVGV4dCwgdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0XSA6IHQub3B0aW9ucy5tYXhPcHRpb25zVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB2ID8gdih1LCBmKSA6IHYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICRbMF0ucmVwbGFjZShcIntufVwiLCB1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ID0gJFsxXS5yZXBsYWNlKFwie259XCIsIGYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBlKCc8ZGl2IGNsYXNzPVwibm90aWZ5XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkWzJdICYmICh4ID0geC5yZXBsYWNlKFwie3Zhcn1cIiwgJFsyXVt1ID4gMSA/IDAgOiAxXSksIHcgPSB3LnJlcGxhY2UoXCJ7dmFyfVwiLCAkWzJdW2YgPiAxID8gMCA6IDFdKSksIGgucHJvcChcInNlbGVjdGVkXCIsICExKSwgdC4kbWVudS5hcHBlbmQoeSksIHUgJiYgbSAmJiAoeS5hcHBlbmQoZShcIjxkaXY+XCIgKyB4ICsgXCI8L2Rpdj5cIikpLCByID0gITEsIHQuJGVsZW1lbnQudHJpZ2dlcihcIm1heFJlYWNoZWQuYnMuc2VsZWN0XCIpKSwgZiAmJiBnICYmICh5LmFwcGVuZChlKFwiPGRpdj5cIiArIHcgKyBcIjwvZGl2PlwiKSksIHIgPSAhMSwgdC4kZWxlbWVudC50cmlnZ2VyKFwibWF4UmVhY2hlZEdycC5icy5zZWxlY3RcIikpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc2V0U2VsZWN0ZWQobywgITEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMCksIHkuZGVsYXkoNzUwKS5mYWRlT3V0KDMwMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSh0aGlzKS5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBkLnByb3AoXCJzZWxlY3RlZFwiLCAhMSksIGgucHJvcChcInNlbGVjdGVkXCIsICEwKSwgdC4kbWVudUlubmVyLmZpbmQoXCIuc2VsZWN0ZWRcIikucmVtb3ZlQ2xhc3MoXCJzZWxlY3RlZFwiKS5maW5kKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLmF0dHIoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdC5zZXRTZWxlY3RlZChvLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAhdC5tdWx0aXBsZSB8fCB0Lm11bHRpcGxlICYmIDEgPT09IHQub3B0aW9ucy5tYXhPcHRpb25zID8gdC4kYnV0dG9uLmZvY3VzKCkgOiB0Lm9wdGlvbnMubGl2ZVNlYXJjaCAmJiB0LiRzZWFyY2hib3guZm9jdXMoKSwgciAmJiAoYSAhPSB0LiRlbGVtZW50LnZhbCgpICYmIHQubXVsdGlwbGUgfHwgbCAhPSB0LiRlbGVtZW50LnByb3AoXCJzZWxlY3RlZEluZGV4XCIpICYmICF0Lm11bHRpcGxlKSAmJiAocyA9IFtvLCBoLnByb3AoXCJzZWxlY3RlZFwiKSwgY10sIHQuJGVsZW1lbnQudHJpZ2dlck5hdGl2ZShcImNoYW5nZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRtZW51Lm9uKFwiY2xpY2tcIiwgXCJhLmRpc2FibGVkIHNwYW4uZHJvcGRvd24taXRlbS1pbm5lciAsIC5wb3BvdmVyLXRpdGxlLCAucG9wb3Zlci10aXRsZSA6bm90KC5jbG9zZSlcIiwgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICBpLmN1cnJlbnRUYXJnZXQgPT0gdGhpcyAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBpLnN0b3BQcm9wYWdhdGlvbigpLCB0Lm9wdGlvbnMubGl2ZVNlYXJjaCAmJiAhZShpLnRhcmdldCkuaGFzQ2xhc3MoXCJjbG9zZVwiKSA/IHQuJHNlYXJjaGJveC5mb2N1cygpIDogdC4kYnV0dG9uLmZvY3VzKCkpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuJG1lbnVJbm5lci5vbihcImNsaWNrXCIsIFwiLmRpdmlkZXIsIC5kcm9wZG93bi1oZWFkZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIHQub3B0aW9ucy5saXZlU2VhcmNoID8gdC4kc2VhcmNoYm94LmZvY3VzKCkgOiB0LiRidXR0b24uZm9jdXMoKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRtZW51Lm9uKFwiY2xpY2tcIiwgXCIucG9wb3Zlci10aXRsZSAuY2xvc2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHQuJGJ1dHRvbi5jbGljaygpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuJHNlYXJjaGJveC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRtZW51Lm9uKFwiY2xpY2tcIiwgXCIuYWN0aW9ucy1idG5cIiwgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICB0Lm9wdGlvbnMubGl2ZVNlYXJjaCA/IHQuJHNlYXJjaGJveC5mb2N1cygpIDogdC4kYnV0dG9uLmZvY3VzKCksIGkucHJldmVudERlZmF1bHQoKSwgaS5zdG9wUHJvcGFnYXRpb24oKSwgZSh0aGlzKS5oYXNDbGFzcyhcImJzLXNlbGVjdC1hbGxcIikgPyB0LnNlbGVjdEFsbCgpIDogdC5kZXNlbGVjdEFsbCgpXG4gICAgICAgICAgICAgICAgfSksIHRoaXMuJGVsZW1lbnQuY2hhbmdlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0LnJlbmRlcighMSksIHQuJGVsZW1lbnQudHJpZ2dlcihcImNoYW5nZWQuYnMuc2VsZWN0XCIsIHMpLCBzID0gbnVsbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGl2ZVNlYXJjaExpc3RlbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG4gPSBlKCc8bGkgY2xhc3M9XCJuby1yZXN1bHRzXCI+PC9saT4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRidXR0b24ub24oXCJjbGljay5kcm9wZG93bi5kYXRhLWFwaVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaS4kbWVudUlubmVyLmZpbmQoXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLCBpLiRzZWFyY2hib3gudmFsKCkgJiYgKGkuJHNlYXJjaGJveC52YWwoXCJcIiksIGkuJGxpcy5ub3QoXCIuaXMtaGlkZGVuXCIpLnJlbW92ZUNsYXNzKFwiaGlkZGVuXCIpLCBuLnBhcmVudCgpLmxlbmd0aCAmJiBuLnJlbW92ZSgpKSwgaS5tdWx0aXBsZSB8fCBpLiRtZW51SW5uZXIuZmluZChcIi5zZWxlY3RlZFwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKSwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuJHNlYXJjaGJveC5mb2N1cygpXG4gICAgICAgICAgICAgICAgICAgIH0sIDEwKVxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLiRzZWFyY2hib3gub24oXCJjbGljay5kcm9wZG93bi5kYXRhLWFwaSBmb2N1cy5kcm9wZG93bi5kYXRhLWFwaSB0b3VjaGVuZC5kcm9wZG93bi5kYXRhLWFwaVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy4kc2VhcmNoYm94Lm9uKFwiaW5wdXQgcHJvcGVydHljaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpLiRsaXMubm90KFwiLmlzLWhpZGRlblwiKS5yZW1vdmVDbGFzcyhcImhpZGRlblwiKSwgaS4kbGlzLmZpbHRlcihcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksIG4ucmVtb3ZlKCksIGkuJHNlYXJjaGJveC52YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMsIG8gPSBpLiRsaXMubm90KFwiLmlzLWhpZGRlbiwgLmRpdmlkZXIsIC5kcm9wZG93bi1oZWFkZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9IGkub3B0aW9ucy5saXZlU2VhcmNoTm9ybWFsaXplID8gby5ub3QoXCI6YVwiICsgaS5fc2VhcmNoU3R5bGUoKSArICcoXCInICsgdChpLiRzZWFyY2hib3gudmFsKCkpICsgJ1wiKScpIDogby5ub3QoXCI6XCIgKyBpLl9zZWFyY2hTdHlsZSgpICsgJyhcIicgKyBpLiRzZWFyY2hib3gudmFsKCkgKyAnXCIpJyksIHMubGVuZ3RoID09PSBvLmxlbmd0aCkgbi5odG1sKGkub3B0aW9ucy5ub25lUmVzdWx0c1RleHQucmVwbGFjZShcInswfVwiLCAnXCInICsgcihpLiRzZWFyY2hib3gudmFsKCkpICsgJ1wiJykpLCBpLiRtZW51SW5uZXIuYXBwZW5kKG4pLCBpLiRsaXMuYWRkQ2xhc3MoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmFkZENsYXNzKFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCBsID0gaS4kbGlzLm5vdChcIi5oaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbC5lYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmhhc0NsYXNzKFwiZGl2aWRlclwiKSA/IHZvaWQgMCA9PT0gYSA/IGkuYWRkQ2xhc3MoXCJoaWRkZW5cIikgOiAoYSAmJiBhLmFkZENsYXNzKFwiaGlkZGVuXCIpLCBhID0gaSkgOiBpLmhhc0NsYXNzKFwiZHJvcGRvd24taGVhZGVyXCIpICYmIGwuZXEodCArIDEpLmRhdGEoXCJvcHRncm91cFwiKSAhPT0gaS5kYXRhKFwib3B0Z3JvdXBcIikgPyBpLmFkZENsYXNzKFwiaGlkZGVuXCIpIDogYSA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgYSAmJiBhLmFkZENsYXNzKFwiaGlkZGVuXCIpLCBvLm5vdChcIi5oaWRkZW5cIikuZmlyc3QoKS5hZGRDbGFzcyhcImFjdGl2ZVwiKSwgaS4kbWVudUlubmVyLnNjcm9sbFRvcCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2VhcmNoU3R5bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbnM6IFwiaWJlZ2luc1wiLFxuICAgICAgICAgICAgICAgICAgICBzdGFydHNXaXRoOiBcImliZWdpbnNcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVbdGhpcy5vcHRpb25zLmxpdmVTZWFyY2hTdHlsZV0gfHwgXCJpY29udGFpbnNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlID8gKHRoaXMuJGVsZW1lbnQudmFsKGUpLCB0aGlzLnJlbmRlcigpLCB0aGlzLiRlbGVtZW50KSA6IHRoaXMuJGVsZW1lbnQudmFsKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFuZ2VBbGw6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBcInVuZGVmaW5lZFwiID09IHR5cGVvZiB0ICYmICh0ID0gITApLCB0aGlzLmZpbmRMaXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCJvcHRpb25cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy4kbGlzLm5vdChcIi5kaXZpZGVyLCAuZHJvcGRvd24taGVhZGVyLCAuZGlzYWJsZWQsIC5oaWRkZW5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5maWx0ZXIoXCIuc2VsZWN0ZWRcIikubGVuZ3RoID09PSBuLmxlbmd0aCkgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gbi5maWx0ZXIoXCIuc2VsZWN0ZWRcIikubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIG4udG9nZ2xlQ2xhc3MoXCJzZWxlY3RlZFwiLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IHMgPiBhOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gblthXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9yaWdpbmFsLWluZGV4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb1tvLmxlbmd0aF0gPSBpLmVxKGwpWzBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZShvKS5wcm9wKFwic2VsZWN0ZWRcIiwgdCksIHRoaXMucmVuZGVyKCExKSwgdGhpcy50b2dnbGVQbGFjZWhvbGRlcigpLCB0aGlzLiRlbGVtZW50LnRyaWdnZXJOYXRpdmUoXCJjaGFuZ2VcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VBbGwoITApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUFsbCghMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQsIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy4kYnV0dG9uLnRyaWdnZXIoXCJjbGlja1wiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleWRvd246IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbiwgcywgbywgYSA9IGUodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGwgPSBhLmlzKFwiaW5wdXRcIikgPyBhLnBhcmVudCgpLnBhcmVudCgpIDogYS5wYXJlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgciA9IGwuZGF0YShcInRoaXNcIiksXG4gICAgICAgICAgICAgICAgICAgIGQgPSBcIjpub3QoLmRpc2FibGVkLCAuaGlkZGVuLCAuZHJvcGRvd24taGVhZGVyLCAuZGl2aWRlcilcIixcbiAgICAgICAgICAgICAgICAgICAgaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMyOiBcIiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDQ4OiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDQ5OiBcIjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDUwOiBcIjJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDUxOiBcIjNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDUyOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDUzOiBcIjVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDU0OiBcIjZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDU1OiBcIjdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDU2OiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDU3OiBcIjlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDU5OiBcIjtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDY1OiBcImFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDY2OiBcImJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDY3OiBcImNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDY4OiBcImRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDY5OiBcImVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDcwOiBcImZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDcxOiBcImdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDcyOiBcImhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDczOiBcImlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDc0OiBcImpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDc1OiBcImtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDc2OiBcImxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDc3OiBcIm1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDc4OiBcIm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDc5OiBcIm9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDgwOiBcInBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDgxOiBcInFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDgyOiBcInJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDgzOiBcInNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDg0OiBcInRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDg1OiBcInVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDg2OiBcInZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDg3OiBcIndcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDg4OiBcInhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDg5OiBcInlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDkwOiBcInpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDk2OiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDk3OiBcIjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDk4OiBcIjJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDk5OiBcIjNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMDogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDE6IFwiNVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAyOiBcIjZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMzogXCI3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDQ6IFwiOFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTA1OiBcIjlcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvID0gci4kbmV3RWxlbWVudC5oYXNDbGFzcyhcIm9wZW5cIiksICFvICYmICh0LmtleUNvZGUgPj0gNDggJiYgdC5rZXlDb2RlIDw9IDU3IHx8IHQua2V5Q29kZSA+PSA5NiAmJiB0LmtleUNvZGUgPD0gMTA1IHx8IHQua2V5Q29kZSA+PSA2NSAmJiB0LmtleUNvZGUgPD0gOTApKSByZXR1cm4gci5vcHRpb25zLmNvbnRhaW5lciA/IHIuJGJ1dHRvbi50cmlnZ2VyKFwiY2xpY2tcIikgOiAoci5zZXRTaXplKCksIHIuJG1lbnUucGFyZW50KCkuYWRkQ2xhc3MoXCJvcGVuXCIpLCBvID0gITApLCB2b2lkIHIuJHNlYXJjaGJveC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGlmIChyLm9wdGlvbnMubGl2ZVNlYXJjaCAmJiAvKF45JHwyNykvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgJiYgbyAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpLCByLiRtZW51SW5uZXIuY2xpY2soKSwgci4kYnV0dG9uLmZvY3VzKCkpLCAvKDM4fDQwKS8udGVzdCh0LmtleUNvZGUudG9TdHJpbmcoMTApKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IHIuJGxpcy5maWx0ZXIoZCksICFpLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBuID0gci5vcHRpb25zLmxpdmVTZWFyY2ggPyBpLmluZGV4KGkuZmlsdGVyKFwiLmFjdGl2ZVwiKSkgOiBpLmluZGV4KGkuZmluZChcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKS5maWx0ZXIoXCI6Zm9jdXNcIikucGFyZW50KCkpLCBzID0gci4kbWVudUlubmVyLmRhdGEoXCJwcmV2SW5kZXhcIiksIDM4ID09IHQua2V5Q29kZSA/ICghci5vcHRpb25zLmxpdmVTZWFyY2ggJiYgbiAhPSBzIHx8IC0xID09IG4gfHwgbi0tLCAwID4gbiAmJiAobiArPSBpLmxlbmd0aCkpIDogNDAgPT0gdC5rZXlDb2RlICYmICgoci5vcHRpb25zLmxpdmVTZWFyY2ggfHwgbiA9PSBzKSAmJiBuKyssIG4gJT0gaS5sZW5ndGgpLCByLiRtZW51SW5uZXIuZGF0YShcInByZXZJbmRleFwiLCBuKSwgci5vcHRpb25zLmxpdmVTZWFyY2ggPyAodC5wcmV2ZW50RGVmYXVsdCgpLCBhLmhhc0NsYXNzKFwiZHJvcGRvd24tdG9nZ2xlXCIpIHx8IChpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLmVxKG4pLmFkZENsYXNzKFwiYWN0aXZlXCIpLmNoaWxkcmVuKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLmZvY3VzKCksIGEuZm9jdXMoKSkpIDogaS5lcShuKS5jaGlsZHJlbihcInNwYW4uZHJvcGRvd24taXRlbS1pbm5lclwiKS5mb2N1cygpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYS5pcyhcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjLCBwLCB1ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGkgPSByLiRsaXMuZmlsdGVyKGQpLCBpLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS50cmltKGUodGhpcykuY2hpbGRyZW4oXCJzcGFuLmRyb3Bkb3duLWl0ZW0taW5uZXJcIikudGV4dCgpLnRvTG93ZXJDYXNlKCkpLnN1YnN0cmluZygwLCAxKSA9PSBoW3Qua2V5Q29kZV0gJiYgdS5wdXNoKGkpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBjID0gZShkb2N1bWVudCkuZGF0YShcImtleWNvdW50XCIpLCBjKyssIGUoZG9jdW1lbnQpLmRhdGEoXCJrZXljb3VudFwiLCBjKSwgcCA9IGUudHJpbShlKFwiOmZvY3VzXCIpLnRleHQoKS50b0xvd2VyQ2FzZSgpKS5zdWJzdHJpbmcoMCwgMSksIHAgIT0gaFt0LmtleUNvZGVdID8gKGMgPSAxLCBlKGRvY3VtZW50KS5kYXRhKFwia2V5Y291bnRcIiwgYykpIDogYyA+PSB1Lmxlbmd0aCAmJiAoZShkb2N1bWVudCkuZGF0YShcImtleWNvdW50XCIsIDApLCBjID4gdS5sZW5ndGggJiYgKGMgPSAxKSksIGkuZXEodVtjIC0gMV0pLmNoaWxkcmVuKFwic3Bhbi5kcm9wZG93bi1pdGVtLWlubmVyXCIpLmZvY3VzKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgvKDEzfDMyKS8udGVzdCh0LmtleUNvZGUudG9TdHJpbmcoMTApKSB8fCAvKF45JCkvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgJiYgci5vcHRpb25zLnNlbGVjdE9uVGFiKSAmJiBvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvKDMyKS8udGVzdCh0LmtleUNvZGUudG9TdHJpbmcoMTApKSB8fCB0LnByZXZlbnREZWZhdWx0KCksIHIub3B0aW9ucy5saXZlU2VhcmNoKSAvKDMyKS8udGVzdCh0LmtleUNvZGUudG9TdHJpbmcoMTApKSB8fCAoci4kbWVudUlubmVyLmZpbmQoXCIuYWN0aXZlIGFcIikuY2xpY2soKSwgYS5mb2N1cygpKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGUoXCI6Zm9jdXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmNsaWNrKCksIGYuZm9jdXMoKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCBlKGRvY3VtZW50KS5kYXRhKFwic3BhY2VTZWxlY3RcIiwgITApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZShkb2N1bWVudCkuZGF0YShcImtleWNvdW50XCIsIDApXG4gICAgICAgICAgICAgICAgfSgvKF45JHwyNykvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgJiYgbyAmJiAoci5tdWx0aXBsZSB8fCByLm9wdGlvbnMubGl2ZVNlYXJjaCkgfHwgLygyNykvLnRlc3QodC5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgJiYgIW8pICYmIChyLiRtZW51LnBhcmVudCgpLnJlbW92ZUNsYXNzKFwib3BlblwiKSwgci5vcHRpb25zLmNvbnRhaW5lciAmJiByLiRuZXdFbGVtZW50LnJlbW92ZUNsYXNzKFwib3BlblwiKSwgci4kYnV0dG9uLmZvY3VzKCkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9iaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwibW9iaWxlLWRldmljZVwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGxpcyA9IG51bGwsIHRoaXMubGlPYmogPSB7fSwgdGhpcy5yZWxvYWRMaSgpLCB0aGlzLnJlbmRlcigpLCB0aGlzLmNoZWNrRGlzYWJsZWQoKSwgdGhpcy5saUhlaWdodCghMCksIHRoaXMuc2V0U3R5bGUoKSwgdGhpcy5zZXRXaWR0aCgpLCB0aGlzLiRsaXMgJiYgdGhpcy4kc2VhcmNoYm94LnRyaWdnZXIoXCJwcm9wZXJ0eWNoYW5nZVwiKSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwicmVmcmVzaGVkLmJzLnNlbGVjdFwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5ld0VsZW1lbnQuaGlkZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5zaG93KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5ld0VsZW1lbnQucmVtb3ZlKCksIHRoaXMuJGVsZW1lbnQucmVtb3ZlKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmJlZm9yZSh0aGlzLiRlbGVtZW50KS5yZW1vdmUoKSwgdGhpcy4kYnNDb250YWluZXIgPyB0aGlzLiRic0NvbnRhaW5lci5yZW1vdmUoKSA6IHRoaXMuJG1lbnUucmVtb3ZlKCksIHRoaXMuJGVsZW1lbnQub2ZmKFwiLmJzLnNlbGVjdFwiKS5yZW1vdmVEYXRhKFwic2VsZWN0cGlja2VyXCIpLnJlbW92ZUNsYXNzKFwiYnMtc2VsZWN0LWhpZGRlbiBzZWxlY3RwaWNrZXJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGMgPSBlLmZuLnNlbGVjdHBpY2tlcjtcbiAgICAgICAgZS5mbi5zZWxlY3RwaWNrZXIgPSBpLCBlLmZuLnNlbGVjdHBpY2tlci5Db25zdHJ1Y3RvciA9IGgsIGUuZm4uc2VsZWN0cGlja2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmZuLnNlbGVjdHBpY2tlciA9IGMsIHRoaXNcbiAgICAgICAgfSwgZShkb2N1bWVudCkuZGF0YShcImtleWNvdW50XCIsIDApLm9uKFwia2V5ZG93bi5icy5zZWxlY3RcIiwgJy5ib290c3RyYXAtc2VsZWN0IFtkYXRhLXRvZ2dsZT1kcm9wZG93bl0sIC5ib290c3RyYXAtc2VsZWN0IFtyb2xlPVwibGlzdGJveFwiXSwgLmJzLXNlYXJjaGJveCBpbnB1dCcsIGgucHJvdG90eXBlLmtleWRvd24pLm9uKFwiZm9jdXNpbi5tb2RhbFwiLCAnLmJvb3RzdHJhcC1zZWxlY3QgW2RhdGEtdG9nZ2xlPWRyb3Bkb3duXSwgLmJvb3RzdHJhcC1zZWxlY3QgW3JvbGU9XCJsaXN0Ym94XCJdLCAuYnMtc2VhcmNoYm94IGlucHV0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9KSwgZSh3aW5kb3cpLm9uKFwibG9hZC5icy5zZWxlY3QuZGF0YS1hcGlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlKFwiLnNlbGVjdHBpY2tlclwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpLmNhbGwodCwgdC5kYXRhKCkpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH0oZSlcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Zyb250ZW5kL2pzL3ZlbmRvci9ib290c3RyYXAtc2VsZWN0LmpzIiwiLyohXG4gKiBDaGFydC5qc1xuICogaHR0cDovL2NoYXJ0anMub3JnL1xuICogVmVyc2lvbjogMi43LjBcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNyBOaWNrIERvd25pZVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLkNoYXJ0ID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIE1JVCBsaWNlbnNlICovXG52YXIgY29sb3JOYW1lcyA9IHJlcXVpcmUoNik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgZ2V0UmdiYTogZ2V0UmdiYSxcbiAgIGdldEhzbGE6IGdldEhzbGEsXG4gICBnZXRSZ2I6IGdldFJnYixcbiAgIGdldEhzbDogZ2V0SHNsLFxuICAgZ2V0SHdiOiBnZXRId2IsXG4gICBnZXRBbHBoYTogZ2V0QWxwaGEsXG5cbiAgIGhleFN0cmluZzogaGV4U3RyaW5nLFxuICAgcmdiU3RyaW5nOiByZ2JTdHJpbmcsXG4gICByZ2JhU3RyaW5nOiByZ2JhU3RyaW5nLFxuICAgcGVyY2VudFN0cmluZzogcGVyY2VudFN0cmluZyxcbiAgIHBlcmNlbnRhU3RyaW5nOiBwZXJjZW50YVN0cmluZyxcbiAgIGhzbFN0cmluZzogaHNsU3RyaW5nLFxuICAgaHNsYVN0cmluZzogaHNsYVN0cmluZyxcbiAgIGh3YlN0cmluZzogaHdiU3RyaW5nLFxuICAga2V5d29yZDoga2V5d29yZFxufVxuXG5mdW5jdGlvbiBnZXRSZ2JhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBhYmJyID0gIC9eIyhbYS1mQS1GMC05XXszfSkkL2ksXG4gICAgICAgaGV4ID0gIC9eIyhbYS1mQS1GMC05XXs2fSkkL2ksXG4gICAgICAgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBwZXIgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAga2V5d29yZCA9IC8oXFx3KykvO1xuXG4gICB2YXIgcmdiID0gWzAsIDAsIDBdLFxuICAgICAgIGEgPSAxLFxuICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGhleCkpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICByZ2IgPSBjb2xvck5hbWVzW21hdGNoWzFdXTtcbiAgICAgIGlmICghcmdiKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9XG5cbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JbaV0gPSBzY2FsZShyZ2JbaV0sIDAsIDI1NSk7XG4gICB9XG4gICBpZiAoIWEgJiYgYSAhPSAwKSB7XG4gICAgICBhID0gMTtcbiAgIH1cbiAgIGVsc2Uge1xuICAgICAgYSA9IHNjYWxlKGEsIDAsIDEpO1xuICAgfVxuICAgcmdiWzNdID0gYTtcbiAgIHJldHVybiByZ2I7XG59XG5cbmZ1bmN0aW9uIGdldEhzbGEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGhzbCA9IC9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHMgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBsID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHMsIGwsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRId2Ioc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGh3YiA9IC9eaHdiXFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcbiAgIGlmIChtYXRjaCkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgdyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgdywgYiwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldFJnYihzdHJpbmcpIHtcbiAgIHZhciByZ2JhID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgcmV0dXJuIHJnYmEgJiYgcmdiYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsKHN0cmluZykge1xuICB2YXIgaHNsYSA9IGdldEhzbGEoc3RyaW5nKTtcbiAgcmV0dXJuIGhzbGEgJiYgaHNsYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxwaGEoc3RyaW5nKSB7XG4gICB2YXIgdmFscyA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIGlmICh2YWxzKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRIc2xhKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEh3YihzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbn1cblxuLy8gZ2VuZXJhdG9yc1xuZnVuY3Rpb24gaGV4U3RyaW5nKHJnYikge1xuICAgcmV0dXJuIFwiI1wiICsgaGV4RG91YmxlKHJnYlswXSkgKyBoZXhEb3VibGUocmdiWzFdKVxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JbMl0pO1xufVxuXG5mdW5jdGlvbiByZ2JTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2IoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl0gKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKHJnYmFbM10gIT09IHVuZGVmaW5lZCA/IHJnYmFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl1cbiAgICAgICAgICAgKyBcIiwgXCIgKyBhbHBoYSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50U3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcblxuICAgcmV0dXJuIFwicmdiKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUsIFwiICsgKGFscGhhIHx8IHJnYmFbM10gfHwgMSkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gaHNsU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChoc2xhWzNdICYmIGhzbGFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGhzbGFbM10gIT09IHVuZGVmaW5lZCA/IGhzbGFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbGEoXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlLCBcIlxuICAgICAgICAgICArIGFscGhhICsgXCIpXCI7XG59XG5cbi8vIGh3YiBpcyBhIGJpdCBkaWZmZXJlbnQgdGhhbiByZ2IoYSkgJiBoc2woYSkgc2luY2UgdGhlcmUgaXMgbm8gYWxwaGEgc3BlY2lmaWMgc3ludGF4XG4vLyAoaHdiIGhhdmUgYWxwaGEgb3B0aW9uYWwgJiAxIGlzIGRlZmF1bHQgdmFsdWUpXG5mdW5jdGlvbiBod2JTdHJpbmcoaHdiLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGh3YlszXSAhPT0gdW5kZWZpbmVkID8gaHdiWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJod2IoXCIgKyBod2JbMF0gKyBcIiwgXCIgKyBod2JbMV0gKyBcIiUsIFwiICsgaHdiWzJdICsgXCIlXCJcbiAgICAgICAgICAgKyAoYWxwaGEgIT09IHVuZGVmaW5lZCAmJiBhbHBoYSAhPT0gMSA/IFwiLCBcIiArIGFscGhhIDogXCJcIikgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24ga2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VOYW1lc1tyZ2Iuc2xpY2UoMCwgMyldO1xufVxuXG4vLyBoZWxwZXJzXG5mdW5jdGlvbiBzY2FsZShudW0sIG1pbiwgbWF4KSB7XG4gICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XG4gIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiAoc3RyLmxlbmd0aCA8IDIpID8gXCIwXCIgKyBzdHIgOiBzdHI7XG59XG5cblxuLy9jcmVhdGUgYSBsaXN0IG9mIHJldmVyc2UgY29sb3IgbmFtZXNcbnZhciByZXZlcnNlTmFtZXMgPSB7fTtcbmZvciAodmFyIG5hbWUgaW4gY29sb3JOYW1lcykge1xuICAgcmV2ZXJzZU5hbWVzW2NvbG9yTmFtZXNbbmFtZV1dID0gbmFtZTtcbn1cblxufSx7XCI2XCI6Nn1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb252ZXJ0ID0gcmVxdWlyZSg1KTtcbnZhciBzdHJpbmcgPSByZXF1aXJlKDIpO1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGlmIChvYmogaW5zdGFuY2VvZiBDb2xvcikge1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbG9yKSkge1xuXHRcdHJldHVybiBuZXcgQ29sb3Iob2JqKTtcblx0fVxuXG5cdHRoaXMudmFsaWQgPSBmYWxzZTtcblx0dGhpcy52YWx1ZXMgPSB7XG5cdFx0cmdiOiBbMCwgMCwgMF0sXG5cdFx0aHNsOiBbMCwgMCwgMF0sXG5cdFx0aHN2OiBbMCwgMCwgMF0sXG5cdFx0aHdiOiBbMCwgMCwgMF0sXG5cdFx0Y215azogWzAsIDAsIDAsIDBdLFxuXHRcdGFscGhhOiAxXG5cdH07XG5cblx0Ly8gcGFyc2UgQ29sb3IoKSBhcmd1bWVudFxuXHR2YXIgdmFscztcblx0aWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG5cdFx0dmFscyA9IHN0cmluZy5nZXRSZ2JhKG9iaik7XG5cdFx0aWYgKHZhbHMpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBzdHJpbmcuZ2V0SHNsYShvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gc3RyaW5nLmdldEh3YihvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgdmFscyk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG5cdFx0dmFscyA9IG9iajtcblx0XHRpZiAodmFscy5yICE9PSB1bmRlZmluZWQgfHwgdmFscy5yZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5sICE9PSB1bmRlZmluZWQgfHwgdmFscy5saWdodG5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy52ICE9PSB1bmRlZmluZWQgfHwgdmFscy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHN2JywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLncgIT09IHVuZGVmaW5lZCB8fCB2YWxzLndoaXRlbmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmMgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmN5YW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2NteWsnLCB2YWxzKTtcblx0XHR9XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbGlkO1xuXHR9LFxuXHRyZ2I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgncmdiJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHNsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzbCcsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzdjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc3YnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRod2I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHdiJywgYXJndW1lbnRzKTtcblx0fSxcblx0Y215azogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdjbXlrJywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRyZ2JBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5yZ2I7XG5cdH0sXG5cdGhzbEFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzbDtcblx0fSxcblx0aHN2QXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHN2O1xuXHR9LFxuXHRod2JBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWVzLmh3Yi5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVzLmh3Yjtcblx0fSxcblx0Y215a0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmNteWs7XG5cdH0sXG5cdHJnYmFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLnJnYi5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRoc2xhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5oc2wuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0YWxwaGE6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgdmFsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZWQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAwLCB2YWwpO1xuXHR9LFxuXHRncmVlbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsdWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAyLCB2YWwpO1xuXHR9LFxuXHRodWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAodmFsKSB7XG5cdFx0XHR2YWwgJT0gMzYwO1xuXHRcdFx0dmFsID0gdmFsIDwgMCA/IDM2MCArIHZhbCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMCwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDEsIHZhbCk7XG5cdH0sXG5cdGxpZ2h0bmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDIsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb252OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMSwgdmFsKTtcblx0fSxcblx0d2hpdGVuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHdiJywgMSwgdmFsKTtcblx0fSxcblx0YmxhY2tuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHdiJywgMiwgdmFsKTtcblx0fSxcblx0dmFsdWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAyLCB2YWwpO1xuXHR9LFxuXHRjeWFuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDAsIHZhbCk7XG5cdH0sXG5cdG1hZ2VudGE6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMSwgdmFsKTtcblx0fSxcblx0eWVsbG93OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDIsIHZhbCk7XG5cdH0sXG5cdGJsYWNrOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDMsIHZhbCk7XG5cdH0sXG5cblx0aGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5oZXhTdHJpbmcodGhpcy52YWx1ZXMucmdiKTtcblx0fSxcblx0cmdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZ2JTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHJnYmFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJnYmFTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHBlcmNlbnRTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnBlcmNlbnRTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcuaHNsU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5oc2xhU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRod2JTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLmh3YlN0cmluZyh0aGlzLnZhbHVlcy5od2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0a2V5d29yZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcua2V5d29yZCh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblxuXHRyZ2JOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHJldHVybiAocmdiWzBdIDw8IDE2KSB8IChyZ2JbMV0gPDwgOCkgfCByZ2JbMl07XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuMjEyNiAqIGx1bVswXSArIDAuNzE1MiAqIGx1bVsxXSArIDAuMDcyMiAqIGx1bVsyXTtcblx0fSxcblxuXHRjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHR2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuXHRcdHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0ZGFyazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3Rcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCByZ2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGxpZ2h0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdICs9IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRhcmtlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gLT0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdICs9IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdIC09IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdoaXRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMV0gKz0gaHdiWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YmxhY2tlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMl0gKz0gaHdiWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z3JleXNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgW3ZhbCwgdmFsLCB2YWxdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbGVhcmVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSAtIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3BhcXVlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgKyAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdHZhciBodWUgPSAoaHNsWzBdICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHNsWzBdID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXNzL2xpYnNhc3MvYmxvYi8wZTZiNGEyODUwMDkyMzU2YWEzZWNlMDdjNmIyNDlmMDIyMWNhY2VkL2Z1bmN0aW9ucy5jcHAjTDIwOVxuXHQgKi9cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0dmFyIGNvbG9yMSA9IHRoaXM7XG5cdFx0dmFyIGNvbG9yMiA9IG1peGluQ29sb3I7XG5cdFx0dmFyIHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdHZhciB3ID0gMiAqIHAgLSAxO1xuXHRcdHZhciBhID0gY29sb3IxLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuXHRcdHZhciB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdHZhciB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQucmdiKFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ncmVlbigpICsgdzIgKiBjb2xvcjIuZ3JlZW4oKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpXG5cdFx0XHQpXG5cdFx0XHQuYWxwaGEoY29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZ2IoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIE5PVEUoU0IpOiB1c2luZyBub2RlLWNsb25lIGNyZWF0ZXMgYSBkZXBlbmRlbmN5IHRvIEJ1ZmZlciB3aGVuIHVzaW5nIGJyb3dzZXJpZnksXG5cdFx0Ly8gbWFraW5nIHRoZSBmaW5hbCBidWlsZCB3YXkgdG8gYmlnIHRvIGVtYmVkIGluIENoYXJ0LmpzLiBTbyBsZXQncyBkbyBpdCBtYW51YWxseSxcblx0XHQvLyBhc3N1bWluZyB0aGF0IHZhbHVlcyB0byBjbG9uZSBhcmUgMSBkaW1lbnNpb24gYXJyYXlzIGNvbnRhaW5pbmcgb25seSBudW1iZXJzLFxuXHRcdC8vIGV4Y2VwdCAnYWxwaGEnIHdoaWNoIGlzIGEgbnVtYmVyLlxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29sb3IoKTtcblx0XHR2YXIgc291cmNlID0gdGhpcy52YWx1ZXM7XG5cdFx0dmFyIHRhcmdldCA9IHJlc3VsdC52YWx1ZXM7XG5cdFx0dmFyIHZhbHVlLCB0eXBlO1xuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcblx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cdFx0XHRcdHR5cGUgPSAoe30pLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlLnNsaWNlKDApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcigndW5leHBlY3RlZCBjb2xvciB2YWx1ZTonLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc3BhY2VzID0ge1xuXHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRoc3Y6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAndmFsdWUnXSxcblx0aHdiOiBbJ2h1ZScsICd3aGl0ZW5lc3MnLCAnYmxhY2tuZXNzJ10sXG5cdGNteWs6IFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjayddXG59O1xuXG5Db2xvci5wcm90b3R5cGUubWF4ZXMgPSB7XG5cdHJnYjogWzI1NSwgMjU1LCAyNTVdLFxuXHRoc2w6IFszNjAsIDEwMCwgMTAwXSxcblx0aHN2OiBbMzYwLCAxMDAsIDEwMF0sXG5cdGh3YjogWzM2MCwgMTAwLCAxMDBdLFxuXHRjbXlrOiBbMTAwLCAxMDAsIDEwMCwgMTAwXVxufTtcblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSkge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciB2YWxzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhbHNbc3BhY2UuY2hhckF0KGkpXSA9IHZhbHVlc1tzcGFjZV1baV07XG5cdH1cblxuXHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0dmFscy5hID0gdmFsdWVzLmFscGhhO1xuXHR9XG5cblx0Ly8ge3I6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDAuNH1cblx0cmV0dXJuIHZhbHM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlLCB2YWxzKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzO1xuXHR2YXIgbWF4ZXMgPSB0aGlzLm1heGVzO1xuXHR2YXIgYWxwaGEgPSAxO1xuXHR2YXIgaTtcblxuXHR0aGlzLnZhbGlkID0gdHJ1ZTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRhbHBoYSA9IHZhbHM7XG5cdH0gZWxzZSBpZiAodmFscy5sZW5ndGgpIHtcblx0XHQvLyBbMTAsIDEwLCAxMF1cblx0XHR2YWx1ZXNbc3BhY2VdID0gdmFscy5zbGljZSgwLCBzcGFjZS5sZW5ndGgpO1xuXHRcdGFscGhhID0gdmFsc1tzcGFjZS5sZW5ndGhdO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2UuY2hhckF0KDApXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3I6IDEwLCBnOiAxMCwgYjogMTB9XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tzcGFjZS5jaGFyQXQoaSldO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2VzW3NwYWNlXVswXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyZWQ6IDEwLCBncmVlbjogMTAsIGJsdWU6IDEwfVxuXHRcdHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW2NoYW5zW2ldXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYWxwaGE7XG5cdH1cblxuXHR2YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgPT09IHVuZGVmaW5lZCA/IHZhbHVlcy5hbHBoYSA6IGFscGhhKSkpO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjYXBwZWQ7XG5cblx0Ly8gY2FwIHZhbHVlcyBvZiB0aGUgc3BhY2UgcHJpb3IgY29udmVydGluZyBhbGwgdmFsdWVzXG5cdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NwYWNlXVtpXSwgdmFsdWVzW3NwYWNlXVtpXSkpO1xuXHRcdHZhbHVlc1tzcGFjZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG5cdH1cblxuXHQvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG5cdGZvciAodmFyIHNuYW1lIGluIHNwYWNlcykge1xuXHRcdGlmIChzbmFtZSAhPT0gc3BhY2UpIHtcblx0XHRcdHZhbHVlc1tzbmFtZV0gPSBjb252ZXJ0W3NwYWNlXVtzbmFtZV0odmFsdWVzW3NwYWNlXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0U3BhY2UgPSBmdW5jdGlvbiAoc3BhY2UsIGFyZ3MpIHtcblx0dmFyIHZhbHMgPSBhcmdzWzBdO1xuXG5cdGlmICh2YWxzID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZ2IoKVxuXHRcdHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG5cdH1cblxuXHQvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcblx0aWYgKHR5cGVvZiB2YWxzID09PSAnbnVtYmVyJykge1xuXHRcdHZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcblx0fVxuXG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWxzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0Q2hhbm5lbCA9IGZ1bmN0aW9uIChzcGFjZSwgaW5kZXgsIHZhbCkge1xuXHR2YXIgc3ZhbHVlcyA9IHRoaXMudmFsdWVzW3NwYWNlXTtcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmVkKClcblx0XHRyZXR1cm4gc3ZhbHVlc1tpbmRleF07XG5cdH0gZWxzZSBpZiAodmFsID09PSBzdmFsdWVzW2luZGV4XSkge1xuXHRcdC8vIGNvbG9yLnJlZChjb2xvci5yZWQoKSlcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGNvbG9yLnJlZCgxMDApXG5cdHN2YWx1ZXNbaW5kZXhdID0gdmFsO1xuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgc3ZhbHVlcyk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LkNvbG9yID0gQ29sb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG5cbn0se1wiMlwiOjIsXCI1XCI6NX1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogTUlUIGxpY2Vuc2UgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJnYjJoc2w6IHJnYjJoc2wsXG4gIHJnYjJoc3Y6IHJnYjJoc3YsXG4gIHJnYjJod2I6IHJnYjJod2IsXG4gIHJnYjJjbXlrOiByZ2IyY215ayxcbiAgcmdiMmtleXdvcmQ6IHJnYjJrZXl3b3JkLFxuICByZ2IyeHl6OiByZ2IyeHl6LFxuICByZ2IybGFiOiByZ2IybGFiLFxuICByZ2IybGNoOiByZ2IybGNoLFxuXG4gIGhzbDJyZ2I6IGhzbDJyZ2IsXG4gIGhzbDJoc3Y6IGhzbDJoc3YsXG4gIGhzbDJod2I6IGhzbDJod2IsXG4gIGhzbDJjbXlrOiBoc2wyY215ayxcbiAgaHNsMmtleXdvcmQ6IGhzbDJrZXl3b3JkLFxuXG4gIGhzdjJyZ2I6IGhzdjJyZ2IsXG4gIGhzdjJoc2w6IGhzdjJoc2wsXG4gIGhzdjJod2I6IGhzdjJod2IsXG4gIGhzdjJjbXlrOiBoc3YyY215ayxcbiAgaHN2MmtleXdvcmQ6IGhzdjJrZXl3b3JkLFxuXG4gIGh3YjJyZ2I6IGh3YjJyZ2IsXG4gIGh3YjJoc2w6IGh3YjJoc2wsXG4gIGh3YjJoc3Y6IGh3YjJoc3YsXG4gIGh3YjJjbXlrOiBod2IyY215ayxcbiAgaHdiMmtleXdvcmQ6IGh3YjJrZXl3b3JkLFxuXG4gIGNteWsycmdiOiBjbXlrMnJnYixcbiAgY215azJoc2w6IGNteWsyaHNsLFxuICBjbXlrMmhzdjogY215azJoc3YsXG4gIGNteWsyaHdiOiBjbXlrMmh3YixcbiAgY215azJrZXl3b3JkOiBjbXlrMmtleXdvcmQsXG5cbiAga2V5d29yZDJyZ2I6IGtleXdvcmQycmdiLFxuICBrZXl3b3JkMmhzbDoga2V5d29yZDJoc2wsXG4gIGtleXdvcmQyaHN2OiBrZXl3b3JkMmhzdixcbiAga2V5d29yZDJod2I6IGtleXdvcmQyaHdiLFxuICBrZXl3b3JkMmNteWs6IGtleXdvcmQyY215ayxcbiAga2V5d29yZDJsYWI6IGtleXdvcmQybGFiLFxuICBrZXl3b3JkMnh5ejoga2V5d29yZDJ4eXosXG5cbiAgeHl6MnJnYjogeHl6MnJnYixcbiAgeHl6MmxhYjogeHl6MmxhYixcbiAgeHl6MmxjaDogeHl6MmxjaCxcblxuICBsYWIyeHl6OiBsYWIyeHl6LFxuICBsYWIycmdiOiBsYWIycmdiLFxuICBsYWIybGNoOiBsYWIybGNoLFxuXG4gIGxjaDJsYWI6IGxjaDJsYWIsXG4gIGxjaDJ4eXo6IGxjaDJ4eXosXG4gIGxjaDJyZ2I6IGxjaDJyZ2Jcbn1cblxuXG5mdW5jdGlvbiByZ2IyaHNsKHJnYikge1xuICB2YXIgciA9IHJnYlswXS8yNTUsXG4gICAgICBnID0gcmdiWzFdLzI1NSxcbiAgICAgIGIgPSByZ2JbMl0vMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgbDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKS8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgbCA9IChtaW4gKyBtYXgpIC8gMjtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBzID0gMDtcbiAgZWxzZSBpZiAobCA8PSAwLjUpXG4gICAgcyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG4gIGVsc2VcbiAgICBzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cbiAgcmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmhzdihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgIGgsIHMsIHY7XG5cbiAgaWYgKG1heCA9PSAwKVxuICAgIHMgPSAwO1xuICBlbHNlXG4gICAgcyA9IChkZWx0YS9tYXggKiAxMDAwKS8xMDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgaWYgKGggPCAwKVxuICAgIGggKz0gMzYwO1xuXG4gIHYgPSAoKG1heCAvIDI1NSkgKiAxMDAwKSAvIDEwO1xuXG4gIHJldHVybiBbaCwgcywgdl07XG59XG5cbmZ1bmN0aW9uIHJnYjJod2IocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLFxuICAgICAgZyA9IHJnYlsxXSxcbiAgICAgIGIgPSByZ2JbMl0sXG4gICAgICBoID0gcmdiMmhzbChyZ2IpWzBdLFxuICAgICAgdyA9IDEvMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpLFxuICAgICAgYiA9IDEgLSAxLzI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuICByZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyY215ayhyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NSxcbiAgICAgIGMsIG0sIHksIGs7XG5cbiAgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuICBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICByZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2Iya2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShyZ2IpXTtcbn1cblxuZnVuY3Rpb24gcmdiMnh5eihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcbiAgZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG4gIGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG4gIHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuICB2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcbiAgdmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cbiAgcmV0dXJuIFt4ICogMTAwLCB5ICoxMDAsIHogKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IybGFiKHJnYikge1xuICB2YXIgeHl6ID0gcmdiMnh5eihyZ2IpLFxuICAgICAgICB4ID0geHl6WzBdLFxuICAgICAgICB5ID0geHl6WzFdLFxuICAgICAgICB6ID0geHl6WzJdLFxuICAgICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gcmdiMmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHJnYjJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wycmdiKGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSAvIDM2MCxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgdDEsIHQyLCB0MywgcmdiLCB2YWw7XG5cbiAgaWYgKHMgPT0gMCkge1xuICAgIHZhbCA9IGwgKiAyNTU7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIGlmIChsIDwgMC41KVxuICAgIHQyID0gbCAqICgxICsgcyk7XG4gIGVsc2VcbiAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gIHQxID0gMiAqIGwgLSB0MjtcblxuICByZ2IgPSBbMCwgMCwgMF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdDMgPSBoICsgMSAvIDMgKiAtIChpIC0gMSk7XG4gICAgdDMgPCAwICYmIHQzKys7XG4gICAgdDMgPiAxICYmIHQzLS07XG5cbiAgICBpZiAoNiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuICAgIGVsc2UgaWYgKDIgKiB0MyA8IDEpXG4gICAgICB2YWwgPSB0MjtcbiAgICBlbHNlIGlmICgzICogdDMgPCAyKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgIGVsc2VcbiAgICAgIHZhbCA9IHQxO1xuXG4gICAgcmdiW2ldID0gdmFsICogMjU1O1xuICB9XG5cbiAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gaHNsMmhzdihoc2wpIHtcbiAgdmFyIGggPSBoc2xbMF0sXG4gICAgICBzID0gaHNsWzFdIC8gMTAwLFxuICAgICAgbCA9IGhzbFsyXSAvIDEwMCxcbiAgICAgIHN2LCB2O1xuXG4gIGlmKGwgPT09IDApIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gZG8gY2FsYyBvbiBibGFja1xuICAgICAgLy8gYWxzbyBhdm9pZHMgZGl2aWRlIGJ5IDAgZXJyb3JcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICBsICo9IDI7XG4gIHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHYgPSAobCArIHMpIC8gMjtcbiAgc3YgPSAoMiAqIHMpIC8gKGwgKyBzKTtcbiAgcmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzbDJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHNsMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGhzbDJyZ2IoYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIGhzdjJyZ2IoaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdIC8gNjAsXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cbiAgdmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKSxcbiAgICAgIHAgPSAyNTUgKiB2ICogKDEgLSBzKSxcbiAgICAgIHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKSxcbiAgICAgIHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKSxcbiAgICAgIHYgPSAyNTUgKiB2O1xuXG4gIHN3aXRjaChoaSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBbdiwgdCwgcF07XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFtxLCB2LCBwXTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW3AsIHYsIHRdO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBbcCwgcSwgdl07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFt0LCBwLCB2XTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gW3YsIHAsIHFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhzdjJoc2woaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdLFxuICAgICAgcyA9IGhzdlsxXSAvIDEwMCxcbiAgICAgIHYgPSBoc3ZbMl0gLyAxMDAsXG4gICAgICBzbCwgbDtcblxuICBsID0gKDIgLSBzKSAqIHY7XG4gIHNsID0gcyAqIHY7XG4gIHNsIC89IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuICBzbCA9IHNsIHx8IDA7XG4gIGwgLz0gMjtcbiAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzdjJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc3YycmdiKGFyZ3MpKVxufVxuXG5mdW5jdGlvbiBoc3YyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc3YycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHN2MmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHN2MnJnYihhcmdzKSk7XG59XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuZnVuY3Rpb24gaHdiMnJnYihod2IpIHtcbiAgdmFyIGggPSBod2JbMF0gLyAzNjAsXG4gICAgICB3aCA9IGh3YlsxXSAvIDEwMCxcbiAgICAgIGJsID0gaHdiWzJdIC8gMTAwLFxuICAgICAgcmF0aW8gPSB3aCArIGJsLFxuICAgICAgaSwgdiwgZiwgbjtcblxuICAvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG4gIGlmIChyYXRpbyA+IDEpIHtcbiAgICB3aCAvPSByYXRpbztcbiAgICBibCAvPSByYXRpbztcbiAgfVxuXG4gIGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcbiAgdiA9IDEgLSBibDtcbiAgZiA9IDYgKiBoIC0gaTtcbiAgaWYgKChpICYgMHgwMSkgIT0gMCkge1xuICAgIGYgPSAxIC0gZjtcbiAgfVxuICBuID0gd2ggKyBmICogKHYgLSB3aCk7ICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG4gIHN3aXRjaCAoaSkge1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gaHdiMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2IyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2Iya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJyZ2IoY215aykge1xuICB2YXIgYyA9IGNteWtbMF0gLyAxMDAsXG4gICAgICBtID0gY215a1sxXSAvIDEwMCxcbiAgICAgIHkgPSBjbXlrWzJdIC8gMTAwLFxuICAgICAgayA9IGNteWtbM10gLyAxMDAsXG4gICAgICByLCBnLCBiO1xuXG4gIHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIGNteWsyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3YihjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChjbXlrMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24geHl6MnJnYih4eXopIHtcbiAgdmFyIHggPSB4eXpbMF0gLyAxMDAsXG4gICAgICB5ID0geHl6WzFdIC8gMTAwLFxuICAgICAgeiA9IHh5elsyXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuICBnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcbiAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgLy8gYXNzdW1lIHNSR0JcbiAgciA9IHIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IHIgPSAociAqIDEyLjkyKTtcblxuICBnID0gZyA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogZyA9IChnICogMTIuOTIpO1xuXG4gIGIgPSBiID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBiID0gKGIgKiAxMi45Mik7XG5cbiAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcbiAgZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcbiAgYiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiB4eXoybGFiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSxcbiAgICAgIHkgPSB4eXpbMV0sXG4gICAgICB6ID0geHl6WzJdLFxuICAgICAgbCwgYSwgYjtcblxuICB4IC89IDk1LjA0NztcbiAgeSAvPSAxMDA7XG4gIHogLz0gMTA4Ljg4MztcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMS8zKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEvMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxLzMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG4gIGwgPSAoMTE2ICogeSkgLSAxNjtcbiAgYSA9IDUwMCAqICh4IC0geSk7XG4gIGIgPSAyMDAgKiAoeSAtIHopO1xuXG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIHh5ejJsY2goYXJncykge1xuICByZXR1cm4gbGFiMmxjaCh4eXoybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eihsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIHgsIHksIHosIHkyO1xuXG4gIGlmIChsIDw9IDgpIHtcbiAgICB5ID0gKGwgKiAxMDApIC8gOTAzLjM7XG4gICAgeTIgPSAoNy43ODcgKiAoeSAvIDEwMCkpICsgKDE2IC8gMTE2KTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gMTAwICogTWF0aC5wb3coKGwgKyAxNikgLyAxMTYsIDMpO1xuICAgIHkyID0gTWF0aC5wb3coeSAvIDEwMCwgMS8zKTtcbiAgfVxuXG4gIHggPSB4IC8gOTUuMDQ3IDw9IDAuMDA4ODU2ID8geCA9ICg5NS4wNDcgKiAoKGEgLyA1MDApICsgeTIgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDk1LjA0NyAqIE1hdGgucG93KChhIC8gNTAwKSArIHkyLCAzKTtcblxuICB6ID0geiAvIDEwOC44ODMgPD0gMC4wMDg4NTkgPyB6ID0gKDEwOC44ODMgKiAoeTIgLSAoYiAvIDIwMCkgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDEwOC44ODMgKiBNYXRoLnBvdyh5MiAtIChiIC8gMjAwKSwgMyk7XG5cbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cblxuZnVuY3Rpb24gbGFiMmxjaChsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIGhyLCBoLCBjO1xuXG4gIGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMzYwO1xuICB9XG4gIGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gIHJldHVybiBbbCwgYywgaF07XG59XG5cbmZ1bmN0aW9uIGxhYjJyZ2IoYXJncykge1xuICByZXR1cm4geHl6MnJnYihsYWIyeHl6KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMmxhYihsY2gpIHtcbiAgdmFyIGwgPSBsY2hbMF0sXG4gICAgICBjID0gbGNoWzFdLFxuICAgICAgaCA9IGxjaFsyXSxcbiAgICAgIGEsIGIsIGhyO1xuXG4gIGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgYiA9IGMgKiBNYXRoLnNpbihocik7XG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIGxjaDJ4eXooYXJncykge1xuICByZXR1cm4gbGFiMnh5eihsY2gybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMnJnYihhcmdzKSB7XG4gIHJldHVybiBsYWIycmdiKGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMnJnYihrZXl3b3JkKSB7XG4gIHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3Yoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJsYWIoYXJncykge1xuICByZXR1cm4gcmdiMmxhYihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyeHl6KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJ4eXooa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG52YXIgY3NzS2V5d29yZHMgPSB7XG4gIGFsaWNlYmx1ZTogIFsyNDAsMjQ4LDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwyMzUsMjE1XSxcbiAgYXF1YTogWzAsMjU1LDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsMjU1LDIxMl0sXG4gIGF6dXJlOiAgWzI0MCwyNTUsMjU1XSxcbiAgYmVpZ2U6ICBbMjQ1LDI0NSwyMjBdLFxuICBiaXNxdWU6IFsyNTUsMjI4LDE5Nl0sXG4gIGJsYWNrOiAgWzAsMCwwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsMjM1LDIwNV0sXG4gIGJsdWU6IFswLDAsMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCw0MywyMjZdLFxuICBicm93bjogIFsxNjUsNDIsNDJdLFxuICBidXJseXdvb2Q6ICBbMjIyLDE4NCwxMzVdLFxuICBjYWRldGJsdWU6ICBbOTUsMTU4LDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsMjU1LDBdLFxuICBjaG9jb2xhdGU6ICBbMjEwLDEwNSwzMF0sXG4gIGNvcmFsOiAgWzI1NSwxMjcsODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwxNDksMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsMjQ4LDIyMF0sXG4gIGNyaW1zb246ICBbMjIwLDIwLDYwXSxcbiAgY3lhbjogWzAsMjU1LDI1NV0sXG4gIGRhcmtibHVlOiBbMCwwLDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwxMzksMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogIFsxODQsMTM0LDExXSxcbiAgZGFya2dyYXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtncmVlbjogIFswLDEwMCwwXSxcbiAgZGFya2dyZXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtraGFraTogIFsxODksMTgzLDEwN10sXG4gIGRhcmttYWdlbnRhOiAgWzEzOSwwLDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsMTA3LDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwxNDAsMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsNTAsMjA0XSxcbiAgZGFya3JlZDogIFsxMzksMCwwXSxcbiAgZGFya3NhbG1vbjogWzIzMywxNTAsMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLDE4OCwxNDNdLFxuICBkYXJrc2xhdGVibHVlOiAgWzcyLDYxLDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6ICBbNDcsNzksNzldLFxuICBkYXJrc2xhdGVncmV5OiAgWzQ3LDc5LDc5XSxcbiAgZGFya3R1cnF1b2lzZTogIFswLDIwNiwyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LDAsMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsMjAsMTQ3XSxcbiAgZGVlcHNreWJsdWU6ICBbMCwxOTEsMjU1XSxcbiAgZGltZ3JheTogIFsxMDUsMTA1LDEwNV0sXG4gIGRpbWdyZXk6ICBbMTA1LDEwNSwxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsMTQ0LDI1NV0sXG4gIGZpcmVicmljazogIFsxNzgsMzQsMzRdLFxuICBmbG9yYWx3aGl0ZTogIFsyNTUsMjUwLDI0MF0sXG4gIGZvcmVzdGdyZWVuOiAgWzM0LDEzOSwzNF0sXG4gIGZ1Y2hzaWE6ICBbMjU1LDAsMjU1XSxcbiAgZ2FpbnNib3JvOiAgWzIyMCwyMjAsMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwyNDgsMjU1XSxcbiAgZ29sZDogWzI1NSwyMTUsMF0sXG4gIGdvbGRlbnJvZDogIFsyMTgsMTY1LDMyXSxcbiAgZ3JheTogWzEyOCwxMjgsMTI4XSxcbiAgZ3JlZW46ICBbMCwxMjgsMF0sXG4gIGdyZWVueWVsbG93OiAgWzE3MywyNTUsNDddLFxuICBncmV5OiBbMTI4LDEyOCwxMjhdLFxuICBob25leWRldzogWzI0MCwyNTUsMjQwXSxcbiAgaG90cGluazogIFsyNTUsMTA1LDE4MF0sXG4gIGluZGlhbnJlZDogIFsyMDUsOTIsOTJdLFxuICBpbmRpZ286IFs3NSwwLDEzMF0sXG4gIGl2b3J5OiAgWzI1NSwyNTUsMjQwXSxcbiAga2hha2k6ICBbMjQwLDIzMCwxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwyMzAsMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogIFsyNTUsMjQwLDI0NV0sXG4gIGxhd25ncmVlbjogIFsxMjQsMjUyLDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsMjUwLDIwNV0sXG4gIGxpZ2h0Ymx1ZTogIFsxNzMsMjE2LDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsMTI4LDEyOF0sXG4gIGxpZ2h0Y3lhbjogIFsyMjQsMjU1LDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLDI1MCwyMTBdLFxuICBsaWdodGdyYXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LDIzOCwxNDRdLFxuICBsaWdodGdyZXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodHBpbms6ICBbMjU1LDE4MiwxOTNdLFxuICBsaWdodHNhbG1vbjogIFsyNTUsMTYwLDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46ICBbMzIsMTc4LDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwyMDYsMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LDEzNiwxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwxOTYsMjIyXSxcbiAgbGlnaHR5ZWxsb3c6ICBbMjU1LDI1NSwyMjRdLFxuICBsaW1lOiBbMCwyNTUsMF0sXG4gIGxpbWVncmVlbjogIFs1MCwyMDUsNTBdLFxuICBsaW5lbjogIFsyNTAsMjQwLDIzMF0sXG4gIG1hZ2VudGE6ICBbMjU1LDAsMjU1XSxcbiAgbWFyb29uOiBbMTI4LDAsMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsMjA1LDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLDAsMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LDg1LDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywxMTIsMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwxNzksMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiAgWzEyMywxMDQsMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46ICBbMCwyNTAsMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiAgWzcyLDIwOSwyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6ICBbMTk5LDIxLDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LDI1LDExMl0sXG4gIG1pbnRjcmVhbTogIFsyNDUsMjU1LDI1MF0sXG4gIG1pc3R5cm9zZTogIFsyNTUsMjI4LDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LDIyOCwxODFdLFxuICBuYXZham93aGl0ZTogIFsyNTUsMjIyLDE3M10sXG4gIG5hdnk6IFswLDAsMTI4XSxcbiAgb2xkbGFjZTogIFsyNTMsMjQ1LDIzMF0sXG4gIG9saXZlOiAgWzEyOCwxMjgsMF0sXG4gIG9saXZlZHJhYjogIFsxMDcsMTQyLDM1XSxcbiAgb3JhbmdlOiBbMjU1LDE2NSwwXSxcbiAgb3JhbmdlcmVkOiAgWzI1NSw2OSwwXSxcbiAgb3JjaGlkOiBbMjE4LDExMiwyMTRdLFxuICBwYWxlZ29sZGVucm9kOiAgWzIzOCwyMzIsMTcwXSxcbiAgcGFsZWdyZWVuOiAgWzE1MiwyNTEsMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogIFsxNzUsMjM4LDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6ICBbMjE5LDExMiwxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LDIzOSwyMTNdLFxuICBwZWFjaHB1ZmY6ICBbMjU1LDIxOCwxODVdLFxuICBwZXJ1OiBbMjA1LDEzMyw2M10sXG4gIHBpbms6IFsyNTUsMTkyLDIwM10sXG4gIHBsdW06IFsyMjEsMTYwLDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsMjI0LDIzMF0sXG4gIHB1cnBsZTogWzEyOCwwLDEyOF0sXG4gIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICByZWQ6ICBbMjU1LDAsMF0sXG4gIHJvc3licm93bjogIFsxODgsMTQzLDE0M10sXG4gIHJveWFsYmx1ZTogIFs2NSwxMDUsMjI1XSxcbiAgc2FkZGxlYnJvd246ICBbMTM5LDY5LDE5XSxcbiAgc2FsbW9uOiBbMjUwLDEyOCwxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LDE2NCw5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsMTM5LDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsMjQ1LDIzOF0sXG4gIHNpZW5uYTogWzE2MCw4Miw0NV0sXG4gIHNpbHZlcjogWzE5MiwxOTIsMTkyXSxcbiAgc2t5Ymx1ZTogIFsxMzUsMjA2LDIzNV0sXG4gIHNsYXRlYmx1ZTogIFsxMDYsOTAsMjA1XSxcbiAgc2xhdGVncmF5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc2xhdGVncmV5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc25vdzogWzI1NSwyNTAsMjUwXSxcbiAgc3ByaW5nZ3JlZW46ICBbMCwyNTUsMTI3XSxcbiAgc3RlZWxibHVlOiAgWzcwLDEzMCwxODBdLFxuICB0YW46ICBbMjEwLDE4MCwxNDBdLFxuICB0ZWFsOiBbMCwxMjgsMTI4XSxcbiAgdGhpc3RsZTogIFsyMTYsMTkxLDIxNl0sXG4gIHRvbWF0bzogWzI1NSw5OSw3MV0sXG4gIHR1cnF1b2lzZTogIFs2NCwyMjQsMjA4XSxcbiAgdmlvbGV0OiBbMjM4LDEzMCwyMzhdLFxuICB3aGVhdDogIFsyNDUsMjIyLDE3OV0sXG4gIHdoaXRlOiAgWzI1NSwyNTUsMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwyNDUsMjQ1XSxcbiAgeWVsbG93OiBbMjU1LDI1NSwwXSxcbiAgeWVsbG93Z3JlZW46ICBbMTU0LDIwNSw1MF1cbn07XG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjc3NLZXl3b3Jkcykge1xuICByZXZlcnNlS2V5d29yZHNbSlNPTi5zdHJpbmdpZnkoY3NzS2V5d29yZHNba2V5XSldID0ga2V5O1xufVxuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoNCk7XG5cbnZhciBjb252ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IENvbnZlcnRlcigpO1xufVxuXG5mb3IgKHZhciBmdW5jIGluIGNvbnZlcnNpb25zKSB7XG4gIC8vIGV4cG9ydCBSYXcgdmVyc2lvbnNcbiAgY29udmVydFtmdW5jICsgXCJSYXdcIl0gPSAgKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBhY2NlcHQgYXJyYXkgb3IgcGxhaW4gYXJnc1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICB9XG4gIH0pKGZ1bmMpO1xuXG4gIHZhciBwYWlyID0gLyhcXHcrKTIoXFx3KykvLmV4ZWMoZnVuYyksXG4gICAgICBmcm9tID0gcGFpclsxXSxcbiAgICAgIHRvID0gcGFpclsyXTtcblxuICAvLyBleHBvcnQgcmdiMmhzbCBhbmQgW1wicmdiXCJdW1wiaHNsXCJdXG4gIGNvbnZlcnRbZnJvbV0gPSBjb252ZXJ0W2Zyb21dIHx8IHt9O1xuXG4gIGNvbnZlcnRbZnJvbV1bdG9dID0gY29udmVydFtmdW5jXSA9IChmdW5jdGlvbihmdW5jKSB7IFxuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBcbiAgICAgIHZhciB2YWwgPSBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiB8fCB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHZhbDsgLy8ga2V5d29yZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgdmFsW2ldID0gTWF0aC5yb3VuZCh2YWxbaV0pO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pKGZ1bmMpO1xufVxuXG5cbi8qIENvbnZlcnRlciBkb2VzIGxhenkgY29udmVyc2lvbiBhbmQgY2FjaGluZyAqL1xudmFyIENvbnZlcnRlciA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5jb252cyA9IHt9O1xufTtcblxuLyogRWl0aGVyIGdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlIG9yXG4gIHNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBkZXBlbmRpbmcgb24gYXJncyAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5yb3V0ZVNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWx1ZXMgPSBhcmdzWzBdO1xuICAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjb2xvci5yZ2IoKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcbiAgIH1cbiAgIC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7ICAgICAgICBcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWx1ZXMpO1xufTtcbiAgXG4vKiBTZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgaW52YWxpZGF0aW5nIGNhY2hlICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWx1ZXMpIHtcbiAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgIHRoaXMuY29udnMgPSB7fTtcbiAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFsdWVzO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiBHZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZS4gSWYgdGhlcmUncyBhbHJlYWR5XG4gIGEgY29udmVyc2lvbiBmb3IgdGhlIHNwYWNlLCBmZXRjaCBpdCwgb3RoZXJ3aXNlXG4gIGNvbXB1dGUgaXQgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UpIHtcbiAgIHZhciB2YWxzID0gdGhpcy5jb252c1tzcGFjZV07XG4gICBpZiAoIXZhbHMpIHtcbiAgICAgIHZhciBmc3BhY2UgPSB0aGlzLnNwYWNlLFxuICAgICAgICAgIGZyb20gPSB0aGlzLmNvbnZzW2ZzcGFjZV07XG4gICAgICB2YWxzID0gY29udmVydFtmc3BhY2VdW3NwYWNlXShmcm9tKTtcblxuICAgICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWxzO1xuICAgfVxuICByZXR1cm4gdmFscztcbn07XG5cbltcInJnYlwiLCBcImhzbFwiLCBcImhzdlwiLCBcImNteWtcIiwgXCJrZXl3b3JkXCJdLmZvckVhY2goZnVuY3Rpb24oc3BhY2UpIHtcbiAgIENvbnZlcnRlci5wcm90b3R5cGVbc3BhY2VdID0gZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMucm91dGVTcGFjZShzcGFjZSwgYXJndW1lbnRzKTtcbiAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7XG59LHtcIjRcIjo0fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcblx0XCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcblx0XCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXG5cdFwiYmxhY2tcIjogWzAsIDAsIDBdLFxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxuXHRcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxuXHRcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxuXHRcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXG5cdFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcblx0XCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxuXHRcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcblx0XCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxuXHRcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcblx0XCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcblx0XCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxuXHRcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXG5cdFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcblx0XCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXG5cdFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXG5cdFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxuXHRcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcblx0XCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxuXHRcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxuXHRcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXG5cdFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxuXHRcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxuXHRcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXG5cdFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcblx0XCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcblx0XCJsaW1lXCI6IFswLCAyNTUsIDBdLFxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcblx0XCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxuXHRcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXG5cdFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxuXHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXG5cdFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcblx0XCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcblx0XCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcblx0XCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXG5cdFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcblx0XCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXG5cdFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXG5cdFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXG5cdFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcblx0XCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcblx0XCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcblx0XCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcblx0XCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXG5cdFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxuXHRcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcblx0XCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXG5cdFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cbn07XG5cbn0se31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKi9cbnZhciBDaGFydCA9IHJlcXVpcmUoMjkpKCk7XG5cbkNoYXJ0LmhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxucmVxdWlyZSgyNykoQ2hhcnQpO1xuXG5DaGFydC5kZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xuQ2hhcnQuRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xuQ2hhcnQuZWxlbWVudHMgPSByZXF1aXJlKDQwKTtcbkNoYXJ0LkludGVyYWN0aW9uID0gcmVxdWlyZSgyOCk7XG5DaGFydC5wbGF0Zm9ybSA9IHJlcXVpcmUoNDgpO1xuXG5yZXF1aXJlKDMxKShDaGFydCk7XG5yZXF1aXJlKDIyKShDaGFydCk7XG5yZXF1aXJlKDIzKShDaGFydCk7XG5yZXF1aXJlKDI0KShDaGFydCk7XG5yZXF1aXJlKDMwKShDaGFydCk7XG5yZXF1aXJlKDMzKShDaGFydCk7XG5yZXF1aXJlKDMyKShDaGFydCk7XG5yZXF1aXJlKDM1KShDaGFydCk7XG5cbnJlcXVpcmUoNTQpKENoYXJ0KTtcbnJlcXVpcmUoNTIpKENoYXJ0KTtcbnJlcXVpcmUoNTMpKENoYXJ0KTtcbnJlcXVpcmUoNTUpKENoYXJ0KTtcbnJlcXVpcmUoNTYpKENoYXJ0KTtcbnJlcXVpcmUoNTcpKENoYXJ0KTtcblxuLy8gQ29udHJvbGxlcnMgbXVzdCBiZSBsb2FkZWQgYWZ0ZXIgZWxlbWVudHNcbi8vIFNlZSBDaGFydC5jb3JlLmRhdGFzZXRDb250cm9sbGVyLmRhdGFFbGVtZW50VHlwZVxucmVxdWlyZSgxNSkoQ2hhcnQpO1xucmVxdWlyZSgxNikoQ2hhcnQpO1xucmVxdWlyZSgxNykoQ2hhcnQpO1xucmVxdWlyZSgxOCkoQ2hhcnQpO1xucmVxdWlyZSgxOSkoQ2hhcnQpO1xucmVxdWlyZSgyMCkoQ2hhcnQpO1xucmVxdWlyZSgyMSkoQ2hhcnQpO1xuXG5yZXF1aXJlKDgpKENoYXJ0KTtcbnJlcXVpcmUoOSkoQ2hhcnQpO1xucmVxdWlyZSgxMCkoQ2hhcnQpO1xucmVxdWlyZSgxMSkoQ2hhcnQpO1xucmVxdWlyZSgxMikoQ2hhcnQpO1xucmVxdWlyZSgxMykoQ2hhcnQpO1xucmVxdWlyZSgxNCkoQ2hhcnQpO1xuXG4vLyBMb2FkaW5nIGJ1aWx0LWl0IHBsdWdpbnNcbnZhciBwbHVnaW5zID0gW107XG5cbnBsdWdpbnMucHVzaChcblx0cmVxdWlyZSg0OSkoQ2hhcnQpLFxuXHRyZXF1aXJlKDUwKShDaGFydCksXG5cdHJlcXVpcmUoNTEpKENoYXJ0KVxuKTtcblxuQ2hhcnQucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zKTtcblxuQ2hhcnQucGxhdGZvcm0uaW5pdGlhbGl6ZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5DaGFydCA9IENoYXJ0O1xufVxuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmNhbnZhc0hlbHBlcnNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbkNoYXJ0LmNhbnZhc0hlbHBlcnMgPSBDaGFydC5oZWxwZXJzLmNhbnZhcztcblxufSx7XCIxMFwiOjEwLFwiMTFcIjoxMSxcIjEyXCI6MTIsXCIxM1wiOjEzLFwiMTRcIjoxNCxcIjE1XCI6MTUsXCIxNlwiOjE2LFwiMTdcIjoxNyxcIjE4XCI6MTgsXCIxOVwiOjE5LFwiMjBcIjoyMCxcIjIxXCI6MjEsXCIyMlwiOjIyLFwiMjNcIjoyMyxcIjI0XCI6MjQsXCIyNVwiOjI1LFwiMjZcIjoyNixcIjI3XCI6MjcsXCIyOFwiOjI4LFwiMjlcIjoyOSxcIjMwXCI6MzAsXCIzMVwiOjMxLFwiMzJcIjozMixcIjMzXCI6MzMsXCIzNVwiOjM1LFwiNDBcIjo0MCxcIjQ1XCI6NDUsXCI0OFwiOjQ4LFwiNDlcIjo0OSxcIjUwXCI6NTAsXCI1MVwiOjUxLFwiNTJcIjo1MixcIjUzXCI6NTMsXCI1NFwiOjU0LFwiNTVcIjo1NSxcIjU2XCI6NTYsXCI1N1wiOjU3LFwiOFwiOjgsXCI5XCI6OX1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuQmFyID0gZnVuY3Rpb24oY29udGV4dCwgY29uZmlnKSB7XG5cdFx0Y29uZmlnLnR5cGUgPSAnYmFyJztcblxuXHRcdHJldHVybiBuZXcgQ2hhcnQoY29udGV4dCwgY29uZmlnKTtcblx0fTtcblxufTtcblxufSx7fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5CdWJibGUgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdidWJibGUnO1xuXHRcdHJldHVybiBuZXcgQ2hhcnQoY29udGV4dCwgY29uZmlnKTtcblx0fTtcblxufTtcblxufSx7fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuRG91Z2hudXQgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdkb3VnaG51dCc7XG5cblx0XHRyZXR1cm4gbmV3IENoYXJ0KGNvbnRleHQsIGNvbmZpZyk7XG5cdH07XG5cbn07XG5cbn0se31dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LkxpbmUgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdsaW5lJztcblxuXHRcdHJldHVybiBuZXcgQ2hhcnQoY29udGV4dCwgY29uZmlnKTtcblx0fTtcblxufTtcblxufSx7fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuUG9sYXJBcmVhID0gZnVuY3Rpb24oY29udGV4dCwgY29uZmlnKSB7XG5cdFx0Y29uZmlnLnR5cGUgPSAncG9sYXJBcmVhJztcblxuXHRcdHJldHVybiBuZXcgQ2hhcnQoY29udGV4dCwgY29uZmlnKTtcblx0fTtcblxufTtcblxufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuUmFkYXIgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdyYWRhcic7XG5cblx0XHRyZXR1cm4gbmV3IENoYXJ0KGNvbnRleHQsIGNvbmZpZyk7XG5cdH07XG5cbn07XG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXHRDaGFydC5TY2F0dGVyID0gZnVuY3Rpb24oY29udGV4dCwgY29uZmlnKSB7XG5cdFx0Y29uZmlnLnR5cGUgPSAnc2NhdHRlcic7XG5cdFx0cmV0dXJuIG5ldyBDaGFydChjb250ZXh0LCBjb25maWcpO1xuXHR9O1xufTtcblxufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBlbGVtZW50cyA9IHJlcXVpcmUoNDApO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnYmFyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdsYWJlbCdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cblx0XHRcdC8vIFNwZWNpZmljIHRvIEJhciBDb250cm9sbGVyXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblxuXHRcdFx0Ly8gb2Zmc2V0IHNldHRpbmdzXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cblx0XHRcdC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuXHRcdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRcdG9mZnNldEdyaWRMaW5lczogdHJ1ZVxuXHRcdFx0fVxuXHRcdH1dLFxuXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJ1xuXHRcdH1dXG5cdH1cbn0pO1xuXG5kZWZhdWx0cy5fc2V0KCdob3Jpem9udGFsQmFyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdpbmRleCcsXG5cdFx0YXhpczogJ3knXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xuXHRcdH1dLFxuXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRcdFx0dHlwZTogJ2NhdGVnb3J5JyxcblxuXHRcdFx0Ly8gU3BlY2lmaWMgdG8gSG9yaXpvbnRhbCBCYXIgQ29udHJvbGxlclxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjksXG5cblx0XHRcdC8vIG9mZnNldCBzZXR0aW5nc1xuXHRcdFx0b2Zmc2V0OiB0cnVlLFxuXG5cdFx0XHQvLyBncmlkIGxpbmUgc2V0dGluZ3Ncblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XVxuXHR9LFxuXG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnbGVmdCdcblx0XHR9XG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdC8vIFBpY2sgZmlyc3QgeExhYmVsIGZvciBub3dcblx0XHRcdFx0dmFyIHRpdGxlID0gJyc7XG5cblx0XHRcdFx0aWYgKGl0ZW0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGlmIChpdGVtWzBdLnlMYWJlbCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBpdGVtWzBdLnlMYWJlbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCA+IDAgJiYgaXRlbVswXS5pbmRleCA8IGRhdGEubGFiZWxzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBkYXRhLmxhYmVsc1tpdGVtWzBdLmluZGV4XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGl0bGU7XG5cdFx0XHR9LFxuXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgZGF0YXNldExhYmVsID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cdFx0XHRcdHJldHVybiBkYXRhc2V0TGFiZWwgKyAnOiAnICsgaXRlbS54TGFiZWw7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLmJhciA9IENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0XHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlJlY3RhbmdsZSxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhO1xuXG5cdFx0XHRDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdFx0bWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdG1ldGEuc3RhY2sgPSBtZS5nZXREYXRhc2V0KCkuc3RhY2s7XG5cdFx0XHRtZXRhLmJhciA9IHRydWU7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcblx0XHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0XHRtZS5fcnVsZXIgPSBtZS5nZXRSdWxlcigpO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcmVjdHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocmVjdHNbaV0sIGksIHJlc2V0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgY3VzdG9tID0gcmVjdGFuZ2xlLmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciByZWN0YW5nbGVPcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5yZWN0YW5nbGU7XG5cblx0XHRcdHJlY3RhbmdsZS5feFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdFx0cmVjdGFuZ2xlLl95U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0XHRyZWN0YW5nbGUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0cmVjdGFuZ2xlLl9pbmRleCA9IGluZGV4O1xuXG5cdFx0XHRyZWN0YW5nbGUuX21vZGVsID0ge1xuXHRcdFx0XHRkYXRhc2V0TGFiZWw6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRcdGxhYmVsOiBjaGFydC5kYXRhLmxhYmVsc1tpbmRleF0sXG5cdFx0XHRcdGJvcmRlclNraXBwZWQ6IGN1c3RvbS5ib3JkZXJTa2lwcGVkID8gY3VzdG9tLmJvcmRlclNraXBwZWQgOiByZWN0YW5nbGVPcHRpb25zLmJvcmRlclNraXBwZWQsXG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmJhY2tncm91bmRDb2xvciwgaW5kZXgsIHJlY3RhbmdsZU9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSxcblx0XHRcdFx0Ym9yZGVyQ29sb3I6IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYm9yZGVyQ29sb3IsIGluZGV4LCByZWN0YW5nbGVPcHRpb25zLmJvcmRlckNvbG9yKSxcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYm9yZGVyV2lkdGgsIGluZGV4LCByZWN0YW5nbGVPcHRpb25zLmJvcmRlcldpZHRoKVxuXHRcdFx0fTtcblxuXHRcdFx0bWUudXBkYXRlRWxlbWVudEdlb21ldHJ5KHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KTtcblxuXHRcdFx0cmVjdGFuZ2xlLnBpdm90KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dXBkYXRlRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtb2RlbCA9IHJlY3RhbmdsZS5fbW9kZWw7XG5cdFx0XHR2YXIgdnNjYWxlID0gbWUuZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdFx0dmFyIGJhc2UgPSB2c2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdFx0XHR2YXIgaG9yaXpvbnRhbCA9IHZzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHZhciBydWxlciA9IG1lLl9ydWxlciB8fCBtZS5nZXRSdWxlcigpO1xuXHRcdFx0dmFyIHZwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhtZS5pbmRleCwgaW5kZXgpO1xuXHRcdFx0dmFyIGlwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhtZS5pbmRleCwgaW5kZXgsIHJ1bGVyKTtcblxuXHRcdFx0bW9kZWwuaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XG5cdFx0XHRtb2RlbC5iYXNlID0gcmVzZXQgPyBiYXNlIDogdnBpeGVscy5iYXNlO1xuXHRcdFx0bW9kZWwueCA9IGhvcml6b250YWwgPyByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcjtcblx0XHRcdG1vZGVsLnkgPSBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQ7XG5cdFx0XHRtb2RlbC5oZWlnaHQgPSBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogdW5kZWZpbmVkO1xuXHRcdFx0bW9kZWwud2lkdGggPSBob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRnZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0VmFsdWVTY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuZ2V0VmFsdWVTY2FsZUlkKCkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldEluZGV4U2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLmdldEluZGV4U2NhbGVJZCgpKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldFN0YWNrQ291bnQ6IGZ1bmN0aW9uKGxhc3QpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmdldEluZGV4U2NhbGUoKTtcblx0XHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdFx0dmFyIGlsZW4gPSBsYXN0ID09PSB1bmRlZmluZWQgPyBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCA6IGxhc3QgKyAxO1xuXHRcdFx0dmFyIHN0YWNrcyA9IFtdO1xuXHRcdFx0dmFyIGksIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAobWV0YS5iYXIgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJlxuXHRcdFx0XHRcdChzdGFja2VkID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdChzdGFja2VkID09PSB0cnVlICYmIHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSkgfHxcblx0XHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIChtZXRhLnN0YWNrID09PSB1bmRlZmluZWQgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSkpKSB7XG5cdFx0XHRcdFx0c3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0YWNrcy5sZW5ndGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0U3RhY2tJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTdGFja0NvdW50KGRhdGFzZXRJbmRleCkgLSAxO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldFJ1bGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc2NhbGUgPSBtZS5nZXRJbmRleFNjYWxlKCk7XG5cdFx0XHR2YXIgc3RhY2tDb3VudCA9IG1lLmdldFN0YWNrQ291bnQoKTtcblx0XHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRcdHZhciBwaXhlbHMgPSBbXTtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHZhciBzdGFydCA9IGlzSG9yaXpvbnRhbCA/IHNjYWxlLmxlZnQgOiBzY2FsZS50b3A7XG5cdFx0XHR2YXIgZW5kID0gc3RhcnQgKyAoaXNIb3Jpem9udGFsID8gc2NhbGUud2lkdGggOiBzY2FsZS5oZWlnaHQpO1xuXHRcdFx0dmFyIGksIGlsZW47XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS5nZXRNZXRhKCkuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBkYXRhc2V0SW5kZXgpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGl4ZWxzOiBwaXhlbHMsXG5cdFx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdFx0ZW5kOiBlbmQsXG5cdFx0XHRcdHN0YWNrQ291bnQ6IHN0YWNrQ291bnQsXG5cdFx0XHRcdHNjYWxlOiBzY2FsZVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTm90ZTogcGl4ZWwgdmFsdWVzIGFyZSBub3QgY2xhbXBlZCB0byB0aGUgc2NhbGUgYXJlYS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmdldFZhbHVlU2NhbGUoKTtcblx0XHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0XHR2YXIgdmFsdWUgPSBzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0XHR2YXIgc3RhY2sgPSBtZXRhLnN0YWNrO1xuXHRcdFx0dmFyIHN0YXJ0ID0gMDtcblx0XHRcdHZhciBpLCBpbWV0YSwgaXZhbHVlLCBiYXNlLCBoZWFkLCBzaXplO1xuXG5cdFx0XHRpZiAoc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIHN0YWNrICE9PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuXHRcdFx0XHRcdGltZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cblx0XHRcdFx0XHRpZiAoaW1ldGEuYmFyICYmXG5cdFx0XHRcdFx0XHRpbWV0YS5zdGFjayA9PT0gc3RhY2sgJiZcblx0XHRcdFx0XHRcdGltZXRhLmNvbnRyb2xsZXIuZ2V0VmFsdWVTY2FsZUlkKCkgPT09IHNjYWxlLmlkICYmXG5cdFx0XHRcdFx0XHRjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cblx0XHRcdFx0XHRcdGl2YWx1ZSA9IHNjYWxlLmdldFJpZ2h0VmFsdWUoZGF0YXNldHNbaV0uZGF0YVtpbmRleF0pO1xuXHRcdFx0XHRcdFx0aWYgKCh2YWx1ZSA8IDAgJiYgaXZhbHVlIDwgMCkgfHwgKHZhbHVlID49IDAgJiYgaXZhbHVlID4gMCkpIHtcblx0XHRcdFx0XHRcdFx0c3RhcnQgKz0gaXZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRiYXNlID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCk7XG5cdFx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIHZhbHVlKTtcblx0XHRcdHNpemUgPSAoaGVhZCAtIGJhc2UpIC8gMjtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0YmFzZTogYmFzZSxcblx0XHRcdFx0aGVhZDogaGVhZCxcblx0XHRcdFx0Y2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y2FsY3VsYXRlQmFySW5kZXhQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIHJ1bGVyKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBydWxlci5zY2FsZS5vcHRpb25zO1xuXHRcdFx0dmFyIHN0YWNrSW5kZXggPSBtZS5nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuXHRcdFx0dmFyIGJhc2UgPSBwaXhlbHNbaW5kZXhdO1xuXHRcdFx0dmFyIGxlbmd0aCA9IHBpeGVscy5sZW5ndGg7XG5cdFx0XHR2YXIgc3RhcnQgPSBydWxlci5zdGFydDtcblx0XHRcdHZhciBlbmQgPSBydWxlci5lbmQ7XG5cdFx0XHR2YXIgbGVmdFNhbXBsZVNpemUsIHJpZ2h0U2FtcGxlU2l6ZSwgbGVmdENhdGVnb3J5U2l6ZSwgcmlnaHRDYXRlZ29yeVNpemUsIGZ1bGxCYXJTaXplLCBzaXplO1xuXG5cdFx0XHRpZiAobGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGxlZnRTYW1wbGVTaXplID0gYmFzZSA+IHN0YXJ0ID8gYmFzZSAtIHN0YXJ0IDogZW5kIC0gYmFzZTtcblx0XHRcdFx0cmlnaHRTYW1wbGVTaXplID0gYmFzZSA8IGVuZCA/IGVuZCAtIGJhc2UgOiBiYXNlIC0gc3RhcnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0bGVmdFNhbXBsZVNpemUgPSAoYmFzZSAtIHBpeGVsc1tpbmRleCAtIDFdKSAvIDI7XG5cdFx0XHRcdFx0aWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRyaWdodFNhbXBsZVNpemUgPSBsZWZ0U2FtcGxlU2l6ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluZGV4IDwgbGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdHJpZ2h0U2FtcGxlU2l6ZSA9IChwaXhlbHNbaW5kZXggKyAxXSAtIGJhc2UpIC8gMjtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0XHRcdGxlZnRTYW1wbGVTaXplID0gcmlnaHRTYW1wbGVTaXplO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZWZ0Q2F0ZWdvcnlTaXplID0gbGVmdFNhbXBsZVNpemUgKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblx0XHRcdHJpZ2h0Q2F0ZWdvcnlTaXplID0gcmlnaHRTYW1wbGVTaXplICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cdFx0XHRmdWxsQmFyU2l6ZSA9IChsZWZ0Q2F0ZWdvcnlTaXplICsgcmlnaHRDYXRlZ29yeVNpemUpIC8gcnVsZXIuc3RhY2tDb3VudDtcblx0XHRcdHNpemUgPSBmdWxsQmFyU2l6ZSAqIG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcblxuXHRcdFx0c2l6ZSA9IE1hdGgubWluKFxuXHRcdFx0XHRoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuYmFyVGhpY2tuZXNzLCBzaXplKSxcblx0XHRcdFx0aGVscGVycy52YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpKTtcblxuXHRcdFx0YmFzZSAtPSBsZWZ0Q2F0ZWdvcnlTaXplO1xuXHRcdFx0YmFzZSArPSBmdWxsQmFyU2l6ZSAqIHN0YWNrSW5kZXg7XG5cdFx0XHRiYXNlICs9IChmdWxsQmFyU2l6ZSAtIHNpemUpIC8gMjtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0YmFzZTogYmFzZSxcblx0XHRcdFx0aGVhZDogYmFzZSArIHNpemUsXG5cdFx0XHRcdGNlbnRlcjogYmFzZSArIHNpemUgLyAyXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmdldFZhbHVlU2NhbGUoKTtcblx0XHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgaWxlbiA9IHJlY3RzLmxlbmd0aDtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0aGVscGVycy5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCBjaGFydC5jaGFydEFyZWEpO1xuXG5cdFx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpZiAoIWlzTmFOKHNjYWxlLmdldFJpZ2h0VmFsdWUoZGF0YXNldC5kYXRhW2ldKSkpIHtcblx0XHRcdFx0XHRyZWN0c1tpXS5kcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aGVscGVycy5jYW52YXMudW5jbGlwQXJlYShjaGFydC5jdHgpO1xuXHRcdH0sXG5cblx0XHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihyZWN0YW5nbGUpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3JlY3RhbmdsZS5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBpbmRleCA9IHJlY3RhbmdsZS5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gcmVjdGFuZ2xlLmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBtb2RlbCA9IHJlY3RhbmdsZS5fbW9kZWw7XG5cblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yID8gY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmhvdmVyQm9yZGVyQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGggPyBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgaW5kZXgsIG1vZGVsLmJvcmRlcldpZHRoKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24ocmVjdGFuZ2xlKSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tyZWN0YW5nbGUuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgaW5kZXggPSByZWN0YW5nbGUuX2luZGV4O1xuXHRcdFx0dmFyIGN1c3RvbSA9IHJlY3RhbmdsZS5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgbW9kZWwgPSByZWN0YW5nbGUuX21vZGVsO1xuXHRcdFx0dmFyIHJlY3RhbmdsZUVsZW1lbnRPcHRpb25zID0gdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnJlY3RhbmdsZTtcblxuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmJhY2tncm91bmRDb2xvciwgaW5kZXgsIHJlY3RhbmdsZUVsZW1lbnRPcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYm9yZGVyQ29sb3IsIGluZGV4LCByZWN0YW5nbGVFbGVtZW50T3B0aW9ucy5ib3JkZXJDb2xvcik7XG5cdFx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYm9yZGVyV2lkdGgsIGluZGV4LCByZWN0YW5nbGVFbGVtZW50T3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0fVxuXHR9KTtcblxuXHRDaGFydC5jb250cm9sbGVycy5ob3Jpem9udGFsQmFyID0gQ2hhcnQuY29udHJvbGxlcnMuYmFyLmV4dGVuZCh7XG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRnZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS55QXhpc0lEO1xuXHRcdH1cblx0fSk7XG59O1xuXG59LHtcIjI1XCI6MjUsXCI0MFwiOjQwLFwiNDVcIjo0NX1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgZWxlbWVudHMgPSByZXF1aXJlKDQwKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmRlZmF1bHRzLl9zZXQoJ2J1YmJsZScsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsIC8vIGJ1YmJsZSBzaG91bGQgcHJvYmFibHkgdXNlIGEgbGluZWFyIHNjYWxlIGJ5IGRlZmF1bHRcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJyxcblx0XHRcdGlkOiAneC1heGlzLTAnIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHRcdGlkOiAneS1heGlzLTAnXG5cdFx0fV1cblx0fSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaXRsZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2Ugd2UgZm9ybWF0IHRoZSBkYXRhIGFzIGEgcG9pbnRcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblx0XHRcdFx0dmFyIGRhdGFQb2ludCA9IGRhdGEuZGF0YXNldHNbaXRlbS5kYXRhc2V0SW5kZXhdLmRhdGFbaXRlbS5pbmRleF07XG5cdFx0XHRcdHJldHVybiBkYXRhc2V0TGFiZWwgKyAnOiAoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJywgJyArIGRhdGFQb2ludC5yICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLmJ1YmJsZSA9IENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YTtcblxuXHRcdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdFx0aGVscGVycy5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGluZGV4LCByZXNldCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgeFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXHRcdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YVtpbmRleF07XG5cdFx0XHR2YXIgZHNJbmRleCA9IG1lLmluZGV4O1xuXG5cdFx0XHR2YXIgeCA9IHJlc2V0ID8geFNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogeFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YSA6IE5hTiwgaW5kZXgsIGRzSW5kZXgpO1xuXHRcdFx0dmFyIHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGRhdGEsIGluZGV4LCBkc0luZGV4KTtcblxuXHRcdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XG5cdFx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcblx0XHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXHRcdFx0cG9pbnQuX21vZGVsID0ge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXG5cdFx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdFx0cmFkaXVzOiByZXNldCA/IDAgOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHksXG5cdFx0XHR9O1xuXG5cdFx0XHRwb2ludC5waXZvdCgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgaGVscGVycy5nZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBoZWxwZXJzLmdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaG92ZXJSYWRpdXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblxuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cdFx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0XHR2YXIgZGF0YXNldCA9IGRhdGFzZXRzW21lLmluZGV4XTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XG5cdFx0XHR2YXIgcmVzb2x2ZSA9IGhlbHBlcnMub3B0aW9ucy5yZXNvbHZlO1xuXHRcdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIga2V5cyA9IFtcblx0XHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRcdCdob3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0XHQnaG92ZXJSYWRpdXMnLFxuXHRcdFx0XHQnaGl0UmFkaXVzJyxcblx0XHRcdFx0J3BvaW50U3R5bGUnXG5cdFx0XHRdO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlKFtcblx0XHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG5cdFx0XHR2YWx1ZXMucmFkaXVzID0gcmVzb2x2ZShbXG5cdFx0XHRcdGN1c3RvbS5yYWRpdXMsXG5cdFx0XHRcdGRhdGEgPyBkYXRhLnIgOiB1bmRlZmluZWQsXG5cdFx0XHRcdGRhdGFzZXQucmFkaXVzLFxuXHRcdFx0XHRvcHRpb25zLnJhZGl1c1xuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdH1cblx0fSk7XG59O1xuXG59LHtcIjI1XCI6MjUsXCI0MFwiOjQwLFwiNDVcIjo0NX1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgZWxlbWVudHMgPSByZXF1aXJlKDQwKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmRlZmF1bHRzLl9zZXQoJ2RvdWdobnV0Jywge1xuXHRhbmltYXRpb246IHtcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcblx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxuXHRcdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgc2NhbGluZyB0aGUgRG91Z2hudXQgZnJvbSB0aGUgY2VudHJlXG5cdFx0YW5pbWF0ZVNjYWxlOiBmYWxzZVxuXHR9LFxuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdzaW5nbGUnXG5cdH0sXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgZHMgPSBkYXRhLmRhdGFzZXRzWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMgJiYgYXJjLmN1c3RvbSB8fCB7fTtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblx0XHRcdFx0XHRcdHZhciBhcmNPcHRzID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0XHRcdFx0XHR2YXIgZmlsbCA9IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uYmFja2dyb3VuZENvbG9yIDogdmFsdWVBdEluZGV4T3JEZWZhdWx0KGRzLmJhY2tncm91bmRDb2xvciwgaSwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3IpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IHZhbHVlQXRJbmRleE9yRGVmYXVsdChkcy5ib3JkZXJDb2xvciwgaSwgYXJjT3B0cy5ib3JkZXJDb2xvcik7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyV2lkdGgsIGksIGFyY09wdHMuYm9yZGVyV2lkdGgpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcblx0XHRcdFx0aWYgKG1ldGEuZGF0YVtpbmRleF0pIHtcblx0XHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuXHRjdXRvdXRQZXJjZW50YWdlOiA1MCxcblxuXHQvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuXHRyb3RhdGlvbjogTWF0aC5QSSAqIC0wLjUsXG5cblx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuXHRjaXJjdW1mZXJlbmNlOiBNYXRoLlBJICogMi4wLFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICc6ICcgKyBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cblx0XHRcdFx0aWYgKGhlbHBlcnMuaXNBcnJheShkYXRhTGFiZWwpKSB7XG5cdFx0XHRcdFx0Ly8gc2hvdyB2YWx1ZSBvbiBmaXJzdCBsaW5lIG9mIG11bHRpbGluZSBsYWJlbFxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gY2xvbmUgYmVjYXVzZSB3ZSBhcmUgY2hhbmdpbmcgdGhlIHZhbHVlXG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFMYWJlbCArPSB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhTGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuZGVmYXVsdHMuX3NldCgncGllJywgaGVscGVycy5jbG9uZShkZWZhdWx0cy5kb3VnaG51dCkpO1xuZGVmYXVsdHMuX3NldCgncGllJywge1xuXHRjdXRvdXRQZXJjZW50YWdlOiAwXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLmRvdWdobnV0ID0gQ2hhcnQuY29udHJvbGxlcnMucGllID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRcdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxuXG5cdFx0bGlua1NjYWxlczogaGVscGVycy5ub29wLFxuXG5cdFx0Ly8gR2V0IGluZGV4IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0XHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIHJpbmdJbmRleCA9IDA7XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YXNldEluZGV4OyArK2opIHtcblx0XHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShqKSkge1xuXHRcdFx0XHRcdCsrcmluZ0luZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByaW5nSW5kZXg7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0XHR2YXIgYXJjT3B0cyA9IG9wdHMuZWxlbWVudHMuYXJjO1xuXHRcdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQgLSBhcmNPcHRzLmJvcmRlcldpZHRoO1xuXHRcdFx0dmFyIGF2YWlsYWJsZUhlaWdodCA9IGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wIC0gYXJjT3B0cy5ib3JkZXJXaWR0aDtcblx0XHRcdHZhciBtaW5TaXplID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0ge3g6IDAsIHk6IDB9O1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgY3V0b3V0UGVyY2VudGFnZSA9IG9wdHMuY3V0b3V0UGVyY2VudGFnZTtcblx0XHRcdHZhciBjaXJjdW1mZXJlbmNlID0gb3B0cy5jaXJjdW1mZXJlbmNlO1xuXG5cdFx0XHQvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBtaW5TaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG5cdFx0XHRpZiAoY2lyY3VtZmVyZW5jZSA8IE1hdGguUEkgKiAyLjApIHtcblx0XHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyLjApO1xuXHRcdFx0XHRzdGFydEFuZ2xlICs9IE1hdGguUEkgKiAyLjAgKiAoc3RhcnRBbmdsZSA+PSBNYXRoLlBJID8gLTEgOiBzdGFydEFuZ2xlIDwgLU1hdGguUEkgPyAxIDogMCk7XG5cdFx0XHRcdHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuXHRcdFx0XHR2YXIgc3RhcnQgPSB7eDogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpfTtcblx0XHRcdFx0dmFyIGVuZCA9IHt4OiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IE1hdGguc2luKGVuZEFuZ2xlKX07XG5cdFx0XHRcdHZhciBjb250YWluczAgPSAoc3RhcnRBbmdsZSA8PSAwICYmIGVuZEFuZ2xlID49IDApIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAyLjAgJiYgTWF0aC5QSSAqIDIuMCA8PSBlbmRBbmdsZSk7XG5cdFx0XHRcdHZhciBjb250YWluczkwID0gKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDAuNSAmJiBNYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi41ICYmIE1hdGguUEkgKiAyLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0XHR2YXIgY29udGFpbnMxODAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAmJiAtTWF0aC5QSSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAmJiBNYXRoLlBJIDw9IGVuZEFuZ2xlKTtcblx0XHRcdFx0dmFyIGNvbnRhaW5zMjcwID0gKHN0YXJ0QW5nbGUgPD0gLU1hdGguUEkgKiAwLjUgJiYgLU1hdGguUEkgKiAwLjUgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAxLjUgJiYgTWF0aC5QSSAqIDEuNSA8PSBlbmRBbmdsZSk7XG5cdFx0XHRcdHZhciBjdXRvdXQgPSBjdXRvdXRQZXJjZW50YWdlIC8gMTAwLjA7XG5cdFx0XHRcdHZhciBtaW4gPSB7eDogY29udGFpbnMxODAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnggKiAoc3RhcnQueCA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPCAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczI3MCA/IC0xIDogTWF0aC5taW4oc3RhcnQueSAqIChzdGFydC55IDwgMCA/IDEgOiBjdXRvdXQpLCBlbmQueSAqIChlbmQueSA8IDAgPyAxIDogY3V0b3V0KSl9O1xuXHRcdFx0XHR2YXIgbWF4ID0ge3g6IGNvbnRhaW5zMCA/IDEgOiBNYXRoLm1heChzdGFydC54ICogKHN0YXJ0LnggPiAwID8gMSA6IGN1dG91dCksIGVuZC54ICogKGVuZC54ID4gMCA/IDEgOiBjdXRvdXQpKSwgeTogY29udGFpbnM5MCA/IDEgOiBNYXRoLm1heChzdGFydC55ICogKHN0YXJ0LnkgPiAwID8gMSA6IGN1dG91dCksIGVuZC55ICogKGVuZC55ID4gMCA/IDEgOiBjdXRvdXQpKX07XG5cdFx0XHRcdHZhciBzaXplID0ge3dpZHRoOiAobWF4LnggLSBtaW4ueCkgKiAwLjUsIGhlaWdodDogKG1heC55IC0gbWluLnkpICogMC41fTtcblx0XHRcdFx0bWluU2l6ZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoIC8gc2l6ZS53aWR0aCwgYXZhaWxhYmxlSGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHRcdFx0XHRvZmZzZXQgPSB7eDogKG1heC54ICsgbWluLngpICogLTAuNSwgeTogKG1heC55ICsgbWluLnkpICogLTAuNX07XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LmJvcmRlcldpZHRoID0gbWUuZ2V0TWF4Qm9yZGVyV2lkdGgobWV0YS5kYXRhKTtcblx0XHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgoKG1pblNpemUgLSBjaGFydC5ib3JkZXJXaWR0aCkgLyAyLCAwKTtcblx0XHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgoY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAoY3V0b3V0UGVyY2VudGFnZSkgOiAwLCAwKTtcblx0XHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblx0XHRcdGNoYXJ0Lm9mZnNldFggPSBvZmZzZXQueCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXHRcdFx0Y2hhcnQub2Zmc2V0WSA9IG9mZnNldC55ICogY2hhcnQub3V0ZXJSYWRpdXM7XG5cblx0XHRcdG1ldGEudG90YWwgPSBtZS5jYWxjdWxhdGVUb3RhbCgpO1xuXG5cdFx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gKGNoYXJ0LnJhZGl1c0xlbmd0aCAqIG1lLmdldFJpbmdJbmRleChtZS5pbmRleCkpO1xuXHRcdFx0bWUuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aCwgMCk7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGFyYywgaW5kZXgpIHtcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmMsIGluZGV4LCByZXNldCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdFx0dmFyIGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcblx0XHRcdHZhciBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcblx0XHRcdHZhciBlbmRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyAwIDogYXJjLmhpZGRlbiA/IDAgOiBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pICogKG9wdHMuY2lyY3VtZmVyZW5jZSAvICgyLjAgKiBNYXRoLlBJKSk7XG5cdFx0XHR2YXIgaW5uZXJSYWRpdXMgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBtZS5pbm5lclJhZGl1cztcblx0XHRcdHZhciBvdXRlclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLm91dGVyUmFkaXVzO1xuXHRcdFx0dmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChhcmMsIHtcblx0XHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdFx0X2luZGV4OiBpbmRleCxcblxuXHRcdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0XHR4OiBjZW50ZXJYICsgY2hhcnQub2Zmc2V0WCxcblx0XHRcdFx0XHR5OiBjZW50ZXJZICsgY2hhcnQub2Zmc2V0WSxcblx0XHRcdFx0XHRzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZSxcblx0XHRcdFx0XHRjaXJjdW1mZXJlbmNlOiBjaXJjdW1mZXJlbmNlLFxuXHRcdFx0XHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcblx0XHRcdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRcdFx0bGFiZWw6IHZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmxhYmVsLCBpbmRleCwgY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdKVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblx0XHRcdC8vIFJlc2V0cyB0aGUgdmlzdWFsIHN0eWxlc1xuXHRcdFx0dGhpcy5yZW1vdmVIb3ZlclN0eWxlKGFyYyk7XG5cblx0XHRcdC8vIFNldCBjb3JyZWN0IGFuZ2xlcyBpZiBub3QgcmVzZXR0aW5nXG5cdFx0XHRpZiAoIXJlc2V0IHx8ICFhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcblx0XHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG1lLmdldE1ldGEoKS5kYXRhW2luZGV4IC0gMV0uX21vZGVsLmVuZEFuZ2xlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bW9kZWwuZW5kQW5nbGUgPSBtb2RlbC5zdGFydEFuZ2xlICsgbW9kZWwuY2lyY3VtZmVyZW5jZTtcblx0XHRcdH1cblxuXHRcdFx0YXJjLnBpdm90KCk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xuXHRcdFx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUhvdmVyU3R5bGUuY2FsbCh0aGlzLCBhcmMsIHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmMpO1xuXHRcdH0sXG5cblx0XHRjYWxjdWxhdGVUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0XHR2YXIgdmFsdWU7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0XHRcdHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHRcdFx0aWYgKCFpc05hTih2YWx1ZSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdFx0dG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0LyogaWYgKHRvdGFsID09PSAwKSB7XG5cdFx0XHRcdHRvdGFsID0gTmFOO1xuXHRcdFx0fSovXG5cblx0XHRcdHJldHVybiB0b3RhbDtcblx0XHR9LFxuXG5cdFx0Y2FsY3VsYXRlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciB0b3RhbCA9IHRoaXMuZ2V0TWV0YSgpLnRvdGFsO1xuXHRcdFx0aWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiAoTWF0aC5QSSAqIDIuMCkgKiAodmFsdWUgLyB0b3RhbCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9LFxuXG5cdFx0Ly8gZ2V0cyB0aGUgbWF4IGJvcmRlciBvciBob3ZlciB3aWR0aCB0byBwcm9wZXJseSBzY2FsZSBwaWUgY2hhcnRzXG5cdFx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcblx0XHRcdHZhciBtYXggPSAwO1xuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRcdHZhciBsZW5ndGggPSBhcmNzLmxlbmd0aDtcblx0XHRcdHZhciBib3JkZXJXaWR0aDtcblx0XHRcdHZhciBob3ZlcldpZHRoO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gYXJjc1tpXS5fbW9kZWwgPyBhcmNzW2ldLl9tb2RlbC5ib3JkZXJXaWR0aCA6IDA7XG5cdFx0XHRcdGhvdmVyV2lkdGggPSBhcmNzW2ldLl9jaGFydCA/IGFyY3NbaV0uX2NoYXJ0LmNvbmZpZy5kYXRhLmRhdGFzZXRzW2luZGV4XS5ob3ZlckJvcmRlcldpZHRoIDogMDtcblxuXHRcdFx0XHRtYXggPSBib3JkZXJXaWR0aCA+IG1heCA/IGJvcmRlcldpZHRoIDogbWF4O1xuXHRcdFx0XHRtYXggPSBob3ZlcldpZHRoID4gbWF4ID8gaG92ZXJXaWR0aCA6IG1heDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXg7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjQwXCI6NDAsXCI0NVwiOjQ1fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBlbGVtZW50cyA9IHJlcXVpcmUoNDApO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnbGluZScsIHtcblx0c2hvd0xpbmVzOiB0cnVlLFxuXHRzcGFuR2FwczogZmFsc2UsXG5cblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdGZ1bmN0aW9uIGxpbmVFbmFibGVkKGRhdGFzZXQsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gaGVscGVycy52YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnNob3dMaW5lLCBvcHRpb25zLnNob3dMaW5lcyk7XG5cdH1cblxuXHRDaGFydC5jb250cm9sbGVycy5saW5lID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRcdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcblxuXHRcdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcblx0XHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XG5cdFx0XHR2YXIgbGluZUVsZW1lbnRPcHRpb25zID0gb3B0aW9ucy5lbGVtZW50cy5saW5lO1xuXHRcdFx0dmFyIHNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdFx0dmFyIGksIGlsZW4sIGN1c3RvbTtcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIHNob3dMaW5lID0gbGluZUVuYWJsZWQoZGF0YXNldCwgb3B0aW9ucyk7XG5cblx0XHRcdC8vIFVwZGF0ZSBMaW5lXG5cdFx0XHRpZiAoc2hvd0xpbmUpIHtcblx0XHRcdFx0Y3VzdG9tID0gbGluZS5jdXN0b20gfHwge307XG5cblx0XHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0XHRpZiAoKGRhdGFzZXQudGVuc2lvbiAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5saW5lVGVuc2lvbiA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRcdGRhdGFzZXQubGluZVRlbnNpb24gPSBkYXRhc2V0LnRlbnNpb247XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRcdGxpbmUuX3NjYWxlID0gc2NhbGU7XG5cdFx0XHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0XHQvLyBEYXRhXG5cdFx0XHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xuXHRcdFx0XHQvLyBNb2RlbFxuXHRcdFx0XHRsaW5lLl9tb2RlbCA9IHtcblx0XHRcdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRcdFx0Ly8gVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgbGluZXMgaXMgdG8gYnJlYWsgYXQgbnVsbCB2YWx1ZXMsIGFjY29yZGluZ1xuXHRcdFx0XHRcdC8vIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDM1I2lzc3VlY29tbWVudC0yMTY3MTgxNThcblx0XHRcdFx0XHQvLyBUaGlzIG9wdGlvbiBnaXZlcyBsaW5lcyB0aGUgYWJpbGl0eSB0byBzcGFuIGdhcHNcblx0XHRcdFx0XHRzcGFuR2FwczogZGF0YXNldC5zcGFuR2FwcyA/IGRhdGFzZXQuc3BhbkdhcHMgOiBvcHRpb25zLnNwYW5HYXBzLFxuXHRcdFx0XHRcdHRlbnNpb246IGN1c3RvbS50ZW5zaW9uID8gY3VzdG9tLnRlbnNpb24gOiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGRhdGFzZXQubGluZVRlbnNpb24sIGxpbmVFbGVtZW50T3B0aW9ucy50ZW5zaW9uKSxcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uYmFja2dyb3VuZENvbG9yIDogKGRhdGFzZXQuYmFja2dyb3VuZENvbG9yIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpLFxuXHRcdFx0XHRcdGJvcmRlcldpZHRoOiBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiAoZGF0YXNldC5ib3JkZXJXaWR0aCB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyV2lkdGgpLFxuXHRcdFx0XHRcdGJvcmRlckNvbG9yOiBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiAoZGF0YXNldC5ib3JkZXJDb2xvciB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyQ29sb3IpLFxuXHRcdFx0XHRcdGJvcmRlckNhcFN0eWxlOiBjdXN0b20uYm9yZGVyQ2FwU3R5bGUgPyBjdXN0b20uYm9yZGVyQ2FwU3R5bGUgOiAoZGF0YXNldC5ib3JkZXJDYXBTdHlsZSB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpLFxuXHRcdFx0XHRcdGJvcmRlckRhc2g6IGN1c3RvbS5ib3JkZXJEYXNoID8gY3VzdG9tLmJvcmRlckRhc2ggOiAoZGF0YXNldC5ib3JkZXJEYXNoIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJEYXNoKSxcblx0XHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0OiBjdXN0b20uYm9yZGVyRGFzaE9mZnNldCA/IGN1c3RvbS5ib3JkZXJEYXNoT2Zmc2V0IDogKGRhdGFzZXQuYm9yZGVyRGFzaE9mZnNldCB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCksXG5cdFx0XHRcdFx0Ym9yZGVySm9pblN0eWxlOiBjdXN0b20uYm9yZGVySm9pblN0eWxlID8gY3VzdG9tLmJvcmRlckpvaW5TdHlsZSA6IChkYXRhc2V0LmJvcmRlckpvaW5TdHlsZSB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVySm9pblN0eWxlKSxcblx0XHRcdFx0XHRmaWxsOiBjdXN0b20uZmlsbCA/IGN1c3RvbS5maWxsIDogKGRhdGFzZXQuZmlsbCAhPT0gdW5kZWZpbmVkID8gZGF0YXNldC5maWxsIDogbGluZUVsZW1lbnRPcHRpb25zLmZpbGwpLFxuXHRcdFx0XHRcdHN0ZXBwZWRMaW5lOiBjdXN0b20uc3RlcHBlZExpbmUgPyBjdXN0b20uc3RlcHBlZExpbmUgOiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuc3RlcHBlZExpbmUsIGxpbmVFbGVtZW50T3B0aW9ucy5zdGVwcGVkKSxcblx0XHRcdFx0XHRjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBjdXN0b20uY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA/IGN1c3RvbS5jdWJpY0ludGVycG9sYXRpb25Nb2RlIDogaGVscGVycy52YWx1ZU9yRGVmYXVsdChkYXRhc2V0LmN1YmljSW50ZXJwb2xhdGlvbk1vZGUsIGxpbmVFbGVtZW50T3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlKSxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRsaW5lLnBpdm90KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSBQb2ludHNcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzaG93TGluZSAmJiBsaW5lLl9tb2RlbC50ZW5zaW9uICE9PSAwKSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRwb2ludHNbaV0ucGl2b3QoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0UG9pbnRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuXHRcdFx0dmFyIGJhY2tncm91bmRDb2xvciA9IHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblxuXHRcdFx0aWYgKGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yID0gY3VzdG9tLmJhY2tncm91bmRDb2xvcjtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YXNldC5wb2ludEJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50QmFja2dyb3VuZENvbG9yLCBpbmRleCwgYmFja2dyb3VuZENvbG9yKTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yID0gZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBiYWNrZ3JvdW5kQ29sb3I7XG5cdFx0fSxcblxuXHRcdGdldFBvaW50Qm9yZGVyQ29sb3I6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuXHRcdFx0dmFyIGJvcmRlckNvbG9yID0gdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LmJvcmRlckNvbG9yO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cblx0XHRcdGlmIChjdXN0b20uYm9yZGVyQ29sb3IpIHtcblx0XHRcdFx0Ym9yZGVyQ29sb3IgPSBjdXN0b20uYm9yZGVyQ29sb3I7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGFzZXQucG9pbnRCb3JkZXJDb2xvcikge1xuXHRcdFx0XHRib3JkZXJDb2xvciA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCb3JkZXJDb2xvciwgaW5kZXgsIGJvcmRlckNvbG9yKTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YXNldC5ib3JkZXJDb2xvcikge1xuXHRcdFx0XHRib3JkZXJDb2xvciA9IGRhdGFzZXQuYm9yZGVyQ29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBib3JkZXJDb2xvcjtcblx0XHR9LFxuXG5cdFx0Z2V0UG9pbnRCb3JkZXJXaWR0aDogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHR2YXIgYm9yZGVyV2lkdGggPSB0aGlzLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQuYm9yZGVyV2lkdGg7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblxuXHRcdFx0aWYgKCFpc05hTihjdXN0b20uYm9yZGVyV2lkdGgpKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gY3VzdG9tLmJvcmRlcldpZHRoO1xuXHRcdFx0fSBlbHNlIGlmICghaXNOYU4oZGF0YXNldC5wb2ludEJvcmRlcldpZHRoKSB8fCBoZWxwZXJzLmlzQXJyYXkoZGF0YXNldC5wb2ludEJvcmRlcldpZHRoKSkge1xuXHRcdFx0XHRib3JkZXJXaWR0aCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCb3JkZXJXaWR0aCwgaW5kZXgsIGJvcmRlcldpZHRoKTtcblx0XHRcdH0gZWxzZSBpZiAoIWlzTmFOKGRhdGFzZXQuYm9yZGVyV2lkdGgpKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gZGF0YXNldC5ib3JkZXJXaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJvcmRlcldpZHRoO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0XHR2YXIgdmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0XHR2YXIgcG9pbnRPcHRpb25zID0gbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHRcdHZhciB4LCB5O1xuXG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQucmFkaXVzICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LnBvaW50UmFkaXVzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQucG9pbnRSYWRpdXMgPSBkYXRhc2V0LnJhZGl1cztcblx0XHRcdH1cblx0XHRcdGlmICgoZGF0YXNldC5oaXRSYWRpdXMgIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQucG9pbnRIaXRSYWRpdXMgPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5wb2ludEhpdFJhZGl1cyA9IGRhdGFzZXQuaGl0UmFkaXVzO1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0geFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlIDogTmFOLCBpbmRleCwgZGF0YXNldEluZGV4KTtcblx0XHRcdHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IG1lLmNhbGN1bGF0ZVBvaW50WSh2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdHBvaW50Ll94U2NhbGUgPSB4U2NhbGU7XG5cdFx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdFx0cG9pbnQuX2RhdGFzZXRJbmRleCA9IGRhdGFzZXRJbmRleDtcblx0XHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0cG9pbnQuX21vZGVsID0ge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0XHRyYWRpdXM6IGN1c3RvbS5yYWRpdXMgfHwgaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludFJhZGl1cywgaW5kZXgsIHBvaW50T3B0aW9ucy5yYWRpdXMpLFxuXHRcdFx0XHRwb2ludFN0eWxlOiBjdXN0b20ucG9pbnRTdHlsZSB8fCBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50U3R5bGUsIGluZGV4LCBwb2ludE9wdGlvbnMucG9pbnRTdHlsZSksXG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogbWUuZ2V0UG9pbnRCYWNrZ3JvdW5kQ29sb3IocG9pbnQsIGluZGV4KSxcblx0XHRcdFx0Ym9yZGVyQ29sb3I6IG1lLmdldFBvaW50Qm9yZGVyQ29sb3IocG9pbnQsIGluZGV4KSxcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG1lLmdldFBvaW50Qm9yZGVyV2lkdGgocG9pbnQsIGluZGV4KSxcblx0XHRcdFx0dGVuc2lvbjogbWV0YS5kYXRhc2V0Ll9tb2RlbCA/IG1ldGEuZGF0YXNldC5fbW9kZWwudGVuc2lvbiA6IDAsXG5cdFx0XHRcdHN0ZXBwZWRMaW5lOiBtZXRhLmRhdGFzZXQuX21vZGVsID8gbWV0YS5kYXRhc2V0Ll9tb2RlbC5zdGVwcGVkTGluZSA6IGZhbHNlLFxuXHRcdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRcdGhpdFJhZGl1czogY3VzdG9tLmhpdFJhZGl1cyB8fCBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SGl0UmFkaXVzLCBpbmRleCwgcG9pbnRPcHRpb25zLmhpdFJhZGl1cylcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGNhbGN1bGF0ZVBvaW50WTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRcdHZhciBzdW1Qb3MgPSAwO1xuXHRcdFx0dmFyIHN1bU5lZyA9IDA7XG5cdFx0XHR2YXIgaSwgZHMsIGRzTWV0YTtcblxuXHRcdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgaSsrKSB7XG5cdFx0XHRcdFx0ZHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldO1xuXHRcdFx0XHRcdGRzTWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRcdGlmIChkc01ldGEudHlwZSA9PT0gJ2xpbmUnICYmIGRzTWV0YS55QXhpc0lEID09PSB5U2NhbGUuaWQgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRcdFx0dmFyIHN0YWNrZWRSaWdodFZhbHVlID0gTnVtYmVyKHlTY2FsZS5nZXRSaWdodFZhbHVlKGRzLmRhdGFbaW5kZXhdKSk7XG5cdFx0XHRcdFx0XHRpZiAoc3RhY2tlZFJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHN1bU5lZyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c3VtUG9zICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUodmFsdWUpKTtcblx0XHRcdFx0aWYgKHJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bU5lZyArIHJpZ2h0VmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdW1Qb3MgKyByaWdodFZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgYXJlYSA9IG1lLmNoYXJ0LmNoYXJ0QXJlYTtcblx0XHRcdHZhciBwb2ludHMgPSAobWV0YS5kYXRhIHx8IFtdKTtcblx0XHRcdHZhciBpLCBpbGVuLCBwb2ludCwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XG5cblx0XHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG5cdFx0XHRpZiAobWV0YS5kYXRhc2V0Ll9tb2RlbC5zcGFuR2Fwcykge1xuXHRcdFx0XHRwb2ludHMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHB0KSB7XG5cdFx0XHRcdFx0cmV0dXJuICFwdC5fbW9kZWwuc2tpcDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWV0YS5kYXRhc2V0Ll9tb2RlbC5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG5cdFx0XHRcdGhlbHBlcnMuc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFx0XHRtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHRcdFx0XHRjb250cm9sUG9pbnRzID0gaGVscGVycy5zcGxpbmVDdXJ2ZShcblx0XHRcdFx0XHRcdGhlbHBlcnMucHJldmlvdXNJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdFx0XHRoZWxwZXJzLm5leHRJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdFx0bWV0YS5kYXRhc2V0Ll9tb2RlbC50ZW5zaW9uXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5saW5lLmNhcEJlemllclBvaW50cykge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHRcdHZhciBpbGVuID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0aGVscGVycy5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCBhcmVhKTtcblxuXHRcdFx0aWYgKGxpbmVFbmFibGVkKG1lLmdldERhdGFzZXQoKSwgY2hhcnQub3B0aW9ucykpIHtcblx0XHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblx0XHRcdH1cblxuXHRcdFx0aGVscGVycy5jYW52YXMudW5jbGlwQXJlYShjaGFydC5jdHgpO1xuXG5cdFx0XHQvLyBEcmF3IHRoZSBwb2ludHNcblx0XHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0Ly8gUG9pbnRcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3BvaW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdFx0dmFyIGluZGV4ID0gcG9pbnQuX2luZGV4O1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblxuXHRcdFx0bW9kZWwucmFkaXVzID0gY3VzdG9tLmhvdmVyUmFkaXVzIHx8IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIb3ZlclJhZGl1cywgaW5kZXgsIHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5ob3ZlclJhZGl1cyk7XG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgfHwgaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhvdmVyQmFja2dyb3VuZENvbG9yLCBpbmRleCwgaGVscGVycy5nZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uaG92ZXJCb3JkZXJDb2xvciB8fCBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCb3JkZXJDb2xvciwgaW5kZXgsIGhlbHBlcnMuZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCB8fCBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCb3JkZXJXaWR0aCwgaW5kZXgsIG1vZGVsLmJvcmRlcldpZHRoKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmNoYXJ0LmRhdGEuZGF0YXNldHNbcG9pbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgaW5kZXggPSBwb2ludC5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQucmFkaXVzICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LnBvaW50UmFkaXVzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQucG9pbnRSYWRpdXMgPSBkYXRhc2V0LnJhZGl1cztcblx0XHRcdH1cblxuXHRcdFx0bW9kZWwucmFkaXVzID0gY3VzdG9tLnJhZGl1cyB8fCBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50UmFkaXVzLCBpbmRleCwgbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5yYWRpdXMpO1xuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gbWUuZ2V0UG9pbnRCYWNrZ3JvdW5kQ29sb3IocG9pbnQsIGluZGV4KTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gbWUuZ2V0UG9pbnRCb3JkZXJDb2xvcihwb2ludCwgaW5kZXgpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBtZS5nZXRQb2ludEJvcmRlcldpZHRoKHBvaW50LCBpbmRleCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjQwXCI6NDAsXCI0NVwiOjQ1fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBlbGVtZW50cyA9IHJlcXVpcmUoNDApO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgncG9sYXJBcmVhJywge1xuXHRzY2FsZToge1xuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuXHRcdGFuZ2xlTGluZXM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHRncmlkTGluZXM6IHtcblx0XHRcdGNpcmN1bGFyOiB0cnVlXG5cdFx0fSxcblx0XHRwb2ludExhYmVsczoge1xuXHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHR9LFxuXHRcdHRpY2tzOiB7XG5cdFx0XHRiZWdpbkF0WmVybzogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnRcblx0YW5pbWF0aW9uOiB7XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHRhbmltYXRlU2NhbGU6IHRydWVcblx0fSxcblxuXHRzdGFydEFuZ2xlOiAtMC41ICogTWF0aC5QSSxcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRleHQgPSBbXTtcblx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV0gKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XG5cdFx0XHRcdFx0dGV4dC5wdXNoKGxhYmVsc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fSxcblx0bGVnZW5kOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcblx0XHRcdFx0XHRcdHZhciBkcyA9IGRhdGEuZGF0YXNldHNbMF07XG5cdFx0XHRcdFx0XHR2YXIgYXJjID0gbWV0YS5kYXRhW2ldO1xuXHRcdFx0XHRcdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cdFx0XHRcdFx0XHR2YXIgYXJjT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdFx0XHRcdFx0dmFyIGZpbGwgPSBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IHZhbHVlQXRJbmRleE9yRGVmYXVsdChkcy5iYWNrZ3JvdW5kQ29sb3IsIGksIGFyY09wdHMuYmFja2dyb3VuZENvbG9yKTtcblx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyQ29sb3IsIGksIGFyY09wdHMuYm9yZGVyQ29sb3IpO1xuXHRcdFx0XHRcdFx0dmFyIGJ3ID0gY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogdmFsdWVBdEluZGV4T3JEZWZhdWx0KGRzLmJvcmRlcldpZHRoLCBpLCBhcmNPcHRzLmJvcmRlcldpZHRoKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogZmlsbCxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0cm9rZSxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkcy5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxuXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhLmxhYmVsc1tpdGVtLmluZGV4XSArICc6ICcgKyBpdGVtLnlMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuY29udHJvbGxlcnMucG9sYXJBcmVhID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRcdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxuXG5cdFx0bGlua1NjYWxlczogaGVscGVycy5ub29wLFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdFx0dmFyIGFyY09wdHMgPSBvcHRzLmVsZW1lbnRzLmFyYztcblx0XHRcdHZhciBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblx0XHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgoKG1pblNpemUgLSBhcmNPcHRzLmJvcmRlcldpZHRoIC8gMikgLyAyLCAwKTtcblx0XHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG5cdFx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cblx0XHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xuXHRcdFx0bWUuaW5uZXJSYWRpdXMgPSBtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aDtcblxuXHRcdFx0bWV0YS5jb3VudCA9IG1lLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGFyYywgaW5kZXgpIHtcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmMsIGluZGV4LCByZXNldCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcblx0XHRcdHZhciBzY2FsZSA9IGNoYXJ0LnNjYWxlO1xuXHRcdFx0dmFyIGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzO1xuXG5cdFx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IG1lLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0XHR2YXIgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG5cdFx0XHR2YXIgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIE5hTiBkYXRhIGJlZm9yZSB1cywgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIHN0YXJ0aW5nIGFuZ2xlIGNvcnJlY3RseS5cblx0XHRcdC8vIFdlIGNvdWxkIGJlIHdheSBtb3JlIGVmZmljaWVudCBoZXJlLCBidXQgaXRzIHVubGlrZWx5IHRoYXQgdGhlIHBvbGFyIGFyZWEgY2hhcnQgd2lsbCBoYXZlIGEgbG90IG9mIGRhdGFcblx0XHRcdHZhciB2aXNpYmxlQ291bnQgPSAwO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyArK2kpIHtcblx0XHRcdFx0aWYgKCFpc05hTihkYXRhc2V0LmRhdGFbaV0pICYmICFtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0Kyt2aXNpYmxlQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdmFyIG5lZ0hhbGZQSSA9IC0wLjUgKiBNYXRoLlBJO1xuXHRcdFx0dmFyIGRhdGFzZXRTdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGRpc3RhbmNlID0gYXJjLmhpZGRlbiA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAqIHZpc2libGVDb3VudCk7XG5cdFx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGFyYy5oaWRkZW4gPyAwIDogY2lyY3VtZmVyZW5jZSk7XG5cblx0XHRcdHZhciByZXNldFJhZGl1cyA9IGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChhcmMsIHtcblx0XHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdFx0X2luZGV4OiBpbmRleCxcblx0XHRcdFx0X3NjYWxlOiBzY2FsZSxcblxuXHRcdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0XHR4OiBjZW50ZXJYLFxuXHRcdFx0XHRcdHk6IGNlbnRlclksXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXM6IDAsXG5cdFx0XHRcdFx0b3V0ZXJSYWRpdXM6IHJlc2V0ID8gcmVzZXRSYWRpdXMgOiBkaXN0YW5jZSxcblx0XHRcdFx0XHRzdGFydEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdFx0ZW5kQW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogZW5kQW5nbGUsXG5cdFx0XHRcdFx0bGFiZWw6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGxhYmVscywgaW5kZXgsIGxhYmVsc1tpbmRleF0pXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBib3JkZXIgYW5kIGZpbGwgc3R5bGVcblx0XHRcdG1lLnJlbW92ZUhvdmVyU3R5bGUoYXJjKTtcblxuXHRcdFx0YXJjLnBpdm90KCk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xuXHRcdFx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUhvdmVyU3R5bGUuY2FsbCh0aGlzLCBhcmMsIHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmMpO1xuXHRcdH0sXG5cblx0XHRjb3VudFZpc2libGVFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9LFxuXG5cdFx0Y2FsY3VsYXRlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBjb3VudCA9IHRoaXMuZ2V0TWV0YSgpLmNvdW50O1xuXHRcdFx0aWYgKGNvdW50ID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiAoMiAqIE1hdGguUEkpIC8gY291bnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdH0pO1xufTtcblxufSx7XCIyNVwiOjI1LFwiNDBcIjo0MCxcIjQ1XCI6NDV9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGVsZW1lbnRzID0gcmVxdWlyZSg0MCk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdyYWRhcicsIHtcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJ1xuXHR9LFxuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdHRlbnNpb246IDAgLy8gbm8gYmV6aWVyIGluIHJhZGFyXG5cdFx0fVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLnJhZGFyID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRcdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcblxuXHRcdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0XHRsaW5rU2NhbGVzOiBoZWxwZXJzLm5vb3AsXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcblx0XHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGE7XG5cdFx0XHR2YXIgY3VzdG9tID0gbGluZS5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBsaW5lRWxlbWVudE9wdGlvbnMgPSBtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmU7XG5cdFx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcblxuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHRcdH1cblxuXHRcdFx0aGVscGVycy5leHRlbmQobWV0YS5kYXRhc2V0LCB7XG5cdFx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRcdF9zY2FsZTogc2NhbGUsXG5cdFx0XHRcdC8vIERhdGFcblx0XHRcdFx0X2NoaWxkcmVuOiBwb2ludHMsXG5cdFx0XHRcdF9sb29wOiB0cnVlLFxuXHRcdFx0XHQvLyBNb2RlbFxuXHRcdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRcdFx0dGVuc2lvbjogY3VzdG9tLnRlbnNpb24gPyBjdXN0b20udGVuc2lvbiA6IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoZGF0YXNldC5saW5lVGVuc2lvbiwgbGluZUVsZW1lbnRPcHRpb25zLnRlbnNpb24pLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiAoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJhY2tncm91bmRDb2xvciksXG5cdFx0XHRcdFx0Ym9yZGVyV2lkdGg6IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IChkYXRhc2V0LmJvcmRlcldpZHRoIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJXaWR0aCksXG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IChkYXRhc2V0LmJvcmRlckNvbG9yIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJDb2xvciksXG5cdFx0XHRcdFx0ZmlsbDogY3VzdG9tLmZpbGwgPyBjdXN0b20uZmlsbCA6IChkYXRhc2V0LmZpbGwgIT09IHVuZGVmaW5lZCA/IGRhdGFzZXQuZmlsbCA6IGxpbmVFbGVtZW50T3B0aW9ucy5maWxsKSxcblx0XHRcdFx0XHRib3JkZXJDYXBTdHlsZTogY3VzdG9tLmJvcmRlckNhcFN0eWxlID8gY3VzdG9tLmJvcmRlckNhcFN0eWxlIDogKGRhdGFzZXQuYm9yZGVyQ2FwU3R5bGUgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckNhcFN0eWxlKSxcblx0XHRcdFx0XHRib3JkZXJEYXNoOiBjdXN0b20uYm9yZGVyRGFzaCA/IGN1c3RvbS5ib3JkZXJEYXNoIDogKGRhdGFzZXQuYm9yZGVyRGFzaCB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyRGFzaCksXG5cdFx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogY3VzdG9tLmJvcmRlckRhc2hPZmZzZXQgPyBjdXN0b20uYm9yZGVyRGFzaE9mZnNldCA6IChkYXRhc2V0LmJvcmRlckRhc2hPZmZzZXQgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpLFxuXHRcdFx0XHRcdGJvcmRlckpvaW5TdHlsZTogY3VzdG9tLmJvcmRlckpvaW5TdHlsZSA/IGN1c3RvbS5ib3JkZXJKb2luU3R5bGUgOiAoZGF0YXNldC5ib3JkZXJKb2luU3R5bGUgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckpvaW5TdHlsZSksXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRtZXRhLmRhdGFzZXQucGl2b3QoKTtcblxuXHRcdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdFx0aGVscGVycy5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGluZGV4LCByZXNldCk7XG5cdFx0XHR9LCBtZSk7XG5cblx0XHRcdC8vIFVwZGF0ZSBiZXppZXIgY29udHJvbCBwb2ludHNcblx0XHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcblx0XHR9LFxuXHRcdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcblx0XHRcdHZhciBwb2ludEVsZW1lbnRPcHRpb25zID0gbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHRcdHZhciBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCBkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblxuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0aWYgKChkYXRhc2V0LnJhZGl1cyAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5wb2ludFJhZGl1cyA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRkYXRhc2V0LnBvaW50UmFkaXVzID0gZGF0YXNldC5yYWRpdXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKGRhdGFzZXQuaGl0UmFkaXVzICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LnBvaW50SGl0UmFkaXVzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQucG9pbnRIaXRSYWRpdXMgPSBkYXRhc2V0LmhpdFJhZGl1cztcblx0XHRcdH1cblxuXHRcdFx0aGVscGVycy5leHRlbmQocG9pbnQsIHtcblx0XHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdFx0X2luZGV4OiBpbmRleCxcblx0XHRcdFx0X3NjYWxlOiBzY2FsZSxcblxuXHRcdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0XHR4OiByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLngsIC8vIHZhbHVlIG5vdCB1c2VkIGluIGRhdGFzZXQgc2NhbGUsIGJ1dCB3ZSB3YW50IGEgY29uc2lzdGVudCBBUEkgYmV0d2VlbiBzY2FsZXNcblx0XHRcdFx0XHR5OiByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnksXG5cblx0XHRcdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRcdFx0dGVuc2lvbjogY3VzdG9tLnRlbnNpb24gPyBjdXN0b20udGVuc2lvbiA6IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoZGF0YXNldC5saW5lVGVuc2lvbiwgbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5saW5lLnRlbnNpb24pLFxuXHRcdFx0XHRcdHJhZGl1czogY3VzdG9tLnJhZGl1cyA/IGN1c3RvbS5yYWRpdXMgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50UmFkaXVzLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5yYWRpdXMpLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50QmFja2dyb3VuZENvbG9yLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpLFxuXHRcdFx0XHRcdGJvcmRlckNvbG9yOiBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50Qm9yZGVyQ29sb3IsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmJvcmRlckNvbG9yKSxcblx0XHRcdFx0XHRib3JkZXJXaWR0aDogY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJvcmRlcldpZHRoLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5ib3JkZXJXaWR0aCksXG5cdFx0XHRcdFx0cG9pbnRTdHlsZTogY3VzdG9tLnBvaW50U3R5bGUgPyBjdXN0b20ucG9pbnRTdHlsZSA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRTdHlsZSwgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMucG9pbnRTdHlsZSksXG5cblx0XHRcdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRcdFx0aGl0UmFkaXVzOiBjdXN0b20uaGl0UmFkaXVzID8gY3VzdG9tLmhpdFJhZGl1cyA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIaXRSYWRpdXMsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmhpdFJhZGl1cylcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHBvaW50Ll9tb2RlbC5za2lwID0gY3VzdG9tLnNraXAgPyBjdXN0b20uc2tpcCA6IChpc05hTihwb2ludC5fbW9kZWwueCkgfHwgaXNOYU4ocG9pbnQuX21vZGVsLnkpKTtcblx0XHR9LFxuXHRcdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNoYXJ0QXJlYSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhO1xuXHRcdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHRcdFx0dmFyIGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRcdGhlbHBlcnMucHJldmlvdXNJdGVtKG1ldGEuZGF0YSwgaW5kZXgsIHRydWUpLl9tb2RlbCxcblx0XHRcdFx0XHRtb2RlbCxcblx0XHRcdFx0XHRoZWxwZXJzLm5leHRJdGVtKG1ldGEuZGF0YSwgaW5kZXgsIHRydWUpLl9tb2RlbCxcblx0XHRcdFx0XHRtb2RlbC50ZW5zaW9uXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gUHJldmVudCB0aGUgYmV6aWVyIGdvaW5nIG91dHNpZGUgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gTWF0aC5tYXgoTWF0aC5taW4oY29udHJvbFBvaW50cy5wcmV2aW91cy54LCBjaGFydEFyZWEucmlnaHQpLCBjaGFydEFyZWEubGVmdCk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IE1hdGgubWF4KE1hdGgubWluKGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgY2hhcnRBcmVhLmJvdHRvbSksIGNoYXJ0QXJlYS50b3ApO1xuXG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gTWF0aC5tYXgoTWF0aC5taW4oY29udHJvbFBvaW50cy5uZXh0LngsIGNoYXJ0QXJlYS5yaWdodCksIGNoYXJ0QXJlYS5sZWZ0KTtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBNYXRoLm1heChNYXRoLm1pbihjb250cm9sUG9pbnRzLm5leHQueSwgY2hhcnRBcmVhLmJvdHRvbSksIGNoYXJ0QXJlYS50b3ApO1xuXG5cdFx0XHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxuXHRcdFx0XHRwb2ludC5waXZvdCgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHQvLyBQb2ludFxuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbcG9pbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIGluZGV4ID0gcG9pbnQuX2luZGV4O1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBjdXN0b20uaG92ZXJSYWRpdXMgPyBjdXN0b20uaG92ZXJSYWRpdXMgOiBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJSYWRpdXMsIGluZGV4LCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQuaG92ZXJSYWRpdXMpO1xuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhvdmVyQmFja2dyb3VuZENvbG9yLCBpbmRleCwgaGVscGVycy5nZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uaG92ZXJCb3JkZXJDb2xvciA/IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhvdmVyQm9yZGVyQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGggPyBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIb3ZlckJvcmRlcldpZHRoLCBpbmRleCwgbW9kZWwuYm9yZGVyV2lkdGgpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbcG9pbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIGluZGV4ID0gcG9pbnQuX2luZGV4O1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdFx0dmFyIHBvaW50RWxlbWVudE9wdGlvbnMgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XG5cblx0XHRcdG1vZGVsLnJhZGl1cyA9IGN1c3RvbS5yYWRpdXMgPyBjdXN0b20ucmFkaXVzIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludFJhZGl1cywgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMucmFkaXVzKTtcblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uYmFja2dyb3VuZENvbG9yIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJhY2tncm91bmRDb2xvciwgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJvcmRlckNvbG9yLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5ib3JkZXJDb2xvcik7XG5cdFx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCb3JkZXJXaWR0aCwgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdH1cblx0fSk7XG59O1xuXG59LHtcIjI1XCI6MjUsXCI0MFwiOjQwLFwiNDVcIjo0NX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG5cbmRlZmF1bHRzLl9zZXQoJ3NjYXR0ZXInLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdGlkOiAneC1heGlzLTEnLCAgICAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXG5cdFx0XHR0eXBlOiAnbGluZWFyJywgICAgLy8gc2NhdHRlciBzaG91bGQgbm90IHVzZSBhIGNhdGVnb3J5IGF4aXNcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xuXHRcdH1dLFxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0aWQ6ICd5LWF4aXMtMScsXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCdcblx0XHR9XVxuXHR9LFxuXG5cdHNob3dMaW5lczogZmFsc2UsXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnOyAgICAgLy8gZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIGRhdGEgYXJlIGZvcm1hdHRlZCBhcyBhIHBvaW50XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuICcoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHQvLyBTY2F0dGVyIGNoYXJ0cyB1c2UgbGluZSBjb250cm9sbGVyc1xuXHRDaGFydC5jb250cm9sbGVycy5zY2F0dGVyID0gQ2hhcnQuY29udHJvbGxlcnMubGluZTtcblxufTtcblxufSx7XCIyNVwiOjI1fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIHdpbmRvdzogZmFsc2UgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRhbmltYXRpb246IHtcblx0XHRkdXJhdGlvbjogMTAwMCxcblx0XHRlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuXHRcdG9uUHJvZ3Jlc3M6IGhlbHBlcnMubm9vcCxcblx0XHRvbkNvbXBsZXRlOiBoZWxwZXJzLm5vb3Bcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5BbmltYXRpb24gPSBFbGVtZW50LmV4dGVuZCh7XG5cdFx0Y2hhcnQ6IG51bGwsIC8vIHRoZSBhbmltYXRpb24gYXNzb2NpYXRlZCBjaGFydCBpbnN0YW5jZVxuXHRcdGN1cnJlbnRTdGVwOiAwLCAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RlcFxuXHRcdG51bVN0ZXBzOiA2MCwgLy8gZGVmYXVsdCBudW1iZXIgb2Ygc3RlcHNcblx0XHRlYXNpbmc6ICcnLCAvLyB0aGUgZWFzaW5nIHRvIHVzZSBmb3IgdGhpcyBhbmltYXRpb25cblx0XHRyZW5kZXI6IG51bGwsIC8vIHJlbmRlciBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhbmltYXRpb24gc2VydmljZVxuXG5cdFx0b25BbmltYXRpb25Qcm9ncmVzczogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSBvbiBlYWNoIHN0ZXAgb2YgdGhlIGFuaW1hdGlvblxuXHRcdG9uQW5pbWF0aW9uQ29tcGxldGU6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzXG5cdH0pO1xuXG5cdENoYXJ0LmFuaW1hdGlvblNlcnZpY2UgPSB7XG5cdFx0ZnJhbWVEdXJhdGlvbjogMTcsXG5cdFx0YW5pbWF0aW9uczogW10sXG5cdFx0ZHJvcEZyYW1lczogMCxcblx0XHRyZXF1ZXN0OiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgdG8gYW5pbWF0ZS5cblx0XHQgKiBAcGFyYW0ge0NoYXJ0LkFuaW1hdGlvbn0gYW5pbWF0aW9uIC0gVGhlIGFuaW1hdGlvbiB0aGF0IHdlIHdpbGwgYW5pbWF0ZS5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gLSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbGF6eSAtIGlmIHRydWUsIHRoZSBjaGFydCBpcyBub3QgbWFya2VkIGFzIGFuaW1hdGluZyB0byBlbmFibGUgbW9yZSByZXNwb25zaXZlIGludGVyYWN0aW9uc1xuXHRcdCAqL1xuXHRcdGFkZEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpIHtcblx0XHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdFx0dmFyIGksIGlsZW47XG5cblx0XHRcdGFuaW1hdGlvbi5jaGFydCA9IGNoYXJ0O1xuXG5cdFx0XHRpZiAoIWxhenkpIHtcblx0XHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChhbmltYXRpb25zW2ldLmNoYXJ0ID09PSBjaGFydCkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyBxdWV1ZWQsIG1hbnVhbGx5IGtpY2tzdGFydCBhIGRpZ2VzdCwgZm9yIGxhY2sgb2YgYSBiZXR0ZXIgd29yZFxuXHRcdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdHZhciBpbmRleCA9IGhlbHBlcnMuZmluZEluZGV4KHRoaXMuYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBhbmltYXRpb24uY2hhcnQgPT09IGNoYXJ0O1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGlmIChtZS5yZXF1ZXN0ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxuXHRcdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIG1vdXNlIGV2ZW50cywgZS5nLiAnbW91c2Vtb3ZlJ1xuXHRcdFx0XHQvLyBhbmQgJ21vdXNlb3V0JyBldmVudHMgd2lsbCB0cmlnZ2VyIG11bHRpcGxlIHJlbmRlcnMuXG5cdFx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG1lLnJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHRcdG1lLnN0YXJ0RGlnZXN0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHN0YXJ0RGlnZXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdHZhciBmcmFtZXNUb0Ryb3AgPSAwO1xuXG5cdFx0XHRpZiAobWUuZHJvcEZyYW1lcyA+IDEpIHtcblx0XHRcdFx0ZnJhbWVzVG9Ecm9wID0gTWF0aC5mbG9vcihtZS5kcm9wRnJhbWVzKTtcblx0XHRcdFx0bWUuZHJvcEZyYW1lcyA9IG1lLmRyb3BGcmFtZXMgJSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5hZHZhbmNlKDEgKyBmcmFtZXNUb0Ryb3ApO1xuXG5cdFx0XHR2YXIgZW5kVGltZSA9IERhdGUubm93KCk7XG5cblx0XHRcdG1lLmRyb3BGcmFtZXMgKz0gKGVuZFRpbWUgLSBzdGFydFRpbWUpIC8gbWUuZnJhbWVEdXJhdGlvbjtcblxuXHRcdFx0Ly8gRG8gd2UgaGF2ZSBtb3JlIHN0dWZmIHRvIGFuaW1hdGU/XG5cdFx0XHRpZiAobWUuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdG1lLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGFkdmFuY2U6IGZ1bmN0aW9uKGNvdW50KSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHRcdHZhciBhbmltYXRpb24sIGNoYXJ0O1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XG5cdFx0XHRcdGNoYXJ0ID0gYW5pbWF0aW9uLmNoYXJ0O1xuXG5cdFx0XHRcdGFuaW1hdGlvbi5jdXJyZW50U3RlcCA9IChhbmltYXRpb24uY3VycmVudFN0ZXAgfHwgMCkgKyBjb3VudDtcblx0XHRcdFx0YW5pbWF0aW9uLmN1cnJlbnRTdGVwID0gTWF0aC5taW4oYW5pbWF0aW9uLmN1cnJlbnRTdGVwLCBhbmltYXRpb24ubnVtU3RlcHMpO1xuXG5cdFx0XHRcdGhlbHBlcnMuY2FsbGJhY2soYW5pbWF0aW9uLnJlbmRlciwgW2NoYXJ0LCBhbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRcdGhlbHBlcnMuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uUHJvZ3Jlc3MsIFthbmltYXRpb25dLCBjaGFydCk7XG5cblx0XHRcdFx0aWYgKGFuaW1hdGlvbi5jdXJyZW50U3RlcCA+PSBhbmltYXRpb24ubnVtU3RlcHMpIHtcblx0XHRcdFx0XHRoZWxwZXJzLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xuXHRcdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCsraTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5BbmltYXRpb24gaW5zdGVhZFxuXHQgKiBAcHJvcCBDaGFydC5BbmltYXRpb24jYW5pbWF0aW9uT2JqZWN0XG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXJ0LkFuaW1hdGlvbi5wcm90b3R5cGUsICdhbmltYXRpb25PYmplY3QnLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0IGluc3RlYWRcblx0ICogQHByb3AgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0SW5zdGFuY2Vcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhcnQuQW5pbWF0aW9uLnByb3RvdHlwZSwgJ2NoYXJ0SW5zdGFuY2UnLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoYXJ0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5jaGFydCA9IHZhbHVlO1xuXHRcdH1cblx0fSk7XG5cbn07XG5cbn0se1wiMjVcIjoyNSxcIjI2XCI6MjYsXCI0NVwiOjQ1fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKDI4KTtcbnZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoNDgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cdHZhciBwbHVnaW5zID0gQ2hhcnQucGx1Z2lucztcblxuXHQvLyBDcmVhdGUgYSBkaWN0aW9uYXJ5IG9mIGNoYXJ0IHR5cGVzLCB0byBhbGxvdyBmb3IgZXh0ZW5zaW9uIG9mIGV4aXN0aW5nIHR5cGVzXG5cdENoYXJ0LnR5cGVzID0ge307XG5cblx0Ly8gU3RvcmUgYSByZWZlcmVuY2UgdG8gZWFjaCBpbnN0YW5jZSAtIGFsbG93aW5nIHVzIHRvIGdsb2JhbGx5IHJlc2l6ZSBjaGFydCBpbnN0YW5jZXMgb24gd2luZG93IHJlc2l6ZS5cblx0Ly8gRGVzdHJveSBtZXRob2Qgb24gdGhlIGNoYXJ0IHdpbGwgcmVtb3ZlIHRoZSBpbnN0YW5jZSBvZiB0aGUgY2hhcnQgZnJvbSB0aGlzIHJlZmVyZW5jZS5cblx0Q2hhcnQuaW5zdGFuY2VzID0ge307XG5cblx0Ly8gQ29udHJvbGxlcnMgYXZhaWxhYmxlIGZvciBkYXRhc2V0IHZpc3VhbGl6YXRpb24gZWcuIGJhciwgbGluZSwgc2xpY2UsIGV0Yy5cblx0Q2hhcnQuY29udHJvbGxlcnMgPSB7fTtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIGdpdmVuIGNvbmZpZyB3aXRoIGdsb2JhbCBhbmQgY2hhcnQgZGVmYXVsdCB2YWx1ZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHRcdC8vIERvIE5PVCB1c2UgY29uZmlnTWVyZ2UoKSBmb3IgdGhlIGRhdGEgb2JqZWN0IGJlY2F1c2UgdGhpcyBtZXRob2QgbWVyZ2VzIGFycmF5c1xuXHRcdC8vIGFuZCBzbyB3b3VsZCBjaGFuZ2UgcmVmZXJlbmNlcyB0byBsYWJlbHMgYW5kIGRhdGFzZXRzLCBwcmV2ZW50aW5nIGRhdGEgdXBkYXRlcy5cblx0XHR2YXIgZGF0YSA9IGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG5cdFx0ZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG5cdFx0ZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcblxuXHRcdGNvbmZpZy5vcHRpb25zID0gaGVscGVycy5jb25maWdNZXJnZShcblx0XHRcdGRlZmF1bHRzLmdsb2JhbCxcblx0XHRcdGRlZmF1bHRzW2NvbmZpZy50eXBlXSxcblx0XHRcdGNvbmZpZy5vcHRpb25zIHx8IHt9KTtcblxuXHRcdHJldHVybiBjb25maWc7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY29uZmlnIG9mIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0gY2hhcnQge0NoYXJ0fSBjaGFydCB0byB1cGRhdGUgdGhlIG9wdGlvbnMgZm9yXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVDb25maWcoY2hhcnQpIHtcblx0XHR2YXIgbmV3T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cblx0XHQvLyBVcGRhdGUgU2NhbGUocykgd2l0aCBvcHRpb25zXG5cdFx0aWYgKG5ld09wdGlvbnMuc2NhbGUpIHtcblx0XHRcdGNoYXJ0LnNjYWxlLm9wdGlvbnMgPSBuZXdPcHRpb25zLnNjYWxlO1xuXHRcdH0gZWxzZSBpZiAobmV3T3B0aW9ucy5zY2FsZXMpIHtcblx0XHRcdG5ld09wdGlvbnMuc2NhbGVzLnhBeGVzLmNvbmNhdChuZXdPcHRpb25zLnNjYWxlcy55QXhlcykuZm9yRWFjaChmdW5jdGlvbihzY2FsZU9wdGlvbnMpIHtcblx0XHRcdFx0Y2hhcnQuc2NhbGVzW3NjYWxlT3B0aW9ucy5pZF0ub3B0aW9ucyA9IHNjYWxlT3B0aW9ucztcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIFRvb2x0aXBcblx0XHRjaGFydC50b29sdGlwLl9vcHRpb25zID0gbmV3T3B0aW9ucy50b29sdGlwcztcblx0fVxuXG5cdGZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG5cdH1cblxuXHRoZWxwZXJzLmV4dGVuZChDaGFydC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgQ2hhcnQgKi8ge1xuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcblxuXHRcdFx0dmFyIGNvbnRleHQgPSBwbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpdGVtLCBjb25maWcpO1xuXHRcdFx0dmFyIGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG5cdFx0XHR2YXIgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuXG5cdFx0XHRtZS5pZCA9IGhlbHBlcnMudWlkKCk7XG5cdFx0XHRtZS5jdHggPSBjb250ZXh0O1xuXHRcdFx0bWUuY2FudmFzID0gY2FudmFzO1xuXHRcdFx0bWUuY29uZmlnID0gY29uZmlnO1xuXHRcdFx0bWUud2lkdGggPSB3aWR0aDtcblx0XHRcdG1lLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdG1lLmFzcGVjdFJhdGlvID0gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuXHRcdFx0bWUub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuXHRcdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIENoYXJ0IGFuZCBDaGFydC5Db250cm9sbGVyIGhhdmUgYmVlbiBtZXJnZWQsXG5cdFx0XHQgKiB0aGUgXCJpbnN0YW5jZVwiIHN0aWxsIG5lZWQgdG8gYmUgZGVmaW5lZCBzaW5jZSBpdCBtaWdodCBiZSBjYWxsZWQgZnJvbSBwbHVnaW5zLlxuXHRcdFx0ICogQHByb3AgQ2hhcnQjY2hhcnRcblx0XHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0XHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0XHRcdG1lLmNoYXJ0ID0gbWU7XG5cdFx0XHRtZS5jb250cm9sbGVyID0gbWU7IC8vIGNoYXJ0LmNoYXJ0LmNvbnRyb2xsZXIgI2luY2VwdGlvblxuXG5cdFx0XHQvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG5cdFx0XHRDaGFydC5pbnN0YW5jZXNbbWUuaWRdID0gbWU7XG5cblx0XHRcdC8vIERlZmluZSBhbGlhcyB0byB0aGUgY29uZmlnIGRhdGE6IGBjaGFydC5kYXRhID09PSBjaGFydC5jb25maWcuZGF0YWBcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2RhdGEnLCB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1lLmNvbmZpZy5kYXRhO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0bWUuY29uZmlnLmRhdGEgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG5cdFx0XHRcdC8vIFRoZSBnaXZlbiBpdGVtIGlzIG5vdCBhIGNvbXBhdGlibGUgY29udGV4dDJkIGVsZW1lbnQsIGxldCdzIHJldHVybiBiZWZvcmUgZmluYWxpemluZ1xuXHRcdFx0XHQvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuXHRcdFx0XHQvLyBjYW4gaGVscCB0byBmaWd1cmUgb3V0IHRoYXQgdGhlIGNoYXJ0IGlzIG5vdCB2YWxpZCAoZS5nIGNoYXJ0LmNhbnZhcyAhPT0gbnVsbCk7XG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5pbml0aWFsaXplKCk7XG5cdFx0XHRtZS51cGRhdGUoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlSW5pdCcpO1xuXG5cdFx0XHRoZWxwZXJzLnJldGluYVNjYWxlKG1lLCBtZS5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0XHRtZS5iaW5kRXZlbnRzKCk7XG5cblx0XHRcdGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcblx0XHRcdFx0Ly8gSW5pdGlhbCByZXNpemUgYmVmb3JlIGNoYXJ0IGRyYXdzIChtdXN0IGJlIHNpbGVudCB0byBwcmVzZXJ2ZSBpbml0aWFsIGFuaW1hdGlvbnMpLlxuXHRcdFx0XHRtZS5yZXNpemUodHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSBzY2FsZXMgaGF2ZSBJRHMgYW5kIGFyZSBidWlsdCBiZWZvcmUgd2UgYnVpbGQgYW55IGNvbnRyb2xsZXJzLlxuXHRcdFx0bWUuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuXHRcdFx0bWUuYnVpbGRTY2FsZXMoKTtcblx0XHRcdG1lLmluaXRUb29sVGlwKCk7XG5cblx0XHRcdC8vIEFmdGVyIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckluaXQnKTtcblxuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH0sXG5cblx0XHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbnZhcy5jbGVhcih0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIFN0b3BzIGFueSBjdXJyZW50IGFuaW1hdGlvbiBsb29wIG9jY3VycmluZ1xuXHRcdFx0Q2hhcnQuYW5pbWF0aW9uU2VydmljZS5jYW5jZWxBbmltYXRpb24odGhpcyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0cmVzaXplOiBmdW5jdGlvbihzaWxlbnQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdFx0dmFyIGFzcGVjdFJhdGlvID0gKG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBtZS5hc3BlY3RSYXRpbykgfHwgbnVsbDtcblxuXHRcdFx0Ly8gdGhlIGNhbnZhcyByZW5kZXIgd2lkdGggYW5kIGhlaWdodCB3aWxsIGJlIGNhc3RlZCB0byBpbnRlZ2VycyBzbyBtYWtlIHN1cmUgdGhhdFxuXHRcdFx0Ly8gdGhlIGNhbnZhcyBkaXNwbGF5IHN0eWxlIHVzZXMgdGhlIHNhbWUgaW50ZWdlciB2YWx1ZXMgdG8gYXZvaWQgYmx1cnJpbmcgZWZmZWN0LlxuXG5cdFx0XHQvLyBTZXQgdG8gMCBpbnN0ZWFkIG9mIGNhbnZhcy5zaXplIGJlY2F1c2UgdGhlIHNpemUgZGVmYXVsdHMgdG8gMzAweDE1MCBpZiB0aGUgZWxlbWVudCBpcyBjb2xsYXNlZFxuXHRcdFx0dmFyIG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihoZWxwZXJzLmdldE1heGltdW1XaWR0aChjYW52YXMpKSk7XG5cdFx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihhc3BlY3RSYXRpbyA/IG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWxwZXJzLmdldE1heGltdW1IZWlnaHQoY2FudmFzKSkpO1xuXG5cdFx0XHRpZiAobWUud2lkdGggPT09IG5ld1dpZHRoICYmIG1lLmhlaWdodCA9PT0gbmV3SGVpZ2h0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2FudmFzLndpZHRoID0gbWUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBtZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0XHRjYW52YXMuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICdweCc7XG5cdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0aGVscGVycy5yZXRpbmFTY2FsZShtZSwgb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdFx0aWYgKCFzaWxlbnQpIHtcblx0XHRcdFx0Ly8gTm90aWZ5IGFueSBwbHVnaW5zIGFib3V0IHRoZSByZXNpemVcblx0XHRcdFx0dmFyIG5ld1NpemUgPSB7d2lkdGg6IG5ld1dpZHRoLCBoZWlnaHQ6IG5ld0hlaWdodH07XG5cdFx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAncmVzaXplJywgW25ld1NpemVdKTtcblxuXHRcdFx0XHQvLyBOb3RpZnkgb2YgcmVzaXplXG5cdFx0XHRcdGlmIChtZS5vcHRpb25zLm9uUmVzaXplKSB7XG5cdFx0XHRcdFx0bWUub3B0aW9ucy5vblJlc2l6ZShtZSwgbmV3U2l6ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZS5zdG9wKCk7XG5cdFx0XHRcdG1lLnVwZGF0ZShtZS5vcHRpb25zLnJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvbik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGVuc3VyZVNjYWxlc0hhdmVJRHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0XHR2YXIgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXHRcdFx0dmFyIHNjYWxlT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGU7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChzY2FsZXNPcHRpb25zLnhBeGVzLCBmdW5jdGlvbih4QXhpc09wdGlvbnMsIGluZGV4KSB7XG5cdFx0XHRcdHhBeGlzT3B0aW9ucy5pZCA9IHhBeGlzT3B0aW9ucy5pZCB8fCAoJ3gtYXhpcy0nICsgaW5kZXgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChzY2FsZXNPcHRpb25zLnlBeGVzLCBmdW5jdGlvbih5QXhpc09wdGlvbnMsIGluZGV4KSB7XG5cdFx0XHRcdHlBeGlzT3B0aW9ucy5pZCA9IHlBeGlzT3B0aW9ucy5pZCB8fCAoJ3ktYXhpcy0nICsgaW5kZXgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChzY2FsZU9wdGlvbnMpIHtcblx0XHRcdFx0c2NhbGVPcHRpb25zLmlkID0gc2NhbGVPcHRpb25zLmlkIHx8ICdzY2FsZSc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXG5cdFx0ICovXG5cdFx0YnVpbGRTY2FsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHRcdHZhciBzY2FsZXMgPSBtZS5zY2FsZXMgPSB7fTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5zY2FsZXMpIHtcblx0XHRcdFx0aXRlbXMgPSBpdGVtcy5jb25jYXQoXG5cdFx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnhBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeEF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHhBeGlzT3B0aW9ucywgZHR5cGU6ICdjYXRlZ29yeScsIGRwb3NpdGlvbjogJ2JvdHRvbSd9O1xuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdChvcHRpb25zLnNjYWxlcy55QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHlBeGlzT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB5QXhpc09wdGlvbnMsIGR0eXBlOiAnbGluZWFyJywgZHBvc2l0aW9uOiAnbGVmdCd9O1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLnNjYWxlKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goe1xuXHRcdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnMuc2NhbGUsXG5cdFx0XHRcdFx0ZHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuXHRcdFx0XHRcdGlzRGVmYXVsdDogdHJ1ZSxcblx0XHRcdFx0XHRkcG9zaXRpb246ICdjaGFydEFyZWEnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0dmFyIHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcblx0XHRcdFx0dmFyIHNjYWxlVHlwZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuXHRcdFx0XHR2YXIgc2NhbGVDbGFzcyA9IENoYXJ0LnNjYWxlU2VydmljZS5nZXRTY2FsZUNvbnN0cnVjdG9yKHNjYWxlVHlwZSk7XG5cdFx0XHRcdGlmICghc2NhbGVDbGFzcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24pICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcblx0XHRcdFx0XHRzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcblx0XHRcdFx0XHRpZDogc2NhbGVPcHRpb25zLmlkLFxuXHRcdFx0XHRcdG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcblx0XHRcdFx0XHRjdHg6IG1lLmN0eCxcblx0XHRcdFx0XHRjaGFydDogbWVcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuXHRcdFx0XHRzY2FsZS5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXG5cdFx0XHRcdC8vIFRPRE8oU0IpOiBJIHRoaW5rIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZSB0aGlzIGN1c3RvbSBjYXNlIChvcHRpb25zLnNjYWxlKVxuXHRcdFx0XHQvLyBhbmQgY29uc2lkZXIgaXQgYXMgYSByZWd1bGFyIHNjYWxlIHBhcnQgb2YgdGhlIFwic2NhbGVzXCJcIiBtYXAgb25seSEgVGhpcyB3b3VsZFxuXHRcdFx0XHQvLyBtYWtlIHRoZSBsb2dpYyBlYXNpZXIgYW5kIHJlbW92ZSBzb21lIHVzZWxlc3M/IGN1c3RvbSBjb2RlLlxuXHRcdFx0XHRpZiAoaXRlbS5pc0RlZmF1bHQpIHtcblx0XHRcdFx0XHRtZS5zY2FsZSA9IHNjYWxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Q2hhcnQuc2NhbGVTZXJ2aWNlLmFkZFNjYWxlc1RvTGF5b3V0KHRoaXMpO1xuXHRcdH0sXG5cblx0XHRidWlsZE9yVXBkYXRlQ29udHJvbGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0eXBlcyA9IFtdO1xuXHRcdFx0dmFyIG5ld0NvbnRyb2xsZXJzID0gW107XG5cblx0XHRcdGhlbHBlcnMuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBtZS5jb25maWcudHlwZTtcblxuXHRcdFx0XHRpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuXHRcdFx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1ldGEudHlwZSA9IHR5cGU7XG5cblx0XHRcdFx0dHlwZXMucHVzaChtZXRhLnR5cGUpO1xuXG5cdFx0XHRcdGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgQ29udHJvbGxlckNsYXNzID0gQ2hhcnQuY29udHJvbGxlcnNbbWV0YS50eXBlXTtcblx0XHRcdFx0XHRpZiAoQ29udHJvbGxlckNsYXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignXCInICsgbWV0YS50eXBlICsgJ1wiIGlzIG5vdCBhIGNoYXJ0IHR5cGUuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHRuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG1lKTtcblxuXHRcdFx0cmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXNldCB0aGUgZWxlbWVudHMgb2YgYWxsIGRhdGFzZXRzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRyZXNldEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRoZWxwZXJzLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuXHRcdFx0fSwgbWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdCdzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0XHQqL1xuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVzZXRFbGVtZW50cygpO1xuXHRcdFx0dGhpcy50b29sdGlwLmluaXRpYWxpemUoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdGNvbmZpZyA9IHtcblx0XHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGVDb25maWcobWUpO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxuXHRcdFx0bWUudG9vbHRpcC5fZGF0YSA9IG1lLmRhdGE7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSBkYXRhc2V0IGNvbnRyb2xsZXJzIGFyZSB1cGRhdGVkIGFuZCBuZXcgY29udHJvbGxlcnMgYXJlIHJlc2V0XG5cdFx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBtZS5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG5cdFx0XHRoZWxwZXJzLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMoKTtcblx0XHRcdH0sIG1lKTtcblxuXHRcdFx0bWUudXBkYXRlTGF5b3V0KCk7XG5cblx0XHRcdC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHRcdFx0aGVscGVycy5lYWNoKG5ld0NvbnRyb2xsZXJzLCBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cdFx0XHRcdGNvbnRyb2xsZXIucmVzZXQoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRtZS51cGRhdGVEYXRhc2V0cygpO1xuXG5cdFx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XG5cblx0XHRcdGlmIChtZS5fYnVmZmVyZWRSZW5kZXIpIHtcblx0XHRcdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IHtcblx0XHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLmR1cmF0aW9uLFxuXHRcdFx0XHRcdGVhc2luZzogY29uZmlnLmVhc2luZyxcblx0XHRcdFx0XHRsYXp5OiBjb25maWcubGF6eVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUucmVuZGVyKGNvbmZpZyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHRcdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0aWYgKHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlTGF5b3V0JykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Q2hhcnQubGF5b3V0U2VydmljZS51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgYGFmdGVyTGF5b3V0YCBpbnN0ZWFkLlxuXHRcdFx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyU2NhbGVVcGRhdGVcblx0XHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcblx0XHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJTY2FsZVVwZGF0ZScpO1xuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckxheW91dCcpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdFx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dXBkYXRlRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0aWYgKHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldHNVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1lLnVwZGF0ZURhdGFzZXQoaSk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdFx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR1cGRhdGVEYXRhc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRcdGluZGV4OiBpbmRleFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldFVwZGF0ZScsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bWV0YS5jb250cm9sbGVyLnVwZGF0ZSgpO1xuXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldFVwZGF0ZScsIFthcmdzXSk7XG5cdFx0fSxcblxuXHRcdHJlbmRlcjogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRjb25maWcgPSB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZyxcblx0XHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uO1xuXHRcdFx0dmFyIGxhenkgPSBjb25maWcubGF6eTtcblxuXHRcdFx0aWYgKHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlUmVuZGVyJykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGFuaW1hdGlvbk9wdGlvbnMgPSBtZS5vcHRpb25zLmFuaW1hdGlvbjtcblx0XHRcdHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJSZW5kZXInKTtcblx0XHRcdFx0aGVscGVycy5jYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2FuaW1hdGlvbl0sIG1lKTtcblx0XHRcdH07XG5cblx0XHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmICgodHlwZW9mIGR1cmF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBkdXJhdGlvbiAhPT0gMCkgfHwgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgJiYgYW5pbWF0aW9uT3B0aW9ucy5kdXJhdGlvbiAhPT0gMCkpKSB7XG5cdFx0XHRcdHZhciBhbmltYXRpb24gPSBuZXcgQ2hhcnQuQW5pbWF0aW9uKHtcblx0XHRcdFx0XHRudW1TdGVwczogKGR1cmF0aW9uIHx8IGFuaW1hdGlvbk9wdGlvbnMuZHVyYXRpb24pIC8gMTYuNjYsIC8vIDYwIGZwc1xuXHRcdFx0XHRcdGVhc2luZzogY29uZmlnLmVhc2luZyB8fCBhbmltYXRpb25PcHRpb25zLmVhc2luZyxcblxuXHRcdFx0XHRcdHJlbmRlcjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbk9iamVjdCkge1xuXHRcdFx0XHRcdFx0dmFyIGVhc2luZ0Z1bmN0aW9uID0gaGVscGVycy5lYXNpbmcuZWZmZWN0c1thbmltYXRpb25PYmplY3QuZWFzaW5nXTtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcblx0XHRcdFx0XHRcdHZhciBzdGVwRGVjaW1hbCA9IGN1cnJlbnRTdGVwIC8gYW5pbWF0aW9uT2JqZWN0Lm51bVN0ZXBzO1xuXG5cdFx0XHRcdFx0XHRjaGFydC5kcmF3KGVhc2luZ0Z1bmN0aW9uKHN0ZXBEZWNpbWFsKSwgc3RlcERlY2ltYWwsIGN1cnJlbnRTdGVwKTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0b25BbmltYXRpb25Qcm9ncmVzczogYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLFxuXHRcdFx0XHRcdG9uQW5pbWF0aW9uQ29tcGxldGU6IG9uQ29tcGxldGVcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Q2hhcnQuYW5pbWF0aW9uU2VydmljZS5hZGRBbmltYXRpb24obWUsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuZHJhdygpO1xuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxuXHRcdFx0XHRvbkNvbXBsZXRlKG5ldyBDaGFydC5BbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZTtcblx0XHR9LFxuXG5cdFx0ZHJhdzogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdG1lLmNsZWFyKCk7XG5cblx0XHRcdGlmIChoZWxwZXJzLmlzTnVsbE9yVW5kZWYoZWFzaW5nVmFsdWUpKSB7XG5cdFx0XHRcdGVhc2luZ1ZhbHVlID0gMTtcblx0XHRcdH1cblxuXHRcdFx0bWUudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cblx0XHRcdGlmIChwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmF3IGFsbCB0aGUgc2NhbGVzXG5cdFx0XHRoZWxwZXJzLmVhY2gobWUuYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRib3guZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdFx0fSwgbWUpO1xuXG5cdFx0XHRpZiAobWUuc2NhbGUpIHtcblx0XHRcdFx0bWUuc2NhbGUuZHJhdygpO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5kcmF3RGF0YXNldHMoZWFzaW5nVmFsdWUpO1xuXG5cdFx0XHQvLyBGaW5hbGx5IGRyYXcgdGhlIHRvb2x0aXBcblx0XHRcdG1lLnRvb2x0aXAuZHJhdygpO1xuXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IChtZS5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRtZS5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG1lLnRvb2x0aXAudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXdzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNEcmF3YFxuXHRcdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRkcmF3RGF0YXNldHM6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmF3IGRhdGFzZXRzIHJldmVyc2VkIHRvIHN1cHBvcnQgcHJvcGVyIGxpbmUgc3RhY2tpbmdcblx0XHRcdGZvciAodmFyIGkgPSAobWUuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRtZS5kcmF3RGF0YXNldChpLCBlYXNpbmdWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0XHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRkcmF3RGF0YXNldDogZnVuY3Rpb24oaW5kZXgsIGVhc2luZ1ZhbHVlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0XHR2YXIgYXJncyA9IHtcblx0XHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcblx0XHRcdH07XG5cblx0XHRcdGlmIChwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXREcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRhLmNvbnRyb2xsZXIuZHJhdyhlYXNpbmdWYWx1ZSk7XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0RHJhdycsIFthcmdzXSk7XG5cdFx0fSxcblxuXHRcdC8vIEdldCB0aGUgc2luZ2xlIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBvblxuXHRcdC8vIEByZXR1cm4gOiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YXNldCBpbmRleCBhbmQgZWxlbWVudCBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgZWxlbWVudC4gQWxzbyBjb250YWlucyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2FzIGRyYXdcblx0XHRnZXRFbGVtZW50QXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdFx0cmV0dXJuIEludGVyYWN0aW9uLm1vZGVzLnNpbmdsZSh0aGlzLCBlKTtcblx0XHR9LFxuXG5cdFx0Z2V0RWxlbWVudHNBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gSW50ZXJhY3Rpb24ubW9kZXMubGFiZWwodGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHRcdH0sXG5cblx0XHRnZXRFbGVtZW50c0F0WEF4aXM6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiBJbnRlcmFjdGlvbi5tb2Rlc1sneC1heGlzJ10odGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHRcdH0sXG5cblx0XHRnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlOiBmdW5jdGlvbihlLCBtb2RlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG5cdFx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSxcblxuXHRcdGdldERhdGFzZXRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdFx0fSxcblxuXHRcdGdldERhdGFzZXRNZXRhOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHRcdGlmICghZGF0YXNldC5fbWV0YSkge1xuXHRcdFx0XHRkYXRhc2V0Ll9tZXRhID0ge307XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtZXRhID0gZGF0YXNldC5fbWV0YVttZS5pZF07XG5cdFx0XHRpZiAoIW1ldGEpIHtcblx0XHRcdFx0bWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdID0ge1xuXHRcdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdFx0ZGF0YXNldDogbnVsbCxcblx0XHRcdFx0XHRjb250cm9sbGVyOiBudWxsLFxuXHRcdFx0XHRcdGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcblx0XHRcdFx0XHR4QXhpc0lEOiBudWxsLFxuXHRcdFx0XHRcdHlBeGlzSUQ6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1ldGE7XG5cdFx0fSxcblxuXHRcdGdldFZpc2libGVEYXRhc2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvdW50ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpZiAodGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRpc0RhdGFzZXRWaXNpYmxlOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHQvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG5cdFx0XHQvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXG5cdFx0XHRyZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uaGlkZGVuO1xuXHRcdH0sXG5cblx0XHRnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxlZ2VuZENhbGxiYWNrKHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3lEYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzLmlkO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBtZXRhID0gZGF0YXNldC5fbWV0YSAmJiBkYXRhc2V0Ll9tZXRhW2lkXTtcblxuXHRcdFx0aWYgKG1ldGEpIHtcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLmRlc3Ryb3koKTtcblx0XHRcdFx0ZGVsZXRlIGRhdGFzZXQuX21ldGFbaWRdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdFx0dmFyIGksIGlsZW47XG5cblx0XHRcdG1lLnN0b3AoKTtcblxuXHRcdFx0Ly8gZGF0YXNldCBjb250cm9sbGVycyBuZWVkIHRvIGNsZWFudXAgYXNzb2NpYXRlZCBkYXRhXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2FudmFzKSB7XG5cdFx0XHRcdG1lLnVuYmluZEV2ZW50cygpO1xuXHRcdFx0XHRoZWxwZXJzLmNhbnZhcy5jbGVhcihtZSk7XG5cdFx0XHRcdHBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KG1lLmN0eCk7XG5cdFx0XHRcdG1lLmNhbnZhcyA9IG51bGw7XG5cdFx0XHRcdG1lLmN0eCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnZGVzdHJveScpO1xuXG5cdFx0XHRkZWxldGUgQ2hhcnQuaW5zdGFuY2VzW21lLmlkXTtcblx0XHR9LFxuXG5cdFx0dG9CYXNlNjRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRpbml0VG9vbFRpcDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0bWUudG9vbHRpcCA9IG5ldyBDaGFydC5Ub29sdGlwKHtcblx0XHRcdFx0X2NoYXJ0OiBtZSxcblx0XHRcdFx0X2NoYXJ0SW5zdGFuY2U6IG1lLCAvLyBkZXByZWNhdGVkLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdF9kYXRhOiBtZS5kYXRhLFxuXHRcdFx0XHRfb3B0aW9uczogbWUub3B0aW9ucy50b29sdGlwc1xuXHRcdFx0fSwgbWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzID0ge307XG5cdFx0XHR2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUuZXZlbnRIYW5kbGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1lLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0bGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRWxlbWVudHMgdXNlZCB0byBkZXRlY3Qgc2l6ZSBjaGFuZ2Ugc2hvdWxkIG5vdCBiZSBpbmplY3RlZCBmb3Igbm9uIHJlc3BvbnNpdmUgY2hhcnRzLlxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMjEwXG5cdFx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0bWUucmVzaXplKCk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcblx0XHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9IG1lLl9saXN0ZW5lcnM7XG5cdFx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBtZS5fbGlzdGVuZXJzO1xuXHRcdFx0aGVscGVycy5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcblx0XHRcdFx0cGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnRzLCBtb2RlLCBlbmFibGVkKSB7XG5cdFx0XHR2YXIgbWV0aG9kID0gZW5hYmxlZCA/ICdzZXRIb3ZlclN0eWxlJyA6ICdyZW1vdmVIb3ZlclN0eWxlJztcblx0XHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcblx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHR0aGlzLmdldERhdGFzZXRNZXRhKGVsZW1lbnQuX2RhdGFzZXRJbmRleCkuY29udHJvbGxlclttZXRob2RdKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZXZlbnRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVFdmVudCcsIFtlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnVmZmVyIGFueSB1cGRhdGUgY2FsbHMgc28gdGhhdCByZW5kZXJzIGRvIG5vdCBvY2N1clxuXHRcdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gdHJ1ZTtcblx0XHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0XHR2YXIgY2hhbmdlZCA9IG1lLmhhbmRsZUV2ZW50KGUpO1xuXHRcdFx0Y2hhbmdlZCB8PSB0b29sdGlwICYmIHRvb2x0aXAuaGFuZGxlRXZlbnQoZSk7XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJFdmVudCcsIFtlXSk7XG5cblx0XHRcdHZhciBidWZmZXJlZFJlcXVlc3QgPSBtZS5fYnVmZmVyZWRSZXF1ZXN0O1xuXHRcdFx0aWYgKGJ1ZmZlcmVkUmVxdWVzdCkge1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIHVwZGF0ZSB0aGF0IHdhcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gZG8gYSBub3JtYWwgcmVuZGVyXG5cdFx0XHRcdG1lLnJlbmRlcihidWZmZXJlZFJlcXVlc3QpO1xuXHRcdFx0fSBlbHNlIGlmIChjaGFuZ2VkICYmICFtZS5hbmltYXRpbmcpIHtcblx0XHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XG5cdFx0XHRcdG1lLnN0b3AoKTtcblxuXHRcdFx0XHQvLyBXZSBvbmx5IG5lZWQgdG8gcmVuZGVyIGF0IHRoaXMgcG9pbnQuIFVwZGF0aW5nIHdpbGwgY2F1c2Ugc2NhbGVzIHRvIGJlXG5cdFx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXG5cdFx0XHRcdG1lLnJlbmRlcihtZS5vcHRpb25zLmhvdmVyLmFuaW1hdGlvbkR1cmF0aW9uLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gaGFuZGxlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdFx0ICovXG5cdFx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG5cdFx0XHR2YXIgaG92ZXJPcHRpb25zID0gb3B0aW9ucy5ob3Zlcjtcblx0XHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgaG92ZXIgYW5kIHRvb2x0aXBzXG5cdFx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG5cdFx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuYWN0aXZlID0gbWUuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW52b2tlIG9uSG92ZXIgaG9va1xuXHRcdFx0Ly8gTmVlZCB0byBjYWxsIHdpdGggbmF0aXZlIGV2ZW50IGhlcmUgdG8gbm90IGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciB8fCBvcHRpb25zLmhvdmVyLm9uSG92ZXIsIFtlLm5hdGl2ZSwgbWUuYWN0aXZlXSwgbWUpO1xuXG5cdFx0XHRpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLm9uQ2xpY2spIHtcblx0XHRcdFx0XHQvLyBVc2UgZS5uYXRpdmUgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0XHRvcHRpb25zLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmFjdGl2ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXG5cdFx0XHRpZiAobWUubGFzdEFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdFx0bWUudXBkYXRlSG92ZXJTdHlsZShtZS5sYXN0QWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdWlsdCBpbiBob3ZlciBzdHlsaW5nXG5cdFx0XHRpZiAobWUuYWN0aXZlLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuXHRcdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFuZ2VkID0gIWhlbHBlcnMuYXJyYXlFcXVhbHMobWUuYWN0aXZlLCBtZS5sYXN0QWN0aXZlKTtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG5cdFx0XHRtZS5sYXN0QWN0aXZlID0gbWUuYWN0aXZlO1xuXG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0IGluc3RlYWQuXG5cdCAqIEBjbGFzcyBDaGFydC5Db250cm9sbGVyXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Q2hhcnQuQ29udHJvbGxlciA9IENoYXJ0O1xufTtcblxufSx7XCIyNVwiOjI1LFwiMjhcIjoyOCxcIjQ1XCI6NDUsXCI0OFwiOjQ4fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuXG5cdC8qKlxuXHQgKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuXHQgKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG5cdCAqIGNhbGxlZCBvbiB0aGUgJ29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBvbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdFx0aWYgKGFycmF5Ll9jaGFydGpzKSB7XG5cdFx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdGxpc3RlbmVyczogW2xpc3RlbmVyXVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciBtZXRob2QgPSAnb25EYXRhJyArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcblx0XHRcdHZhciBiYXNlID0gYXJyYXlba2V5XTtcblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMsIGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRvYmplY3RbbWV0aG9kXS5hcHBseShvYmplY3QsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYXJyYXkgZXZlbnQgbGlzdGVuZXIgYW5kIGNsZWFudXAgZXh0cmEgYXR0YWNoZWQgcHJvcGVydGllcyAoc3VjaCBhc1xuXHQgKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuXHRcdGlmICghc3R1Yikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcblx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlbGV0ZSBhcnJheVtrZXldO1xuXHRcdH0pO1xuXG5cdFx0ZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xuXHR9XG5cblx0Ly8gQmFzZSBjbGFzcyBmb3IgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgKGxpbmUsIGJhciwgZXRjKVxuXHRDaGFydC5EYXRhc2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR0aGlzLmluaXRpYWxpemUoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cdH07XG5cblx0aGVscGVycy5leHRlbmQoQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cblx0XHQvKipcblx0XHQgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmUpLlxuXHRcdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdFx0ICovXG5cdFx0ZGF0YXNldEVsZW1lbnRUeXBlOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludCkuXG5cdFx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cblx0XHQgKi9cblx0XHRkYXRhRWxlbWVudFR5cGU6IG51bGwsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0bWUuY2hhcnQgPSBjaGFydDtcblx0XHRcdG1lLmluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdFx0bWUubGlua1NjYWxlcygpO1xuXHRcdFx0bWUuYWRkRWxlbWVudHMoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcblx0XHR9LFxuXG5cdFx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblxuXHRcdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZXRhLnhBeGlzSUQgPSBkYXRhc2V0LnhBeGlzSUQgfHwgbWUuY2hhcnQub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0uaWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsKSB7XG5cdFx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy55QXhlc1swXS5pZDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0RGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuXHRcdH0sXG5cblx0XHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuXHRcdH0sXG5cblx0XHRnZXRTY2FsZUZvcklkOiBmdW5jdGlvbihzY2FsZUlEKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudXBkYXRlKHRydWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX2RhdGEpIHtcblx0XHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0eXBlID0gbWUuZGF0YXNldEVsZW1lbnRUeXBlO1xuXHRcdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGNyZWF0ZU1ldGFEYXRhOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0eXBlID0gbWUuZGF0YUVsZW1lbnRUeXBlO1xuXHRcdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdFx0X2luZGV4OiBpbmRleFxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGFkZEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGEgfHwgW107XG5cdFx0XHR2YXIgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG5cdFx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XG5cdFx0XHR9XG5cblx0XHRcdG1ldGEuZGF0YXNldCA9IG1ldGEuZGF0YXNldCB8fCBtZS5jcmVhdGVNZXRhRGF0YXNldCgpO1xuXHRcdH0sXG5cblx0XHRhZGRFbGVtZW50QW5kUmVzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlTWV0YURhdGEoaW5kZXgpO1xuXHRcdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuXHRcdFx0dGhpcy51cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG5cblx0XHRcdC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuIHRodXMgc2ltdWxhdGVcblx0XHRcdC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuXHRcdFx0Ly8gdGhlIGludGVybmFsIG1ldGEgZGF0YSBhY2NvcmRpbmdseS5cblx0XHRcdGlmIChtZS5fZGF0YSAhPT0gZGF0YSkge1xuXHRcdFx0XHRpZiAobWUuX2RhdGEpIHtcblx0XHRcdFx0XHQvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuXHRcdFx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHMobWUuX2RhdGEsIG1lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIG1lKTtcblx0XHRcdFx0bWUuX2RhdGEgPSBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuXHRcdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cblx0XHRcdG1lLnJlc3luY0VsZW1lbnRzKCk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogaGVscGVycy5ub29wLFxuXG5cdFx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0ZWxlbWVudHNbaV0udHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtZXRhLmRhdGFzZXQpIHtcblx0XHRcdFx0bWV0YS5kYXRhc2V0LnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0aWYgKG1ldGEuZGF0YXNldCkge1xuXHRcdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRlbGVtZW50c1tpXS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGVsZW1lbnRPcHRzKSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblx0XHRcdHZhciBtb2RlbCA9IGVsZW1lbnQuX21vZGVsO1xuXG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuYmFja2dyb3VuZENvbG9yLCBpbmRleCwgZWxlbWVudE9wdHMuYmFja2dyb3VuZENvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJDb2xvciwgaW5kZXgsIGVsZW1lbnRPcHRzLmJvcmRlckNvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJXaWR0aCwgaW5kZXgsIGVsZW1lbnRPcHRzLmJvcmRlcldpZHRoKTtcblx0XHR9LFxuXG5cdFx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZWxlbWVudC5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHRcdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cdFx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMuZ2V0SG92ZXJDb2xvcjtcblx0XHRcdHZhciBtb2RlbCA9IGVsZW1lbnQuX21vZGVsO1xuXG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgOiB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LmhvdmVyQmFja2dyb3VuZENvbG9yLCBpbmRleCwgZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IgPyBjdXN0b20uaG92ZXJCb3JkZXJDb2xvciA6IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCb3JkZXJDb2xvciwgaW5kZXgsIGdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGggPyBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA6IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgaW5kZXgsIG1vZGVsLmJvcmRlcldpZHRoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRyZXN5bmNFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhO1xuXHRcdFx0dmFyIG51bU1ldGEgPSBtZXRhLmRhdGEubGVuZ3RoO1xuXHRcdFx0dmFyIG51bURhdGEgPSBkYXRhLmxlbmd0aDtcblxuXHRcdFx0aWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG5cdFx0XHRcdG1ldGEuZGF0YS5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuXHRcdFx0fSBlbHNlIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuXHRcdFx0XHRtZS5pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0aW5zZXJ0RWxlbWVudHM6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRcdHRoaXMuYWRkRWxlbWVudEFuZFJlc2V0KHN0YXJ0ICsgaSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0b25EYXRhUHVzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gMSwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0b25EYXRhUG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEucG9wKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0b25EYXRhU2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zaGlmdCgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG9uRGF0YVNwbGljZTogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuXHRcdFx0dGhpcy5pbnNlcnRFbGVtZW50cyhzdGFydCwgYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG9uRGF0YVVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pbnNlcnRFbGVtZW50cygwLCBhcmd1bWVudHMubGVuZ3RoKTtcblx0XHR9XG5cdH0pO1xuXG5cdENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XG59O1xuXG59LHtcIjQ1XCI6NDV9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZXMpIHtcblx0XHRyZXR1cm4gaGVscGVycy5tZXJnZSh0aGlzW3Njb3BlXSB8fCAodGhpc1tzY29wZV0gPSB7fSksIHZhbHVlcyk7XG5cdH1cbn07XG5cbn0se1wiNDVcIjo0NX1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbG9yID0gcmVxdWlyZSgzKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSkge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vZGVsKTtcblx0dmFyIGksIGlsZW4sIGtleSwgYWN0dWFsLCBvcmlnaW4sIHRhcmdldCwgdHlwZSwgYzAsIGMxO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGtleSA9IGtleXNbaV07XG5cblx0XHR0YXJnZXQgPSBtb2RlbFtrZXldO1xuXG5cdFx0Ly8gaWYgYSB2YWx1ZSBpcyBhZGRlZCB0byB0aGUgbW9kZWwgYWZ0ZXIgcGl2b3QoKSBoYXMgYmVlbiBjYWxsZWQsIHRoZSB2aWV3XG5cdFx0Ly8gZG9lc24ndCBjb250YWluIGl0LCBzbyBsZXQncyBpbml0aWFsaXplIHRoZSB2aWV3IHRvIHRoZSB0YXJnZXQgdmFsdWUuXG5cdFx0aWYgKCF2aWV3Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0XHR9XG5cblx0XHRhY3R1YWwgPSB2aWV3W2tleV07XG5cblx0XHRpZiAoYWN0dWFsID09PSB0YXJnZXQgfHwga2V5WzBdID09PSAnXycpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghc3RhcnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0c3RhcnRba2V5XSA9IGFjdHVhbDtcblx0XHR9XG5cblx0XHRvcmlnaW4gPSBzdGFydFtrZXldO1xuXG5cdFx0dHlwZSA9IHR5cGVvZiB0YXJnZXQ7XG5cblx0XHRpZiAodHlwZSA9PT0gdHlwZW9mIG9yaWdpbikge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGMwID0gY29sb3Iob3JpZ2luKTtcblx0XHRcdFx0aWYgKGMwLnZhbGlkKSB7XG5cdFx0XHRcdFx0YzEgPSBjb2xvcih0YXJnZXQpO1xuXHRcdFx0XHRcdGlmIChjMS52YWxpZCkge1xuXHRcdFx0XHRcdFx0dmlld1trZXldID0gYzEubWl4KGMwLCBlYXNlKS5yZ2JTdHJpbmcoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShvcmlnaW4pICYmIGlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdFx0dmlld1trZXldID0gb3JpZ2luICsgKHRhcmdldCAtIG9yaWdpbikgKiBlYXNlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XG5cdH1cbn1cblxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XG5cdGhlbHBlcnMuZXh0ZW5kKHRoaXMsIGNvbmZpZ3VyYXRpb24pO1xuXHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmhlbHBlcnMuZXh0ZW5kKEVsZW1lbnQucHJvdG90eXBlLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oaWRkZW4gPSBmYWxzZTtcblx0fSxcblxuXHRwaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAoIW1lLl92aWV3KSB7XG5cdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMuY2xvbmUobWUuX21vZGVsKTtcblx0XHR9XG5cdFx0bWUuX3N0YXJ0ID0ge307XG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2UpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcblx0XHR2YXIgc3RhcnQgPSBtZS5fc3RhcnQ7XG5cdFx0dmFyIHZpZXcgPSBtZS5fdmlldztcblxuXHRcdC8vIE5vIGFuaW1hdGlvbiAtPiBObyBUcmFuc2l0aW9uXG5cdFx0aWYgKCFtb2RlbCB8fCBlYXNlID09PSAxKSB7XG5cdFx0XHRtZS5fdmlldyA9IG1vZGVsO1xuXHRcdFx0bWUuX3N0YXJ0ID0gbnVsbDtcblx0XHRcdHJldHVybiBtZTtcblx0XHR9XG5cblx0XHRpZiAoIXZpZXcpIHtcblx0XHRcdHZpZXcgPSBtZS5fdmlldyA9IHt9O1xuXHRcdH1cblxuXHRcdGlmICghc3RhcnQpIHtcblx0XHRcdHN0YXJ0ID0gbWUuX3N0YXJ0ID0ge307XG5cdFx0fVxuXG5cdFx0aW50ZXJwb2xhdGUoc3RhcnQsIHZpZXcsIG1vZGVsLCBlYXNlKTtcblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB0aGlzLl9tb2RlbC54LFxuXHRcdFx0eTogdGhpcy5fbW9kZWwueVxuXHRcdH07XG5cdH0sXG5cblx0aGFzVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBoZWxwZXJzLmlzTnVtYmVyKHRoaXMuX21vZGVsLngpICYmIGhlbHBlcnMuaXNOdW1iZXIodGhpcy5fbW9kZWwueSk7XG5cdH1cbn0pO1xuXG5FbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxufSx7XCIzXCI6MyxcIjQ1XCI6NDV9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBnbG9iYWwgd2luZG93OiBmYWxzZSAqL1xuLyogZ2xvYmFsIGRvY3VtZW50OiBmYWxzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29sb3IgPSByZXF1aXJlKDMpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Ly8gLS0gQmFzaWMganMgdXRpbGl0eSBtZXRob2RzXG5cblx0aGVscGVycy5leHRlbmQgPSBmdW5jdGlvbihiYXNlKSB7XG5cdFx0dmFyIHNldEZuID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0YmFzZVtrZXldID0gdmFsdWU7XG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMSwgaWxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRcdGhlbHBlcnMuZWFjaChhcmd1bWVudHNbaV0sIHNldEZuKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH07XG5cblx0aGVscGVycy5jb25maWdNZXJnZSA9IGZ1bmN0aW9uKC8qIG9iamVjdHMgLi4uICovKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UoaGVscGVycy5jbG9uZShhcmd1bWVudHNbMF0pLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHtcblx0XHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldIHx8IHt9O1xuXHRcdFx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzY2FsZXMnKSB7XG5cdFx0XHRcdFx0Ly8gc2NhbGUgY29uZmlnIG1lcmdpbmcgaXMgY29tcGxleC4gQWRkIG91ciBvd24gZnVuY3Rpb24gaGVyZSBmb3IgdGhhdFxuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycy5zY2FsZU1lcmdlKHR2YWwsIHN2YWwpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xuXHRcdFx0XHRcdC8vIHVzZWQgaW4gcG9sYXIgYXJlYSAmIHJhZGFyIGNoYXJ0cyBzaW5jZSB0aGVyZSBpcyBvbmx5IG9uZSBzY2FsZVxuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycy5tZXJnZSh0dmFsLCBbQ2hhcnQuc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoc3ZhbC50eXBlKSwgc3ZhbF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhlbHBlcnMuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdGhlbHBlcnMuc2NhbGVNZXJnZSA9IGZ1bmN0aW9uKC8qIG9iamVjdHMgLi4uICovKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UoaGVscGVycy5jbG9uZShhcmd1bWVudHNbMF0pLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHtcblx0XHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0XHRpZiAoa2V5ID09PSAneEF4ZXMnIHx8IGtleSA9PT0gJ3lBeGVzJykge1xuXHRcdFx0XHRcdHZhciBzbGVuID0gc291cmNlW2tleV0ubGVuZ3RoO1xuXHRcdFx0XHRcdHZhciBpLCB0eXBlLCBzY2FsZTtcblxuXHRcdFx0XHRcdGlmICghdGFyZ2V0W2tleV0pIHtcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNsZW47ICsraSkge1xuXHRcdFx0XHRcdFx0c2NhbGUgPSBzb3VyY2Vba2V5XVtpXTtcblx0XHRcdFx0XHRcdHR5cGUgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KHNjYWxlLnR5cGUsIGtleSA9PT0gJ3hBeGVzJyA/ICdjYXRlZ29yeScgOiAnbGluZWFyJyk7XG5cblx0XHRcdFx0XHRcdGlmIChpID49IHRhcmdldFtrZXldLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRba2V5XS5wdXNoKHt9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XVtpXS50eXBlIHx8IChzY2FsZS50eXBlICYmIHNjYWxlLnR5cGUgIT09IHRhcmdldFtrZXldW2ldLnR5cGUpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG5ldy91bnR5cGVkIHNjYWxlIG9yIHR5cGUgY2hhbmdlZDogbGV0J3MgYXBwbHkgdGhlIG5ldyBkZWZhdWx0c1xuXHRcdFx0XHRcdFx0XHQvLyB0aGVuIG1lcmdlIHNvdXJjZSBzY2FsZSB0byBjb3JyZWN0bHkgb3ZlcndyaXRlIHRoZSBkZWZhdWx0cy5cblx0XHRcdFx0XHRcdFx0aGVscGVycy5tZXJnZSh0YXJnZXRba2V5XVtpXSwgW0NoYXJ0LnNjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHR5cGUpLCBzY2FsZV0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gc2NhbGVzIHR5cGUgYXJlIHRoZSBzYW1lXG5cdFx0XHRcdFx0XHRcdGhlbHBlcnMubWVyZ2UodGFyZ2V0W2tleV1baV0sIHNjYWxlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVscGVycy5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0aGVscGVycy53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheShjb2xsZWN0aW9uKSAmJiBBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG5cdFx0XHRyZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoZmlsdGVyQ2FsbGJhY2spO1xuXHRcdH1cblx0XHR2YXIgZmlsdGVyZWQgPSBbXTtcblxuXHRcdGhlbHBlcnMuZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soaXRlbSkpIHtcblx0XHRcdFx0ZmlsdGVyZWQucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBmaWx0ZXJlZDtcblx0fTtcblx0aGVscGVycy5maW5kSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID9cblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzLmZpbmROZXh0V2hlcmUgPSBmdW5jdGlvbihhcnJheVRvU2VhcmNoLCBmaWx0ZXJDYWxsYmFjaywgc3RhcnRJbmRleCkge1xuXHRcdC8vIERlZmF1bHQgdG8gc3RhcnQgb2YgdGhlIGFycmF5XG5cdFx0aWYgKGhlbHBlcnMuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xuXHRcdFx0c3RhcnRJbmRleCA9IC0xO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBhcnJheVRvU2VhcmNoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VycmVudEl0ZW0gPSBhcnJheVRvU2VhcmNoW2ldO1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycy5pc051bGxPclVuZGVmKHN0YXJ0SW5kZXgpKSB7XG5cdFx0XHRzdGFydEluZGV4ID0gYXJyYXlUb1NlYXJjaC5sZW5ndGg7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBzdGFydEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soY3VycmVudEl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50SXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGhlbHBlcnMuaW5oZXJpdHMgPSBmdW5jdGlvbihleHRlbnNpb25zKSB7XG5cdFx0Ly8gQmFzaWMgamF2YXNjcmlwdCBpbmhlcml0YW5jZSBiYXNlZCBvbiB0aGUgbW9kZWwgY3JlYXRlZCBpbiBCYWNrYm9uZS5qc1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIENoYXJ0RWxlbWVudCA9IChleHRlbnNpb25zICYmIGV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpID8gZXh0ZW5zaW9ucy5jb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY29uc3RydWN0b3IgPSBDaGFydEVsZW1lbnQ7XG5cdFx0fTtcblx0XHRTdXJyb2dhdGUucHJvdG90eXBlID0gbWUucHJvdG90eXBlO1xuXHRcdENoYXJ0RWxlbWVudC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XG5cblx0XHRDaGFydEVsZW1lbnQuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcblxuXHRcdGlmIChleHRlbnNpb25zKSB7XG5cdFx0XHRoZWxwZXJzLmV4dGVuZChDaGFydEVsZW1lbnQucHJvdG90eXBlLCBleHRlbnNpb25zKTtcblx0XHR9XG5cblx0XHRDaGFydEVsZW1lbnQuX19zdXBlcl9fID0gbWUucHJvdG90eXBlO1xuXG5cdFx0cmV0dXJuIENoYXJ0RWxlbWVudDtcblx0fTtcblx0Ly8gLS0gTWF0aCBtZXRob2RzXG5cdGhlbHBlcnMuaXNOdW1iZXIgPSBmdW5jdGlvbihuKSB7XG5cdFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcblx0fTtcblx0aGVscGVycy5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbih4LCB5LCBlcHNpbG9uKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG5cdH07XG5cdGhlbHBlcnMuYWxtb3N0V2hvbGUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG5cdFx0dmFyIHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuXHRcdHJldHVybiAoKChyb3VuZGVkIC0gZXBzaWxvbikgPCB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+IHgpKTtcblx0fTtcblx0aGVscGVycy5tYXggPSBmdW5jdGlvbihhcnJheSkge1xuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWF4LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KG1heCwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heDtcblx0XHR9LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuXHR9O1xuXHRoZWxwZXJzLm1pbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtaW4sIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4obWluLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWluO1xuXHRcdH0sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMuc2lnbiA9IE1hdGguc2lnbiA/XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc2lnbih4KTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHR4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcblx0XHRcdGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKSB7XG5cdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHggPiAwID8gMSA6IC0xO1xuXHRcdH07XG5cdGhlbHBlcnMubG9nMTAgPSBNYXRoLmxvZzEwID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5sb2cxMCh4KTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG5cdFx0fTtcblx0aGVscGVycy50b1JhZGlhbnMgPSBmdW5jdGlvbihkZWdyZWVzKSB7XG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdH07XG5cdGhlbHBlcnMudG9EZWdyZWVzID0gZnVuY3Rpb24ocmFkaWFucykge1xuXHRcdHJldHVybiByYWRpYW5zICogKDE4MCAvIE1hdGguUEkpO1xuXHR9O1xuXHQvLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuXHRoZWxwZXJzLmdldEFuZ2xlRnJvbVBvaW50ID0gZnVuY3Rpb24oY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcblx0XHR2YXIgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG5cdFx0dmFyIGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuXHRcdHZhciByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cblx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGRpc3RhbmNlRnJvbVlDZW50ZXIsIGRpc3RhbmNlRnJvbVhDZW50ZXIpO1xuXG5cdFx0aWYgKGFuZ2xlIDwgKC0wLjUgKiBNYXRoLlBJKSkge1xuXHRcdFx0YW5nbGUgKz0gMi4wICogTWF0aC5QSTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YW5nbGU6IGFuZ2xlLFxuXHRcdFx0ZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuXHRcdH07XG5cdH07XG5cdGhlbHBlcnMuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24ocHQxLCBwdDIpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xuXHR9O1xuXHRoZWxwZXJzLmFsaWFzUGl4ZWwgPSBmdW5jdGlvbihwaXhlbFdpZHRoKSB7XG5cdFx0cmV0dXJuIChwaXhlbFdpZHRoICUgMiA9PT0gMCkgPyAwIDogMC41O1xuXHR9O1xuXHRoZWxwZXJzLnNwbGluZUN1cnZlID0gZnVuY3Rpb24oZmlyc3RQb2ludCwgbWlkZGxlUG9pbnQsIGFmdGVyUG9pbnQsIHQpIHtcblx0XHQvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcblx0XHQvLyBodHRwOi8vc2NhbGVkaW5ub3ZhdGlvbi5jb20vYW5hbHl0aWNzL3NwbGluZXMvYWJvdXRTcGxpbmVzLmh0bWxcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBhbHNvIHJlc3BlY3QgXCJza2lwcGVkXCIgcG9pbnRzXG5cblx0XHR2YXIgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG5cdFx0dmFyIGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcblx0XHR2YXIgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcblxuXHRcdHZhciBkMDEgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudC54IC0gcHJldmlvdXMueCwgMikgKyBNYXRoLnBvdyhjdXJyZW50LnkgLSBwcmV2aW91cy55LCAyKSk7XG5cdFx0dmFyIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyhuZXh0LnggLSBjdXJyZW50LngsIDIpICsgTWF0aC5wb3cobmV4dC55IC0gY3VycmVudC55LCAyKSk7XG5cblx0XHR2YXIgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG5cdFx0dmFyIHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuXG5cdFx0Ly8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuXHRcdHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuXHRcdHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuXG5cdFx0dmFyIGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG5cdFx0dmFyIGZiID0gdCAqIHMxMjtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRwcmV2aW91czoge1xuXHRcdFx0XHR4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcblx0XHRcdFx0eTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcblx0XHRcdH0sXG5cdFx0XHRuZXh0OiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGhlbHBlcnMuRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXHRoZWxwZXJzLnNwbGluZUN1cnZlTW9ub3RvbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcblx0XHQvLyBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG5cdFx0Ly8gYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cblxuXHRcdHZhciBwb2ludHNXaXRoVGFuZ2VudHMgPSAocG9pbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGVsOiBwb2ludC5fbW9kZWwsXG5cdFx0XHRcdGRlbHRhSzogMCxcblx0XHRcdFx0bUs6IDBcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcblx0XHR2YXIgcG9pbnRzTGVuID0gcG9pbnRzV2l0aFRhbmdlbnRzLmxlbmd0aDtcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHZhciBzbG9wZURlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCk7XG5cblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG5cdFx0XHRcdHBvaW50Q3VycmVudC5kZWx0YUsgPSBzbG9wZURlbHRhWCAhPT0gMCA/IChwb2ludEFmdGVyLm1vZGVsLnkgLSBwb2ludEN1cnJlbnQubW9kZWwueSkgLyBzbG9wZURlbHRhWCA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcG9pbnRCZWZvcmUgfHwgcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRCZWZvcmUuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpZ24ocG9pbnRCZWZvcmUuZGVsdGFLKSAhPT0gdGhpcy5zaWduKHBvaW50Q3VycmVudC5kZWx0YUspKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAocG9pbnRCZWZvcmUuZGVsdGFLICsgcG9pbnRDdXJyZW50LmRlbHRhSykgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcblx0XHR2YXIgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRwb2ludEFmdGVyID0gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoZWxwZXJzLmFsbW9zdEVxdWFscyhwb2ludEN1cnJlbnQuZGVsdGFLLCAwLCB0aGlzLkVQU0lMT04pKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50QWZ0ZXIubUsgPSAwO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0YWxwaGFLID0gcG9pbnRDdXJyZW50Lm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdGJldGFLID0gcG9pbnRBZnRlci5tSyAvIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcblx0XHRcdGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuXHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gYWxwaGFLICogdGF1SyAqIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRwb2ludEFmdGVyLm1LID0gYmV0YUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlIGNvbnRyb2wgcG9pbnRzXG5cdFx0dmFyIGRlbHRhWDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRCZWZvcmUgJiYgIXBvaW50QmVmb3JlLm1vZGVsLnNraXApIHtcblx0XHRcdFx0ZGVsdGFYID0gKHBvaW50Q3VycmVudC5tb2RlbC54IC0gcG9pbnRCZWZvcmUubW9kZWwueCkgLyAzO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggLSBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBwb2ludEN1cnJlbnQubW9kZWwueSAtIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcblx0XHRcdH1cblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0ZGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IHBvaW50Q3VycmVudC5tb2RlbC54ICsgZGVsdGFYO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBwb2ludEN1cnJlbnQubW9kZWwueSArIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGhlbHBlcnMubmV4dEl0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvblswXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0fTtcblx0aGVscGVycy5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHR9O1xuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuXHRoZWxwZXJzLm5pY2VOdW0gPSBmdW5jdGlvbihyYW5nZSwgcm91bmQpIHtcblx0XHR2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKGhlbHBlcnMubG9nMTAocmFuZ2UpKTtcblx0XHR2YXIgZnJhY3Rpb24gPSByYW5nZSAvIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG5cdFx0dmFyIG5pY2VGcmFjdGlvbjtcblxuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0aWYgKGZyYWN0aW9uIDwgMS41KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgMykge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDcpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMS4wKSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMikge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDUpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdH1cblxuXHRcdHJldHVybiBuaWNlRnJhY3Rpb24gKiBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHR9O1xuXHQvLyBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbCAtIGh0dHA6Ly93d3cucGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuXHRoZWxwZXJzLnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cdFx0XHR9O1xuXHR9KCkpO1xuXHQvLyAtLSBET00gbWV0aG9kc1xuXHRoZWxwZXJzLmdldFJlbGF0aXZlUG9zaXRpb24gPSBmdW5jdGlvbihldnQsIGNoYXJ0KSB7XG5cdFx0dmFyIG1vdXNlWCwgbW91c2VZO1xuXHRcdHZhciBlID0gZXZ0Lm9yaWdpbmFsRXZlbnQgfHwgZXZ0O1xuXHRcdHZhciBjYW52YXMgPSBldnQuY3VycmVudFRhcmdldCB8fCBldnQuc3JjRWxlbWVudDtcblx0XHR2YXIgYm91bmRpbmdSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0dmFyIHRvdWNoZXMgPSBlLnRvdWNoZXM7XG5cdFx0aWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtb3VzZVggPSB0b3VjaGVzWzBdLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSB0b3VjaGVzWzBdLmNsaWVudFk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0bW91c2VYID0gZS5jbGllbnRYO1xuXHRcdFx0bW91c2VZID0gZS5jbGllbnRZO1xuXHRcdH1cblxuXHRcdC8vIFNjYWxlIG1vdXNlIGNvb3JkaW5hdGVzIGludG8gY2FudmFzIGNvb3JkaW5hdGVzXG5cdFx0Ly8gYnkgZm9sbG93aW5nIHRoZSBwYXR0ZXJuIGxhaWQgb3V0IGJ5ICdqZXJyeWonIGluIHRoZSBjb21tZW50cyBvZlxuXHRcdC8vIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KGhlbHBlcnMuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1sZWZ0JykpO1xuXHRcdHZhciBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChoZWxwZXJzLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctdG9wJykpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KGhlbHBlcnMuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoaGVscGVycy5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWJvdHRvbScpKTtcblx0XHR2YXIgd2lkdGggPSBib3VuZGluZ1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXHRcdHZhciBoZWlnaHQgPSBib3VuZGluZ1JlY3QuYm90dG9tIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuXG5cdFx0Ly8gV2UgZGl2aWRlIGJ5IHRoZSBjdXJyZW50IGRldmljZSBwaXhlbCByYXRpbywgYmVjYXVzZSB0aGUgY2FudmFzIGlzIHNjYWxlZCB1cCBieSB0aGF0IGFtb3VudCBpbiBlYWNoIGRpcmVjdGlvbi4gSG93ZXZlclxuXHRcdC8vIHRoZSBiYWNrZW5kIG1vZGVsIGlzIGluIHVuc2NhbGVkIGNvb3JkaW5hdGVzLiBTaW5jZSB3ZSBhcmUgZ29pbmcgdG8gZGVhbCB3aXRoIG91ciBtb2RlbCBjb29yZGluYXRlcywgd2UgZ28gYmFjayBoZXJlXG5cdFx0bW91c2VYID0gTWF0aC5yb3VuZCgobW91c2VYIC0gYm91bmRpbmdSZWN0LmxlZnQgLSBwYWRkaW5nTGVmdCkgLyAod2lkdGgpICogY2FudmFzLndpZHRoIC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXHRcdG1vdXNlWSA9IE1hdGgucm91bmQoKG1vdXNlWSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wKSAvIChoZWlnaHQpICogY2FudmFzLmhlaWdodCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBtb3VzZVgsXG5cdFx0XHR5OiBtb3VzZVlcblx0XHR9O1xuXG5cdH07XG5cblx0Ly8gUHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuXHRmdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG5cdFx0dmFyIHZhbHVlSW5QaXhlbHM7XG5cdFx0aWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuXHRcdFx0aWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuXHRcdFx0XHQvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cblx0XHRcdFx0dmFsdWVJblBpeGVscyA9IHZhbHVlSW5QaXhlbHMgLyAxMDAgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVJblBpeGVscztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGlmIHRoZSBnaXZlbiB2YWx1ZSBjb250YWlucyBhbiBlZmZlY3RpdmUgY29uc3RyYWludC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGlzQ29uc3RyYWluZWRWYWx1ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnbm9uZSc7XG5cdH1cblxuXHQvLyBQcml2YXRlIGhlbHBlciB0byBnZXQgYSBjb25zdHJhaW50IGRpbWVuc2lvblxuXHQvLyBAcGFyYW0gZG9tTm9kZSA6IHRoZSBub2RlIHRvIGNoZWNrIHRoZSBjb25zdHJhaW50IG9uXG5cdC8vIEBwYXJhbSBtYXhTdHlsZSA6IHRoZSBzdHlsZSB0aGF0IGRlZmluZXMgdGhlIG1heGltdW0gZm9yIHRoZSBkaXJlY3Rpb24gd2UgYXJlIHVzaW5nIChtYXhXaWR0aCAvIG1heEhlaWdodClcblx0Ly8gQHBhcmFtIHBlcmNlbnRhZ2VQcm9wZXJ0eSA6IHByb3BlcnR5IG9mIHBhcmVudCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB3aWR0aCBhcyBhIHBlcmNlbnRhZ2Vcblx0Ly8gQHNlZSBodHRwOi8vd3d3Lm5hdGhhbmFlbGpvbmVzLmNvbS9ibG9nLzIwMTMvcmVhZGluZy1tYXgtd2lkdGgtY3Jvc3MtYnJvd3NlclxuXHRmdW5jdGlvbiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsIG1heFN0eWxlLCBwZXJjZW50YWdlUHJvcGVydHkpIHtcblx0XHR2YXIgdmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdHZhciBjb25zdHJhaW5lZE5vZGUgPSB2aWV3LmdldENvbXB1dGVkU3R5bGUoZG9tTm9kZSlbbWF4U3R5bGVdO1xuXHRcdHZhciBjb25zdHJhaW5lZENvbnRhaW5lciA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKVttYXhTdHlsZV07XG5cdFx0dmFyIGhhc0NOb2RlID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkTm9kZSk7XG5cdFx0dmFyIGhhc0NDb250YWluZXIgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWRDb250YWluZXIpO1xuXHRcdHZhciBpbmZpbml0eSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuXHRcdGlmIChoYXNDTm9kZSB8fCBoYXNDQ29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oXG5cdFx0XHRcdGhhc0NOb2RlID8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZE5vZGUsIGRvbU5vZGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkgOiBpbmZpbml0eSxcblx0XHRcdFx0aGFzQ0NvbnRhaW5lciA/IHBhcnNlTWF4U3R5bGUoY29uc3RyYWluZWRDb250YWluZXIsIHBhcmVudE5vZGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkgOiBpbmZpbml0eSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdub25lJztcblx0fVxuXHQvLyByZXR1cm5zIE51bWJlciBvciB1bmRlZmluZWQgaWYgbm8gY29uc3RyYWludFxuXHRoZWxwZXJzLmdldENvbnN0cmFpbnRXaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LXdpZHRoJywgJ2NsaWVudFdpZHRoJyk7XG5cdH07XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMuZ2V0Q29uc3RyYWludEhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LWhlaWdodCcsICdjbGllbnRIZWlnaHQnKTtcblx0fTtcblx0aGVscGVycy5nZXRNYXhpbXVtV2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIGRvbU5vZGUuY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0dmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoaGVscGVycy5nZXRTdHlsZShjb250YWluZXIsICdwYWRkaW5nLWxlZnQnKSwgMTApO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUludChoZWxwZXJzLmdldFN0eWxlKGNvbnRhaW5lciwgJ3BhZGRpbmctcmlnaHQnKSwgMTApO1xuXHRcdHZhciB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoIC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG5cdFx0dmFyIGN3ID0gaGVscGVycy5nZXRDb25zdHJhaW50V2lkdGgoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGN3KSA/IHcgOiBNYXRoLm1pbih3LCBjdyk7XG5cdH07XG5cdGhlbHBlcnMuZ2V0TWF4aW11bUhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRIZWlnaHQ7XG5cdFx0fVxuXG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBwYXJzZUludChoZWxwZXJzLmdldFN0eWxlKGNvbnRhaW5lciwgJ3BhZGRpbmctdG9wJyksIDEwKTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KGhlbHBlcnMuZ2V0U3R5bGUoY29udGFpbmVyLCAncGFkZGluZy1ib3R0b20nKSwgMTApO1xuXHRcdHZhciBoID0gY29udGFpbmVyLmNsaWVudEhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuXHRcdHZhciBjaCA9IGhlbHBlcnMuZ2V0Q29uc3RyYWludEhlaWdodChkb21Ob2RlKTtcblx0XHRyZXR1cm4gaXNOYU4oY2gpID8gaCA6IE1hdGgubWluKGgsIGNoKTtcblx0fTtcblx0aGVscGVycy5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBlbC5jdXJyZW50U3R5bGUgP1xuXHRcdFx0ZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XSA6XG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0fTtcblx0aGVscGVycy5yZXRpbmFTY2FsZSA9IGZ1bmN0aW9uKGNoYXJ0LCBmb3JjZVJhdGlvKSB7XG5cdFx0dmFyIHBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblx0XHRpZiAocGl4ZWxSYXRpbyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0dmFyIGhlaWdodCA9IGNoYXJ0LmhlaWdodDtcblx0XHR2YXIgd2lkdGggPSBjaGFydC53aWR0aDtcblxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRjaGFydC5jdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cblx0XHQvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuXHRcdC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG5cdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHR9O1xuXHQvLyAtLSBDYW52YXMgbWV0aG9kc1xuXHRoZWxwZXJzLmZvbnRTdHJpbmcgPSBmdW5jdGlvbihwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuXHRcdHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG5cdH07XG5cdGhlbHBlcnMubG9uZ2VzdFRleHQgPSBmdW5jdGlvbihjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG5cdFx0Y2FjaGUgPSBjYWNoZSB8fCB7fTtcblx0XHR2YXIgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuXHRcdHZhciBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cblx0XHRpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuXHRcdFx0ZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcblx0XHRcdGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcblx0XHRcdGNhY2hlLmZvbnQgPSBmb250O1xuXHRcdH1cblxuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHR2YXIgbG9uZ2VzdCA9IDA7XG5cdFx0aGVscGVycy5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcblx0XHRcdGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGhlbHBlcnMuaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcblx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcblx0XHRcdFx0Ly8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xuXHRcdFx0XHRoZWxwZXJzLmVhY2godGhpbmcsIGZ1bmN0aW9uKG5lc3RlZFRoaW5nKSB7XG5cdFx0XHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG5cdFx0XHRcdFx0aWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWhlbHBlcnMuaXNBcnJheShuZXN0ZWRUaGluZykpIHtcblx0XHRcdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzLm1lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dmFyIGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcblx0XHRpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG5cdFx0XHRcdGRlbGV0ZSBkYXRhW2djW2ldXTtcblx0XHRcdH1cblx0XHRcdGdjLnNwbGljZSgwLCBnY0xlbik7XG5cdFx0fVxuXHRcdHJldHVybiBsb25nZXN0O1xuXHR9O1xuXHRoZWxwZXJzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG5cdFx0dmFyIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcblx0XHRpZiAoIXRleHRXaWR0aCkge1xuXHRcdFx0dGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG5cdFx0XHRnYy5wdXNoKHN0cmluZyk7XG5cdFx0fVxuXHRcdGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG5cdFx0XHRsb25nZXN0ID0gdGV4dFdpZHRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblx0aGVscGVycy5udW1iZXJPZkxhYmVsTGluZXMgPSBmdW5jdGlvbihhcnJheU9mVGhpbmdzKSB7XG5cdFx0dmFyIG51bWJlck9mTGluZXMgPSAxO1xuXHRcdGhlbHBlcnMuZWFjaChhcnJheU9mVGhpbmdzLCBmdW5jdGlvbih0aGluZykge1xuXHRcdFx0aWYgKGhlbHBlcnMuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0aWYgKHRoaW5nLmxlbmd0aCA+IG51bWJlck9mTGluZXMpIHtcblx0XHRcdFx0XHRudW1iZXJPZkxpbmVzID0gdGhpbmcubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG51bWJlck9mTGluZXM7XG5cdH07XG5cblx0aGVscGVycy5jb2xvciA9ICFjb2xvciA/XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvbG9yLmpzIG5vdCBmb3VuZCEnKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFsIENhbnZhc0dyYWRpZW50ICovXG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkge1xuXHRcdFx0XHR2YWx1ZSA9IGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb2xvcih2YWx1ZSk7XG5cdFx0fTtcblxuXHRoZWxwZXJzLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XG5cdFx0LyogZ2xvYmFsIENhbnZhc1BhdHRlcm4gKi9cblx0XHRyZXR1cm4gKGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuKSA/XG5cdFx0XHRjb2xvclZhbHVlIDpcblx0XHRcdGhlbHBlcnMuY29sb3IoY29sb3JWYWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5yZ2JTdHJpbmcoKTtcblx0fTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjNcIjozLFwiNDVcIjo0NX1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHJlbGF0aXZlIHBvc2l0aW9uIGZvciBhbiBldmVudFxuICogQHBhcmFtIHtFdmVudHxJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGdldCB0aGUgcG9zaXRpb24gZm9yXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydFxuICogQHJldHVybnMge1BvaW50fSB0aGUgZXZlbnQgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCkge1xuXHRpZiAoZS5uYXRpdmUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogZS54LFxuXHRcdFx0eTogZS55XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBoZWxwZXJzLmdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB0cmF2ZXJzZSBhbGwgb2YgdGhlIHZpc2libGUgZWxlbWVudHMgaW4gdGhlIGNoYXJ0XG4gKiBAcGFyYW0gY2hhcnQge2NoYXJ0fSB0aGUgY2hhcnRcbiAqIEBwYXJhbSBoYW5kbGVyIHtGdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBoYW5kbGVyKSB7XG5cdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdHZhciBtZXRhLCBpLCBqLCBpbGVuLCBqbGVuO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpZiAoIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRmb3IgKGogPSAwLCBqbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBtZXRhLmRhdGFbal07XG5cdFx0XHRpZiAoIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xuXHRcdFx0XHRoYW5kbGVyKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIGl0ZW1zIHtDaGFydEVsZW1lbnRbXX0gZWxlbWVudHMgdG8gZmlsdGVyXG4gKiBAcGFyYW0gcG9zaXRpb24ge1BvaW50fSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikge1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gY29uc2lkZXJpbmcgYWxsIHZpc2libGUgaXRlbXMgaW4gdGVoIGNoYXJ0XG4gKiBAcGFyYW0gY2hhcnQge0NoYXJ0fSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0gcG9zaXRpb24ge1BvaW50fSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHBhcmFtIGludGVyc2VjdCB7Qm9vbGVhbn0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSBkaXN0YW5jZU1ldHJpYyB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIHByb3ZpZGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzXG4gKiBAcmV0dXJuIHtDaGFydEVsZW1lbnRbXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYykge1xuXHR2YXIgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdHZhciBuZWFyZXN0SXRlbXMgPSBbXTtcblxuXHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGlmIChpbnRlcnNlY3QgJiYgIWVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KCk7XG5cdFx0dmFyIGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG5cblx0XHRpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0bmVhcmVzdEl0ZW1zID0gW2VsZW1lbnRdO1xuXHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuXHRcdFx0Ly8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcblx0XHRcdG5lYXJlc3RJdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIG5lYXJlc3RJdGVtcztcbn1cblxuLyoqXG4gKiBHZXQgYSBkaXN0YW5jZSBtZXRyaWMgZnVuY3Rpb24gZm9yIHR3byBwb2ludHMgYmFzZWQgb24gdGhlXG4gKiBheGlzIG1vZGUgc2V0dGluZ1xuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgdGhlIGF4aXMgbW9kZS4geHx5fHh5XG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG5cdHZhciB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuXHR2YXIgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuXHRyZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcblx0XHR2YXIgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcblx0XHR2YXIgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gaW5kZXhNb2RlKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHQvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcblx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4Jztcblx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdGlmICghaXRlbXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0Y2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2l0ZW1zWzBdLl9pbmRleF07XG5cblx0XHRcdC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcblx0XHRcdGlmIChlbGVtZW50ICYmICFlbGVtZW50Ll92aWV3LnNraXApIHtcblx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIElJbnRlcmFjdGlvbk9wdGlvbnNcbiAqL1xuLyoqXG4gKiBJZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb2ludFxuICogQG5hbWUgSUludGVyZmFjZU9wdGlvbnMjYm9vbGVhblxuICogQHR5cGUgQm9vbGVhblxuICovXG5cbi8qKlxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuSW50ZXJhY3Rpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IG1vZGVzXG5cdG1vZGVzOiB7XG5cdFx0c2luZ2xlOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGVsZW1lbnRzLnNsaWNlKDAsIDEpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMubGFiZWxcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0bGFiZWw6IGluZGV4TW9kZSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSBjaGFydCB7Y2hhcnR9IHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0gZSB7RXZlbnR9IHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0gb3B0aW9ucyB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGluZGV4OiBpbmRleE1vZGUsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGluIHRoZSBzYW1lIGRhdGFzZXQuIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0XG5cdFx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIHRvIHVzZSBkdXJpbmcgaW50ZXJhY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0ZGF0YXNldDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XG5cblx0XHRcdGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGl0ZW1zID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uX2RhdGFzZXRJbmRleCkuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueC1heGlzXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMC4gVXNlIGluZGV4IG1vZGUgYW5kIGludGVyc2VjdCA9PSB0cnVlXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0J3gtYXhpcyc6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhNb2RlKGNoYXJ0LCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cblx0XHQgKiBvZiB0aGUgZXZlbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRwb2ludDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSBjaGFydCB7Y2hhcnR9IHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0gZSB7RXZlbnR9IHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0gb3B0aW9ucyB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0bmVhcmVzdDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHZhciBuZWFyZXN0SXRlbXMgPSBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBvcHRpb25zLmludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpO1xuXG5cdFx0XHQvLyBXZSBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gdGhlIGV2ZW50LiBOb3cgc29ydCBieSBzbWFsbGVzdFxuXHRcdFx0aWYgKG5lYXJlc3RJdGVtcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdG5lYXJlc3RJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHR2YXIgc2l6ZUEgPSBhLmdldEFyZWEoKTtcblx0XHRcdFx0XHR2YXIgc2l6ZUIgPSBiLmdldEFyZWEoKTtcblx0XHRcdFx0XHR2YXIgcmV0ID0gc2l6ZUEgLSBzaXplQjtcblxuXHRcdFx0XHRcdGlmIChyZXQgPT09IDApIHtcblx0XHRcdFx0XHRcdC8vIGlmIGVxdWFsIHNvcnQgYnkgZGF0YXNldCBpbmRleFxuXHRcdFx0XHRcdFx0cmV0ID0gYS5fZGF0YXNldEluZGV4IC0gYi5fZGF0YXNldEluZGV4O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSAxIGl0ZW1cblx0XHRcdHJldHVybiBuZWFyZXN0SXRlbXMuc2xpY2UoMCwgMSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHR4OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pblhSYW5nZShwb3NpdGlvbi54KSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0gY2hhcnQge2NoYXJ0fSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIGUge0V2ZW50fSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIG9wdGlvbnMge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHk6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluWVJhbmdlKHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuXHRcdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0fVxufTtcblxufSx7XCI0NVwiOjQ1fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRyZXNwb25zaXZlOiB0cnVlLFxuXHRyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb246IDAsXG5cdG1haW50YWluQXNwZWN0UmF0aW86IHRydWUsXG5cdGV2ZW50czogWydtb3VzZW1vdmUnLCAnbW91c2VvdXQnLCAnY2xpY2snLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXSxcblx0aG92ZXI6IHtcblx0XHRvbkhvdmVyOiBudWxsLFxuXHRcdG1vZGU6ICduZWFyZXN0Jyxcblx0XHRpbnRlcnNlY3Q6IHRydWUsXG5cdFx0YW5pbWF0aW9uRHVyYXRpb246IDQwMFxuXHR9LFxuXHRvbkNsaWNrOiBudWxsLFxuXHRkZWZhdWx0Q29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxuXHRkZWZhdWx0Rm9udENvbG9yOiAnIzY2NicsXG5cdGRlZmF1bHRGb250RmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG5cdGRlZmF1bHRGb250U2l6ZTogMTIsXG5cdGRlZmF1bHRGb250U3R5bGU6ICdub3JtYWwnLFxuXHRzaG93TGluZXM6IHRydWUsXG5cblx0Ly8gRWxlbWVudCBkZWZhdWx0cyBkZWZpbmVkIGluIGVsZW1lbnQgZXh0ZW5zaW9uc1xuXHRlbGVtZW50czoge30sXG5cblx0Ly8gTGF5b3V0IG9wdGlvbnMgc3VjaCBhcyBwYWRkaW5nXG5cdGxheW91dDoge1xuXHRcdHBhZGRpbmc6IHtcblx0XHRcdHRvcDogMCxcblx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0bGVmdDogMFxuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cblx0Ly8gT2NjdXB5IHRoZSBnbG9iYWwgdmFyaWFibGUgb2YgQ2hhcnQsIGFuZCBjcmVhdGUgYSBzaW1wbGUgYmFzZSBjbGFzc1xuXHR2YXIgQ2hhcnQgPSBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHR0aGlzLmNvbnN0cnVjdChpdGVtLCBjb25maWcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdENoYXJ0LkNoYXJ0ID0gQ2hhcnQ7XG5cblx0cmV0dXJuIENoYXJ0O1xufTtcblxufSx7XCIyNVwiOjI1fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0ZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcblx0XHRyZXR1cm4gaGVscGVycy53aGVyZShhcnJheSwgZnVuY3Rpb24odikge1xuXHRcdFx0cmV0dXJuIHYucG9zaXRpb24gPT09IHBvc2l0aW9uO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG5cdFx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2LCBpKSB7XG5cdFx0XHR2Ll90bXBJbmRleF8gPSBpO1xuXHRcdFx0cmV0dXJuIHY7XG5cdFx0fSk7XG5cdFx0YXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgdjAgPSByZXZlcnNlID8gYiA6IGE7XG5cdFx0XHR2YXIgdjEgPSByZXZlcnNlID8gYSA6IGI7XG5cdFx0XHRyZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuXHRcdFx0XHR2MC5fdG1wSW5kZXhfIC0gdjEuX3RtcEluZGV4XyA6XG5cdFx0XHRcdHYwLndlaWdodCAtIHYxLndlaWdodDtcblx0XHR9KTtcblx0XHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcblx0XHRcdGRlbGV0ZSB2Ll90bXBJbmRleF87XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQGludGVyZmFjZSBJTGF5b3V0SXRlbVxuXHQgKiBAcHJvcCB7U3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG5cdCAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcblx0ICogQHByb3Age051bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuXHQgKiBAcHJvcCB7Qm9vbGVhbn0gZnVsbFdpZHRoIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG5cdCAqIEBwcm9wIHtGdW5jdGlvbn0gaXNIb3Jpem9udGFsIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBsYXlvdXQgaXRlbSBpcyBob3Jpem9udGFsIChpZS4gdG9wIG9yIGJvdHRvbSlcblx0ICogQHByb3Age0Z1bmN0aW9ufSB1cGRhdGUgLSBUYWtlcyB0d28gcGFyYW1ldGVyczogd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBzaXplIG9mIGl0ZW1cblx0ICogQHByb3Age0Z1bmN0aW9ufSBnZXRQYWRkaW5nIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcblx0ICogQHByb3Age051bWJlcn0gd2lkdGggLSBXaWR0aCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG5cdCAqIEBwcm9wIHtOdW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG5cdCAqIEBwcm9wIHtOdW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcblx0ICogQHByb3Age051bWJlcn0gdG9wIC0gVG9wIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcblx0ICogQHByb3Age051bWJlcn0gcmlnaHQgLSBSaWdodCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG5cdCAqIEBwcm9wIHtOdW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG5cdCAqL1xuXG5cdC8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxuXHQvLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcblx0Ly8gSXQgaXMgdGhpcyBzZXJ2aWNlJ3MgcmVzcG9uc2liaWxpdHkgb2YgY2Fycnlpbmcgb3V0IHRoYXQgbGF5b3V0LlxuXHRDaGFydC5sYXlvdXRTZXJ2aWNlID0ge1xuXHRcdGRlZmF1bHRzOiB7fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVyIGEgYm94IHRvIGEgY2hhcnQuXG5cdFx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gYWRkIHRvIGJlIGxheWVkIG91dFxuXHRcdCAqL1xuXHRcdGFkZEJveDogZnVuY3Rpb24oY2hhcnQsIGl0ZW0pIHtcblx0XHRcdGlmICghY2hhcnQuYm94ZXMpIHtcblx0XHRcdFx0Y2hhcnQuYm94ZXMgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5pdGlhbGl6ZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZXNcblx0XHRcdGl0ZW0uZnVsbFdpZHRoID0gaXRlbS5mdWxsV2lkdGggfHwgZmFsc2U7XG5cdFx0XHRpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcblx0XHRcdGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcblxuXHRcdFx0Y2hhcnQuYm94ZXMucHVzaChpdGVtKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XG5cdFx0ICovXG5cdFx0cmVtb3ZlQm94OiBmdW5jdGlvbihjaGFydCwgbGF5b3V0SXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCBpbiB3aGljaCB0aGUgaXRlbSBsaXZlcyAob3Igd2lsbCBiZSBhZGRlZCB0bylcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cblx0XHQgKi9cblx0XHRjb25maWd1cmU6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcHJvcHMgPSBbJ2Z1bGxXaWR0aCcsICdwb3NpdGlvbicsICd3ZWlnaHQnXTtcblx0XHRcdHZhciBpbGVuID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0dmFyIHByb3A7XG5cblx0XHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0XHRpdGVtW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHRcdCAqIHRoZW4gcnVubmluZyBhIGZpdHRpbmcgYWxnb3JpdGhtXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCB0byBmaXQgaW50b1xuXHRcdCAqL1xuXHRcdHVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdGlmICghY2hhcnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGF5b3V0T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMubGF5b3V0IHx8IHt9O1xuXHRcdFx0dmFyIHBhZGRpbmcgPSBoZWxwZXJzLm9wdGlvbnMudG9QYWRkaW5nKGxheW91dE9wdGlvbnMucGFkZGluZyk7XG5cdFx0XHR2YXIgbGVmdFBhZGRpbmcgPSBwYWRkaW5nLmxlZnQ7XG5cdFx0XHR2YXIgcmlnaHRQYWRkaW5nID0gcGFkZGluZy5yaWdodDtcblx0XHRcdHZhciB0b3BQYWRkaW5nID0gcGFkZGluZy50b3A7XG5cdFx0XHR2YXIgYm90dG9tUGFkZGluZyA9IHBhZGRpbmcuYm90dG9tO1xuXG5cdFx0XHR2YXIgbGVmdEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2xlZnQnKTtcblx0XHRcdHZhciByaWdodEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ3JpZ2h0Jyk7XG5cdFx0XHR2YXIgdG9wQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAndG9wJyk7XG5cdFx0XHR2YXIgYm90dG9tQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnYm90dG9tJyk7XG5cdFx0XHR2YXIgY2hhcnRBcmVhQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnY2hhcnRBcmVhJyk7XG5cblx0XHRcdC8vIFNvcnQgYm94ZXMgYnkgd2VpZ2h0LiBBIGhpZ2hlciB3ZWlnaHQgaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcblx0XHRcdHNvcnRCeVdlaWdodChsZWZ0Qm94ZXMsIHRydWUpO1xuXHRcdFx0c29ydEJ5V2VpZ2h0KHJpZ2h0Qm94ZXMsIGZhbHNlKTtcblx0XHRcdHNvcnRCeVdlaWdodCh0b3BCb3hlcywgdHJ1ZSk7XG5cdFx0XHRzb3J0QnlXZWlnaHQoYm90dG9tQm94ZXMsIGZhbHNlKTtcblxuXHRcdFx0Ly8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuXHRcdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG5cdFx0XHQvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuXHRcdFx0Ly8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG5cdFx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcblx0XHRcdC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuXHRcdFx0Ly8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0XHQvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcblx0XHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcblx0XHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuXHRcdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdFx0Ly8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcblx0XHRcdC8vXG5cdFx0XHQvLyBXaGF0IHdlIGRvIHRvIGZpbmQgdGhlIGJlc3Qgc2l6aW5nLCB3ZSBkbyB0aGUgZm9sbG93aW5nXG5cdFx0XHQvLyAxLiBEZXRlcm1pbmUgdGhlIG1pbmltdW0gc2l6ZSBvZiB0aGUgY2hhcnQgYXJlYS5cblx0XHRcdC8vIDIuIFNwbGl0IHRoZSByZW1haW5pbmcgd2lkdGggZXF1YWxseSBiZXR3ZWVuIGVhY2ggdmVydGljYWwgYXhpc1xuXHRcdFx0Ly8gMy4gU3BsaXQgdGhlIHJlbWFpbmluZyBoZWlnaHQgZXF1YWxseSBiZXR3ZWVuIGVhY2ggaG9yaXpvbnRhbCBheGlzXG5cdFx0XHQvLyA0LiBHaXZlIGVhY2ggbGF5b3V0IHRoZSBtYXhpbXVtIHNpemUgaXQgY2FuIGJlLiBUaGUgbGF5b3V0IHdpbGwgcmV0dXJuIGl0J3MgbWluaW11bSBzaXplXG5cdFx0XHQvLyA1LiBBZGp1c3QgdGhlIHNpemVzIG9mIGVhY2ggYXhpcyBiYXNlZCBvbiBpdCdzIG1pbmltdW0gcmVwb3J0ZWQgc2l6ZS5cblx0XHRcdC8vIDYuIFJlZml0IGVhY2ggYXhpc1xuXHRcdFx0Ly8gNy4gUG9zaXRpb24gZWFjaCBheGlzIGluIHRoZSBmaW5hbCBsb2NhdGlvblxuXHRcdFx0Ly8gOC4gVGVsbCB0aGUgY2hhcnQgdGhlIGZpbmFsIGxvY2F0aW9uIG9mIHRoZSBjaGFydCBhcmVhXG5cdFx0XHQvLyA5LiBUZWxsIGFueSBheGVzIHRoYXQgb3ZlcmxheSB0aGUgY2hhcnQgYXJlYSB0aGUgcG9zaXRpb25zIG9mIHRoZSBjaGFydCBhcmVhXG5cblx0XHRcdC8vIFN0ZXAgMVxuXHRcdFx0dmFyIGNoYXJ0V2lkdGggPSB3aWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nO1xuXHRcdFx0dmFyIGNoYXJ0SGVpZ2h0ID0gaGVpZ2h0IC0gdG9wUGFkZGluZyAtIGJvdHRvbVBhZGRpbmc7XG5cdFx0XHR2YXIgY2hhcnRBcmVhV2lkdGggPSBjaGFydFdpZHRoIC8gMjsgLy8gbWluIDUwJVxuXHRcdFx0dmFyIGNoYXJ0QXJlYUhlaWdodCA9IGNoYXJ0SGVpZ2h0IC8gMjsgLy8gbWluIDUwJVxuXG5cdFx0XHQvLyBTdGVwIDJcblx0XHRcdHZhciB2ZXJ0aWNhbEJveFdpZHRoID0gKHdpZHRoIC0gY2hhcnRBcmVhV2lkdGgpIC8gKGxlZnRCb3hlcy5sZW5ndGggKyByaWdodEJveGVzLmxlbmd0aCk7XG5cblx0XHRcdC8vIFN0ZXAgM1xuXHRcdFx0dmFyIGhvcml6b250YWxCb3hIZWlnaHQgPSAoaGVpZ2h0IC0gY2hhcnRBcmVhSGVpZ2h0KSAvICh0b3BCb3hlcy5sZW5ndGggKyBib3R0b21Cb3hlcy5sZW5ndGgpO1xuXG5cdFx0XHQvLyBTdGVwIDRcblx0XHRcdHZhciBtYXhDaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGg7XG5cdFx0XHR2YXIgbWF4Q2hhcnRBcmVhSGVpZ2h0ID0gY2hhcnRIZWlnaHQ7XG5cdFx0XHR2YXIgbWluQm94U2l6ZXMgPSBbXTtcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0TWluaW11bUJveFNpemUoYm94KSB7XG5cdFx0XHRcdHZhciBtaW5TaXplO1xuXHRcdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gYm94LmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBob3Jpem9udGFsQm94SGVpZ2h0KTtcblx0XHRcdFx0XHRtYXhDaGFydEFyZWFIZWlnaHQgLT0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWluU2l6ZSA9IGJveC51cGRhdGUodmVydGljYWxCb3hXaWR0aCwgY2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0XHRtYXhDaGFydEFyZWFXaWR0aCAtPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWluQm94U2l6ZXMucHVzaCh7XG5cdFx0XHRcdFx0aG9yaXpvbnRhbDogaXNIb3Jpem9udGFsLFxuXHRcdFx0XHRcdG1pblNpemU6IG1pblNpemUsXG5cdFx0XHRcdFx0Ym94OiBib3gsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzLCB0b3BCb3hlcywgYm90dG9tQm94ZXMpLCBnZXRNaW5pbXVtQm94U2l6ZSk7XG5cblx0XHRcdC8vIElmIGEgaG9yaXpvbnRhbCBib3ggaGFzIHBhZGRpbmcsIHdlIG1vdmUgdGhlIGxlZnQgYm94ZXMgb3ZlciB0byBhdm9pZCB1Z2x5IGNoYXJ0cyAoc2VlIGlzc3VlICMyNDc4KVxuXHRcdFx0dmFyIG1heEhvcml6b250YWxMZWZ0UGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgbWF4SG9yaXpvbnRhbFJpZ2h0UGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgbWF4VmVydGljYWxUb3BQYWRkaW5nID0gMDtcblx0XHRcdHZhciBtYXhWZXJ0aWNhbEJvdHRvbVBhZGRpbmcgPSAwO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2godG9wQm94ZXMuY29uY2F0KGJvdHRvbUJveGVzKSwgZnVuY3Rpb24oaG9yaXpvbnRhbEJveCkge1xuXHRcdFx0XHRpZiAoaG9yaXpvbnRhbEJveC5nZXRQYWRkaW5nKSB7XG5cdFx0XHRcdFx0dmFyIGJveFBhZGRpbmcgPSBob3Jpem9udGFsQm94LmdldFBhZGRpbmcoKTtcblx0XHRcdFx0XHRtYXhIb3Jpem9udGFsTGVmdFBhZGRpbmcgPSBNYXRoLm1heChtYXhIb3Jpem9udGFsTGVmdFBhZGRpbmcsIGJveFBhZGRpbmcubGVmdCk7XG5cdFx0XHRcdFx0bWF4SG9yaXpvbnRhbFJpZ2h0UGFkZGluZyA9IE1hdGgubWF4KG1heEhvcml6b250YWxSaWdodFBhZGRpbmcsIGJveFBhZGRpbmcucmlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKGxlZnRCb3hlcy5jb25jYXQocmlnaHRCb3hlcyksIGZ1bmN0aW9uKHZlcnRpY2FsQm94KSB7XG5cdFx0XHRcdGlmICh2ZXJ0aWNhbEJveC5nZXRQYWRkaW5nKSB7XG5cdFx0XHRcdFx0dmFyIGJveFBhZGRpbmcgPSB2ZXJ0aWNhbEJveC5nZXRQYWRkaW5nKCk7XG5cdFx0XHRcdFx0bWF4VmVydGljYWxUb3BQYWRkaW5nID0gTWF0aC5tYXgobWF4VmVydGljYWxUb3BQYWRkaW5nLCBib3hQYWRkaW5nLnRvcCk7XG5cdFx0XHRcdFx0bWF4VmVydGljYWxCb3R0b21QYWRkaW5nID0gTWF0aC5tYXgobWF4VmVydGljYWxCb3R0b21QYWRkaW5nLCBib3hQYWRkaW5nLmJvdHRvbSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBtYXhDaGFydEFyZWFIZWlnaHQgYW5kIG1heENoYXJ0QXJlYVdpZHRoIGFyZSB0aGUgc2l6ZSB0aGUgY2hhcnQgYXJlYSBjb3VsZFxuXHRcdFx0Ly8gYmUgaWYgdGhlIGF4ZXMgYXJlIGRyYXduIGF0IHRoZWlyIG1pbmltdW0gc2l6ZXMuXG5cdFx0XHQvLyBTdGVwcyA1ICYgNlxuXHRcdFx0dmFyIHRvdGFsTGVmdEJveGVzV2lkdGggPSBsZWZ0UGFkZGluZztcblx0XHRcdHZhciB0b3RhbFJpZ2h0Qm94ZXNXaWR0aCA9IHJpZ2h0UGFkZGluZztcblx0XHRcdHZhciB0b3RhbFRvcEJveGVzSGVpZ2h0ID0gdG9wUGFkZGluZztcblx0XHRcdHZhciB0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ID0gYm90dG9tUGFkZGluZztcblxuXHRcdFx0Ly8gRnVuY3Rpb24gdG8gZml0IGEgYm94XG5cdFx0XHRmdW5jdGlvbiBmaXRCb3goYm94KSB7XG5cdFx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycy5maW5kTmV4dFdoZXJlKG1pbkJveFNpemVzLCBmdW5jdGlvbihtaW5Cb3gpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWluQm94LmJveCA9PT0gYm94O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRcdGlmIChib3guaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0XHRcdHZhciBzY2FsZU1hcmdpbiA9IHtcblx0XHRcdFx0XHRcdFx0bGVmdDogTWF0aC5tYXgodG90YWxMZWZ0Qm94ZXNXaWR0aCwgbWF4SG9yaXpvbnRhbExlZnRQYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0cmlnaHQ6IE1hdGgubWF4KHRvdGFsUmlnaHRCb3hlc1dpZHRoLCBtYXhIb3Jpem9udGFsUmlnaHRQYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0XHRib3R0b206IDBcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHVzZSBtaW4gc2l6ZSBoZXJlIGJlY2F1c2Ugb2YgbGFiZWwgcm90YXRpb24uIFdoZW4gdGhlIGxhYmVscyBhcmUgcm90YXRlZCwgdGhlaXIgcm90YXRpb24gaGlnaGx5IGRlcGVuZHNcblx0XHRcdFx0XHRcdC8vIG9uIHRoZSBtYXJnaW4uIFNvbWV0aW1lcyB0aGV5IG5lZWQgdG8gaW5jcmVhc2UgaW4gc2l6ZSBzbGlnaHRseVxuXHRcdFx0XHRcdFx0Ym94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBjaGFydEhlaWdodCAvIDIsIHNjYWxlTWFyZ2luKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLm1pblNpemUud2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSwgYW5kIGNhbGN1bGF0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgbWFyZ2lucyBmb3IgdGhlIGhvcml6b250YWwgYm94ZXNcblx0XHRcdGhlbHBlcnMuZWFjaChsZWZ0Qm94ZXMuY29uY2F0KHJpZ2h0Qm94ZXMpLCBmaXRCb3gpO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHJpZ2h0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbFJpZ2h0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBMZWZ0IGFuZCBSaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdFx0aGVscGVycy5lYWNoKHRvcEJveGVzLmNvbmNhdChib3R0b21Cb3hlcyksIGZpdEJveCk7XG5cblx0XHRcdC8vIEZpZ3VyZSBvdXQgaG93IG11Y2ggbWFyZ2luIGlzIG9uIHRoZSB0b3AgYW5kIGJvdHRvbSBvZiB0aGUgdmVydGljYWwgYm94ZXNcblx0XHRcdGhlbHBlcnMuZWFjaCh0b3BCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdHRvdGFsVG9wQm94ZXNIZWlnaHQgKz0gYm94LmhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2goYm90dG9tQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ICs9IGJveC5oZWlnaHQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZnVuY3Rpb24gZmluYWxGaXRWZXJ0aWNhbEJveChib3gpIHtcblx0XHRcdFx0dmFyIG1pbkJveFNpemUgPSBoZWxwZXJzLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pblNpemUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWluU2l6ZS5ib3ggPT09IGJveDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdFx0dG9wOiB0b3RhbFRvcEJveGVzSGVpZ2h0LFxuXHRcdFx0XHRcdGJvdHRvbTogdG90YWxCb3R0b21Cb3hlc0hlaWdodFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmIChtaW5Cb3hTaXplKSB7XG5cdFx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLm1pblNpemUud2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExldCB0aGUgbGVmdCBsYXlvdXQga25vdyB0aGUgZmluYWwgbWFyZ2luXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzKSwgZmluYWxGaXRWZXJ0aWNhbEJveCk7XG5cblx0XHRcdC8vIFJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHNpemUgb2YgZWFjaCBsYXlvdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNsaWdodGx5IGR1ZSB0byB0aGUgbWFyZ2lucyAobGFiZWwgcm90YXRpb24gZm9yIGluc3RhbmNlKVxuXHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCA9IGxlZnRQYWRkaW5nO1xuXHRcdFx0dG90YWxSaWdodEJveGVzV2lkdGggPSByaWdodFBhZGRpbmc7XG5cdFx0XHR0b3RhbFRvcEJveGVzSGVpZ2h0ID0gdG9wUGFkZGluZztcblx0XHRcdHRvdGFsQm90dG9tQm94ZXNIZWlnaHQgPSBib3R0b21QYWRkaW5nO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHJpZ2h0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbFJpZ2h0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHRvcEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0dG90YWxUb3BCb3hlc0hlaWdodCArPSBib3guaGVpZ2h0O1xuXHRcdFx0fSk7XG5cdFx0XHRoZWxwZXJzLmVhY2goYm90dG9tQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ICs9IGJveC5oZWlnaHQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gV2UgbWF5IGJlIGFkZGluZyBzb21lIHBhZGRpbmcgdG8gYWNjb3VudCBmb3Igcm90YXRlZCB4IGF4aXMgbGFiZWxzXG5cdFx0XHR2YXIgbGVmdFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heEhvcml6b250YWxMZWZ0UGFkZGluZyAtIHRvdGFsTGVmdEJveGVzV2lkdGgsIDApO1xuXHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCArPSBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdFx0dG90YWxSaWdodEJveGVzV2lkdGggKz0gTWF0aC5tYXgobWF4SG9yaXpvbnRhbFJpZ2h0UGFkZGluZyAtIHRvdGFsUmlnaHRCb3hlc1dpZHRoLCAwKTtcblxuXHRcdFx0dmFyIHRvcFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFZlcnRpY2FsVG9wUGFkZGluZyAtIHRvdGFsVG9wQm94ZXNIZWlnaHQsIDApO1xuXHRcdFx0dG90YWxUb3BCb3hlc0hlaWdodCArPSB0b3BQYWRkaW5nQWRkaXRpb247XG5cdFx0XHR0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ICs9IE1hdGgubWF4KG1heFZlcnRpY2FsQm90dG9tUGFkZGluZyAtIHRvdGFsQm90dG9tQm94ZXNIZWlnaHQsIDApO1xuXG5cdFx0XHQvLyBGaWd1cmUgb3V0IGlmIG91ciBjaGFydCBhcmVhIGNoYW5nZWQuIFRoaXMgd291bGQgb2NjdXIgaWYgdGhlIGRhdGFzZXQgbGF5b3V0IGxhYmVsIHJvdGF0aW9uXG5cdFx0XHQvLyBjaGFuZ2VkIGR1ZSB0byB0aGUgYXBwbGljYXRpb24gb2YgdGhlIG1hcmdpbnMgaW4gc3RlcCA2LiBTaW5jZSB3ZSBjYW4gb25seSBnZXQgYmlnZ2VyLCB0aGlzIGlzIHNhZmUgdG8gZG9cblx0XHRcdC8vIHdpdGhvdXQgY2FsbGluZyBgZml0YCBhZ2FpblxuXHRcdFx0dmFyIG5ld01heENoYXJ0QXJlYUhlaWdodCA9IGhlaWdodCAtIHRvdGFsVG9wQm94ZXNIZWlnaHQgLSB0b3RhbEJvdHRvbUJveGVzSGVpZ2h0O1xuXHRcdFx0dmFyIG5ld01heENoYXJ0QXJlYVdpZHRoID0gd2lkdGggLSB0b3RhbExlZnRCb3hlc1dpZHRoIC0gdG90YWxSaWdodEJveGVzV2lkdGg7XG5cblx0XHRcdGlmIChuZXdNYXhDaGFydEFyZWFXaWR0aCAhPT0gbWF4Q2hhcnRBcmVhV2lkdGggfHwgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ICE9PSBtYXhDaGFydEFyZWFIZWlnaHQpIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGxlZnRCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdFx0Ym94LmhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKHJpZ2h0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRcdGJveC5oZWlnaHQgPSBuZXdNYXhDaGFydEFyZWFIZWlnaHQ7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaCh0b3BCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdFx0aWYgKCFib3guZnVsbFdpZHRoKSB7XG5cdFx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChib3R0b21Cb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdFx0aWYgKCFib3guZnVsbFdpZHRoKSB7XG5cdFx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdFx0bWF4Q2hhcnRBcmVhV2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RlcCA3IC0gUG9zaXRpb24gdGhlIGJveGVzXG5cdFx0XHR2YXIgbGVmdCA9IGxlZnRQYWRkaW5nICsgbGVmdFBhZGRpbmdBZGRpdGlvbjtcblx0XHRcdHZhciB0b3AgPSB0b3BQYWRkaW5nICsgdG9wUGFkZGluZ0FkZGl0aW9uO1xuXG5cdFx0XHRmdW5jdGlvbiBwbGFjZUJveChib3gpIHtcblx0XHRcdFx0aWYgKGJveC5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRcdGJveC5sZWZ0ID0gYm94LmZ1bGxXaWR0aCA/IGxlZnRQYWRkaW5nIDogdG90YWxMZWZ0Qm94ZXNXaWR0aDtcblx0XHRcdFx0XHRib3gucmlnaHQgPSBib3guZnVsbFdpZHRoID8gd2lkdGggLSByaWdodFBhZGRpbmcgOiB0b3RhbExlZnRCb3hlc1dpZHRoICsgbWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0XHRcdFx0Ym94LnRvcCA9IHRvcDtcblx0XHRcdFx0XHRib3guYm90dG9tID0gdG9wICsgYm94LmhlaWdodDtcblxuXHRcdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdHRvcCA9IGJveC5ib3R0b207XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGJveC5sZWZ0ID0gbGVmdDtcblx0XHRcdFx0XHRib3gucmlnaHQgPSBsZWZ0ICsgYm94LndpZHRoO1xuXHRcdFx0XHRcdGJveC50b3AgPSB0b3RhbFRvcEJveGVzSGVpZ2h0O1xuXHRcdFx0XHRcdGJveC5ib3R0b20gPSB0b3RhbFRvcEJveGVzSGVpZ2h0ICsgbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gTW92ZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdFx0bGVmdCA9IGJveC5yaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLmNvbmNhdCh0b3BCb3hlcyksIHBsYWNlQm94KTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgY2hhcnQgd2lkdGggYW5kIGhlaWdodFxuXHRcdFx0bGVmdCArPSBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdHRvcCArPSBtYXhDaGFydEFyZWFIZWlnaHQ7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChyaWdodEJveGVzLCBwbGFjZUJveCk7XG5cdFx0XHRoZWxwZXJzLmVhY2goYm90dG9tQm94ZXMsIHBsYWNlQm94KTtcblxuXHRcdFx0Ly8gU3RlcCA4XG5cdFx0XHRjaGFydC5jaGFydEFyZWEgPSB7XG5cdFx0XHRcdGxlZnQ6IHRvdGFsTGVmdEJveGVzV2lkdGgsXG5cdFx0XHRcdHRvcDogdG90YWxUb3BCb3hlc0hlaWdodCxcblx0XHRcdFx0cmlnaHQ6IHRvdGFsTGVmdEJveGVzV2lkdGggKyBtYXhDaGFydEFyZWFXaWR0aCxcblx0XHRcdFx0Ym90dG9tOiB0b3RhbFRvcEJveGVzSGVpZ2h0ICsgbWF4Q2hhcnRBcmVhSGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBTdGVwIDlcblx0XHRcdGhlbHBlcnMuZWFjaChjaGFydEFyZWFCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdGJveC5sZWZ0ID0gY2hhcnQuY2hhcnRBcmVhLmxlZnQ7XG5cdFx0XHRcdGJveC50b3AgPSBjaGFydC5jaGFydEFyZWEudG9wO1xuXHRcdFx0XHRib3gucmlnaHQgPSBjaGFydC5jaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRcdGJveC5ib3R0b20gPSBjaGFydC5jaGFydEFyZWEuYm90dG9tO1xuXG5cdFx0XHRcdGJveC51cGRhdGUobWF4Q2hhcnRBcmVhV2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59O1xuXG59LHtcIjQ1XCI6NDV9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKDI2KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0cGx1Z2luczoge31cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0LyoqXG5cdCAqIFRoZSBwbHVnaW4gc2VydmljZSBzaW5nbGV0b25cblx0ICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5zXG5cdCAqIEBzaW5jZSAyLjEuMFxuXHQgKi9cblx0Q2hhcnQucGx1Z2lucyA9IHtcblx0XHQvKipcblx0XHQgKiBHbG9iYWxseSByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfcGx1Z2luczogW10sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGlkZW50aWZpZXIgaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZSBkZXNjcmlwdG9ycyBjYWNoZSBhdHRhY2hlZCB0byBlYWNoIGNoYXJ0XG5cdFx0ICogd2hlbiBhIGdsb2JhbCBwbHVnaW4gaXMgcmVnaXN0ZXJlZCBvciB1bnJlZ2lzdGVyZWQuIEluIHRoaXMgY2FzZSwgdGhlIGNhY2hlIElEIGlzXG5cdFx0ICogaW5jcmVtZW50ZWQgYW5kIGRlc2NyaXB0b3JzIGFyZSByZWdlbmVyYXRlZCBkdXJpbmcgZm9sbG93aW5nIEFQSSBjYWxscy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9jYWNoZUlkOiAwLFxuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZC5cblx0XHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXG5cdFx0ICovXG5cdFx0cmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdGlmIChwLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRwLnB1c2gocGx1Z2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX2NhY2hlSWQrKztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBvbmx5IGlmIHJlZ2lzdGVyZWQuXG5cdFx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHRcdCAqL1xuXHRcdHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdHZhciBpZHggPSBwLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0XHRwLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0XHQgKiBAc2luY2UgMi4xLjVcblx0XHQgKi9cblx0XHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9wbHVnaW5zID0gW107XG5cdFx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiByZWdpc3RlcmVkIHBsdWdpbnM/XG5cdFx0ICogQHJldHVybnMge051bWJlcn1cblx0XHQgKiBAc2luY2UgMi4xLjVcblx0XHQgKi9cblx0XHRjb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucy5sZW5ndGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlcy5cblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5IG9mIHBsdWdpbiBvYmplY3RzLlxuXHRcdCAqIEBzaW5jZSAyLjEuNVxuXHRcdCAqL1xuXHRcdGdldEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0XHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0XHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHRcdCAqL1xuXHRcdG5vdGlmeTogZnVuY3Rpb24oY2hhcnQsIGhvb2ssIGFyZ3MpIHtcblx0XHRcdHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuZGVzY3JpcHRvcnMoY2hhcnQpO1xuXHRcdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG5cdFx0XHR2YXIgaSwgZGVzY3JpcHRvciwgcGx1Z2luLCBwYXJhbXMsIG1ldGhvZDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbaV07XG5cdFx0XHRcdHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuXHRcdFx0XHRtZXRob2QgPSBwbHVnaW5baG9va107XG5cdFx0XHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cGFyYW1zID0gW2NoYXJ0XS5jb25jYXQoYXJncyB8fCBbXSk7XG5cdFx0XHRcdFx0cGFyYW1zLnB1c2goZGVzY3JpcHRvci5vcHRpb25zKTtcblx0XHRcdFx0XHRpZiAobWV0aG9kLmFwcGx5KHBsdWdpbiwgcGFyYW1zKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZGVzY3JpcHRvcnMgb2YgZW5hYmxlZCBwbHVnaW5zIGZvciB0aGUgZ2l2ZW4gY2hhcnQuXG5cdFx0ICogQHJldHVybnMge0FycmF5fSBbeyBwbHVnaW4sIG9wdGlvbnMgfV1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGRlc2NyaXB0b3JzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0dmFyIGNhY2hlID0gY2hhcnQuX3BsdWdpbnMgfHwgKGNoYXJ0Ll9wbHVnaW5zID0ge30pO1xuXHRcdFx0aWYgKGNhY2hlLmlkID09PSB0aGlzLl9jYWNoZUlkKSB7XG5cdFx0XHRcdHJldHVybiBjYWNoZS5kZXNjcmlwdG9ycztcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBsdWdpbnMgPSBbXTtcblx0XHRcdHZhciBkZXNjcmlwdG9ycyA9IFtdO1xuXHRcdFx0dmFyIGNvbmZpZyA9IChjaGFydCAmJiBjaGFydC5jb25maWcpIHx8IHt9O1xuXHRcdFx0dmFyIG9wdGlvbnMgPSAoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucykgfHwge307XG5cblx0XHRcdHRoaXMuX3BsdWdpbnMuY29uY2F0KGNvbmZpZy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0XHR2YXIgaWR4ID0gcGx1Z2lucy5pbmRleE9mKHBsdWdpbik7XG5cdFx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGlkID0gcGx1Z2luLmlkO1xuXHRcdFx0XHR2YXIgb3B0cyA9IG9wdGlvbnNbaWRdO1xuXHRcdFx0XHRpZiAob3B0cyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdG9wdHMgPSBoZWxwZXJzLmNsb25lKGRlZmF1bHRzLmdsb2JhbC5wbHVnaW5zW2lkXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwbHVnaW5zLnB1c2gocGx1Z2luKTtcblx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaCh7XG5cdFx0XHRcdFx0cGx1Z2luOiBwbHVnaW4sXG5cdFx0XHRcdFx0b3B0aW9uczogb3B0cyB8fCB7fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRjYWNoZS5kZXNjcmlwdG9ycyA9IGRlc2NyaXB0b3JzO1xuXHRcdFx0Y2FjaGUuaWQgPSB0aGlzLl9jYWNoZUlkO1xuXHRcdFx0cmV0dXJuIGRlc2NyaXB0b3JzO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUGx1Z2luIGV4dGVuc2lvbiBob29rcy5cblx0ICogQGludGVyZmFjZSBJUGx1Z2luXG5cdCAqIEBzaW5jZSAyLjEuMFxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVJbml0XG5cdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgaW5pdGlhbGl6aW5nIGBjaGFydGAuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckluaXRcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIGBjaGFydGAgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlVXBkYXRlXG5cdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgdXBkYXRpbmcgYGNoYXJ0YC4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsIHRoZSB1cGRhdGVcblx0ICogaXMgY2FuY2VsbGVkIChhbmQgdGh1cyBzdWJzZXF1ZW50IHJlbmRlcihzKSkgdW50aWwgYW5vdGhlciBgdXBkYXRlYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCB0byBjYW5jZWwgdGhlIGNoYXJ0IHVwZGF0ZS5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJVcGRhdGVcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIGBjaGFydGAgaGFzIGJlZW4gdXBkYXRlZCBhbmQgYmVmb3JlIHJlbmRlcmluZy4gTm90ZSB0aGF0IHRoaXNcblx0ICogaG9vayB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIGNoYXJ0IHVwZGF0ZSBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZURhdGFzZXRzVXBkYXRlXG4gXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIHVwZGF0aW5nIHRoZSBgY2hhcnRgIGRhdGFzZXRzLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCxcblx0ICogdGhlIGRhdGFzZXRzIHVwZGF0ZSBpcyBjYW5jZWxsZWQgdW50aWwgYW5vdGhlciBgdXBkYXRlYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZmFsc2UgdG8gY2FuY2VsIHRoZSBkYXRhc2V0cyB1cGRhdGUuXG5cdCAqIEBzaW5jZSB2ZXJzaW9uIDIuMS41XG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyRGF0YXNldHNVcGRhdGVcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgY2hhcnRgIGRhdGFzZXRzIGhhdmUgYmVlbiB1cGRhdGVkLiBOb3RlIHRoYXQgdGhpcyBob29rXG5cdCAqIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgZGF0YXNldHMgdXBkYXRlIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHNpbmNlIHZlcnNpb24gMi4xLjVcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlRGF0YXNldFVwZGF0ZVxuIFx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSB1cGRhdGluZyB0aGUgYGNoYXJ0YCBkYXRhc2V0IGF0IHRoZSBnaXZlbiBgYXJncy5pbmRleGAuIElmIGFueSBwbHVnaW5cblx0ICogcmV0dXJucyBgZmFsc2VgLCB0aGUgZGF0YXNldHMgdXBkYXRlIGlzIGNhbmNlbGxlZCB1bnRpbCBhbm90aGVyIGB1cGRhdGVgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gVGhlIGNhbGwgYXJndW1lbnRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYXJncy5pbmRleCAtIFRoZSBkYXRhc2V0IGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncy5tZXRhIC0gVGhlIGRhdGFzZXQgbWV0YWRhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCB0byBjYW5jZWwgdGhlIGNoYXJ0IGRhdGFzZXRzIGRyYXdpbmcuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyRGF0YXNldFVwZGF0ZVxuIFx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgY2hhcnRgIGRhdGFzZXRzIGF0IHRoZSBnaXZlbiBgYXJncy5pbmRleGAgaGFzIGJlZW4gdXBkYXRlZC4gTm90ZVxuXHQgKiB0aGF0IHRoaXMgaG9vayB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIGRhdGFzZXRzIHVwZGF0ZSBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gVGhlIGNhbGwgYXJndW1lbnRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYXJncy5pbmRleCAtIFRoZSBkYXRhc2V0IGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncy5tZXRhIC0gVGhlIGRhdGFzZXQgbWV0YWRhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVMYXlvdXRcblx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSBsYXlpbmcgb3V0IGBjaGFydGAuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLFxuXHQgKiB0aGUgbGF5b3V0IHVwZGF0ZSBpcyBjYW5jZWxsZWQgdW50aWwgYW5vdGhlciBgdXBkYXRlYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCB0byBjYW5jZWwgdGhlIGNoYXJ0IGxheW91dC5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJMYXlvdXRcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgY2hhcnRgIGhhcyBiZWVuIGxheWVkIG91dC4gTm90ZSB0aGF0IHRoaXMgaG9vayB3aWxsIG5vdFxuXHQgKiBiZSBjYWxsZWQgaWYgdGhlIGxheW91dCB1cGRhdGUgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVSZW5kZXJcblx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgYGNoYXJ0YC4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsXG5cdCAqIHRoZSByZW5kZXJpbmcgaXMgY2FuY2VsbGVkIHVudGlsIGFub3RoZXIgYHJlbmRlcmAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgdG8gY2FuY2VsIHRoZSBjaGFydCByZW5kZXJpbmcuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyUmVuZGVyXG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGNoYXJ0YCBoYXMgYmVlbiBmdWxseSByZW5kZXJlZCAoYW5kIGFuaW1hdGlvbiBjb21wbGV0ZWQpLiBOb3RlXG5cdCAqIHRoYXQgdGhpcyBob29rIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgcmVuZGVyaW5nIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlRHJhd1xuXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIGRyYXdpbmcgYGNoYXJ0YCBhdCBldmVyeSBhbmltYXRpb24gZnJhbWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlblxuXHQgKiBlYXNpbmcgdmFsdWUuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLCB0aGUgZnJhbWUgZHJhd2luZyBpcyBjYW5jZWxsZWQgdW50aWxcblx0ICogYW5vdGhlciBgcmVuZGVyYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlYXNpbmdWYWx1ZSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiB2YWx1ZSwgYmV0d2VlbiAwLjAgYW5kIDEuMC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgY2hhcnQgZHJhd2luZy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJEcmF3XG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGNoYXJ0YCBoYXMgYmVlbiBkcmF3biBmb3IgdGhlIHNwZWNpZmljIGVhc2luZyB2YWx1ZS4gTm90ZVxuXHQgKiB0aGF0IHRoaXMgaG9vayB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIGRyYXdpbmcgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlYXNpbmdWYWx1ZSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiB2YWx1ZSwgYmV0d2VlbiAwLjAgYW5kIDEuMC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZURhdGFzZXRzRHJhd1xuIFx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSBkcmF3aW5nIHRoZSBgY2hhcnRgIGRhdGFzZXRzLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCxcblx0ICogdGhlIGRhdGFzZXRzIGRyYXdpbmcgaXMgY2FuY2VsbGVkIHVudGlsIGFub3RoZXIgYHJlbmRlcmAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZWFzaW5nVmFsdWUgLSBUaGUgY3VycmVudCBhbmltYXRpb24gdmFsdWUsIGJldHdlZW4gMC4wIGFuZCAxLjAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCB0byBjYW5jZWwgdGhlIGNoYXJ0IGRhdGFzZXRzIGRyYXdpbmcuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyRGF0YXNldHNEcmF3XG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGNoYXJ0YCBkYXRhc2V0cyBoYXZlIGJlZW4gZHJhd24uIE5vdGUgdGhhdCB0aGlzIGhvb2tcblx0ICogd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSBkYXRhc2V0cyBkcmF3aW5nIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZWFzaW5nVmFsdWUgLSBUaGUgY3VycmVudCBhbmltYXRpb24gdmFsdWUsIGJldHdlZW4gMC4wIGFuZCAxLjAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVEYXRhc2V0RHJhd1xuIFx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSBkcmF3aW5nIHRoZSBgY2hhcnRgIGRhdGFzZXQgYXQgdGhlIGdpdmVuIGBhcmdzLmluZGV4YCAoZGF0YXNldHNcblx0ICogYXJlIGRyYXduIGluIHRoZSByZXZlcnNlIG9yZGVyKS4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsIHRoZSBkYXRhc2V0cyBkcmF3aW5nXG5cdCAqIGlzIGNhbmNlbGxlZCB1bnRpbCBhbm90aGVyIGByZW5kZXJgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gVGhlIGNhbGwgYXJndW1lbnRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYXJncy5pbmRleCAtIFRoZSBkYXRhc2V0IGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncy5tZXRhIC0gVGhlIGRhdGFzZXQgbWV0YWRhdGEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmVhc2luZ1ZhbHVlIC0gVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHZhbHVlLCBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgdG8gY2FuY2VsIHRoZSBjaGFydCBkYXRhc2V0cyBkcmF3aW5nLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckRhdGFzZXREcmF3XG4gXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBjaGFydGAgZGF0YXNldHMgYXQgdGhlIGdpdmVuIGBhcmdzLmluZGV4YCBoYXZlIGJlZW4gZHJhd25cblx0ICogKGRhdGFzZXRzIGFyZSBkcmF3biBpbiB0aGUgcmV2ZXJzZSBvcmRlcikuIE5vdGUgdGhhdCB0aGlzIGhvb2sgd2lsbCBub3QgYmUgY2FsbGVkXG5cdCAqIGlmIHRoZSBkYXRhc2V0cyBkcmF3aW5nIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBUaGUgY2FsbCBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmluZGV4IC0gVGhlIGRhdGFzZXQgaW5kZXguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLm1ldGEgLSBUaGUgZGF0YXNldCBtZXRhZGF0YS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZWFzaW5nVmFsdWUgLSBUaGUgY3VycmVudCBhbmltYXRpb24gdmFsdWUsIGJldHdlZW4gMC4wIGFuZCAxLjAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVFdmVudFxuIFx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSBzcGVjaWZpZWQgYGV2ZW50YC4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsXG5cdCAqIHRoZSBldmVudCB3aWxsIGJlIGRpc2NhcmRlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyRXZlbnRcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgZXZlbnRgIGhhcyBiZWVuIGNvbnN1bWVkLiBOb3RlIHRoYXQgdGhpcyBob29rXG5cdCAqIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgYGV2ZW50YCBoYXMgYmVlbiBwcmV2aW91c2x5IGRpc2NhcmRlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI3Jlc2l6ZVxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGNoYXJ0IGFzIGJlZW4gcmVzaXplZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgbmV3IGNhbnZhcyBkaXNwbGF5IHNpemUgKGVxLiBjYW52YXMuc3R5bGUgd2lkdGggJiBoZWlnaHQpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jZGVzdHJveVxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGNoYXJ0IGFzIGJlZW4gZGVzdHJveWVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQucGx1Z2lucyBpbnN0ZWFkXG5cdCAqIEBuYW1lc3BhY2UgQ2hhcnQucGx1Z2luU2VydmljZVxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdENoYXJ0LnBsdWdpblNlcnZpY2UgPSBDaGFydC5wbHVnaW5zO1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaW5oZXJpdGluZyBmcm9tIENoYXJ0LlBsdWdpbmdCYXNlIGhhcyBub1xuXHQgKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG5cdCAqIEBpbnRlcmZhY2UgQ2hhcnQuUGx1Z2luQmFzZVxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNS4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdENoYXJ0LlBsdWdpbkJhc2UgPSBFbGVtZW50LmV4dGVuZCh7fSk7XG59O1xuXG59LHtcIjI1XCI6MjUsXCIyNlwiOjI2LFwiNDVcIjo0NX1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcbnZhciBUaWNrcyA9IHJlcXVpcmUoMzQpO1xuXG5kZWZhdWx0cy5fc2V0KCdzY2FsZScsIHtcblx0ZGlzcGxheTogdHJ1ZSxcblx0cG9zaXRpb246ICdsZWZ0Jyxcblx0b2Zmc2V0OiBmYWxzZSxcblxuXHQvLyBncmlkIGxpbmUgc2V0dGluZ3Ncblx0Z3JpZExpbmVzOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0bGluZVdpZHRoOiAxLFxuXHRcdGRyYXdCb3JkZXI6IHRydWUsXG5cdFx0ZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuXHRcdGRyYXdUaWNrczogdHJ1ZSxcblx0XHR0aWNrTWFya0xlbmd0aDogMTAsXG5cdFx0emVyb0xpbmVXaWR0aDogMSxcblx0XHR6ZXJvTGluZUNvbG9yOiAncmdiYSgwLDAsMCwwLjI1KScsXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoOiBbXSxcblx0XHR6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRvZmZzZXRHcmlkTGluZXM6IGZhbHNlLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHR9LFxuXG5cdC8vIHNjYWxlIGxhYmVsXG5cdHNjYWxlTGFiZWw6IHtcblx0XHQvLyBkaXNwbGF5IHByb3BlcnR5XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cblx0XHQvLyBhY3R1YWwgbGFiZWxcblx0XHRsYWJlbFN0cmluZzogJycsXG5cblx0XHQvLyBsaW5lIGhlaWdodFxuXHRcdGxpbmVIZWlnaHQ6IDEuMixcblxuXHRcdC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuXHRcdHBhZGRpbmc6IHtcblx0XHRcdHRvcDogNCxcblx0XHRcdGJvdHRvbTogNFxuXHRcdH1cblx0fSxcblxuXHQvLyBsYWJlbCBzZXR0aW5nc1xuXHR0aWNrczoge1xuXHRcdGJlZ2luQXRaZXJvOiBmYWxzZSxcblx0XHRtaW5Sb3RhdGlvbjogMCxcblx0XHRtYXhSb3RhdGlvbjogNTAsXG5cdFx0bWlycm9yOiBmYWxzZSxcblx0XHRwYWRkaW5nOiAwLFxuXHRcdHJldmVyc2U6IGZhbHNlLFxuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0YXV0b1NraXA6IHRydWUsXG5cdFx0YXV0b1NraXBQYWRkaW5nOiAwLFxuXHRcdGxhYmVsT2Zmc2V0OiAwLFxuXHRcdC8vIFdlIHBhc3MgdGhyb3VnaCBhcnJheXMgdG8gYmUgcmVuZGVyZWQgYXMgbXVsdGlsaW5lIGxhYmVscywgd2UgY29udmVydCBPdGhlcnMgdG8gc3RyaW5ncyBoZXJlLlxuXHRcdGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcblx0XHRtaW5vcjoge30sXG5cdFx0bWFqb3I6IHt9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBsYWJlbHNGcm9tVGlja3ModGlja3MpIHtcblx0dmFyIGxhYmVscyA9IFtdO1xuXHR2YXIgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0bGFiZWxzLnB1c2godGlja3NbaV0ubGFiZWwpO1xuXHR9XG5cblx0cmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gZ2V0TGluZVZhbHVlKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG5cdHZhciBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpO1xuXG5cdGlmIChvZmZzZXRHcmlkTGluZXMpIHtcblx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4IC0gMSkpIC8gMjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdGZ1bmN0aW9uIGNvbXB1dGVUZXh0U2l6ZShjb250ZXh0LCB0aWNrLCBmb250KSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMuaXNBcnJheSh0aWNrKSA/XG5cdFx0XHRoZWxwZXJzLmxvbmdlc3RUZXh0KGNvbnRleHQsIGZvbnQsIHRpY2spIDpcblx0XHRcdGNvbnRleHQubWVhc3VyZVRleHQodGljaykud2lkdGg7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGRlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0dmFyIHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdHZhciBmYW1pbHkgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0c3R5bGU6IHN0eWxlLFxuXHRcdFx0ZmFtaWx5OiBmYW1pbHksXG5cdFx0XHRmb250OiBoZWxwZXJzLmZvbnRTdHJpbmcoc2l6ZSwgc3R5bGUsIGZhbWlseSlcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VMaW5lSGVpZ2h0KG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gaGVscGVycy5vcHRpb25zLnRvTGluZUhlaWdodChcblx0XHRcdGhlbHBlcnMudmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCAxLjIpLFxuXHRcdFx0aGVscGVycy52YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTaXplLCBkZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKSk7XG5cdH1cblxuXHRDaGFydC5TY2FsZSA9IEVsZW1lbnQuZXh0ZW5kKHtcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0XHQgKiBAbWV0aG9kIGdldFBhZGRpbmdcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEByZXR1cm5zIHtQYWRkaW5nfSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0XHQgKi9cblx0XHRnZXRQYWRkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRsZWZ0OiBtZS5wYWRkaW5nTGVmdCB8fCAwLFxuXHRcdFx0XHR0b3A6IG1lLnBhZGRpbmdUb3AgfHwgMCxcblx0XHRcdFx0cmlnaHQ6IG1lLnBhZGRpbmdSaWdodCB8fCAwLFxuXHRcdFx0XHRib3R0b206IG1lLnBhZGRpbmdCb3R0b20gfHwgMFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzICh7bGFiZWwsIG1ham9yfSlcblx0XHQgKiBAc2luY2UgMi43XG5cdFx0ICovXG5cdFx0Z2V0VGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RpY2tzO1xuXHRcdH0sXG5cblx0XHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWxlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cdFx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIHNjYWxlIHR5cGVzLlxuXHRcdC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuXHRcdG1lcmdlVGlja3NPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblx0XHRcdGlmICh0aWNrcy5taW5vciA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGlja3MubWlub3IgPSB7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICh0aWNrcy5tYWpvciA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGlja3MubWFqb3IgPSB7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGtleSBpbiB0aWNrcykge1xuXHRcdFx0XHRpZiAoa2V5ICE9PSAnbWFqb3InICYmIGtleSAhPT0gJ21pbm9yJykge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgdGlja3MubWlub3Jba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHRpY2tzLm1pbm9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZW9mIHRpY2tzLm1ham9yW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHR0aWNrcy5tYWpvcltrZXldID0gdGlja3Nba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG5cdFx0fSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbGFiZWxzLCBsYWJlbCwgdGlja3MsIHRpY2s7XG5cblx0XHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdFx0Ly8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG5cdFx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdFx0bWUubWFyZ2lucyA9IGhlbHBlcnMuZXh0ZW5kKHtcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0Ym90dG9tOiAwXG5cdFx0XHR9LCBtYXJnaW5zKTtcblx0XHRcdG1lLmxvbmdlc3RUZXh0Q2FjaGUgPSBtZS5sb25nZXN0VGV4dENhY2hlIHx8IHt9O1xuXG5cdFx0XHQvLyBEaW1lbnNpb25zXG5cdFx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuXHRcdFx0Ly8gRGF0YSBtaW4vbWF4XG5cdFx0XHRtZS5iZWZvcmVEYXRhTGltaXRzKCk7XG5cdFx0XHRtZS5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG5cdFx0XHRtZS5hZnRlckRhdGFMaW1pdHMoKTtcblxuXHRcdFx0Ly8gVGlja3MgLSBgdGhpcy50aWNrc2AgaXMgbm93IERFUFJFQ0FURUQhXG5cdFx0XHQvLyBJbnRlcm5hbCB0aWNrcyBhcmUgbm93IHN0b3JlZCBhcyBvYmplY3RzIGluIHRoZSBQUklWQVRFIGB0aGlzLl90aWNrc2AgbWVtYmVyXG5cdFx0XHQvLyBhbmQgbXVzdCBub3QgYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBvdXRzaWRlIHRoaXMgY2xhc3MuIGB0aGlzLnRpY2tzYCBiZWluZ1xuXHRcdFx0Ly8gYXJvdW5kIGZvciBsb25nIHRpbWUgYW5kIG5vdCBtYXJrZWQgYXMgcHJpdmF0ZSwgd2UgY2FuJ3QgY2hhbmdlIGl0cyBzdHJ1Y3R1cmVcblx0XHRcdC8vIHdpdGhvdXQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNjYWxlIHRpY2tzLFxuXHRcdFx0Ly8gdXNlIHNjYWxlLmdldFRpY2tzKCkgaW5zdGVhZC5cblxuXHRcdFx0bWUuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG5cdFx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBidXQgZm9yIEJBQ0tXQVJEIENPTVBBVCxcblx0XHRcdC8vIHdlIHN0aWxsIHN1cHBvcnQgbm8gcmV0dXJuIChgdGhpcy50aWNrc2AgaW50ZXJuYWxseSBzZXQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCkuXG5cdFx0XHR0aWNrcyA9IG1lLmJ1aWxkVGlja3MoKSB8fCBbXTtcblxuXHRcdFx0bWUuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cblx0XHRcdG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gdGhlIGZvcm1hdHRlZCB0aWNrIGxhYmVscyBidXQgZm9yIEJBQ0tXQVJEXG5cdFx0XHQvLyBDT01QQVQsIHdlIHN0aWxsIHN1cHBvcnQgbm8gcmV0dXJuIChgdGhpcy50aWNrc2AgaW50ZXJuYWxseSBjaGFuZ2VkIGJ5IGNhbGxpbmdcblx0XHRcdC8vIHRoaXMgbWV0aG9kIGFuZCBzdXBwb3NlZCB0byBjb250YWluIG9ubHkgc3RyaW5nIHZhbHVlcykuXG5cdFx0XHRsYWJlbHMgPSBtZS5jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykgfHwgbWUudGlja3M7XG5cblx0XHRcdG1lLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cblx0XHRcdG1lLnRpY2tzID0gbGFiZWxzOyAgIC8vIEJBQ0tXQVJEIENPTVBBVElCSUxJVFlcblxuXHRcdFx0Ly8gSU1QT1JUQU5UOiBmcm9tIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG5cdFx0XHQvLyBCQUNLV0FSRCBDT01QQVQ6IHN5bmNocm9uaXplIGBfdGlja3NgIHdpdGggbGFiZWxzIChzbyBwb3RlbnRpYWxseSBgdGhpcy50aWNrc2ApXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRsYWJlbCA9IGxhYmVsc1tpXTtcblx0XHRcdFx0dGljayA9IHRpY2tzW2ldO1xuXHRcdFx0XHRpZiAoIXRpY2spIHtcblx0XHRcdFx0XHR0aWNrcy5wdXNoKHRpY2sgPSB7XG5cdFx0XHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdFx0XHRtYWpvcjogZmFsc2Vcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aWNrLmxhYmVsID0gbGFiZWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bWUuX3RpY2tzID0gdGlja3M7XG5cblx0XHRcdC8vIFRpY2sgUm90YXRpb25cblx0XHRcdG1lLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0XHRtZS5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdFx0Ly8gRml0XG5cdFx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRcdG1lLmZpdCgpO1xuXHRcdFx0bWUuYWZ0ZXJGaXQoKTtcblx0XHRcdC8vXG5cdFx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0XHRyZXR1cm4gbWUubWluU2l6ZTtcblxuXHRcdH0sXG5cdFx0YWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdFx0fSxcblx0XHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdFx0bWUudG9wID0gMDtcblx0XHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblx0XHR9LFxuXHRcdGFmdGVyU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vIERhdGEgbGltaXRzXG5cdFx0YmVmb3JlRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVEYXRhTGltaXRzLCBbdGhpc10pO1xuXHRcdH0sXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogaGVscGVycy5ub29wLFxuXHRcdGFmdGVyRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckRhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vXG5cdFx0YmVmb3JlQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVCdWlsZFRpY2tzLCBbdGhpc10pO1xuXHRcdH0sXG5cdFx0YnVpbGRUaWNrczogaGVscGVycy5ub29wLFxuXHRcdGFmdGVyQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG5cdFx0fSxcblx0XHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0Ly8gQ29udmVydCB0aWNrcyB0byBzdHJpbmdzXG5cdFx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdFx0bWUudGlja3MgPSBtZS50aWNrcy5tYXAodGlja09wdHMudXNlckNhbGxiYWNrIHx8IHRpY2tPcHRzLmNhbGxiYWNrLCB0aGlzKTtcblx0XHR9LFxuXHRcdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHRcdH0sXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0XHR9LFxuXHRcdGNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNvbnRleHQgPSBtZS5jdHg7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0XHQvLyBHZXQgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBieSBjYWxjdWxhdGluZyB0aGUgZGlmZmVyZW5jZVxuXHRcdFx0Ly8gYmV0d2VlbiB4IG9mZnNldHMgYmV0d2VlbiAwIGFuZCAxLlxuXHRcdFx0dmFyIHRpY2tGb250ID0gcGFyc2VGb250T3B0aW9ucyh0aWNrT3B0cyk7XG5cdFx0XHRjb250ZXh0LmZvbnQgPSB0aWNrRm9udC5mb250O1xuXG5cdFx0XHR2YXIgbGFiZWxSb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG5cblx0XHRcdGlmIChsYWJlbHMubGVuZ3RoICYmIG1lLm9wdGlvbnMuZGlzcGxheSAmJiBtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHR2YXIgb3JpZ2luYWxMYWJlbFdpZHRoID0gaGVscGVycy5sb25nZXN0VGV4dChjb250ZXh0LCB0aWNrRm9udC5mb250LCBsYWJlbHMsIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xuXHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IG9yaWdpbmFsTGFiZWxXaWR0aDtcblx0XHRcdFx0dmFyIGNvc1JvdGF0aW9uLCBzaW5Sb3RhdGlvbjtcblxuXHRcdFx0XHQvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuXHRcdFx0XHR2YXIgdGlja1dpZHRoID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gNjtcblxuXHRcdFx0XHQvLyBNYXggbGFiZWwgcm90YXRpb24gY2FuIGJlIHNldCBvciBkZWZhdWx0IHRvIDkwIC0gYWxzbyBhY3QgYXMgYSBsb29wIGNvdW50ZXJcblx0XHRcdFx0d2hpbGUgKGxhYmVsV2lkdGggPiB0aWNrV2lkdGggJiYgbGFiZWxSb3RhdGlvbiA8IHRpY2tPcHRzLm1heFJvdGF0aW9uKSB7XG5cdFx0XHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IGhlbHBlcnMudG9SYWRpYW5zKGxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHRcdGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcblx0XHRcdFx0XHRzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0XHRpZiAoc2luUm90YXRpb24gKiBvcmlnaW5hbExhYmVsV2lkdGggPiBtZS5tYXhIZWlnaHQpIHtcblx0XHRcdFx0XHRcdC8vIGdvIGJhY2sgb25lIHN0ZXBcblx0XHRcdFx0XHRcdGxhYmVsUm90YXRpb24tLTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxhYmVsUm90YXRpb24rKztcblx0XHRcdFx0XHRsYWJlbFdpZHRoID0gY29zUm90YXRpb24gKiBvcmlnaW5hbExhYmVsV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bWUubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG5cdFx0fSxcblx0XHRhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0XHR9LFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZUZpdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG5cdFx0fSxcblx0XHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdC8vIFJlc2V0XG5cdFx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH07XG5cblx0XHRcdHZhciBsYWJlbHMgPSBsYWJlbHNGcm9tVGlja3MobWUuX3RpY2tzKTtcblxuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblx0XHRcdHZhciBzY2FsZUxhYmVsT3B0cyA9IG9wdHMuc2NhbGVMYWJlbDtcblx0XHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0XHRcdHZhciBkaXNwbGF5ID0gb3B0cy5kaXNwbGF5O1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnRPcHRpb25zKHRpY2tPcHRzKTtcblx0XHRcdHZhciB0aWNrTWFya0xlbmd0aCA9IG9wdHMuZ3JpZExpbmVzLnRpY2tNYXJrTGVuZ3RoO1xuXG5cdFx0XHQvLyBXaWR0aFxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHQvLyBzdWJ0cmFjdCB0aGUgbWFyZ2lucyB0byBsaW5lIHVwIHdpdGggdGhlIGNoYXJ0QXJlYSBpZiB3ZSBhcmUgYSBmdWxsIHdpZHRoIHNjYWxlXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBtZS5pc0Z1bGxXaWR0aCgpID8gbWUubWF4V2lkdGggLSBtZS5tYXJnaW5zLmxlZnQgLSBtZS5tYXJnaW5zLnJpZ2h0IDogbWUubWF4V2lkdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBoZWlnaHRcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ICYmIGdyaWRMaW5lT3B0cy5kcmF3VGlja3MgPyB0aWNrTWFya0xlbmd0aCA6IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcmUgd2Ugc2hvd2luZyBhIHRpdGxlIGZvciB0aGUgc2NhbGU/XG5cdFx0XHRpZiAoc2NhbGVMYWJlbE9wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBzY2FsZUxhYmVsTGluZUhlaWdodCA9IHBhcnNlTGluZUhlaWdodChzY2FsZUxhYmVsT3B0cyk7XG5cdFx0XHRcdHZhciBzY2FsZUxhYmVsUGFkZGluZyA9IGhlbHBlcnMub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbE9wdHMucGFkZGluZyk7XG5cdFx0XHRcdHZhciBkZWx0YUhlaWdodCA9IHNjYWxlTGFiZWxMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcuaGVpZ2h0O1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSBkZWx0YUhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtaW5TaXplLndpZHRoICs9IGRlbHRhSGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlbVxuXHRcdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0XHR2YXIgbGFyZ2VzdFRleHRXaWR0aCA9IGhlbHBlcnMubG9uZ2VzdFRleHQobWUuY3R4LCB0aWNrRm9udC5mb250LCBsYWJlbHMsIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xuXHRcdFx0XHR2YXIgdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyA9IGhlbHBlcnMubnVtYmVyT2ZMYWJlbExpbmVzKGxhYmVscyk7XG5cdFx0XHRcdHZhciBsaW5lU3BhY2UgPSB0aWNrRm9udC5zaXplICogMC41O1xuXHRcdFx0XHR2YXIgdGlja1BhZGRpbmcgPSBtZS5vcHRpb25zLnRpY2tzLnBhZGRpbmc7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cblx0XHRcdFx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IGxhcmdlc3RUZXh0V2lkdGg7XG5cblx0XHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycy50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cdFx0XHRcdFx0dmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcblx0XHRcdFx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdFx0Ly8gVE9ETyAtIGltcHJvdmUgdGhpcyBjYWxjdWxhdGlvblxuXHRcdFx0XHRcdHZhciBsYWJlbEhlaWdodCA9IChzaW5Sb3RhdGlvbiAqIGxhcmdlc3RUZXh0V2lkdGgpXG5cdFx0XHRcdFx0XHQrICh0aWNrRm9udC5zaXplICogdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcylcblx0XHRcdFx0XHRcdCsgKGxpbmVTcGFjZSAqICh0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzIC0gMSkpXG5cdFx0XHRcdFx0XHQrIGxpbmVTcGFjZTsgLy8gcGFkZGluZ1xuXG5cdFx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbihtZS5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG5cblx0XHRcdFx0XHRtZS5jdHguZm9udCA9IHRpY2tGb250LmZvbnQ7XG5cdFx0XHRcdFx0dmFyIGZpcnN0TGFiZWxXaWR0aCA9IGNvbXB1dGVUZXh0U2l6ZShtZS5jdHgsIGxhYmVsc1swXSwgdGlja0ZvbnQuZm9udCk7XG5cdFx0XHRcdFx0dmFyIGxhc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXSwgdGlja0ZvbnQuZm9udCk7XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuXHRcdFx0XHRcdC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuXHRcdFx0XHRcdGlmIChtZS5sYWJlbFJvdGF0aW9uICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRtZS5wYWRkaW5nTGVmdCA9IG9wdHMucG9zaXRpb24gPT09ICdib3R0b20nID8gKGNvc1JvdGF0aW9uICogZmlyc3RMYWJlbFdpZHRoKSArIDMgOiAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpICsgMzsgLy8gYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXG5cdFx0XHRcdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBvcHRzLnBvc2l0aW9uID09PSAnYm90dG9tJyA/IChjb3NSb3RhdGlvbiAqIGxpbmVTcGFjZSkgKyAzIDogKGNvc1JvdGF0aW9uICogbGFzdExhYmVsV2lkdGgpICsgMztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBmaXJzdExhYmVsV2lkdGggLyAyICsgMzsgLy8gYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXG5cdFx0XHRcdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxXaWR0aCAvIDIgKyAzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG5cdFx0XHRcdFx0Ly8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xuXHRcdFx0XHRcdGlmICh0aWNrT3B0cy5taXJyb3IpIHtcblx0XHRcdFx0XHRcdGxhcmdlc3RUZXh0V2lkdGggPSAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB1c2UgbGluZVNwYWNlIGZvciBjb25zaXN0ZW5jeSB3aXRoIGhvcml6b250YWwgYXhpc1xuXHRcdFx0XHRcdFx0Ly8gdGlja1BhZGRpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBob3Jpem9udGFsXG5cdFx0XHRcdFx0XHRsYXJnZXN0VGV4dFdpZHRoICs9IHRpY2tQYWRkaW5nICsgbGluZVNwYWNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhcmdlc3RUZXh0V2lkdGgpO1xuXG5cdFx0XHRcdFx0bWUucGFkZGluZ1RvcCA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSB0aWNrRm9udC5zaXplIC8gMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRtZS5oYW5kbGVNYXJnaW5zKCk7XG5cblx0XHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGhhbmRsZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGlmIChtZS5tYXJnaW5zKSB7XG5cdFx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgobWUucGFkZGluZ0xlZnQgLSBtZS5tYXJnaW5zLmxlZnQsIDApO1xuXHRcdFx0XHRtZS5wYWRkaW5nVG9wID0gTWF0aC5tYXgobWUucGFkZGluZ1RvcCAtIG1lLm1hcmdpbnMudG9wLCAwKTtcblx0XHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgobWUucGFkZGluZ1JpZ2h0IC0gbWUubWFyZ2lucy5yaWdodCwgMCk7XG5cdFx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSBNYXRoLm1heChtZS5wYWRkaW5nQm90dG9tIC0gbWUubWFyZ2lucy5ib3R0b20sIDApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZnRlckZpdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcblx0XHR9LFxuXG5cdFx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0XHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0XHR9LFxuXHRcdGlzRnVsbFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAodGhpcy5vcHRpb25zLmZ1bGxXaWR0aCk7XG5cdFx0fSxcblxuXHRcdC8vIEdldCB0aGUgY29ycmVjdCB2YWx1ZS4gTmFOIGJhZCBpbnB1dHMsIElmIHRoZSB2YWx1ZSB0eXBlIGlzIG9iamVjdCBnZXQgdGhlIHggb3IgeSBiYXNlZCBvbiB3aGV0aGVyIHdlIGFyZSBob3Jpem9udGFsIG9yIG5vdFxuXHRcdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0XHQvLyBOdWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZpcnN0XG5cdFx0XHRpZiAoaGVscGVycy5pc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xuXHRcdFx0aWYgKHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHJhd1ZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcblx0XHRcdGlmIChyYXdWYWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRcdGlmIChyYXdWYWx1ZS54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHJhd1ZhbHVlLnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVmFsdWUgaXMgZ29vZCwgcmV0dXJuIGl0XG5cdFx0XHRyZXR1cm4gcmF3VmFsdWU7XG5cdFx0fSxcblxuXHRcdC8vIFVzZWQgdG8gZ2V0IHRoZSB2YWx1ZSB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0XHQvLyBmdW5jdGlvbiBnZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpXG5cdFx0Z2V0TGFiZWxGb3JJbmRleDogaGVscGVycy5ub29wLFxuXG5cdFx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdFx0Z2V0UGl4ZWxGb3JWYWx1ZTogaGVscGVycy5ub29wLFxuXG5cdFx0Ly8gVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcblx0XHRnZXRWYWx1ZUZvclBpeGVsOiBoZWxwZXJzLm5vb3AsXG5cblx0XHQvLyBVc2VkIGZvciB0aWNrIGxvY2F0aW9uLCBzaG91bGRcblx0XHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHZhciBpbm5lcldpZHRoID0gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpO1xuXHRcdFx0XHR2YXIgdGlja1dpZHRoID0gaW5uZXJXaWR0aCAvIE1hdGgubWF4KChtZS5fdGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXHRcdFx0XHR2YXIgcGl4ZWwgPSAodGlja1dpZHRoICogaW5kZXgpICsgbWUucGFkZGluZ0xlZnQ7XG5cblx0XHRcdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0XHRcdHBpeGVsICs9IHRpY2tXaWR0aCAvIDI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZmluYWxWYWwgPSBtZS5sZWZ0ICsgTWF0aC5yb3VuZChwaXhlbCk7XG5cdFx0XHRcdGZpbmFsVmFsICs9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXJnaW5zLmxlZnQgOiAwO1xuXHRcdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaW5uZXJIZWlnaHQgPSBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLnBhZGRpbmdCb3R0b20pO1xuXHRcdFx0cmV0dXJuIG1lLnRvcCArIChpbmRleCAqIChpbm5lckhlaWdodCAvIChtZS5fdGlja3MubGVuZ3RoIC0gMSkpKTtcblx0XHR9LFxuXG5cdFx0Ly8gVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXG5cdFx0Z2V0UGl4ZWxGb3JEZWNpbWFsOiBmdW5jdGlvbihkZWNpbWFsKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHZhciBpbm5lcldpZHRoID0gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpO1xuXHRcdFx0XHR2YXIgdmFsdWVPZmZzZXQgPSAoaW5uZXJXaWR0aCAqIGRlY2ltYWwpICsgbWUucGFkZGluZ0xlZnQ7XG5cblx0XHRcdFx0dmFyIGZpbmFsVmFsID0gbWUubGVmdCArIE1hdGgucm91bmQodmFsdWVPZmZzZXQpO1xuXHRcdFx0XHRmaW5hbFZhbCArPSBtZS5pc0Z1bGxXaWR0aCgpID8gbWUubWFyZ2lucy5sZWZ0IDogMDtcblx0XHRcdFx0cmV0dXJuIGZpbmFsVmFsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lLnRvcCArIChkZWNpbWFsICogbWUuaGVpZ2h0KTtcblx0XHR9LFxuXG5cdFx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG5cdFx0fSxcblxuXHRcdGdldEJhc2VWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHRcdHZhciBtYXggPSBtZS5tYXg7XG5cblx0XHRcdHJldHVybiBtZS5iZWdpbkF0WmVybyA/IDAgOlxuXHRcdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuXHRcdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0XHQwO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRpY2tzIHRvIGJlIHBsb3R0ZWQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X2F1dG9Ta2lwOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdFx0dmFyIHNraXBSYXRpbztcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHR2YXIgb3B0aW9uVGlja3MgPSBtZS5vcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdFx0dmFyIHRpY2tDb3VudCA9IHRpY2tzLmxlbmd0aDtcblx0XHRcdHZhciBsYWJlbFJvdGF0aW9uUmFkaWFucyA9IGhlbHBlcnMudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdFx0dmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3MobGFiZWxSb3RhdGlvblJhZGlhbnMpO1xuXHRcdFx0dmFyIGxvbmdlc3RSb3RhdGVkTGFiZWwgPSBtZS5sb25nZXN0TGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uO1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0dmFyIGksIHRpY2ssIHNob3VsZFNraXA7XG5cblx0XHRcdC8vIGZpZ3VyZSBvdXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGdyaWRsaW5lcyB0byBzaG93XG5cdFx0XHR2YXIgbWF4VGlja3M7XG5cdFx0XHRpZiAob3B0aW9uVGlja3MubWF4VGlja3NMaW1pdCkge1xuXHRcdFx0XHRtYXhUaWNrcyA9IG9wdGlvblRpY2tzLm1heFRpY2tzTGltaXQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0c2tpcFJhdGlvID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKChsb25nZXN0Um90YXRlZExhYmVsICsgb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nKSAqIHRpY2tDb3VudCA+IChtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCkpKSB7XG5cdFx0XHRcdFx0c2tpcFJhdGlvID0gMSArIE1hdGguZmxvb3IoKChsb25nZXN0Um90YXRlZExhYmVsICsgb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nKSAqIHRpY2tDb3VudCkgLyAobWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiB0aGV5IGRlZmluZWQgYSBtYXggbnVtYmVyIG9mIG9wdGlvblRpY2tzLFxuXHRcdFx0XHQvLyBpbmNyZWFzZSBza2lwUmF0aW8gdW50aWwgdGhhdCBudW1iZXIgaXMgbWV0XG5cdFx0XHRcdGlmIChtYXhUaWNrcyAmJiB0aWNrQ291bnQgPiBtYXhUaWNrcykge1xuXHRcdFx0XHRcdHNraXBSYXRpbyA9IE1hdGgubWF4KHNraXBSYXRpbywgTWF0aC5mbG9vcih0aWNrQ291bnQgLyBtYXhUaWNrcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aWNrQ291bnQ7IGkrKykge1xuXHRcdFx0XHR0aWNrID0gdGlja3NbaV07XG5cblx0XHRcdFx0Ly8gU2luY2Ugd2UgYWx3YXlzIHNob3cgdGhlIGxhc3QgdGljayx3ZSBuZWVkIG1heSBuZWVkIHRvIGhpZGUgdGhlIGxhc3Qgc2hvd24gb25lIGJlZm9yZVxuXHRcdFx0XHRzaG91bGRTa2lwID0gKHNraXBSYXRpbyA+IDEgJiYgaSAlIHNraXBSYXRpbyA+IDApIHx8IChpICUgc2tpcFJhdGlvID09PSAwICYmIGkgKyBza2lwUmF0aW8gPj0gdGlja0NvdW50KTtcblx0XHRcdFx0aWYgKHNob3VsZFNraXAgJiYgaSAhPT0gdGlja0NvdW50IC0gMSB8fCBoZWxwZXJzLmlzTnVsbE9yVW5kZWYodGljay5sYWJlbCkpIHtcblx0XHRcdFx0XHQvLyBsZWF2ZSB0aWNrIGluIHBsYWNlIGJ1dCBtYWtlIHN1cmUgaXQncyBub3QgZGlzcGxheWVkICgjNDYzNSlcblx0XHRcdFx0XHRkZWxldGUgdGljay5sYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQucHVzaCh0aWNrKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbGx5IGRyYXcgdGhlIHNjYWxlIG9uIHRoZSBjYW52YXNcblx0XHQvLyBAcGFyYW0ge3JlY3RhbmdsZX0gY2hhcnRBcmVhIDogdGhlIGFyZWEgb2YgdGhlIGNoYXJ0IHRvIGRyYXcgZnVsbCBncmlkIGxpbmVzIG9uXG5cdFx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdFx0aWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29udGV4dCA9IG1lLmN0eDtcblx0XHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGRlZmF1bHRzLmdsb2JhbDtcblx0XHRcdHZhciBvcHRpb25UaWNrcyA9IG9wdGlvbnMudGlja3MubWlub3I7XG5cdFx0XHR2YXIgb3B0aW9uTWFqb3JUaWNrcyA9IG9wdGlvbnMudGlja3MubWFqb3IgfHwgb3B0aW9uVGlja3M7XG5cdFx0XHR2YXIgZ3JpZExpbmVzID0gb3B0aW9ucy5ncmlkTGluZXM7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbCA9IG9wdGlvbnMuc2NhbGVMYWJlbDtcblxuXHRcdFx0dmFyIGlzUm90YXRlZCA9IG1lLmxhYmVsUm90YXRpb24gIT09IDA7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRcdHZhciB0aWNrcyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwID8gbWUuX2F1dG9Ta2lwKG1lLmdldFRpY2tzKCkpIDogbWUuZ2V0VGlja3MoKTtcblx0XHRcdHZhciB0aWNrRm9udENvbG9yID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChvcHRpb25UaWNrcy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0dmFyIHRpY2tGb250ID0gcGFyc2VGb250T3B0aW9ucyhvcHRpb25UaWNrcyk7XG5cdFx0XHR2YXIgbWFqb3JUaWNrRm9udENvbG9yID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChvcHRpb25NYWpvclRpY2tzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHR2YXIgbWFqb3JUaWNrRm9udCA9IHBhcnNlRm9udE9wdGlvbnMob3B0aW9uTWFqb3JUaWNrcyk7XG5cblx0XHRcdHZhciB0bCA9IGdyaWRMaW5lcy5kcmF3VGlja3MgPyBncmlkTGluZXMudGlja01hcmtMZW5ndGggOiAwO1xuXG5cdFx0XHR2YXIgc2NhbGVMYWJlbEZvbnRDb2xvciA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoc2NhbGVMYWJlbC5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxGb250ID0gcGFyc2VGb250T3B0aW9ucyhzY2FsZUxhYmVsKTtcblx0XHRcdHZhciBzY2FsZUxhYmVsUGFkZGluZyA9IGhlbHBlcnMub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbC5wYWRkaW5nKTtcblx0XHRcdHZhciBsYWJlbFJvdGF0aW9uUmFkaWFucyA9IGhlbHBlcnMudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXG5cdFx0XHR2YXIgaXRlbXNUb0RyYXcgPSBbXTtcblxuXHRcdFx0dmFyIHhUaWNrU3RhcnQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAncmlnaHQnID8gbWUubGVmdCA6IG1lLnJpZ2h0IC0gdGw7XG5cdFx0XHR2YXIgeFRpY2tFbmQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAncmlnaHQnID8gbWUubGVmdCArIHRsIDogbWUucmlnaHQ7XG5cdFx0XHR2YXIgeVRpY2tTdGFydCA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nID8gbWUudG9wIDogbWUuYm90dG9tIC0gdGw7XG5cdFx0XHR2YXIgeVRpY2tFbmQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJyA/IG1lLnRvcCArIHRsIDogbWUuYm90dG9tO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2godGlja3MsIGZ1bmN0aW9uKHRpY2ssIGluZGV4KSB7XG5cdFx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcblx0XHRcdFx0aWYgKHRpY2subGFiZWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBsYWJlbCA9IHRpY2subGFiZWw7XG5cdFx0XHRcdHZhciBsaW5lV2lkdGgsIGxpbmVDb2xvciwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0aWYgKGluZGV4ID09PSBtZS56ZXJvTGluZUluZGV4ICYmIG9wdGlvbnMub2Zmc2V0ID09PSBncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzKSB7XG5cdFx0XHRcdFx0Ly8gRHJhdyB0aGUgZmlyc3QgaW5kZXggc3BlY2lhbGx5XG5cdFx0XHRcdFx0bGluZVdpZHRoID0gZ3JpZExpbmVzLnplcm9MaW5lV2lkdGg7XG5cdFx0XHRcdFx0bGluZUNvbG9yID0gZ3JpZExpbmVzLnplcm9MaW5lQ29sb3I7XG5cdFx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2g7XG5cdFx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGluZVdpZHRoID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgaW5kZXgpO1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgaW5kZXgpO1xuXHRcdFx0XHRcdGJvcmRlckRhc2ggPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGdyaWRMaW5lcy5ib3JkZXJEYXNoLCBnbG9iYWxEZWZhdWx0cy5ib3JkZXJEYXNoKTtcblx0XHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChncmlkTGluZXMuYm9yZGVyRGFzaE9mZnNldCwgZ2xvYmFsRGVmYXVsdHMuYm9yZGVyRGFzaE9mZnNldCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb21tb24gcHJvcGVydGllc1xuXHRcdFx0XHR2YXIgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MiwgbGFiZWxYLCBsYWJlbFk7XG5cdFx0XHRcdHZhciB0ZXh0QWxpZ24gPSAnbWlkZGxlJztcblx0XHRcdFx0dmFyIHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHR2YXIgdGlja1BhZGRpbmcgPSBvcHRpb25UaWNrcy5wYWRkaW5nO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHR2YXIgbGFiZWxZT2Zmc2V0ID0gdGwgKyB0aWNrUGFkZGluZztcblxuXHRcdFx0XHRcdGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0XHRcdFx0Ly8gYm90dG9tXG5cdFx0XHRcdFx0XHR0ZXh0QmFzZWxpbmUgPSAhaXNSb3RhdGVkID8gJ3RvcCcgOiAnbWlkZGxlJztcblx0XHRcdFx0XHRcdHRleHRBbGlnbiA9ICFpc1JvdGF0ZWQgPyAnY2VudGVyJyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0XHRsYWJlbFkgPSBtZS50b3AgKyBsYWJlbFlPZmZzZXQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHRvcFxuXHRcdFx0XHRcdFx0dGV4dEJhc2VsaW5lID0gIWlzUm90YXRlZCA/ICdib3R0b20nIDogJ21pZGRsZSc7XG5cdFx0XHRcdFx0XHR0ZXh0QWxpZ24gPSAhaXNSb3RhdGVkID8gJ2NlbnRlcicgOiAnbGVmdCc7XG5cdFx0XHRcdFx0XHRsYWJlbFkgPSBtZS5ib3R0b20gLSBsYWJlbFlPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHhMaW5lVmFsdWUgPSBnZXRMaW5lVmFsdWUobWUsIGluZGV4LCBncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzICYmIHRpY2tzLmxlbmd0aCA+IDEpO1xuXHRcdFx0XHRcdGlmICh4TGluZVZhbHVlIDwgbWUubGVmdCkge1xuXHRcdFx0XHRcdFx0bGluZUNvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR4TGluZVZhbHVlICs9IGhlbHBlcnMuYWxpYXNQaXhlbChsaW5lV2lkdGgpO1xuXG5cdFx0XHRcdFx0bGFiZWxYID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0OyAvLyB4IHZhbHVlcyBmb3Igb3B0aW9uVGlja3MgKG5lZWQgdG8gY29uc2lkZXIgb2Zmc2V0TGFiZWwgb3B0aW9uKVxuXG5cdFx0XHRcdFx0dHgxID0gdHgyID0geDEgPSB4MiA9IHhMaW5lVmFsdWU7XG5cdFx0XHRcdFx0dHkxID0geVRpY2tTdGFydDtcblx0XHRcdFx0XHR0eTIgPSB5VGlja0VuZDtcblx0XHRcdFx0XHR5MSA9IGNoYXJ0QXJlYS50b3A7XG5cdFx0XHRcdFx0eTIgPSBjaGFydEFyZWEuYm90dG9tO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBpc0xlZnQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRcdFx0dmFyIGxhYmVsWE9mZnNldDtcblxuXHRcdFx0XHRcdGlmIChvcHRpb25UaWNrcy5taXJyb3IpIHtcblx0XHRcdFx0XHRcdHRleHRBbGlnbiA9IGlzTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0XHRsYWJlbFhPZmZzZXQgPSB0aWNrUGFkZGluZztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGV4dEFsaWduID0gaXNMZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0Jztcblx0XHRcdFx0XHRcdGxhYmVsWE9mZnNldCA9IHRsICsgdGlja1BhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGFiZWxYID0gaXNMZWZ0ID8gbWUucmlnaHQgLSBsYWJlbFhPZmZzZXQgOiBtZS5sZWZ0ICsgbGFiZWxYT2Zmc2V0O1xuXG5cdFx0XHRcdFx0dmFyIHlMaW5lVmFsdWUgPSBnZXRMaW5lVmFsdWUobWUsIGluZGV4LCBncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzICYmIHRpY2tzLmxlbmd0aCA+IDEpO1xuXHRcdFx0XHRcdGlmICh5TGluZVZhbHVlIDwgbWUudG9wKSB7XG5cdFx0XHRcdFx0XHRsaW5lQ29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHlMaW5lVmFsdWUgKz0gaGVscGVycy5hbGlhc1BpeGVsKGxpbmVXaWR0aCk7XG5cblx0XHRcdFx0XHRsYWJlbFkgPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG5cblx0XHRcdFx0XHR0eDEgPSB4VGlja1N0YXJ0O1xuXHRcdFx0XHRcdHR4MiA9IHhUaWNrRW5kO1xuXHRcdFx0XHRcdHgxID0gY2hhcnRBcmVhLmxlZnQ7XG5cdFx0XHRcdFx0eDIgPSBjaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRcdFx0dHkxID0gdHkyID0geTEgPSB5MiA9IHlMaW5lVmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpdGVtc1RvRHJhdy5wdXNoKHtcblx0XHRcdFx0XHR0eDE6IHR4MSxcblx0XHRcdFx0XHR0eTE6IHR5MSxcblx0XHRcdFx0XHR0eDI6IHR4Mixcblx0XHRcdFx0XHR0eTI6IHR5Mixcblx0XHRcdFx0XHR4MTogeDEsXG5cdFx0XHRcdFx0eTE6IHkxLFxuXHRcdFx0XHRcdHgyOiB4Mixcblx0XHRcdFx0XHR5MjogeTIsXG5cdFx0XHRcdFx0bGFiZWxYOiBsYWJlbFgsXG5cdFx0XHRcdFx0bGFiZWxZOiBsYWJlbFksXG5cdFx0XHRcdFx0Z2xXaWR0aDogbGluZVdpZHRoLFxuXHRcdFx0XHRcdGdsQ29sb3I6IGxpbmVDb2xvcixcblx0XHRcdFx0XHRnbEJvcmRlckRhc2g6IGJvcmRlckRhc2gsXG5cdFx0XHRcdFx0Z2xCb3JkZXJEYXNoT2Zmc2V0OiBib3JkZXJEYXNoT2Zmc2V0LFxuXHRcdFx0XHRcdHJvdGF0aW9uOiAtMSAqIGxhYmVsUm90YXRpb25SYWRpYW5zLFxuXHRcdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0XHRtYWpvcjogdGljay5tYWpvcixcblx0XHRcdFx0XHR0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcblx0XHRcdFx0XHR0ZXh0QWxpZ246IHRleHRBbGlnblxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBEcmF3IGFsbCBvZiB0aGUgdGljayBsYWJlbHMsIHRpY2sgbWFya3MsIGFuZCBncmlkIGxpbmVzIGF0IHRoZSBjb3JyZWN0IHBsYWNlc1xuXHRcdFx0aGVscGVycy5lYWNoKGl0ZW1zVG9EcmF3LCBmdW5jdGlvbihpdGVtVG9EcmF3KSB7XG5cdFx0XHRcdGlmIChncmlkTGluZXMuZGlzcGxheSkge1xuXHRcdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gaXRlbVRvRHJhdy5nbFdpZHRoO1xuXHRcdFx0XHRcdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBpdGVtVG9EcmF3LmdsQ29sb3I7XG5cdFx0XHRcdFx0aWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0TGluZURhc2goaXRlbVRvRHJhdy5nbEJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5saW5lRGFzaE9mZnNldCA9IGl0ZW1Ub0RyYXcuZ2xCb3JkZXJEYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0XHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdUaWNrcykge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5tb3ZlVG8oaXRlbVRvRHJhdy50eDEsIGl0ZW1Ub0RyYXcudHkxKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcudHgyLCBpdGVtVG9EcmF3LnR5Mik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3T25DaGFydEFyZWEpIHtcblx0XHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcueDEsIGl0ZW1Ub0RyYXcueTEpO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5saW5lVG8oaXRlbVRvRHJhdy54MiwgaXRlbVRvRHJhdy55Mik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRyYXcgdGV4dCBpbiB0aGUgY29ycmVjdCBjb2xvciBhbmQgZm9udFxuXHRcdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRcdGNvbnRleHQudHJhbnNsYXRlKGl0ZW1Ub0RyYXcubGFiZWxYLCBpdGVtVG9EcmF3LmxhYmVsWSk7XG5cdFx0XHRcdFx0Y29udGV4dC5yb3RhdGUoaXRlbVRvRHJhdy5yb3RhdGlvbik7XG5cdFx0XHRcdFx0Y29udGV4dC5mb250ID0gaXRlbVRvRHJhdy5tYWpvciA/IG1ham9yVGlja0ZvbnQuZm9udCA6IHRpY2tGb250LmZvbnQ7XG5cdFx0XHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udENvbG9yIDogdGlja0ZvbnRDb2xvcjtcblx0XHRcdFx0XHRjb250ZXh0LnRleHRCYXNlbGluZSA9IGl0ZW1Ub0RyYXcudGV4dEJhc2VsaW5lO1xuXHRcdFx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gaXRlbVRvRHJhdy50ZXh0QWxpZ247XG5cblx0XHRcdFx0XHR2YXIgbGFiZWwgPSBpdGVtVG9EcmF3LmxhYmVsO1xuXHRcdFx0XHRcdGlmIChoZWxwZXJzLmlzQXJyYXkobGFiZWwpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgeSA9IDA7IGkgPCBsYWJlbC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSBqdXN0IG1ha2Ugc3VyZSB0aGUgbXVsdGlsaW5lIGVsZW1lbnQgaXMgYSBzdHJpbmcgaGVyZS4uXG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuZmlsbFRleHQoJycgKyBsYWJlbFtpXSwgMCwgeSk7XG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHNhbWUgbGluZVNwYWNpbmcgYXMgY2FsY3VsYXRlZCBAIEwjMzIwXG5cdFx0XHRcdFx0XHRcdHkgKz0gKHRpY2tGb250LnNpemUgKiAxLjUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAwLCAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoc2NhbGVMYWJlbC5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIERyYXcgdGhlIHNjYWxlIGxhYmVsXG5cdFx0XHRcdHZhciBzY2FsZUxhYmVsWDtcblx0XHRcdFx0dmFyIHNjYWxlTGFiZWxZO1xuXHRcdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXHRcdFx0XHR2YXIgaGFsZkxpbmVIZWlnaHQgPSBwYXJzZUxpbmVIZWlnaHQoc2NhbGVMYWJlbCkgLyAyO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRzY2FsZUxhYmVsWCA9IG1lLmxlZnQgKyAoKG1lLnJpZ2h0IC0gbWUubGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdFx0c2NhbGVMYWJlbFkgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJ1xuXHRcdFx0XHRcdFx0PyBtZS5ib3R0b20gLSBoYWxmTGluZUhlaWdodCAtIHNjYWxlTGFiZWxQYWRkaW5nLmJvdHRvbVxuXHRcdFx0XHRcdFx0OiBtZS50b3AgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaXNMZWZ0ID0gb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuXHRcdFx0XHRcdHNjYWxlTGFiZWxYID0gaXNMZWZ0XG5cdFx0XHRcdFx0XHQ/IG1lLmxlZnQgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcFxuXHRcdFx0XHRcdFx0OiBtZS5yaWdodCAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xuXHRcdFx0XHRcdHNjYWxlTGFiZWxZID0gbWUudG9wICsgKChtZS5ib3R0b20gLSBtZS50b3ApIC8gMik7XG5cdFx0XHRcdFx0cm90YXRpb24gPSBpc0xlZnQgPyAtMC41ICogTWF0aC5QSSA6IDAuNSAqIE1hdGguUEk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdFx0Y29udGV4dC50cmFuc2xhdGUoc2NhbGVMYWJlbFgsIHNjYWxlTGFiZWxZKTtcblx0XHRcdFx0Y29udGV4dC5yb3RhdGUocm90YXRpb24pO1xuXHRcdFx0XHRjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0XHRjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IHNjYWxlTGFiZWxGb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0XHRjb250ZXh0LmZvbnQgPSBzY2FsZUxhYmVsRm9udC5mb250O1xuXHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KHNjYWxlTGFiZWwubGFiZWxTdHJpbmcsIDAsIDApO1xuXHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3Qm9yZGVyKSB7XG5cdFx0XHRcdC8vIERyYXcgdGhlIGxpbmUgYXQgdGhlIGVkZ2Ugb2YgdGhlIGF4aXNcblx0XHRcdFx0Y29udGV4dC5saW5lV2lkdGggPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCAwKTtcblx0XHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgMCk7XG5cdFx0XHRcdHZhciB4MSA9IG1lLmxlZnQ7XG5cdFx0XHRcdHZhciB4MiA9IG1lLnJpZ2h0O1xuXHRcdFx0XHR2YXIgeTEgPSBtZS50b3A7XG5cdFx0XHRcdHZhciB5MiA9IG1lLmJvdHRvbTtcblxuXHRcdFx0XHR2YXIgYWxpYXNQaXhlbCA9IGhlbHBlcnMuYWxpYXNQaXhlbChjb250ZXh0LmxpbmVXaWR0aCk7XG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHR5MSA9IHkyID0gb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgPyBtZS5ib3R0b20gOiBtZS50b3A7XG5cdFx0XHRcdFx0eTEgKz0gYWxpYXNQaXhlbDtcblx0XHRcdFx0XHR5MiArPSBhbGlhc1BpeGVsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHgxID0geDIgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcgPyBtZS5yaWdodCA6IG1lLmxlZnQ7XG5cdFx0XHRcdFx0eDEgKz0gYWxpYXNQaXhlbDtcblx0XHRcdFx0XHR4MiArPSBhbGlhc1BpeGVsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcblx0XHRcdFx0Y29udGV4dC5saW5lVG8oeDIsIHkyKTtcblx0XHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNixcIjM0XCI6MzQsXCI0NVwiOjQ1fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5zY2FsZVNlcnZpY2UgPSB7XG5cdFx0Ly8gU2NhbGUgcmVnaXN0cmF0aW9uIG9iamVjdC4gRXh0ZW5zaW9ucyBjYW4gcmVnaXN0ZXIgbmV3IHNjYWxlIHR5cGVzIChzdWNoIGFzIGxvZyBvciBEQiBzY2FsZXMpIGFuZCB0aGVuXG5cdFx0Ly8gdXNlIHRoZSBuZXcgY2hhcnQgb3B0aW9ucyB0byBncmFiIHRoZSBjb3JyZWN0IHNjYWxlXG5cdFx0Y29uc3RydWN0b3JzOiB7fSxcblx0XHQvLyBVc2UgYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gc28gdGhhdCB3ZSBjYW4gbW92ZSB0byBhbiBFUzYgbWFwIHdoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gc3VwcG9ydFxuXHRcdC8vIG9sZCBicm93c2Vyc1xuXG5cdFx0Ly8gU2NhbGUgY29uZmlnIGRlZmF1bHRzXG5cdFx0ZGVmYXVsdHM6IHt9LFxuXHRcdHJlZ2lzdGVyU2NhbGVUeXBlOiBmdW5jdGlvbih0eXBlLCBzY2FsZUNvbnN0cnVjdG9yLCBzY2FsZURlZmF1bHRzKSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yc1t0eXBlXSA9IHNjYWxlQ29uc3RydWN0b3I7XG5cdFx0XHR0aGlzLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycy5jbG9uZShzY2FsZURlZmF1bHRzKTtcblx0XHR9LFxuXHRcdGdldFNjYWxlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IHRoaXMuY29uc3RydWN0b3JzW3R5cGVdIDogdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0Z2V0U2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0Ly8gUmV0dXJuIHRoZSBzY2FsZSBkZWZhdWx0cyBtZXJnZWQgd2l0aCB0aGUgZ2xvYmFsIHNldHRpbmdzIHNvIHRoYXQgd2UgYWx3YXlzIHVzZSB0aGUgbGF0ZXN0IG9uZXNcblx0XHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycy5tZXJnZSh7fSwgW2RlZmF1bHRzLnNjYWxlLCB0aGlzLmRlZmF1bHRzW3R5cGVdXSkgOiB7fTtcblx0XHR9LFxuXHRcdHVwZGF0ZVNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUsIGFkZGl0aW9ucykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGlmIChtZS5kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuXHRcdFx0XHRtZS5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMuZXh0ZW5kKG1lLmRlZmF1bHRzW3R5cGVdLCBhZGRpdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWRkU2NhbGVzVG9MYXlvdXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHQvLyBBZGRzIGVhY2ggc2NhbGUgdG8gdGhlIGNoYXJ0LmJveGVzIGFycmF5IHRvIGJlIHNpemVkIGFjY29yZGluZ2x5XG5cdFx0XHRoZWxwZXJzLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdFx0XHQvLyBTZXQgSUxheW91dEl0ZW0gcGFyYW1ldGVycyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0c2NhbGUuZnVsbFdpZHRoID0gc2NhbGUub3B0aW9ucy5mdWxsV2lkdGg7XG5cdFx0XHRcdHNjYWxlLnBvc2l0aW9uID0gc2NhbGUub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRcdFx0c2NhbGUud2VpZ2h0ID0gc2NhbGUub3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRcdENoYXJ0LmxheW91dFNlcnZpY2UuYWRkQm94KGNoYXJ0LCBzY2FsZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59O1xuXG59LHtcIjI1XCI6MjUsXCI0NVwiOjQ1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQvKipcblx0ICogTmFtZXNwYWNlIHRvIGhvbGQgZ2VuZXJhdG9ycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXG5cdCAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3MuZ2VuZXJhdG9yc1xuXHQgKi9cblx0Z2VuZXJhdG9yczoge1xuXHRcdC8qKlxuXHRcdCAqIEludGVyZmFjZSBmb3IgdGhlIG9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIG51bWVyaWMgdGljayBnZW5lcmF0b3Jcblx0XHQgKiBAaW50ZXJmYWNlIElOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIGRpc3BsYXlcblx0XHQgKiBAbmFtZSBJTnVtZXJpY1RpY2tHZW5lcmF0aW9uT3B0aW9ucyNtYXhUaWNrc1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggdGljay5cblx0XHQgKiBAbmFtZSBJTnVtZXJpY1RpY2tHZW5lcmF0aW9uT3B0aW9ucyNzdGVwU2l6ZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBvcHRpb25hbFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIEZvcmNlZCBtaW5pbXVtIGZvciB0aGUgdGlja3MuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBtaW5pbXVtIG9mIHRoZSBkYXRhIHJhbmdlIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSB0aWNrIG1pbmltdW1cblx0XHQgKiBAbmFtZSBJTnVtZXJpY1RpY2tHZW5lcmF0aW9uT3B0aW9ucyNtaW5cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAb3B0aW9uYWxcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgdGlja3MuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBtYXhpbXVtIG9mIHRoZSBkYXRhIHJhbmdlIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSB0aWNrIG1heGltdW1cblx0XHQgKiBAbmFtZSBJTnVtZXJpY1RpY2tHZW5lcmF0aW9uT3B0aW9ucyNtYXhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAb3B0aW9uYWxcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrc1xuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZ2VuZXJhdG9ycy5saW5lYXJcblx0XHQgKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMge0lOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zfSB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuXHRcdCAqIEBwYXJhbSBkYXRhUmFuZ2Uge0lSYW5nZX0gdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG5cdFx0ICogQHJldHVybnMge0FycmF5PE51bWJlcj59IGFycmF5IG9mIHRpY2sgdmFsdWVzXG5cdFx0ICovXG5cdFx0bGluZWFyOiBmdW5jdGlvbihnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdFx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHRcdC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuXHRcdFx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuXHRcdFx0Ly8gZm9yIGRldGFpbHMuXG5cblx0XHRcdHZhciBzcGFjaW5nO1xuXHRcdFx0aWYgKGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplICYmIGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplID4gMCkge1xuXHRcdFx0XHRzcGFjaW5nID0gZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbmljZVJhbmdlID0gaGVscGVycy5uaWNlTnVtKGRhdGFSYW5nZS5tYXggLSBkYXRhUmFuZ2UubWluLCBmYWxzZSk7XG5cdFx0XHRcdHNwYWNpbmcgPSBoZWxwZXJzLm5pY2VOdW0obmljZVJhbmdlIC8gKGdlbmVyYXRpb25PcHRpb25zLm1heFRpY2tzIC0gMSksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5pY2VNaW4gPSBNYXRoLmZsb29yKGRhdGFSYW5nZS5taW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG5cdFx0XHR2YXIgbmljZU1heCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXG5cdFx0XHQvLyBJZiBtaW4sIG1heCBhbmQgc3RlcFNpemUgaXMgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG5cdFx0XHRpZiAoZ2VuZXJhdGlvbk9wdGlvbnMubWluICYmIGdlbmVyYXRpb25PcHRpb25zLm1heCAmJiBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwU2l6ZSkge1xuXHRcdFx0XHQvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciB3aG9sZSBudW1iZXIsIHVzZSBpdC5cblx0XHRcdFx0aWYgKGhlbHBlcnMuYWxtb3N0V2hvbGUoKGdlbmVyYXRpb25PcHRpb25zLm1heCAtIGdlbmVyYXRpb25PcHRpb25zLm1pbikgLyBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwU2l6ZSwgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRcdFx0bmljZU1pbiA9IGdlbmVyYXRpb25PcHRpb25zLm1pbjtcblx0XHRcdFx0XHRuaWNlTWF4ID0gZ2VuZXJhdGlvbk9wdGlvbnMubWF4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblx0XHRcdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cblx0XHRcdGlmIChoZWxwZXJzLmFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRcdG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgdGhlIHZhbHVlcyBpbnRvIHRoZSB0aWNrcyBhcnJheVxuXHRcdFx0dGlja3MucHVzaChnZW5lcmF0aW9uT3B0aW9ucy5taW4gIT09IHVuZGVmaW5lZCA/IGdlbmVyYXRpb25PcHRpb25zLm1pbiA6IG5pY2VNaW4pO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPCBudW1TcGFjZXM7ICsraikge1xuXHRcdFx0XHR0aWNrcy5wdXNoKG5pY2VNaW4gKyAoaiAqIHNwYWNpbmcpKTtcblx0XHRcdH1cblx0XHRcdHRpY2tzLnB1c2goZ2VuZXJhdGlvbk9wdGlvbnMubWF4ICE9PSB1bmRlZmluZWQgPyBnZW5lcmF0aW9uT3B0aW9ucy5tYXggOiBuaWNlTWF4KTtcblxuXHRcdFx0cmV0dXJuIHRpY2tzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZ2VuZXJhdG9ycy5sb2dhcml0aG1pY1xuXHRcdCAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB7SU51bWVyaWNUaWNrR2VuZXJhdGlvbk9wdGlvbnN9IHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG5cdFx0ICogQHBhcmFtIGRhdGFSYW5nZSB7SVJhbmdlfSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcblx0XHQgKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPn0gYXJyYXkgb2YgdGljayB2YWx1ZXNcblx0XHQgKi9cblx0XHRsb2dhcml0aG1pYzogZnVuY3Rpb24oZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuXHRcdFx0dmFyIHRpY2tzID0gW107XG5cdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXG5cdFx0XHQvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2Zcblx0XHRcdC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA1MFxuXHRcdFx0Ly8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cblx0XHRcdC8vIHRoZSBncmFwaFxuXHRcdFx0dmFyIHRpY2tWYWwgPSB2YWx1ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMubG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XG5cblx0XHRcdHZhciBlbmRFeHAgPSBNYXRoLmZsb29yKGhlbHBlcnMubG9nMTAoZGF0YVJhbmdlLm1heCkpO1xuXHRcdFx0dmFyIGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG5cdFx0XHR2YXIgZXhwLCBzaWduaWZpY2FuZDtcblxuXHRcdFx0aWYgKHRpY2tWYWwgPT09IDApIHtcblx0XHRcdFx0ZXhwID0gTWF0aC5mbG9vcihoZWxwZXJzLmxvZzEwKGRhdGFSYW5nZS5taW5Ob3RaZXJvKSk7XG5cdFx0XHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcihkYXRhUmFuZ2UubWluTm90WmVybyAvIE1hdGgucG93KDEwLCBleHApKTtcblxuXHRcdFx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXHRcdFx0XHR0aWNrVmFsID0gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycy5sb2cxMCh0aWNrVmFsKSk7XG5cdFx0XHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRkbyB7XG5cdFx0XHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XG5cblx0XHRcdFx0KytzaWduaWZpY2FuZDtcblx0XHRcdFx0aWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xuXHRcdFx0XHRcdHNpZ25pZmljYW5kID0gMTtcblx0XHRcdFx0XHQrK2V4cDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRpY2tWYWwgPSBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xuXHRcdFx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG5cblx0XHRcdHZhciBsYXN0VGljayA9IHZhbHVlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XG5cdFx0XHR0aWNrcy5wdXNoKGxhc3RUaWNrKTtcblxuXHRcdFx0cmV0dXJuIHRpY2tzO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXG5cdCAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3MuZm9ybWF0dGVyc1xuXHQgKi9cblx0Zm9ybWF0dGVyczoge1xuXHRcdC8qKlxuXHRcdCAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLnZhbHVlc1xuXHRcdCAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcblx0XHQgKi9cblx0XHR2YWx1ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciBsaW5lYXIgbnVtZXJpYyB0aWNrc1xuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0XHQgKiBAcGFyYW0gdGlja1ZhbHVlIHtOdW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcblx0XHQgKiBAcGFyYW0gaW5kZXgge051bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuXHRcdCAqIEBwYXJhbSB0aWNrcyB7QXJyYXk8TnVtYmVyPn0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcblx0XHQgKi9cblx0XHRsaW5lYXI6IGZ1bmN0aW9uKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGxvdHMgb2YgdGlja3MsIGRvbid0IHVzZSB0aGUgb25lc1xuXHRcdFx0dmFyIGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdIC0gdGlja3NbMV0gOiB0aWNrc1sxXSAtIHRpY2tzWzBdO1xuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG5cdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEpID4gMSkge1xuXHRcdFx0XHRpZiAodGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcblx0XHRcdFx0XHQvLyBub3QgYW4gaW50ZWdlclxuXHRcdFx0XHRcdGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb2dEZWx0YSA9IGhlbHBlcnMubG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcblx0XHRcdHZhciB0aWNrU3RyaW5nID0gJyc7XG5cblx0XHRcdGlmICh0aWNrVmFsdWUgIT09IDApIHtcblx0XHRcdFx0dmFyIG51bURlY2ltYWwgPSAtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpO1xuXHRcdFx0XHRudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4obnVtRGVjaW1hbCwgMjApLCAwKTsgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcblx0XHRcdFx0dGlja1N0cmluZyA9IHRpY2tWYWx1ZS50b0ZpeGVkKG51bURlY2ltYWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGlja1N0cmluZyA9ICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGlja1N0cmluZztcblx0XHR9LFxuXG5cdFx0bG9nYXJpdGhtaWM6IGZ1bmN0aW9uKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHR2YXIgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMubG9nMTAodGlja1ZhbHVlKSkpKTtcblxuXHRcdFx0aWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJzAnO1xuXHRcdFx0fSBlbHNlIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gdGlja3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRyZXR1cm4gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdH1cbn07XG5cbn0se1wiNDVcIjo0NX1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHR0b29sdGlwczoge1xuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0Y3VzdG9tOiBudWxsLFxuXHRcdG1vZGU6ICduZWFyZXN0Jyxcblx0XHRwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuXHRcdGludGVyc2VjdDogdHJ1ZSxcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuXHRcdHRpdGxlRm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0dGl0bGVTcGFjaW5nOiAyLFxuXHRcdHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuXHRcdHRpdGxlRm9udENvbG9yOiAnI2ZmZicsXG5cdFx0dGl0bGVBbGlnbjogJ2xlZnQnLFxuXHRcdGJvZHlTcGFjaW5nOiAyLFxuXHRcdGJvZHlGb250Q29sb3I6ICcjZmZmJyxcblx0XHRib2R5QWxpZ246ICdsZWZ0Jyxcblx0XHRmb290ZXJGb250U3R5bGU6ICdib2xkJyxcblx0XHRmb290ZXJTcGFjaW5nOiAyLFxuXHRcdGZvb3Rlck1hcmdpblRvcDogNixcblx0XHRmb290ZXJGb250Q29sb3I6ICcjZmZmJyxcblx0XHRmb290ZXJBbGlnbjogJ2xlZnQnLFxuXHRcdHlQYWRkaW5nOiA2LFxuXHRcdHhQYWRkaW5nOiA2LFxuXHRcdGNhcmV0UGFkZGluZzogMixcblx0XHRjYXJldFNpemU6IDUsXG5cdFx0Y29ybmVyUmFkaXVzOiA2LFxuXHRcdG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuXHRcdGRpc3BsYXlDb2xvcnM6IHRydWUsXG5cdFx0Ym9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcblx0XHRib3JkZXJXaWR0aDogMCxcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlVGl0bGU6IGhlbHBlcnMubm9vcCxcblx0XHRcdHRpdGxlOiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHRcdFx0Ly8gUGljayBmaXJzdCB4TGFiZWwgZm9yIG5vd1xuXHRcdFx0XHR2YXIgdGl0bGUgPSAnJztcblx0XHRcdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXHRcdFx0XHR2YXIgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuXG5cdFx0XHRcdGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuXG5cdFx0XHRcdFx0aWYgKGl0ZW0ueExhYmVsKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ueExhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5pbmRleCA8IGxhYmVsQ291bnQpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gbGFiZWxzW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aXRsZTtcblx0XHRcdH0sXG5cdFx0XHRhZnRlclRpdGxlOiBoZWxwZXJzLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlQm9keTogaGVscGVycy5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRcdFx0YmVmb3JlTGFiZWw6IGhlbHBlcnMubm9vcCxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gJzogJztcblx0XHRcdFx0fVxuXHRcdFx0XHRsYWJlbCArPSB0b29sdGlwSXRlbS55TGFiZWw7XG5cdFx0XHRcdHJldHVybiBsYWJlbDtcblx0XHRcdH0sXG5cdFx0XHRsYWJlbENvbG9yOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgY2hhcnQpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIgYWN0aXZlRWxlbWVudCA9IG1ldGEuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2aWV3ID0gYWN0aXZlRWxlbWVudC5fdmlldztcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogdmlldy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHZpZXcuYmFja2dyb3VuZENvbG9yXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxUZXh0Q29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5ib2R5Rm9udENvbG9yO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyTGFiZWw6IGhlbHBlcnMubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRhZnRlckJvZHk6IGhlbHBlcnMubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVGb290ZXI6IGhlbHBlcnMubm9vcCxcblx0XHRcdGZvb3RlcjogaGVscGVycy5ub29wLFxuXHRcdFx0YWZ0ZXJGb290ZXI6IGhlbHBlcnMubm9vcFxuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHQvKipcbiBcdCAqIEhlbHBlciBtZXRob2QgdG8gbWVyZ2UgdGhlIG9wYWNpdHkgaW50byBhIGNvbG9yXG4gXHQgKi9cblx0ZnVuY3Rpb24gbWVyZ2VPcGFjaXR5KGNvbG9yU3RyaW5nLCBvcGFjaXR5KSB7XG5cdFx0dmFyIGNvbG9yID0gaGVscGVycy5jb2xvcihjb2xvclN0cmluZyk7XG5cdFx0cmV0dXJuIGNvbG9yLmFscGhhKG9wYWNpdHkgKiBjb2xvci5hbHBoYSgpKS5yZ2JhU3RyaW5nKCk7XG5cdH1cblxuXHQvLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5cdGZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcblx0XHRpZiAodG9QdXNoKSB7XG5cdFx0XHRpZiAoaGVscGVycy5pc0FycmF5KHRvUHVzaCkpIHtcblx0XHRcdFx0Ly8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiYXNlLnB1c2godG9QdXNoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8vIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuXHQvLyBAcGFyYW0gZWxlbWVudCA6IHRoZSBjaGFydCBlbGVtZW50IChwb2ludCwgYXJjLCBiYXIpIHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuXHQvLyBAcmV0dXJuIDogbmV3IHRvb2x0aXAgaXRlbVxuXHRmdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShlbGVtZW50KSB7XG5cdFx0dmFyIHhTY2FsZSA9IGVsZW1lbnQuX3hTY2FsZTtcblx0XHR2YXIgeVNjYWxlID0gZWxlbWVudC5feVNjYWxlIHx8IGVsZW1lbnQuX3NjYWxlOyAvLyBoYW5kbGUgcmFkYXIgfHwgcG9sYXJBcmVhIGNoYXJ0c1xuXHRcdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBlbGVtZW50Ll9kYXRhc2V0SW5kZXg7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eExhYmVsOiB4U2NhbGUgPyB4U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdFx0eUxhYmVsOiB5U2NhbGUgPyB5U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsXG5cdFx0XHR4OiBlbGVtZW50Ll9tb2RlbC54LFxuXHRcdFx0eTogZWxlbWVudC5fbW9kZWwueVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIHRvIGdldCB0aGUgcmVzZXQgbW9kZWwgZm9yIHRoZSB0b29sdGlwXG5cdCAqIEBwYXJhbSB0b29sdGlwT3B0cyB7T2JqZWN0fSB0aGUgdG9vbHRpcCBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRCYXNlTW9kZWwodG9vbHRpcE9wdHMpIHtcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBkZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQvLyBQb3NpdGlvbmluZ1xuXHRcdFx0eFBhZGRpbmc6IHRvb2x0aXBPcHRzLnhQYWRkaW5nLFxuXHRcdFx0eVBhZGRpbmc6IHRvb2x0aXBPcHRzLnlQYWRkaW5nLFxuXHRcdFx0eEFsaWduOiB0b29sdGlwT3B0cy54QWxpZ24sXG5cdFx0XHR5QWxpZ246IHRvb2x0aXBPcHRzLnlBbGlnbixcblxuXHRcdFx0Ly8gQm9keVxuXHRcdFx0Ym9keUZvbnRDb2xvcjogdG9vbHRpcE9wdHMuYm9keUZvbnRDb2xvcixcblx0XHRcdF9ib2R5Rm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMuYm9keUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdF9ib2R5Rm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy5ib2R5Rm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcblx0XHRcdGJvZHlGb250U2l6ZTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMuYm9keUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdFx0Ym9keVNwYWNpbmc6IHRvb2x0aXBPcHRzLmJvZHlTcGFjaW5nLFxuXG5cdFx0XHQvLyBUaXRsZVxuXHRcdFx0dGl0bGVGb250Q29sb3I6IHRvb2x0aXBPcHRzLnRpdGxlRm9udENvbG9yLFxuXHRcdFx0X3RpdGxlRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0XHRfdGl0bGVGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0KHRvb2x0aXBPcHRzLnRpdGxlRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRcdHRpdGxlRm9udFNpemU6IHZhbHVlT3JEZWZhdWx0KHRvb2x0aXBPcHRzLnRpdGxlRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0XHRfdGl0bGVBbGlnbjogdG9vbHRpcE9wdHMudGl0bGVBbGlnbixcblx0XHRcdHRpdGxlU3BhY2luZzogdG9vbHRpcE9wdHMudGl0bGVTcGFjaW5nLFxuXHRcdFx0dGl0bGVNYXJnaW5Cb3R0b206IHRvb2x0aXBPcHRzLnRpdGxlTWFyZ2luQm90dG9tLFxuXG5cdFx0XHQvLyBGb290ZXJcblx0XHRcdGZvb3RlckZvbnRDb2xvcjogdG9vbHRpcE9wdHMuZm9vdGVyRm9udENvbG9yLFxuXHRcdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0KHRvb2x0aXBPcHRzLmZvb3RlckZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdF9mb290ZXJGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0KHRvb2x0aXBPcHRzLmZvb3RlckZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0XHRmb290ZXJGb250U2l6ZTogdmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMuZm9vdGVyRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxuXHRcdFx0Zm9vdGVyU3BhY2luZzogdG9vbHRpcE9wdHMuZm9vdGVyU3BhY2luZyxcblx0XHRcdGZvb3Rlck1hcmdpblRvcDogdG9vbHRpcE9wdHMuZm9vdGVyTWFyZ2luVG9wLFxuXG5cdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRjYXJldFNpemU6IHRvb2x0aXBPcHRzLmNhcmV0U2l6ZSxcblx0XHRcdGNvcm5lclJhZGl1czogdG9vbHRpcE9wdHMuY29ybmVyUmFkaXVzLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiB0b29sdGlwT3B0cy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0bGVnZW5kQ29sb3JCYWNrZ3JvdW5kOiB0b29sdGlwT3B0cy5tdWx0aUtleUJhY2tncm91bmQsXG5cdFx0XHRkaXNwbGF5Q29sb3JzOiB0b29sdGlwT3B0cy5kaXNwbGF5Q29sb3JzLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IHRvb2x0aXBPcHRzLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IHRvb2x0aXBPcHRzLmJvcmRlcldpZHRoXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcblx0ICovXG5cdGZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG1vZGVsKSB7XG5cdFx0dmFyIGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcblxuXHRcdHZhciBoZWlnaHQgPSBtb2RlbC55UGFkZGluZyAqIDI7IC8vIFRvb2x0aXAgUGFkZGluZ1xuXHRcdHZhciB3aWR0aCA9IDA7XG5cblx0XHQvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcblx0XHR2YXIgYm9keSA9IG1vZGVsLmJvZHk7XG5cdFx0dmFyIGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKGZ1bmN0aW9uKGNvdW50LCBib2R5SXRlbSkge1xuXHRcdFx0cmV0dXJuIGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aDtcblx0XHR9LCAwKTtcblx0XHRjb21iaW5lZEJvZHlMZW5ndGggKz0gbW9kZWwuYmVmb3JlQm9keS5sZW5ndGggKyBtb2RlbC5hZnRlckJvZHkubGVuZ3RoO1xuXG5cdFx0dmFyIHRpdGxlTGluZUNvdW50ID0gbW9kZWwudGl0bGUubGVuZ3RoO1xuXHRcdHZhciBmb290ZXJMaW5lQ291bnQgPSBtb2RlbC5mb290ZXIubGVuZ3RoO1xuXHRcdHZhciB0aXRsZUZvbnRTaXplID0gbW9kZWwudGl0bGVGb250U2l6ZTtcblx0XHR2YXIgYm9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplO1xuXHRcdHZhciBmb290ZXJGb250U2l6ZSA9IG1vZGVsLmZvb3RlckZvbnRTaXplO1xuXG5cdFx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250U2l6ZTsgLy8gVGl0bGUgTGluZXNcblx0XHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xuXHRcdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/IG1vZGVsLnRpdGxlTWFyZ2luQm90dG9tIDogMDsgLy8gVGl0bGUncyBib3R0b20gTWFyZ2luXG5cdFx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCAqIGJvZHlGb250U2l6ZTsgLy8gQm9keSBMaW5lc1xuXHRcdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXG5cdFx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IG1vZGVsLmZvb3Rlck1hcmdpblRvcCA6IDA7IC8vIEZvb3RlciBNYXJnaW5cblx0XHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ICogKGZvb3RlckZvbnRTaXplKTsgLy8gRm9vdGVyIExpbmVzXG5cdFx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXG5cblx0XHQvLyBUaXRsZSB3aWR0aFxuXHRcdHZhciB3aWR0aFBhZGRpbmcgPSAwO1xuXHRcdHZhciBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuXHRcdH07XG5cblx0XHRjdHguZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCBtb2RlbC5fdGl0bGVGb250U3R5bGUsIG1vZGVsLl90aXRsZUZvbnRGYW1pbHkpO1xuXHRcdGhlbHBlcnMuZWFjaChtb2RlbC50aXRsZSwgbWF4TGluZVdpZHRoKTtcblxuXHRcdC8vIEJvZHkgd2lkdGhcblx0XHRjdHguZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xuXHRcdGhlbHBlcnMuZWFjaChtb2RlbC5iZWZvcmVCb2R5LmNvbmNhdChtb2RlbC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG5cdFx0Ly8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG5cdFx0d2lkdGhQYWRkaW5nID0gbW9kZWwuZGlzcGxheUNvbG9ycyA/IChib2R5Rm9udFNpemUgKyAyKSA6IDA7XG5cdFx0aGVscGVycy5lYWNoKGJvZHksIGZ1bmN0aW9uKGJvZHlJdGVtKSB7XG5cdFx0XHRoZWxwZXJzLmVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuXHRcdFx0aGVscGVycy5lYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuXHRcdFx0aGVscGVycy5lYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVzZXQgYmFjayB0byAwXG5cdFx0d2lkdGhQYWRkaW5nID0gMDtcblxuXHRcdC8vIEZvb3RlciB3aWR0aFxuXHRcdGN0eC5mb250ID0gaGVscGVycy5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XG5cdFx0aGVscGVycy5lYWNoKG1vZGVsLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuXHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0d2lkdGggKz0gMiAqIG1vZGVsLnhQYWRkaW5nO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG5cdCAqL1xuXHRmdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQodG9vbHRpcCwgc2l6ZSkge1xuXHRcdHZhciBtb2RlbCA9IHRvb2x0aXAuX21vZGVsO1xuXHRcdHZhciBjaGFydCA9IHRvb2x0aXAuX2NoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSB0b29sdGlwLl9jaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdHZhciB5QWxpZ24gPSAnY2VudGVyJztcblxuXHRcdGlmIChtb2RlbC55IDwgc2l6ZS5oZWlnaHQpIHtcblx0XHRcdHlBbGlnbiA9ICd0b3AnO1xuXHRcdH0gZWxzZSBpZiAobW9kZWwueSA+IChjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodCkpIHtcblx0XHRcdHlBbGlnbiA9ICdib3R0b20nO1xuXHRcdH1cblxuXHRcdHZhciBsZiwgcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgbGVmdCwgcmlnaHQgYWxpZ25tZW50XG5cdFx0dmFyIG9sZiwgb3JmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGlmIGxlZnQvcmlnaHQgYWxpZ25tZW50IGNhdXNlcyB0b29sdGlwIHRvIGdvIG91dHNpZGUgY2hhcnRcblx0XHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXG5cdFx0dmFyIG1pZFggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcblx0XHR2YXIgbWlkWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0XHRyZXR1cm4geCA8PSBtaWRYO1xuXHRcdFx0fTtcblx0XHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0XHRyZXR1cm4geCA+IG1pZFg7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0cmV0dXJuIHggPD0gKHNpemUud2lkdGggLyAyKTtcblx0XHRcdH07XG5cdFx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0cmV0dXJuIHggPj0gKGNoYXJ0LndpZHRoIC0gKHNpemUud2lkdGggLyAyKSk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdG9sZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoO1xuXHRcdH07XG5cdFx0b3JmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggLSBzaXplLndpZHRoIDwgMDtcblx0XHR9O1xuXHRcdHlmID0gZnVuY3Rpb24oeSkge1xuXHRcdFx0cmV0dXJuIHkgPD0gbWlkWSA/ICd0b3AnIDogJ2JvdHRvbSc7XG5cdFx0fTtcblxuXHRcdGlmIChsZihtb2RlbC54KSkge1xuXHRcdFx0eEFsaWduID0gJ2xlZnQnO1xuXG5cdFx0XHQvLyBJcyB0b29sdGlwIHRvbyB3aWRlIGFuZCBnb2VzIG92ZXIgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGNoYXJ0Lj9cblx0XHRcdGlmIChvbGYobW9kZWwueCkpIHtcblx0XHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRcdHlBbGlnbiA9IHlmKG1vZGVsLnkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAocmYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdyaWdodCc7XG5cblx0XHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3V0c2lkZSBsZWZ0IGVkZ2Ugb2YgY2FudmFzP1xuXHRcdFx0aWYgKG9yZihtb2RlbC54KSkge1xuXHRcdFx0XHR4QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4QWxpZ246IG9wdHMueEFsaWduID8gb3B0cy54QWxpZ24gOiB4QWxpZ24sXG5cdFx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KHZtLCBzaXplLCBhbGlnbm1lbnQpIHtcblx0XHQvLyBCYWNrZ3JvdW5kIFBvc2l0aW9uXG5cdFx0dmFyIHggPSB2bS54O1xuXHRcdHZhciB5ID0gdm0ueTtcblxuXHRcdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdFx0dmFyIGNhcmV0UGFkZGluZyA9IHZtLmNhcmV0UGFkZGluZztcblx0XHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHRcdHZhciB4QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXHRcdHZhciBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcblx0XHR2YXIgcmFkaXVzQW5kUGFkZGluZyA9IGNvcm5lclJhZGl1cyArIGNhcmV0UGFkZGluZztcblxuXHRcdGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdHggLT0gc2l6ZS53aWR0aDtcblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHggLT0gKHNpemUud2lkdGggLyAyKTtcblx0XHR9XG5cblx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHkgLT0gc2l6ZS5oZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eSAtPSAoc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHggKz0gcGFkZGluZ0FuZFNpemU7XG5cdFx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHR4IC09IHBhZGRpbmdBbmRTaXplO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdHggLT0gcmFkaXVzQW5kUGFkZGluZztcblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0eCArPSByYWRpdXNBbmRQYWRkaW5nO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH1cblxuXHRDaGFydC5Ub29sdGlwID0gRWxlbWVudC5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fbW9kZWwgPSBnZXRCYXNlTW9kZWwodGhpcy5fb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdC8vIEdldCB0aGUgdGl0bGVcblx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRcdGdldFRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXHRcdFx0dmFyIGNhbGxiYWNrcyA9IG9wdHMuY2FsbGJhY2tzO1xuXG5cdFx0XHR2YXIgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBiZWZvcmVUaXRsZSk7XG5cdFx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgdGl0bGUpO1xuXHRcdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIGFmdGVyVGl0bGUpO1xuXG5cdFx0XHRyZXR1cm4gbGluZXM7XG5cdFx0fSxcblxuXHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbGluZXMgPSB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KGxpbmVzKSA/IGxpbmVzIDogbGluZXMgIT09IHVuZGVmaW5lZCA/IFtsaW5lc10gOiBbXTtcblx0XHR9LFxuXG5cdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRnZXRCb2R5OiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXHRcdFx0dmFyIGJvZHlJdGVtcyA9IFtdO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuXHRcdFx0XHR2YXIgYm9keUl0ZW0gPSB7XG5cdFx0XHRcdFx0YmVmb3JlOiBbXSxcblx0XHRcdFx0XHRsaW5lczogW10sXG5cdFx0XHRcdFx0YWZ0ZXI6IFtdXG5cdFx0XHRcdH07XG5cdFx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIGNhbGxiYWNrcy5iZWZvcmVMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpO1xuXHRcdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGNhbGxiYWNrcy5sYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpO1xuXHRcdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIGNhbGxiYWNrcy5hZnRlckxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cblx0XHRcdFx0Ym9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBib2R5SXRlbXM7XG5cdFx0fSxcblxuXHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsaW5lcyA9IHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGhlbHBlcnMuaXNBcnJheShsaW5lcykgPyBsaW5lcyA6IGxpbmVzICE9PSB1bmRlZmluZWQgPyBbbGluZXNdIDogW107XG5cdFx0fSxcblxuXHRcdC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG5cdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRnZXRGb290ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XG5cblx0XHRcdHZhciBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIGJlZm9yZUZvb3Rlcik7XG5cdFx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgZm9vdGVyKTtcblx0XHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBhZnRlckZvb3Rlcik7XG5cblx0XHRcdHJldHVybiBsaW5lcztcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihjaGFuZ2VkKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcblxuXHRcdFx0Ly8gTmVlZCB0byByZWdlbmVyYXRlIHRoZSBtb2RlbCBiZWNhdXNlIGl0cyBmYXN0ZXIgdGhhbiB1c2luZyBleHRlbmQgYW5kIGl0IGlzIG5lY2Vzc2FyeSBkdWUgdG8gdGhlIG9wdGltaXphdGlvbiBpbiBDaGFydC5FbGVtZW50LnRyYW5zaXRpb25cblx0XHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcblx0XHRcdC8vIHdoaWNoIGJyZWFrcyBhbnkgYW5pbWF0aW9ucy5cblx0XHRcdHZhciBleGlzdGluZ01vZGVsID0gbWUuX21vZGVsO1xuXHRcdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xuXHRcdFx0dmFyIGFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHRcdHZhciBkYXRhID0gbWUuX2RhdGE7XG5cblx0XHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXG5cdFx0XHR2YXIgYWxpZ25tZW50ID0ge1xuXHRcdFx0XHR4QWxpZ246IGV4aXN0aW5nTW9kZWwueEFsaWduLFxuXHRcdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXG5cdFx0XHR9O1xuXHRcdFx0dmFyIGJhY2tncm91bmRQb2ludCA9IHtcblx0XHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxuXHRcdFx0XHR5OiBleGlzdGluZ01vZGVsLnlcblx0XHRcdH07XG5cdFx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiBleGlzdGluZ01vZGVsLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGV4aXN0aW5nTW9kZWwuaGVpZ2h0XG5cdFx0XHR9O1xuXHRcdFx0dmFyIHRvb2x0aXBQb3NpdGlvbiA9IHtcblx0XHRcdFx0eDogZXhpc3RpbmdNb2RlbC5jYXJldFgsXG5cdFx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgaSwgbGVuO1xuXG5cdFx0XHRpZiAoYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0XHRtb2RlbC5vcGFjaXR5ID0gMTtcblxuXHRcdFx0XHR2YXIgbGFiZWxDb2xvcnMgPSBbXTtcblx0XHRcdFx0dmFyIGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuXHRcdFx0XHR0b29sdGlwUG9zaXRpb24gPSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzW29wdHMucG9zaXRpb25dKGFjdGl2ZSwgbWUuX2V2ZW50UG9zaXRpb24pO1xuXG5cdFx0XHRcdHZhciB0b29sdGlwSXRlbXMgPSBbXTtcblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdFx0dG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0oYWN0aXZlW2ldKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuXHRcdFx0XHRpZiAob3B0cy5maWx0ZXIpIHtcblx0XHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRzLmZpbHRlcihhLCBkYXRhKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgc29ydGluZyBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuXHRcdFx0XHRpZiAob3B0cy5pdGVtU29ydCkge1xuXHRcdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRzLml0ZW1Tb3J0KGEsIGIsIGRhdGEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGNvbG9ycyBmb3IgYm94ZXNcblx0XHRcdFx0aGVscGVycy5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdFx0XHRsYWJlbENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsQ29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xuXHRcdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdFx0fSk7XG5cblxuXHRcdFx0XHQvLyBCdWlsZCB0aGUgVGV4dCBMaW5lc1xuXHRcdFx0XHRtb2RlbC50aXRsZSA9IG1lLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRcdG1vZGVsLmJlZm9yZUJvZHkgPSBtZS5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRcdG1vZGVsLmJvZHkgPSBtZS5nZXRCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRcdG1vZGVsLmFmdGVyQm9keSA9IG1lLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0XHRtb2RlbC5mb290ZXIgPSBtZS5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblxuXHRcdFx0XHQvLyBJbml0aWFsIHBvc2l0aW9uaW5nIGFuZCBjb2xvcnNcblx0XHRcdFx0bW9kZWwueCA9IE1hdGgucm91bmQodG9vbHRpcFBvc2l0aW9uLngpO1xuXHRcdFx0XHRtb2RlbC55ID0gTWF0aC5yb3VuZCh0b29sdGlwUG9zaXRpb24ueSk7XG5cdFx0XHRcdG1vZGVsLmNhcmV0UGFkZGluZyA9IG9wdHMuY2FyZXRQYWRkaW5nO1xuXHRcdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuXHRcdFx0XHRtb2RlbC5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG5cblx0XHRcdFx0Ly8gZGF0YSBwb2ludHNcblx0XHRcdFx0bW9kZWwuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcblxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIGRldGVybWluZSBhbGlnbm1lbnQgb2YgdGhlIHRvb2x0aXBcblx0XHRcdFx0dG9vbHRpcFNpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBtb2RlbCk7XG5cdFx0XHRcdGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLCB0b29sdGlwU2l6ZSk7XG5cdFx0XHRcdC8vIEZpbmFsIFNpemUgYW5kIFBvc2l0aW9uXG5cdFx0XHRcdGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChtb2RlbCwgdG9vbHRpcFNpemUsIGFsaWdubWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0bW9kZWwueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcblx0XHRcdG1vZGVsLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdFx0XHRtb2RlbC54ID0gYmFja2dyb3VuZFBvaW50Lng7XG5cdFx0XHRtb2RlbC55ID0gYmFja2dyb3VuZFBvaW50Lnk7XG5cdFx0XHRtb2RlbC53aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdFx0bW9kZWwuaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xuXG5cdFx0XHQvLyBQb2ludCB3aGVyZSB0aGUgY2FyZXQgb24gdGhlIHRvb2x0aXAgcG9pbnRzIHRvXG5cdFx0XHRtb2RlbC5jYXJldFggPSB0b29sdGlwUG9zaXRpb24ueDtcblx0XHRcdG1vZGVsLmNhcmV0WSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXG5cdFx0XHRtZS5fbW9kZWwgPSBtb2RlbDtcblxuXHRcdFx0aWYgKGNoYW5nZWQgJiYgb3B0cy5jdXN0b20pIHtcblx0XHRcdFx0b3B0cy5jdXN0b20uY2FsbChtZSwgbW9kZWwpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fSxcblx0XHRkcmF3Q2FyZXQ6IGZ1bmN0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSkge1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0XHR2YXIgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIHZtKTtcblxuXHRcdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcblx0XHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG5cdFx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuXHRcdH0sXG5cdFx0Z2V0Q2FyZXRQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSkge1xuXHRcdFx0dmFyIHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cdFx0XHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xuXHRcdFx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblx0XHRcdHZhciB4QWxpZ24gPSB2bS54QWxpZ247XG5cdFx0XHR2YXIgeUFsaWduID0gdm0ueUFsaWduO1xuXHRcdFx0dmFyIHB0WCA9IHRvb2x0aXBQb2ludC54O1xuXHRcdFx0dmFyIHB0WSA9IHRvb2x0aXBQb2ludC55O1xuXHRcdFx0dmFyIHdpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdFx0eTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cblx0XHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0eDEgPSBwdFg7XG5cdFx0XHRcdFx0eDIgPSB4MSAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdFx0eTEgPSB5MiArIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR5MyA9IHkyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHgxID0gcHRYICsgd2lkdGg7XG5cdFx0XHRcdFx0eDIgPSB4MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdFx0eTEgPSB5MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR5MyA9IHkyICsgY2FyZXRTaXplO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xuXHRcdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0XHR4MiA9IHB0WCArIHdpZHRoIC0gY29ybmVyUmFkaXVzIC0gY2FyZXRTaXplO1xuXHRcdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4MiA9IHB0WCArICh3aWR0aCAvIDIpO1xuXHRcdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0XHRcdHkxID0gcHRZO1xuXHRcdFx0XHRcdHkyID0geTEgLSBjYXJldFNpemU7XG5cdFx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5MSA9IHB0WSArIGhlaWdodDtcblx0XHRcdFx0XHR5MiA9IHkxICsgY2FyZXRTaXplO1xuXHRcdFx0XHRcdHkzID0geTE7XG5cdFx0XHRcdFx0Ly8gaW52ZXJ0IGRyYXdpbmcgb3JkZXJcblx0XHRcdFx0XHR2YXIgdG1wID0geDM7XG5cdFx0XHRcdFx0eDMgPSB4MTtcblx0XHRcdFx0XHR4MSA9IHRtcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHt4MTogeDEsIHgyOiB4MiwgeDM6IHgzLCB5MTogeTEsIHkyOiB5MiwgeTM6IHkzfTtcblx0XHR9LFxuXHRcdGRyYXdUaXRsZTogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIG9wYWNpdHkpIHtcblx0XHRcdHZhciB0aXRsZSA9IHZtLnRpdGxlO1xuXG5cdFx0XHRpZiAodGl0bGUubGVuZ3RoKSB7XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fdGl0bGVBbGlnbjtcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHRcdHZhciB0aXRsZUZvbnRTaXplID0gdm0udGl0bGVGb250U2l6ZTtcblx0XHRcdFx0dmFyIHRpdGxlU3BhY2luZyA9IHZtLnRpdGxlU3BhY2luZztcblxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLnRpdGxlRm9udENvbG9yLCBvcGFjaXR5KTtcblx0XHRcdFx0Y3R4LmZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcodGl0bGVGb250U2l6ZSwgdm0uX3RpdGxlRm9udFN0eWxlLCB2bS5fdGl0bGVGb250RmFtaWx5KTtcblxuXHRcdFx0XHR2YXIgaSwgbGVuO1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aXRsZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcHQueCwgcHQueSk7XG5cdFx0XHRcdFx0cHQueSArPSB0aXRsZUZvbnRTaXplICsgdGl0bGVTcGFjaW5nOyAvLyBMaW5lIEhlaWdodCBhbmQgc3BhY2luZ1xuXG5cdFx0XHRcdFx0aWYgKGkgKyAxID09PSB0aXRsZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHB0LnkgKz0gdm0udGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkcmF3Qm9keTogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIG9wYWNpdHkpIHtcblx0XHRcdHZhciBib2R5Rm9udFNpemUgPSB2bS5ib2R5Rm9udFNpemU7XG5cdFx0XHR2YXIgYm9keVNwYWNpbmcgPSB2bS5ib2R5U3BhY2luZztcblx0XHRcdHZhciBib2R5ID0gdm0uYm9keTtcblxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl9ib2R5QWxpZ247XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIHZtLl9ib2R5Rm9udFN0eWxlLCB2bS5fYm9keUZvbnRGYW1pbHkpO1xuXG5cdFx0XHQvLyBCZWZvcmUgQm9keVxuXHRcdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54ICsgeExpbmVQYWRkaW5nLCBwdC55KTtcblx0XHRcdFx0cHQueSArPSBib2R5Rm9udFNpemUgKyBib2R5U3BhY2luZztcblx0XHRcdH07XG5cblx0XHRcdC8vIEJlZm9yZSBib2R5IGxpbmVzXG5cdFx0XHRoZWxwZXJzLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0XHR2YXIgZHJhd0NvbG9yQm94ZXMgPSB2bS5kaXNwbGF5Q29sb3JzO1xuXHRcdFx0eExpbmVQYWRkaW5nID0gZHJhd0NvbG9yQm94ZXMgPyAoYm9keUZvbnRTaXplICsgMikgOiAwO1xuXG5cdFx0XHQvLyBEcmF3IGJvZHkgbGluZXMgbm93XG5cdFx0XHRoZWxwZXJzLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0sIGkpIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChib2R5SXRlbS5saW5lcywgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRcdC8vIERyYXcgTGVnZW5kLWxpa2UgYm94ZXMgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XG5cdFx0XHRcdFx0XHQvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG1lcmdlT3BhY2l0eSh2bS5sZWdlbmRDb2xvckJhY2tncm91bmQsIG9wYWNpdHkpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHB0LngsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdFx0Ly8gQm9yZGVyXG5cdFx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gMTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG1lcmdlT3BhY2l0eSh2bS5sYWJlbENvbG9yc1tpXS5ib3JkZXJDb2xvciwgb3BhY2l0eSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdChwdC54LCBwdC55LCBib2R5Rm9udFNpemUsIGJvZHlGb250U2l6ZSk7XG5cblx0XHRcdFx0XHRcdC8vIElubmVyIHNxdWFyZVxuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG1lcmdlT3BhY2l0eSh2bS5sYWJlbENvbG9yc1tpXS5iYWNrZ3JvdW5kQ29sb3IsIG9wYWNpdHkpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHB0LnggKyAxLCBwdC55ICsgMSwgYm9keUZvbnRTaXplIC0gMiwgYm9keUZvbnRTaXplIC0gMik7XG5cdFx0XHRcdFx0XHR2YXIgdGV4dENvbG9yID0gbWVyZ2VPcGFjaXR5KHZtLmxhYmVsVGV4dENvbG9yc1tpXSwgb3BhY2l0eSk7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZpbGxMaW5lT2ZUZXh0KGxpbmUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcblx0XHRcdHhMaW5lUGFkZGluZyA9IDA7XG5cblx0XHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcblx0XHRcdGhlbHBlcnMuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRcdHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuXHRcdH0sXG5cdFx0ZHJhd0Zvb3RlcjogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIG9wYWNpdHkpIHtcblx0XHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XG5cblx0XHRcdGlmIChmb290ZXIubGVuZ3RoKSB7XG5cdFx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyTWFyZ2luVG9wO1xuXG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fZm9vdGVyQWxpZ247XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLmZvb3RlckZvbnRDb2xvciwgb3BhY2l0eSk7XG5cdFx0XHRcdGN0eC5mb250ID0gaGVscGVycy5mb250U3RyaW5nKHZtLmZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKGZvb3RlciwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54LCBwdC55KTtcblx0XHRcdFx0XHRwdC55ICs9IHZtLmZvb3RlckZvbnRTaXplICsgdm0uZm9vdGVyU3BhY2luZztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkcmF3QmFja2dyb3VuZDogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplLCBvcGFjaXR5KSB7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLmJhY2tncm91bmRDb2xvciwgb3BhY2l0eSk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0uYm9yZGVyQ29sb3IsIG9wYWNpdHkpO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xuXHRcdFx0dmFyIHhBbGlnbiA9IHZtLnhBbGlnbjtcblx0XHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0XHR2YXIgeCA9IHB0Lng7XG5cdFx0XHR2YXIgeSA9IHB0Lnk7XG5cdFx0XHR2YXIgd2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XG5cdFx0XHR2YXIgcmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcblx0XHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRcdGN0eC5maWxsKCk7XG5cblx0XHRcdGlmICh2bS5ib3JkZXJXaWR0aCA+IDApIHtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdFx0aWYgKHZtLm9wYWNpdHkgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiB2bS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiB2bS5oZWlnaHRcblx0XHRcdH07XG5cdFx0XHR2YXIgcHQgPSB7XG5cdFx0XHRcdHg6IHZtLngsXG5cdFx0XHRcdHk6IHZtLnlcblx0XHRcdH07XG5cblx0XHRcdC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcblx0XHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XG5cblx0XHRcdC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcblx0XHRcdHZhciBoYXNUb29sdGlwQ29udGVudCA9IHZtLnRpdGxlLmxlbmd0aCB8fCB2bS5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB2bS5ib2R5Lmxlbmd0aCB8fCB2bS5hZnRlckJvZHkubGVuZ3RoIHx8IHZtLmZvb3Rlci5sZW5ndGg7XG5cblx0XHRcdGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcblx0XHRcdFx0Ly8gRHJhdyBCYWNrZ3JvdW5kXG5cdFx0XHRcdHRoaXMuZHJhd0JhY2tncm91bmQocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplLCBvcGFjaXR5KTtcblxuXHRcdFx0XHQvLyBEcmF3IFRpdGxlLCBCb2R5LCBhbmQgRm9vdGVyXG5cdFx0XHRcdHB0LnggKz0gdm0ueFBhZGRpbmc7XG5cdFx0XHRcdHB0LnkgKz0gdm0ueVBhZGRpbmc7XG5cblx0XHRcdFx0Ly8gVGl0bGVzXG5cdFx0XHRcdHRoaXMuZHJhd1RpdGxlKHB0LCB2bSwgY3R4LCBvcGFjaXR5KTtcblxuXHRcdFx0XHQvLyBCb2R5XG5cdFx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgsIG9wYWNpdHkpO1xuXG5cdFx0XHRcdC8vIEZvb3RlclxuXHRcdFx0XHR0aGlzLmRyYXdGb290ZXIocHQsIHZtLCBjdHgsIG9wYWNpdHkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdFx0ICovXG5cdFx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLl9vcHRpb25zO1xuXHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG5cdFx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG5cdFx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLl9hY3RpdmUgPSBtZS5fY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRcdGNoYW5nZWQgPSAhaGVscGVycy5hcnJheUVxdWFscyhtZS5fYWN0aXZlLCBtZS5fbGFzdEFjdGl2ZSk7XG5cblx0XHRcdC8vIElmIHRvb2x0aXAgZGlkbid0IGNoYW5nZSwgZG8gbm90IGhhbmRsZSB0aGUgdGFyZ2V0IGV2ZW50XG5cdFx0XHRpZiAoIWNoYW5nZWQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5fbGFzdEFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5jdXN0b20pIHtcblx0XHRcdFx0bWUuX2V2ZW50UG9zaXRpb24gPSB7XG5cdFx0XHRcdFx0eDogZS54LFxuXHRcdFx0XHRcdHk6IGUueVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcblx0XHRcdFx0bWUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHRtZS5waXZvdCgpO1xuXG5cdFx0XHRcdC8vIFNlZSBpZiBvdXIgdG9vbHRpcCBwb3NpdGlvbiBjaGFuZ2VkXG5cdFx0XHRcdGNoYW5nZWQgfD0gKG1vZGVsLnggIT09IG1lLl9tb2RlbC54KSB8fCAobW9kZWwueSAhPT0gbWUuX21vZGVsLnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcblx0ICovXG5cdENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMgPSB7XG5cdFx0LyoqXG5cdFx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5hdmVyYWdlXG5cdFx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydEVsZW1lbnRbXX0gdGhlIGVsZW1lbnRzIGJlaW5nIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcFxuXHRcdCAqIEByZXR1cm5zIHtQb2ludH0gdG9vbHRpcCBwb3NpdGlvblxuXHRcdCAqL1xuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0XHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHR2YXIgeCA9IDA7XG5cdFx0XHR2YXIgeSA9IDA7XG5cdFx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0XHR2YXIgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG5cdFx0XHRcdFx0eCArPSBwb3MueDtcblx0XHRcdFx0XHR5ICs9IHBvcy55O1xuXHRcdFx0XHRcdCsrY291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogTWF0aC5yb3VuZCh4IC8gY291bnQpLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKHkgLyBjb3VudClcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIHRvb2x0aXAgcG9zaXRpb24gbmVhcmVzdCBvZiB0aGUgaXRlbSBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLm5lYXJlc3Rcblx0XHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0LkVsZW1lbnRbXX0gdGhlIHRvb2x0aXAgZWxlbWVudHNcblx0XHQgKiBAcGFyYW0gZXZlbnRQb3NpdGlvbiB7UG9pbnR9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgaW4gY2FudmFzIGNvb3JkaW5hdGVzXG5cdFx0ICogQHJldHVybnMge1BvaW50fSB0aGUgdG9vbHRpcCBwb3NpdGlvblxuXHRcdCAqL1xuXHRcdG5lYXJlc3Q6IGZ1bmN0aW9uKGVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgeCA9IGV2ZW50UG9zaXRpb24ueDtcblx0XHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xuXHRcdFx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdFx0dmFyIGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG5cblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdFx0XHRcdHZhciBkID0gaGVscGVycy5kaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcblxuXHRcdFx0XHRcdGlmIChkIDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gZDtcblx0XHRcdFx0XHRcdG5lYXJlc3RFbGVtZW50ID0gZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZWFyZXN0RWxlbWVudCkge1xuXHRcdFx0XHR2YXIgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcblx0XHRcdFx0eCA9IHRwLng7XG5cdFx0XHRcdHkgPSB0cC55O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjI2XCI6MjYsXCI0NVwiOjQ1fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgyNik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0YXJjOiB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogJyNmZmYnLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDJcblx0XHR9XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQuZXh0ZW5kKHtcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKGNoYXJ0WCwgY2hhcnRZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bSkge1xuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMuZ2V0QW5nbGVGcm9tUG9pbnQodm0sIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuXHRcdFx0dmFyXHRhbmdsZSA9IHBvaW50UmVsYXRpdmVQb3NpdGlvbi5hbmdsZTtcblx0XHRcdHZhciBkaXN0YW5jZSA9IHBvaW50UmVsYXRpdmVQb3NpdGlvbi5kaXN0YW5jZTtcblxuXHRcdFx0Ly8gU2FuaXRpc2UgYW5nbGUgcmFuZ2Vcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gdm0uc3RhcnRBbmdsZTtcblx0XHRcdHZhciBlbmRBbmdsZSA9IHZtLmVuZEFuZ2xlO1xuXHRcdFx0d2hpbGUgKGVuZEFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRlbmRBbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlID4gZW5kQW5nbGUpIHtcblx0XHRcdFx0YW5nbGUgLT0gMi4wICogTWF0aC5QSTtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChhbmdsZSA8IHN0YXJ0QW5nbGUpIHtcblx0XHRcdFx0YW5nbGUgKz0gMi4wICogTWF0aC5QSTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgb3Blbi9jbG9zZSBhbmdsZVxuXHRcdFx0dmFyIGJldHdlZW5BbmdsZXMgPSAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgd2l0aGluUmFkaXVzID0gKGRpc3RhbmNlID49IHZtLmlubmVyUmFkaXVzICYmIGRpc3RhbmNlIDw9IHZtLm91dGVyUmFkaXVzKTtcblxuXHRcdFx0cmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgaGFsZkFuZ2xlID0gKHZtLnN0YXJ0QW5nbGUgKyB2bS5lbmRBbmdsZSkgLyAyO1xuXHRcdHZhciBoYWxmUmFkaXVzID0gKHZtLmlubmVyUmFkaXVzICsgdm0ub3V0ZXJSYWRpdXMpIC8gMjtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuXHRcdFx0eTogdm0ueSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG5cdFx0fTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiBNYXRoLlBJICogKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gKDIgKiBNYXRoLlBJKSkgKiAoTWF0aC5wb3codm0ub3V0ZXJSYWRpdXMsIDIpIC0gTWF0aC5wb3codm0uaW5uZXJSYWRpdXMsIDIpKTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGNlbnRyZUFuZ2xlID0gdm0uc3RhcnRBbmdsZSArICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvIDIpO1xuXHRcdHZhciByYW5nZUZyb21DZW50cmUgPSAodm0ub3V0ZXJSYWRpdXMgLSB2bS5pbm5lclJhZGl1cykgLyAyICsgdm0uaW5uZXJSYWRpdXM7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCArIChNYXRoLmNvcyhjZW50cmVBbmdsZSkgKiByYW5nZUZyb21DZW50cmUpLFxuXHRcdFx0eTogdm0ueSArIChNYXRoLnNpbihjZW50cmVBbmdsZSkgKiByYW5nZUZyb21DZW50cmUpXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIHNBID0gdm0uc3RhcnRBbmdsZTtcblx0XHR2YXIgZUEgPSB2bS5lbmRBbmdsZTtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0ub3V0ZXJSYWRpdXMsIHNBLCBlQSk7XG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cywgZUEsIHNBLCB0cnVlKTtcblxuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRjdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xuXG5cdFx0aWYgKHZtLmJvcmRlcldpZHRoKSB7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNixcIjQ1XCI6NDV9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKDI2KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbnZhciBnbG9iYWxEZWZhdWx0cyA9IGRlZmF1bHRzLmdsb2JhbDtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdHRlbnNpb246IDAuNCxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDMsXG5cdFx0XHRib3JkZXJDb2xvcjogZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyQ2FwU3R5bGU6ICdidXR0Jyxcblx0XHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wLFxuXHRcdFx0Ym9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuXHRcdFx0Y2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuXHRcdFx0ZmlsbDogdHJ1ZSwgLy8gZG8gd2UgZmlsbCBpbiB0aGUgYXJlYSBiZXR3ZWVuIHRoZSBsaW5lIGFuZCBpdHMgYmFzZSBheGlzXG5cdFx0fVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50LmV4dGVuZCh7XG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHZtID0gbWUuX3ZpZXc7XG5cdFx0dmFyIGN0eCA9IG1lLl9jaGFydC5jdHg7XG5cdFx0dmFyIHNwYW5HYXBzID0gdm0uc3BhbkdhcHM7XG5cdFx0dmFyIHBvaW50cyA9IG1lLl9jaGlsZHJlbi5zbGljZSgpOyAvLyBjbG9uZSBhcnJheVxuXHRcdHZhciBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsYXN0RHJhd25JbmRleCA9IC0xO1xuXHRcdHZhciBpbmRleCwgY3VycmVudCwgcHJldmlvdXMsIGN1cnJlbnRWTTtcblxuXHRcdC8vIElmIHdlIGFyZSBsb29waW5nLCBhZGRpbmcgdGhlIGZpcnN0IHBvaW50IGFnYWluXG5cdFx0aWYgKG1lLl9sb29wICYmIHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Y3R4LnNhdmUoKTtcblxuXHRcdC8vIFN0cm9rZSBMaW5lIE9wdGlvbnNcblx0XHRjdHgubGluZUNhcCA9IHZtLmJvcmRlckNhcFN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJDYXBTdHlsZTtcblxuXHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaCh2bS5ib3JkZXJEYXNoIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJEYXNoKTtcblx0XHR9XG5cblx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2bS5ib3JkZXJEYXNoT2Zmc2V0IHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJEYXNoT2Zmc2V0O1xuXHRcdGN0eC5saW5lSm9pbiA9IHZtLmJvcmRlckpvaW5TdHlsZSB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVySm9pblN0eWxlO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aCB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyV2lkdGg7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmVcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0bGFzdERyYXduSW5kZXggPSAtMTtcblxuXHRcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcblx0XHRcdGN1cnJlbnQgPSBwb2ludHNbaW5kZXhdO1xuXHRcdFx0cHJldmlvdXMgPSBoZWxwZXJzLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KTtcblx0XHRcdGN1cnJlbnRWTSA9IGN1cnJlbnQuX3ZpZXc7XG5cblx0XHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXZpb3VzID0gbGFzdERyYXduSW5kZXggPT09IC0xID8gcHJldmlvdXMgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xuXG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRpZiAoKGxhc3REcmF3bkluZGV4ICE9PSAoaW5kZXggLSAxKSAmJiAhc3BhbkdhcHMpIHx8IGxhc3REcmF3bkluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIGEgZ2FwIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCBhZnRlciB0aGUgZ2FwXG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIExpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdFx0aGVscGVycy5jYW52YXMubGluZVRvKGN0eCwgcHJldmlvdXMuX3ZpZXcsIGN1cnJlbnQuX3ZpZXcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXN0RHJhd25JbmRleCA9IGluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cbn0pO1xuXG59LHtcIjI1XCI6MjUsXCIyNlwiOjI2LFwiNDVcIjo0NX1dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoMjYpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxudmFyIGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRwb2ludDoge1xuXHRcdFx0cmFkaXVzOiAzLFxuXHRcdFx0cG9pbnRTdHlsZTogJ2NpcmNsZScsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRcdC8vIEhvdmVyXG5cdFx0XHRoaXRSYWRpdXM6IDEsXG5cdFx0XHRob3ZlclJhZGl1czogNCxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6IDFcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiB4UmFuZ2UobW91c2VYKSB7XG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdHJldHVybiB2bSA/IChNYXRoLnBvdyhtb3VzZVggLSB2bS54LCAyKSA8IE1hdGgucG93KHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cywgMikpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHlSYW5nZShtb3VzZVkpIHtcblx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0cmV0dXJuIHZtID8gKE1hdGgucG93KG1vdXNlWSAtIHZtLnksIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzLCAyKSkgOiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50LmV4dGVuZCh7XG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0gPyAoKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpICsgTWF0aC5wb3cobW91c2VZIC0gdm0ueSwgMikpIDwgTWF0aC5wb3codm0uaGl0UmFkaXVzICsgdm0ucmFkaXVzLCAyKSkgOiBmYWxzZTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IHhSYW5nZSxcblx0aW5YUmFuZ2U6IHhSYW5nZSxcblx0aW5ZUmFuZ2U6IHlSYW5nZSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5fdmlldy5yYWRpdXMsIDIpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnksXG5cdFx0XHRwYWRkaW5nOiB2bS5yYWRpdXMgKyB2bS5ib3JkZXJXaWR0aFxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgbW9kZWwgPSB0aGlzLl9tb2RlbDtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciBwb2ludFN0eWxlID0gdm0ucG9pbnRTdHlsZTtcblx0XHR2YXIgcmFkaXVzID0gdm0ucmFkaXVzO1xuXHRcdHZhciB4ID0gdm0ueDtcblx0XHR2YXIgeSA9IHZtLnk7XG5cdFx0dmFyIGNvbG9yID0gaGVscGVycy5jb2xvcjtcblx0XHR2YXIgZXJyTWFyZ2luID0gMS4wMTsgLy8gMS4wMSBpcyBtYXJnaW4gZm9yIEFjY3VtdWxhdGVkIGVycm9yLiAoRXNwZWNpYWxseSBFZGdlLCBJRS4pXG5cdFx0dmFyIHJhdGlvID0gMDtcblxuXHRcdGlmICh2bS5za2lwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KHZtLmJvcmRlcldpZHRoLCBkZWZhdWx0cy5nbG9iYWwuZWxlbWVudHMucG9pbnQuYm9yZGVyV2lkdGgpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXG5cdFx0Ly8gQ2xpcGluZyBmb3IgUG9pbnRzLlxuXHRcdC8vIGdvaW5nIG91dCBmcm9tIGlubmVyIGNoYXJBcmVhP1xuXHRcdGlmICgoY2hhcnRBcmVhICE9PSB1bmRlZmluZWQpICYmICgobW9kZWwueCA8IGNoYXJ0QXJlYS5sZWZ0KSB8fCAoY2hhcnRBcmVhLnJpZ2h0ICogZXJyTWFyZ2luIDwgbW9kZWwueCkgfHwgKG1vZGVsLnkgPCBjaGFydEFyZWEudG9wKSB8fCAoY2hhcnRBcmVhLmJvdHRvbSAqIGVyck1hcmdpbiA8IG1vZGVsLnkpKSkge1xuXHRcdFx0Ly8gUG9pbnQgZmFkZSBvdXRcblx0XHRcdGlmIChtb2RlbC54IDwgY2hhcnRBcmVhLmxlZnQpIHtcblx0XHRcdFx0cmF0aW8gPSAoeCAtIG1vZGVsLngpIC8gKGNoYXJ0QXJlYS5sZWZ0IC0gbW9kZWwueCk7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJ0QXJlYS5yaWdodCAqIGVyck1hcmdpbiA8IG1vZGVsLngpIHtcblx0XHRcdFx0cmF0aW8gPSAobW9kZWwueCAtIHgpIC8gKG1vZGVsLnggLSBjaGFydEFyZWEucmlnaHQpO1xuXHRcdFx0fSBlbHNlIGlmIChtb2RlbC55IDwgY2hhcnRBcmVhLnRvcCkge1xuXHRcdFx0XHRyYXRpbyA9ICh5IC0gbW9kZWwueSkgLyAoY2hhcnRBcmVhLnRvcCAtIG1vZGVsLnkpO1xuXHRcdFx0fSBlbHNlIGlmIChjaGFydEFyZWEuYm90dG9tICogZXJyTWFyZ2luIDwgbW9kZWwueSkge1xuXHRcdFx0XHRyYXRpbyA9IChtb2RlbC55IC0geSkgLyAobW9kZWwueSAtIGNoYXJ0QXJlYS5ib3R0b20pO1xuXHRcdFx0fVxuXHRcdFx0cmF0aW8gPSBNYXRoLnJvdW5kKHJhdGlvICogMTAwKSAvIDEwMDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yKGN0eC5zdHJva2VTdHlsZSkuYWxwaGEocmF0aW8pLnJnYlN0cmluZygpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yKGN0eC5maWxsU3R5bGUpLmFscGhhKHJhdGlvKS5yZ2JTdHJpbmcoKTtcblx0XHR9XG5cblx0XHRoZWxwZXJzLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBwb2ludFN0eWxlLCByYWRpdXMsIHgsIHkpO1xuXHR9XG59KTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNixcIjQ1XCI6NDV9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKDI2KTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHJlY3RhbmdsZToge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnYm90dG9tJyxcblx0XHRcdGJvcmRlcldpZHRoOiAwXG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gaXNWZXJ0aWNhbChiYXIpIHtcblx0cmV0dXJuIGJhci5fdmlldy53aWR0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0gYmFyIHtDaGFydC5FbGVtZW50LlJlY3RhbmdsZX0gdGhlIGJhclxuICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhcikge1xuXHR2YXIgdm0gPSBiYXIuX3ZpZXc7XG5cdHZhciB4MSwgeDIsIHkxLCB5MjtcblxuXHRpZiAoaXNWZXJ0aWNhbChiYXIpKSB7XG5cdFx0Ly8gdmVydGljYWxcblx0XHR2YXIgaGFsZldpZHRoID0gdm0ud2lkdGggLyAyO1xuXHRcdHgxID0gdm0ueCAtIGhhbGZXaWR0aDtcblx0XHR4MiA9IHZtLnggKyBoYWxmV2lkdGg7XG5cdFx0eTEgPSBNYXRoLm1pbih2bS55LCB2bS5iYXNlKTtcblx0XHR5MiA9IE1hdGgubWF4KHZtLnksIHZtLmJhc2UpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGhvcml6b250YWwgYmFyXG5cdFx0dmFyIGhhbGZIZWlnaHQgPSB2bS5oZWlnaHQgLyAyO1xuXHRcdHgxID0gTWF0aC5taW4odm0ueCwgdm0uYmFzZSk7XG5cdFx0eDIgPSBNYXRoLm1heCh2bS54LCB2bS5iYXNlKTtcblx0XHR5MSA9IHZtLnkgLSBoYWxmSGVpZ2h0O1xuXHRcdHkyID0gdm0ueSArIGhhbGZIZWlnaHQ7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IHgxLFxuXHRcdHRvcDogeTEsXG5cdFx0cmlnaHQ6IHgyLFxuXHRcdGJvdHRvbTogeTJcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50LmV4dGVuZCh7XG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBzaWduWCwgc2lnblksIGJvcmRlclNraXBwZWQ7XG5cdFx0dmFyIGJvcmRlcldpZHRoID0gdm0uYm9yZGVyV2lkdGg7XG5cblx0XHRpZiAoIXZtLmhvcml6b250YWwpIHtcblx0XHRcdC8vIGJhclxuXHRcdFx0bGVmdCA9IHZtLnggLSB2bS53aWR0aCAvIDI7XG5cdFx0XHRyaWdodCA9IHZtLnggKyB2bS53aWR0aCAvIDI7XG5cdFx0XHR0b3AgPSB2bS55O1xuXHRcdFx0Ym90dG9tID0gdm0uYmFzZTtcblx0XHRcdHNpZ25YID0gMTtcblx0XHRcdHNpZ25ZID0gYm90dG9tID4gdG9wID8gMSA6IC0xO1xuXHRcdFx0Ym9yZGVyU2tpcHBlZCA9IHZtLmJvcmRlclNraXBwZWQgfHwgJ2JvdHRvbSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGhvcml6b250YWwgYmFyXG5cdFx0XHRsZWZ0ID0gdm0uYmFzZTtcblx0XHRcdHJpZ2h0ID0gdm0ueDtcblx0XHRcdHRvcCA9IHZtLnkgLSB2bS5oZWlnaHQgLyAyO1xuXHRcdFx0Ym90dG9tID0gdm0ueSArIHZtLmhlaWdodCAvIDI7XG5cdFx0XHRzaWduWCA9IHJpZ2h0ID4gbGVmdCA/IDEgOiAtMTtcblx0XHRcdHNpZ25ZID0gMTtcblx0XHRcdGJvcmRlclNraXBwZWQgPSB2bS5ib3JkZXJTa2lwcGVkIHx8ICdsZWZ0Jztcblx0XHR9XG5cblx0XHQvLyBDYW52YXMgZG9lc24ndCBhbGxvdyB1cyB0byBzdHJva2UgaW5zaWRlIHRoZSB3aWR0aCBzbyB3ZSBjYW5cblx0XHQvLyBhZGp1c3QgdGhlIHNpemVzIHRvIGZpdCBpZiB3ZSdyZSBzZXR0aW5nIGEgc3Ryb2tlIG9uIHRoZSBsaW5lXG5cdFx0aWYgKGJvcmRlcldpZHRoKSB7XG5cdFx0XHQvLyBib3JkZXJXaWR0aCBzaG9sZCBiZSBsZXNzIHRoYW4gYmFyIHdpZHRoIGFuZCBiYXIgaGVpZ2h0LlxuXHRcdFx0dmFyIGJhclNpemUgPSBNYXRoLm1pbihNYXRoLmFicyhsZWZ0IC0gcmlnaHQpLCBNYXRoLmFicyh0b3AgLSBib3R0b20pKTtcblx0XHRcdGJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggPiBiYXJTaXplID8gYmFyU2l6ZSA6IGJvcmRlcldpZHRoO1xuXHRcdFx0dmFyIGhhbGZTdHJva2UgPSBib3JkZXJXaWR0aCAvIDI7XG5cdFx0XHQvLyBBZGp1c3QgYm9yZGVyV2lkdGggd2hlbiBiYXIgdG9wIHBvc2l0aW9uIGlzIG5lYXIgdm0uYmFzZSh6ZXJvKS5cblx0XHRcdHZhciBib3JkZXJMZWZ0ID0gbGVmdCArIChib3JkZXJTa2lwcGVkICE9PSAnbGVmdCcgPyBoYWxmU3Ryb2tlICogc2lnblggOiAwKTtcblx0XHRcdHZhciBib3JkZXJSaWdodCA9IHJpZ2h0ICsgKGJvcmRlclNraXBwZWQgIT09ICdyaWdodCcgPyAtaGFsZlN0cm9rZSAqIHNpZ25YIDogMCk7XG5cdFx0XHR2YXIgYm9yZGVyVG9wID0gdG9wICsgKGJvcmRlclNraXBwZWQgIT09ICd0b3AnID8gaGFsZlN0cm9rZSAqIHNpZ25ZIDogMCk7XG5cdFx0XHR2YXIgYm9yZGVyQm90dG9tID0gYm90dG9tICsgKGJvcmRlclNraXBwZWQgIT09ICdib3R0b20nID8gLWhhbGZTdHJva2UgKiBzaWduWSA6IDApO1xuXHRcdFx0Ly8gbm90IGJlY29tZSBhIHZlcnRpY2FsIGxpbmU/XG5cdFx0XHRpZiAoYm9yZGVyTGVmdCAhPT0gYm9yZGVyUmlnaHQpIHtcblx0XHRcdFx0dG9wID0gYm9yZGVyVG9wO1xuXHRcdFx0XHRib3R0b20gPSBib3JkZXJCb3R0b207XG5cdFx0XHR9XG5cdFx0XHQvLyBub3QgYmVjb21lIGEgaG9yaXpvbnRhbCBsaW5lP1xuXHRcdFx0aWYgKGJvcmRlclRvcCAhPT0gYm9yZGVyQm90dG9tKSB7XG5cdFx0XHRcdGxlZnQgPSBib3JkZXJMZWZ0O1xuXHRcdFx0XHRyaWdodCA9IGJvcmRlclJpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcblxuXHRcdC8vIENvcm5lciBwb2ludHMsIGZyb20gYm90dG9tLWxlZnQgdG8gYm90dG9tLXJpZ2h0IGNsb2Nrd2lzZVxuXHRcdC8vIHwgMSAyIHxcblx0XHQvLyB8IDAgMyB8XG5cdFx0dmFyIGNvcm5lcnMgPSBbXG5cdFx0XHRbbGVmdCwgYm90dG9tXSxcblx0XHRcdFtsZWZ0LCB0b3BdLFxuXHRcdFx0W3JpZ2h0LCB0b3BdLFxuXHRcdFx0W3JpZ2h0LCBib3R0b21dXG5cdFx0XTtcblxuXHRcdC8vIEZpbmQgZmlyc3QgKHN0YXJ0aW5nKSBjb3JuZXIgd2l0aCBmYWxsYmFjayB0byAnYm90dG9tJ1xuXHRcdHZhciBib3JkZXJzID0gWydib3R0b20nLCAnbGVmdCcsICd0b3AnLCAncmlnaHQnXTtcblx0XHR2YXIgc3RhcnRDb3JuZXIgPSBib3JkZXJzLmluZGV4T2YoYm9yZGVyU2tpcHBlZCwgMCk7XG5cdFx0aWYgKHN0YXJ0Q29ybmVyID09PSAtMSkge1xuXHRcdFx0c3RhcnRDb3JuZXIgPSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcm5lckF0KGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gY29ybmVyc1soc3RhcnRDb3JuZXIgKyBpbmRleCkgJSA0XTtcblx0XHR9XG5cblx0XHQvLyBEcmF3IHJlY3RhbmdsZSBmcm9tICdzdGFydENvcm5lcidcblx0XHR2YXIgY29ybmVyID0gY29ybmVyQXQoMCk7XG5cdFx0Y3R4Lm1vdmVUbyhjb3JuZXJbMF0sIGNvcm5lclsxXSk7XG5cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IDQ7IGkrKykge1xuXHRcdFx0Y29ybmVyID0gY29ybmVyQXQoaSk7XG5cdFx0XHRjdHgubGluZVRvKGNvcm5lclswXSwgY29ybmVyWzFdKTtcblx0XHR9XG5cblx0XHRjdHguZmlsbCgpO1xuXHRcdGlmIChib3JkZXJXaWR0aCkge1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRoZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHZtLmJhc2UgLSB2bS55O1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIGluUmFuZ2UgPSBmYWxzZTtcblxuXHRcdGlmICh0aGlzLl92aWV3KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gZ2V0QmFyQm91bmRzKHRoaXMpO1xuXHRcdFx0aW5SYW5nZSA9IG1vdXNlWCA+PSBib3VuZHMubGVmdCAmJiBtb3VzZVggPD0gYm91bmRzLnJpZ2h0ICYmIG1vdXNlWSA+PSBib3VuZHMudG9wICYmIG1vdXNlWSA8PSBib3VuZHMuYm90dG9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBpblJhbmdlO1xuXHR9LFxuXG5cdGluTGFiZWxSYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmICghbWUuX3ZpZXcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgaW5SYW5nZSA9IGZhbHNlO1xuXHRcdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHMobWUpO1xuXG5cdFx0aWYgKGlzVmVydGljYWwobWUpKSB7XG5cdFx0XHRpblJhbmdlID0gbW91c2VYID49IGJvdW5kcy5sZWZ0ICYmIG1vdXNlWCA8PSBib3VuZHMucmlnaHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluUmFuZ2UgPSBtb3VzZVkgPj0gYm91bmRzLnRvcCAmJiBtb3VzZVkgPD0gYm91bmRzLmJvdHRvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5SYW5nZTtcblx0fSxcblxuXHRpblhSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XG5cdFx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh0aGlzKTtcblx0XHRyZXR1cm4gbW91c2VYID49IGJvdW5kcy5sZWZ0ICYmIG1vdXNlWCA8PSBib3VuZHMucmlnaHQ7XG5cdH0sXG5cblx0aW5ZUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWSkge1xuXHRcdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModGhpcyk7XG5cdFx0cmV0dXJuIG1vdXNlWSA+PSBib3VuZHMudG9wICYmIG1vdXNlWSA8PSBib3VuZHMuYm90dG9tO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciB4LCB5O1xuXHRcdGlmIChpc1ZlcnRpY2FsKHRoaXMpKSB7XG5cdFx0XHR4ID0gdm0ueDtcblx0XHRcdHkgPSAodm0ueSArIHZtLmJhc2UpIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9ICh2bS54ICsgdm0uYmFzZSkgLyAyO1xuXHRcdFx0eSA9IHZtLnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHt4OiB4LCB5OiB5fTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bS53aWR0aCAqIE1hdGguYWJzKHZtLnkgLSB2bS5iYXNlKTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55XG5cdFx0fTtcblx0fVxufSk7XG5cbn0se1wiMjVcIjoyNSxcIjI2XCI6MjZ9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5tb2R1bGUuZXhwb3J0cy5BcmMgPSByZXF1aXJlKDM2KTtcbm1vZHVsZS5leHBvcnRzLkxpbmUgPSByZXF1aXJlKDM3KTtcbm1vZHVsZS5leHBvcnRzLlBvaW50ID0gcmVxdWlyZSgzOCk7XG5tb2R1bGUuZXhwb3J0cy5SZWN0YW5nbGUgPSByZXF1aXJlKDM5KTtcblxufSx7XCIzNlwiOjM2LFwiMzdcIjozNyxcIjM4XCI6MzgsXCIzOVwiOjM5fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDIpO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jYW52YXNcbiAqL1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0LyoqXG5cdCAqIENsZWFycyB0aGUgZW50aXJlIGNhbnZhcyBhc3NvY2lhdGVkIHRvIHRoZSBnaXZlbiBgY2hhcnRgLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBmb3Igd2hpY2ggdG8gY2xlYXIgdGhlIGNhbnZhcy5cblx0ICovXG5cdGNsZWFyOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdGNoYXJ0LmN0eC5jbGVhclJlY3QoMCwgMCwgY2hhcnQud2lkdGgsIGNoYXJ0LmhlaWdodCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBcInBhdGhcIiBmb3IgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgYXQgcG9zaXRpb24gKHgsIHkpIHdpdGggYVxuXHQgKiBnaXZlbiBzaXplICh3aWR0aCwgaGVpZ2h0KSBhbmQgdGhlIHNhbWUgYHJhZGl1c2AgZm9yIGFsbCBjb3JuZXJzLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVGhlIGNhbnZhcyAyRCBDb250ZXh0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB4IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgZm9yIHRoZSByZWN0YW5nbGUgc3RhcnRpbmcgcG9pbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHkgYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHJlY3RhbmdsZSdzIHdpZHRoLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIHJlY3RhbmdsZSdzIGhlaWdodC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyAtIFRoZSByb3VuZGVkIGFtb3VudCAoaW4gcGl4ZWxzKSBmb3IgdGhlIGZvdXIgY29ybmVycy5cblx0ICogQHRvZG8gaGFuZGxlIGByYWRpdXNgIGFzIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLWxlZnQgYXJyYXkvb2JqZWN0P1xuXHQgKi9cblx0cm91bmRlZFJlY3Q6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG5cdFx0aWYgKHJhZGl1cykge1xuXHRcdFx0dmFyIHJ4ID0gTWF0aC5taW4ocmFkaXVzLCB3aWR0aCAvIDIpO1xuXHRcdFx0dmFyIHJ5ID0gTWF0aC5taW4ocmFkaXVzLCBoZWlnaHQgLyAyKTtcblxuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGggLSByeCwgeSk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJ5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByeCwgeSArIGhlaWdodCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyByeCwgeSArIGhlaWdodCk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJ4LCB5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdQb2ludDogZnVuY3Rpb24oY3R4LCBzdHlsZSwgcmFkaXVzLCB4LCB5KSB7XG5cdFx0dmFyIHR5cGUsIGVkZ2VMZW5ndGgsIHhPZmZzZXQsIHlPZmZzZXQsIGhlaWdodCwgc2l6ZTtcblxuXHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcblx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuXHRcdFx0XHRjdHguZHJhd0ltYWdlKHN0eWxlLCB4IC0gc3R5bGUud2lkdGggLyAyLCB5IC0gc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoc3R5bGUpIHtcblx0XHQvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3RyaWFuZ2xlJzpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGVkZ2VMZW5ndGggPSAzICogcmFkaXVzIC8gTWF0aC5zcXJ0KDMpO1xuXHRcdFx0aGVpZ2h0ID0gZWRnZUxlbmd0aCAqIE1hdGguc3FydCgzKSAvIDI7XG5cdFx0XHRjdHgubW92ZVRvKHggLSBlZGdlTGVuZ3RoIC8gMiwgeSArIGhlaWdodCAvIDMpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgZWRnZUxlbmd0aCAvIDIsIHkgKyBoZWlnaHQgLyAzKTtcblx0XHRcdGN0eC5saW5lVG8oeCwgeSAtIDIgKiBoZWlnaHQgLyAzKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdHNpemUgPSAxIC8gTWF0aC5TUVJUMiAqIHJhZGl1cztcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5maWxsUmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XG5cdFx0XHRjdHguc3Ryb2tlUmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Um91bmRlZCc6XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcmFkaXVzIC8gTWF0aC5TUVJUMjtcblx0XHRcdHZhciBsZWZ0WCA9IHggLSBvZmZzZXQ7XG5cdFx0XHR2YXIgdG9wWSA9IHkgLSBvZmZzZXQ7XG5cdFx0XHR2YXIgc2lkZVNpemUgPSBNYXRoLlNRUlQyICogcmFkaXVzO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5yb3VuZGVkUmVjdChjdHgsIGxlZnRYLCB0b3BZLCBzaWRlU2l6ZSwgc2lkZVNpemUsIHJhZGl1cyAvIDIpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3RSb3QnOlxuXHRcdFx0c2l6ZSA9IDEgLyBNYXRoLlNRUlQyICogcmFkaXVzO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0gc2l6ZSwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgKyBzaXplKTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHNpemUsIHkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4LCB5IC0gc2l6ZSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY3Jvc3MnOlxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4LCB5ICsgcmFkaXVzKTtcblx0XHRcdGN0eC5saW5lVG8oeCwgeSAtIHJhZGl1cyk7XG5cdFx0XHRjdHgubW92ZVRvKHggLSByYWRpdXMsIHkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Nyb3NzUm90Jzpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhNYXRoLlBJIC8gNCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4oTWF0aC5QSSAvIDQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc3Rhcic6XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4LCB5IC0gcmFkaXVzKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHJhZGl1cywgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKE1hdGguUEkgLyA0KSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihNYXRoLlBJIC8gNCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsaW5lJzpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHJhZGl1cywgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnZGFzaCc6XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGN0eC5zdHJva2UoKTtcblx0fSxcblxuXHRjbGlwQXJlYTogZnVuY3Rpb24oY3R4LCBhcmVhKSB7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0fSxcblxuXHR1bmNsaXBBcmVhOiBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGxpbmVUbzogZnVuY3Rpb24oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG5cdFx0aWYgKHRhcmdldC5zdGVwcGVkTGluZSkge1xuXHRcdFx0aWYgKCh0YXJnZXQuc3RlcHBlZExpbmUgPT09ICdhZnRlcicgJiYgIWZsaXApIHx8ICh0YXJnZXQuc3RlcHBlZExpbmUgIT09ICdhZnRlcicgJiYgZmxpcCkpIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRhcmdldC50ZW5zaW9uKSB7XG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LmJlemllckN1cnZlVG8oXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNYIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFgsXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNZIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFksXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRYIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWCxcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFkgOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNZLFxuXHRcdFx0dGFyZ2V0LngsXG5cdFx0XHR0YXJnZXQueSk7XG5cdH1cbn07XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMuY2xlYXIgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jbGVhclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5jbGVhciA9IGV4cG9ydHMuY2xlYXI7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5yb3VuZGVkUmVjdCBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4KSB7XG5cdGN0eC5iZWdpblBhdGgoKTtcblx0ZXhwb3J0cy5yb3VuZGVkUmVjdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuXHRjdHguY2xvc2VQYXRoKCk7XG59O1xuXG59LHtcIjQyXCI6NDJ9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cbnZhciBoZWxwZXJzID0ge1xuXHQvKipcblx0ICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cblx0ICovXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB1bmlxdWUgaWQsIHNlcXVlbnRpYWxseSBnZW5lcmF0ZWQgZnJvbSBhIGdsb2JhbCB2YXJpYWJsZS5cblx0ICogQHJldHVybnMge051bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHR1aWQ6IChmdW5jdGlvbigpIHtcblx0XHR2YXIgaWQgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpZCsrO1xuXHRcdH07XG5cdH0oKSksXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0aXNOdWxsT3JVbmRlZjogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0aXNPYmplY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHZhbHVlIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIGFycmF5IGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWUgLSBUaGUgYXJyYXkgdG8gbG9va3VwIGZvciB2YWx1ZSBhdCBgaW5kZXhgLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW4gYHZhbHVlYCB0byBsb29rdXAgZm9yIHZhbHVlLlxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlW2luZGV4XWAgaXMgdW5kZWZpbmVkLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdHZhbHVlQXRJbmRleE9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcblx0XHRyZXR1cm4gaGVscGVycy52YWx1ZU9yRGVmYXVsdChoZWxwZXJzLmlzQXJyYXkodmFsdWUpID8gdmFsdWVbaW5kZXhdIDogdmFsdWUsIGRlZmF1bHRWYWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcblx0ICogdmFsdWUgcmV0dXJuZWQgYnkgYGZuYC4gSWYgYGZuYCBpcyBub3QgYSBmdW5jdGlvbiwgdGhpcyBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG5cdCAqIEBwYXJhbSB7QXJyYXl8dW5kZWZpbmVkfG51bGx9IGFyZ3MgLSBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggYGZuYCBzaG91bGQgYmUgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHRjYWxsYmFjazogZnVuY3Rpb24oZm4sIGFyZ3MsIHRoaXNBcmcpIHtcblx0XHRpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIE5vdGUoU0IpIGZvciBwZXJmb3JtYW5jZSBzYWtlLCB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbG9vcGFibGUgdHlwZVxuXHQgKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuXHQgKiBpdCdzIHByZWZlcmFibGUgdG8gdXNlIGEgcmVndWxhciBmb3IoKSBsb29wIGFuZCBzYXZlIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLlxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gbG9vcGFibGUgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIGl0ZXJhdGVkLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGl0ZW0uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXZlcnNlXSAtIElmIHRydWUsIGl0ZXJhdGVzIGJhY2t3YXJkIG9uIHRoZSBsb29wYWJsZS5cblx0ICovXG5cdGVhY2g6IGZ1bmN0aW9uKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuXHRcdHZhciBpLCBsZW4sIGtleXM7XG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheShsb29wYWJsZSkpIHtcblx0XHRcdGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcblx0XHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRcdGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChoZWxwZXJzLmlzT2JqZWN0KGxvb3BhYmxlKSkge1xuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcblx0XHRcdGxlbiA9IGtleXMubGVuZ3RoO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBgYTBgIGFuZCBgYTFgIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQsIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDg1Mzk3NFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqL1xuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XG5cdFx0dmFyIGksIGlsZW4sIHYwLCB2MTtcblxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0djAgPSBhMFtpXTtcblx0XHRcdHYxID0gYTFbaV07XG5cblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XG5cdFx0XHRcdC8vIE5PVEU6IHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNsb25lOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdHJldHVybiBzb3VyY2UubWFwKGhlbHBlcnMuY2xvbmUpO1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR2YXIgayA9IDA7XG5cblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdHRhcmdldFtrZXlzW2tdXSA9IGhlbHBlcnMuY2xvbmUoc291cmNlW2tleXNba11dKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG5cdCAqIE5vdGUoU0IpOiB0aGlzIG1ldGhvZCBpcyBhbHNvIHVzZWQgYnkgY29uZmlnTWVyZ2UgYW5kIHNjYWxlTWVyZ2UgYXMgZmFsbGJhY2suXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21lcmdlcklmOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xuXHRcdH0gZWxzZSBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEFycmF5KE9iamVjdCl9IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gTWVyZ2luZyBvcHRpb25zOlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHZhciBzb3VyY2VzID0gaGVscGVycy5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcblx0XHR2YXIgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuXHRcdHZhciBtZXJnZSwgaSwga2V5cywga2xlbiwgaztcblxuXHRcdGlmICghaGVscGVycy5pc09iamVjdCh0YXJnZXQpKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdG1lcmdlID0gb3B0aW9ucy5tZXJnZXIgfHwgaGVscGVycy5fbWVyZ2VyO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmICghaGVscGVycy5pc09iamVjdChzb3VyY2UpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdGZvciAoayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuXHRcdFx0XHRtZXJnZShrZXlzW2tdLCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHQvKipcblx0ICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXG5cdCAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cblx0ICogQHBhcmFtIHtPYmplY3R8QXJyYXkoT2JqZWN0KX0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZUlmOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLm1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBoZWxwZXJzLl9tZXJnZXJJZn0pO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhlbHBlcnM7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYWxsYmFjayBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuY2FsbENhbGxiYWNrXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmNhbGxDYWxsYmFjayA9IGhlbHBlcnMuY2FsbGJhY2s7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBpbnN0ZWFkLlxuICogQXJyYXkucHJvdG90eXBlLmluZGV4T2YgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSwgU2FmYXJpLCBGRjEuNSssIElFOStcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmluZGV4T2ZcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tSW5kZXgpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJyYXksIGl0ZW0sIGZyb21JbmRleCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZU9yRGVmYXVsdCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblxufSx7fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDIpO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xudmFyIGVmZmVjdHMgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0O1xuXHR9LFxuXG5cdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLXQgKiAodCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLSgodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xuXHR9LFxuXG5cdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLU1hdGguY29zKHQgKiAoTWF0aC5QSSAvIDIpKSArIDE7XG5cdH0sXG5cblx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJIC8gMikpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5FeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHR9LFxuXG5cdGVhc2VPdXRFeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA+PSAxKSB7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICh0ID0gdCAtIDEpICogdCk7XG5cdH0sXG5cblx0ZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcblx0fSxcblxuXHRlYXNlSW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuMztcblx0XHR9XG5cdFx0aWYgKGEgPCAxKSB7XG5cdFx0XHRhID0gMTtcblx0XHRcdHMgPSBwIC8gNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHR9XG5cdFx0cmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdH0sXG5cblx0ZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPT09IDIpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjQ1O1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRpZiAodCA8IDEpIHtcblx0XHRcdHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHR9LFxuXHRlYXNlSW5CYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuXHR9LFxuXG5cdGVhc2VPdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0QmFjazogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcblx0fSxcblxuXHRlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAoMSAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogdCAqIHQ7XG5cdFx0fVxuXHRcdGlmICh0IDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NTtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMi41IC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzU7XG5cdFx0fVxuXHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzU7XG5cdH0sXG5cblx0ZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAwLjUpIHtcblx0XHRcdHJldHVybiBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XG5cdFx0fVxuXHRcdHJldHVybiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGVmZmVjdHM6IGVmZmVjdHNcbn07XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0cyBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5lYXNpbmdFZmZlY3RzID0gZWZmZWN0cztcblxufSx7XCI0MlwiOjQyfV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDIpO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xuXHRcdHZhciBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XG5cblx0XHRzd2l0Y2ggKG1hdGNoZXNbM10pIHtcblx0XHRjYXNlICdweCc6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSAnJSc6XG5cdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemUgKiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG5cdCAqICBlbHNlLCBpZiBhbmQgb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHRvUGFkZGluZzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdCwgciwgYiwgbDtcblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0dCA9ICt2YWx1ZS50b3AgfHwgMDtcblx0XHRcdHIgPSArdmFsdWUucmlnaHQgfHwgMDtcblx0XHRcdGIgPSArdmFsdWUuYm90dG9tIHx8IDA7XG5cdFx0XHRsID0gK3ZhbHVlLmxlZnQgfHwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dCA9IHIgPSBiID0gbCA9ICt2YWx1ZSB8fCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHQsXG5cdFx0XHRyaWdodDogcixcblx0XHRcdGJvdHRvbTogYixcblx0XHRcdGxlZnQ6IGwsXG5cdFx0XHRoZWlnaHQ6IHQgKyBiLFxuXHRcdFx0d2lkdGg6IGwgKyByXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXlbXX0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcblx0ICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG5cdCAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0cmVzb2x2ZTogZnVuY3Rpb24oaW5wdXRzLCBjb250ZXh0LCBpbmRleCkge1xuXHRcdHZhciBpLCBpbGVuLCB2YWx1ZTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0c1tpXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtpbmRleF07XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG59LHtcIjQyXCI6NDJ9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSg0Mik7XG5tb2R1bGUuZXhwb3J0cy5lYXNpbmcgPSByZXF1aXJlKDQzKTtcbm1vZHVsZS5leHBvcnRzLmNhbnZhcyA9IHJlcXVpcmUoNDEpO1xubW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHJlcXVpcmUoNDQpO1xuXG59LHtcIjQxXCI6NDEsXCI0MlwiOjQyLFwiNDNcIjo0MyxcIjQ0XCI6NDR9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG5cdH1cbn07XG5cbn0se31dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG52YXIgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xudmFyIENTU19QUkVGSVggPSAnY2hhcnRqcy0nO1xudmFyIENTU19SRU5ERVJfTU9OSVRPUiA9IENTU19QUkVGSVggKyAncmVuZGVyLW1vbml0b3InO1xudmFyIENTU19SRU5ERVJfQU5JTUFUSU9OID0gQ1NTX1BSRUZJWCArICdyZW5kZXItYW5pbWF0aW9uJztcbnZhciBBTklNQVRJT05fU1RBUlRfRVZFTlRTID0gWydhbmltYXRpb25zdGFydCcsICd3ZWJraXRBbmltYXRpb25TdGFydCddO1xuXG4vKipcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7XG5cdHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuXHR0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuXHR0b3VjaGVuZDogJ21vdXNldXAnLFxuXHRwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcblx0cG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuXHRwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG5cdHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuXHRwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG5cdHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5cbi8qKlxuICogVGhlIFwidXNlZFwiIHNpemUgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIGEgZGltZW5zaW9uIHByb3BlcnR5IGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgaGF2ZVxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcbiAqIGBlbGVtZW50YCBoYXMgYSBzaXplIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgYW5kIHRoaXMgbGFzdCBvbmUgaXMgbm90IHlldCBkaXNwbGF5ZWQsXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuICogQHJldHVybnMge051bWJlcn0gU2l6ZSBpbiBwaXhlbHMgb3IgdW5kZWZpbmVkIGlmIHVua25vd24uXG4gKi9cbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuXHR2YXIgdmFsdWUgPSBoZWxwZXJzLmdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcblx0cmV0dXJuIG1hdGNoZXMgPyBOdW1iZXIobWF0Y2hlc1sxXSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcblx0dmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcblx0Ly8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cblx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG5cdC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG5cdFx0aW5pdGlhbDoge1xuXHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcblx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcblx0Ly8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuXG5cdGlmIChyZW5kZXJXaWR0aCA9PT0gbnVsbCB8fCByZW5kZXJXaWR0aCA9PT0gJycpIHtcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG5cdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XG5cdFx0aWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG5cdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cblx0XHRcdC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG5cdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcblx0dmFyIHN1cHBvcnRzID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3VwcG9ydHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgb3B0aW9ucyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG5cdH1cblx0cmV0dXJuIHN1cHBvcnRzO1xufSgpKTtcblxuLy8gRGVmYXVsdCBwYXNzaXZlIHRvIHRydWUgYXMgZXhwZWN0ZWQgYnkgQ2hyb21lIGZvciAndG91Y2hzdGFydCcgYW5kICd0b3VjaGVuZCcgZXZlbnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQyODdcbnZhciBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHgsIHksIG5hdGl2ZUV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0dHlwZTogdHlwZSxcblx0XHRjaGFydDogY2hhcnQsXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxuXHRcdHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuXHRcdHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG5cdHZhciB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcblx0dmFyIHBvcyA9IGhlbHBlcnMuZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuXHRyZXR1cm4gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHBvcy54LCBwb3MueSwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiB0aHJvdHRsZWQoZm4sIHRoaXNBcmcpIHtcblx0dmFyIHRpY2tpbmcgPSBmYWxzZTtcblx0dmFyIGFyZ3MgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0dGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcblxuXHRcdGlmICghdGlja2luZykge1xuXHRcdFx0dGlja2luZyA9IHRydWU7XG5cdFx0XHRoZWxwZXJzLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aWNraW5nID0gZmFsc2U7XG5cdFx0XHRcdGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllc1xuZnVuY3Rpb24gY3JlYXRlUmVzaXplcihoYW5kbGVyKSB7XG5cdHZhciByZXNpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdHZhciBjbHMgPSBDU1NfUFJFRklYICsgJ3NpemUtbW9uaXRvcic7XG5cdHZhciBtYXhTaXplID0gMTAwMDAwMDtcblx0dmFyIHN0eWxlID1cblx0XHQncG9zaXRpb246YWJzb2x1dGU7JyArXG5cdFx0J2xlZnQ6MDsnICtcblx0XHQndG9wOjA7JyArXG5cdFx0J3JpZ2h0OjA7JyArXG5cdFx0J2JvdHRvbTowOycgK1xuXHRcdCdvdmVyZmxvdzpoaWRkZW47JyArXG5cdFx0J3BvaW50ZXItZXZlbnRzOm5vbmU7JyArXG5cdFx0J3Zpc2liaWxpdHk6aGlkZGVuOycgK1xuXHRcdCd6LWluZGV4Oi0xOyc7XG5cblx0cmVzaXplci5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG5cdHJlc2l6ZXIuY2xhc3NOYW1lID0gY2xzO1xuXHRyZXNpemVyLmlubmVySFRNTCA9XG5cdFx0JzxkaXYgY2xhc3M9XCInICsgY2xzICsgJy1leHBhbmRcIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICtcblx0XHRcdCc8ZGl2IHN0eWxlPVwiJyArXG5cdFx0XHRcdCdwb3NpdGlvbjphYnNvbHV0ZTsnICtcblx0XHRcdFx0J3dpZHRoOicgKyBtYXhTaXplICsgJ3B4OycgK1xuXHRcdFx0XHQnaGVpZ2h0OicgKyBtYXhTaXplICsgJ3B4OycgK1xuXHRcdFx0XHQnbGVmdDowOycgK1xuXHRcdFx0XHQndG9wOjBcIj4nICtcblx0XHRcdCc8L2Rpdj4nICtcblx0XHQnPC9kaXY+JyArXG5cdFx0JzxkaXYgY2xhc3M9XCInICsgY2xzICsgJy1zaHJpbmtcIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICtcblx0XHRcdCc8ZGl2IHN0eWxlPVwiJyArXG5cdFx0XHRcdCdwb3NpdGlvbjphYnNvbHV0ZTsnICtcblx0XHRcdFx0J3dpZHRoOjIwMCU7JyArXG5cdFx0XHRcdCdoZWlnaHQ6MjAwJTsnICtcblx0XHRcdFx0J2xlZnQ6MDsgJyArXG5cdFx0XHRcdCd0b3A6MFwiPicgK1xuXHRcdFx0JzwvZGl2PicgK1xuXHRcdCc8L2Rpdj4nO1xuXG5cdHZhciBleHBhbmQgPSByZXNpemVyLmNoaWxkTm9kZXNbMF07XG5cdHZhciBzaHJpbmsgPSByZXNpemVyLmNoaWxkTm9kZXNbMV07XG5cblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRleHBhbmQuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xuXHRcdHNocmluay5zY3JvbGxUb3AgPSBtYXhTaXplO1xuXHR9O1xuXHR2YXIgb25TY3JvbGwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXNpemVyLl9yZXNldCgpO1xuXHRcdGhhbmRsZXIoKTtcblx0fTtcblxuXHRhZGRFdmVudExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xuXHRhZGRFdmVudExpc3RlbmVyKHNocmluaywgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoc2hyaW5rLCAnc2hyaW5rJykpO1xuXG5cdHJldHVybiByZXNpemVyO1xufVxuXG4vLyBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cbmZ1bmN0aW9uIHdhdGNoRm9yUmVuZGVyKG5vZGUsIGhhbmRsZXIpIHtcblx0dmFyIGV4cGFuZG8gPSBub2RlW0VYUEFORE9fS0VZXSB8fCAobm9kZVtFWFBBTkRPX0tFWV0gPSB7fSk7XG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHkgPSBmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gQ1NTX1JFTkRFUl9BTklNQVRJT04pIHtcblx0XHRcdGhhbmRsZXIoKTtcblx0XHR9XG5cdH07XG5cblx0aGVscGVycy5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRhZGRFdmVudExpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0fSk7XG5cblx0bm9kZS5jbGFzc0xpc3QuYWRkKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIHVud2F0Y2hGb3JSZW5kZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5O1xuXG5cdGlmIChwcm94eSkge1xuXHRcdGhlbHBlcnMuZWFjaChBTklNQVRJT05fU1RBUlRfRVZFTlRTLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRyZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0XHR9KTtcblxuXHRcdGRlbGV0ZSBleHBhbmRvLnJlbmRlclByb3h5O1xuXHR9XG5cblx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKG5vZGUsIGxpc3RlbmVyLCBjaGFydCkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblxuXHQvLyBMZXQncyBrZWVwIHRyYWNrIG9mIHRoaXMgYWRkZWQgcmVzaXplciBhbmQgdGh1cyBhdm9pZCBET00gcXVlcnkgd2hlbiByZW1vdmluZyBpdC5cblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcblx0XHRpZiAoZXhwYW5kby5yZXNpemVyKSB7XG5cdFx0XHRyZXR1cm4gbGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0fVxuXHR9KSk7XG5cblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXG5cdC8vIHN1cmUgdGhhdCBgbm9kZWAgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBiZWZvcmUgaW5qZWN0aW5nIHRoZSByZXNpemVyIGVsZW1lbnQuXG5cdHdhdGNoRm9yUmVuZGVyKG5vZGUsIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cblx0XHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplcjtcblxuXHRkZWxldGUgZXhwYW5kby5yZXNpemVyO1xuXHR1bndhdGNoRm9yUmVuZGVyKG5vZGUpO1xuXG5cdGlmIChyZXNpemVyICYmIHJlc2l6ZXIucGFyZW50Tm9kZSkge1xuXHRcdHJlc2l6ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXNpemVyKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbmplY3RDU1MocGxhdGZvcm0sIGNzcykge1xuXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTIyMTM5XG5cdHZhciBzdHlsZSA9IHBsYXRmb3JtLl9zdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHRpZiAoIXBsYXRmb3JtLl9zdHlsZSkge1xuXHRcdHBsYXRmb3JtLl9zdHlsZSA9IHN0eWxlO1xuXHRcdGNzcyA9ICcvKiBDaGFydC5qcyAqL1xcbicgKyBjc3M7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH1cblxuXHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuXHQgKiBUaGlzIHByb3BlcnR5IGhvbGRzIHdoZXRoZXIgdGhpcyBwbGF0Zm9ybSBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cblx0ICogQ3VycmVudGx5IHVzZWQgYnkgcGxhdGZvcm0uanMgdG8gc2VsZWN0IHRoZSBwcm9wZXIgaW1wbGVtZW50YXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZW5hYmxlZDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIga2V5ZnJhbWVzID0gJ2Zyb217b3BhY2l0eTowLjk5fXRve29wYWNpdHk6MX0nO1xuXG5cdFx0aW5qZWN0Q1NTKHRoaXMsXG5cdFx0XHQvLyBET00gcmVuZGVyaW5nIGRldGVjdGlvblxuXHRcdFx0Ly8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXG5cdFx0XHQnQC13ZWJraXQta2V5ZnJhbWVzICcgKyBDU1NfUkVOREVSX0FOSU1BVElPTiArICd7JyArIGtleWZyYW1lcyArICd9JyArXG5cdFx0XHQnQGtleWZyYW1lcyAnICsgQ1NTX1JFTkRFUl9BTklNQVRJT04gKyAneycgKyBrZXlmcmFtZXMgKyAnfScgK1xuXHRcdFx0Jy4nICsgQ1NTX1JFTkRFUl9NT05JVE9SICsgJ3snICtcblx0XHRcdFx0Jy13ZWJraXQtYW5pbWF0aW9uOicgKyBDU1NfUkVOREVSX0FOSU1BVElPTiArICcgMC4wMDFzOycgK1xuXHRcdFx0XHQnYW5pbWF0aW9uOicgKyBDU1NfUkVOREVSX0FOSU1BVElPTiArICcgMC4wMDFzOycgK1xuXHRcdFx0J30nXG5cdFx0KTtcblx0fSxcblxuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuXHRcdFx0aXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuXHRcdH0gZWxzZSBpZiAoaXRlbS5sZW5ndGgpIHtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFycmF5IGJhc2VkIHF1ZXJpZXMgKHN1Y2ggYXMgalF1ZXJ5KVxuXHRcdFx0aXRlbSA9IGl0ZW1bMF07XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xuXHRcdH1cblxuXHRcdC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcblx0XHQvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG5cdFx0dmFyIGNvbnRleHQgPSBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHQvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGl0ZW0gaXNcblx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXG5cdFx0Ly8gdHlwZXMgZnJvbSB0aGVpciB0b1N0cmluZygpIHZhbHVlIGJ1dCBsZXQncyBrZWVwIHRoaW5ncyBmbGV4aWJsZSBhbmQgYXNzdW1lIGl0J3Ncblx0XHQvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBpdGVtIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgaXRlbSBhcyBgY2FudmFzYC5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcblx0XHRpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gaXRlbSkge1xuXHRcdFx0aW5pdENhbnZhcyhpdGVtLCBjb25maWcpO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG5cdFx0aWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG5cdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdHZhciB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG5cdFx0XHRpZiAoaGVscGVycy5pc051bGxPclVuZGVmKHZhbHVlKSkge1xuXHRcdFx0XHRjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRoZWxwZXJzLmVhY2goaW5pdGlhbC5zdHlsZSB8fCB7fSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0Y2FudmFzLnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblxuXHRcdC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuXHRcdC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuXHRcdC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cblx0XHRkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcblx0fSxcblxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xuXHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cblx0XHRcdGFkZFJlc2l6ZUxpc3RlbmVyKGNhbnZhcywgbGlzdGVuZXIsIGNoYXJ0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCAobGlzdGVuZXJbRVhQQU5ET19LRVldID0ge30pO1xuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IChleHBhbmRvLnByb3hpZXMgPSB7fSk7XG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcblx0XHR9O1xuXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblx0fSxcblxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xuXHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cblx0XHRcdHJlbW92ZVJlc2l6ZUxpc3RlbmVyKGNhbnZhcywgbGlzdGVuZXIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IHt9O1xuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IHt9O1xuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXTtcblx0XHRpZiAoIXByb3h5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblx0fVxufTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGluc3RlYWQuXG4gKiBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEgNywgU2FmYXJpLCBGRjEuNSssIElFOStcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFkZEV2ZW50XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmFkZEV2ZW50ID0gYWRkRXZlbnRMaXN0ZW5lcjtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMucmVtb3ZlRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMucmVtb3ZlRXZlbnQgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG59LHtcIjQ1XCI6NDV9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG52YXIgYmFzaWMgPSByZXF1aXJlKDQ2KTtcbnZhciBkb20gPSByZXF1aXJlKDQ3KTtcblxuLy8gQFRPRE8gTWFrZSBwb3NzaWJsZSB0byBzZWxlY3QgYW5vdGhlciBwbGF0Zm9ybSBhdCBidWlsZCB0aW1lLlxudmFyIGltcGxlbWVudGF0aW9uID0gZG9tLl9lbmFibGVkID8gZG9tIDogYmFzaWM7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5wbGF0Zm9ybVxuICogQHNlZSBodHRwczovL2NoYXJ0anMuZ2l0Ym9va3MuaW8vcHJvcG9zYWxzL2NvbnRlbnQvUGxhdGZvcm0uaHRtbFxuICogQHNpbmNlIDIuNC4wXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gaGVscGVycy5leHRlbmQoe1xuXHQvKipcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgbmF0aXZlIGl0ZW0gZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBjaGFydCBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKi9cblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBkZXN0cnVjdGlvbiB0aW1lLCByZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRleHRcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRlZCwgZWxzZSBmYWxzZVxuXHQgKi9cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIGxpc3RlbiBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBJRXZlbnR9KSB0eXBlIHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xuXHQgKiB0aGUge0BsaW5rIElFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLUNoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG5cbn0sIGltcGxlbWVudGF0aW9uKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIElQbGF0Zm9ybVxuICogQWxsb3dzIGFic3RyYWN0aW5nIHBsYXRmb3JtIGRlcGVuZGVuY2llcyBhd2F5IGZyb20gdGhlIGNoYXJ0XG4gKiBAYm9ycm93cyBDaGFydC5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dCBhcyBhY3F1aXJlQ29udGV4dFxuICogQGJvcnJvd3MgQ2hhcnQucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQgYXMgcmVsZWFzZUNvbnRleHRcbiAqIEBib3Jyb3dzIENoYXJ0LnBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIgYXMgYWRkRXZlbnRMaXN0ZW5lclxuICogQGJvcnJvd3MgQ2hhcnQucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lciBhcyByZW1vdmVFdmVudExpc3RlbmVyXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJmYWNlIElFdmVudFxuICogQHByb3Age1N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlIG5hbWUsIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gKiAnY29udGV4dG1lbnUnLCAnbW91c2VlbnRlcicsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnbW91c2VvdXQnLFxuICogJ2NsaWNrJywgJ2RibGNsaWNrJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnIGFuZCAncmVzaXplJ1xuICogQHByb3Ageyp9IG5hdGl2ZSAtIFRoZSBvcmlnaW5hbCBuYXRpdmUgZXZlbnQgKG51bGwgZm9yIGVtdWxhdGVkIGV2ZW50cywgZS5nLiAncmVzaXplJylcbiAqIEBwcm9wIHtOdW1iZXJ9IHggLSBUaGUgbW91c2UgeCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyAobnVsbCBmb3IgaW5jb21wYXRpYmxlIGV2ZW50cylcbiAqIEBwcm9wIHtOdW1iZXJ9IHkgLSBUaGUgbW91c2UgeSBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyAobnVsbCBmb3IgaW5jb21wYXRpYmxlIGV2ZW50cylcbiAqL1xuXG59LHtcIjQ1XCI6NDUsXCI0NlwiOjQ2LFwiNDdcIjo0N31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogUGx1Z2luIGJhc2VkIG9uIGRpc2N1c3Npb24gZnJvbSB0aGUgZm9sbG93aW5nIENoYXJ0LmpzIGlzc3VlczpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQ0MCNpc3N1ZWNvbW1lbnQtMjU2NDYxODk3XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBlbGVtZW50cyA9IHJlcXVpcmUoNDApO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRwbHVnaW5zOiB7XG5cdFx0ZmlsbGVyOiB7XG5cdFx0XHRwcm9wYWdhdGU6IHRydWVcblx0XHR9XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBtYXBwZXJzID0ge1xuXHRcdGRhdGFzZXQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0dmFyIGluZGV4ID0gc291cmNlLmZpbGw7XG5cdFx0XHR2YXIgY2hhcnQgPSBzb3VyY2UuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHRcdHZhciB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcblx0XHRcdHZhciBwb2ludHMgPSAodmlzaWJsZSAmJiBtZXRhLmRhdGFzZXQuX2NoaWxkcmVuKSB8fCBbXTtcblx0XHRcdHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIHx8IDA7XG5cblx0XHRcdHJldHVybiAhbGVuZ3RoID8gbnVsbCA6IGZ1bmN0aW9uKHBvaW50LCBpKSB7XG5cdFx0XHRcdHJldHVybiAoaSA8IGxlbmd0aCAmJiBwb2ludHNbaV0uX3ZpZXcpIHx8IG51bGw7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHR2YXIgYm91bmRhcnkgPSBzb3VyY2UuYm91bmRhcnk7XG5cdFx0XHR2YXIgeCA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueCA6IG51bGw7XG5cdFx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHg6IHggPT09IG51bGwgPyBwb2ludC54IDogeCxcblx0XHRcdFx0XHR5OiB5ID09PSBudWxsID8gcG9pbnQueSA6IHksXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblxuXHQvLyBAdG9kbyBpZiAoZmlsbFswXSA9PT0gJyMnKVxuXHRmdW5jdGlvbiBkZWNvZGVGaWxsKGVsLCBpbmRleCwgY291bnQpIHtcblx0XHR2YXIgbW9kZWwgPSBlbC5fbW9kZWwgfHwge307XG5cdFx0dmFyIGZpbGwgPSBtb2RlbC5maWxsO1xuXHRcdHZhciB0YXJnZXQ7XG5cblx0XHRpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0fVxuXG5cdFx0aWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuXHRcdFx0cmV0dXJuICdvcmlnaW4nO1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCwgMTApO1xuXHRcdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG5cdFx0XHRpZiAoZmlsbFswXSA9PT0gJy0nIHx8IGZpbGxbMF0gPT09ICcrJykge1xuXHRcdFx0XHR0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoZmlsbCkge1xuXHRcdC8vIGNvbXBhdGliaWxpdHlcblx0XHRjYXNlICdib3R0b20nOlxuXHRcdFx0cmV0dXJuICdzdGFydCc7XG5cdFx0Y2FzZSAndG9wJzpcblx0XHRcdHJldHVybiAnZW5kJztcblx0XHRjYXNlICd6ZXJvJzpcblx0XHRcdHJldHVybiAnb3JpZ2luJztcblx0XHQvLyBzdXBwb3J0ZWQgYm91bmRhcmllc1xuXHRcdGNhc2UgJ29yaWdpbic6XG5cdFx0Y2FzZSAnc3RhcnQnOlxuXHRcdGNhc2UgJ2VuZCc6XG5cdFx0XHRyZXR1cm4gZmlsbDtcblx0XHQvLyBpbnZhbGlkIGZpbGwgdmFsdWVzXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG5cdFx0dmFyIG1vZGVsID0gc291cmNlLmVsLl9tb2RlbCB8fCB7fTtcblx0XHR2YXIgc2NhbGUgPSBzb3VyY2UuZWwuX3NjYWxlIHx8IHt9O1xuXHRcdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdFx0dmFyIHRhcmdldCA9IG51bGw7XG5cdFx0dmFyIGhvcml6b250YWw7XG5cblx0XHRpZiAoaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxuXHRcdC8vIHRoZSBtb2RlbCAoc2NhbGVUb3AsIHNjYWxlQm90dG9tIGFuZCBzY2FsZVplcm8pIGJlY2F1c2Ugc29tZSBleHRlcm5hbCBwbHVnaW5zIGFuZFxuXHRcdC8vIGNvbnRyb2xsZXJzIG1pZ2h0IHN0aWxsIHVzZSBpdCAoZS5nLiB0aGUgU21pdGggY2hhcnQpLlxuXG5cdFx0aWYgKGZpbGwgPT09ICdzdGFydCcpIHtcblx0XHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlQm90dG9tID09PSB1bmRlZmluZWQgPyBzY2FsZS5ib3R0b20gOiBtb2RlbC5zY2FsZUJvdHRvbTtcblx0XHR9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG5cdFx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVRvcCA9PT0gdW5kZWZpbmVkID8gc2NhbGUudG9wIDogbW9kZWwuc2NhbGVUb3A7XG5cdFx0fSBlbHNlIGlmIChtb2RlbC5zY2FsZVplcm8gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVaZXJvO1xuXHRcdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKSB7XG5cdFx0XHR0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUG9zaXRpb24oKTtcblx0XHR9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuXHRcdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0XHRob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0eDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXG5cdFx0XHRcdFx0eTogaG9yaXpvbnRhbCA/IG51bGwgOiB0YXJnZXRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuXHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0XHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHRcdHZhciB2aXNpdGVkID0gW2luZGV4XTtcblx0XHR2YXIgdGFyZ2V0O1xuXG5cdFx0aWYgKCFwcm9wYWdhdGUpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG5cdFx0XHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0XHRcdHJldHVybiBmaWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuXHRcdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcblx0XHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0XHR9XG5cblx0XHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcblx0XHRcdGZpbGwgPSB0YXJnZXQuZmlsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVNYXBwZXIoc291cmNlKSB7XG5cdFx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgdHlwZSA9ICdkYXRhc2V0JztcblxuXHRcdGlmIChmaWxsID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuXHRcdFx0dHlwZSA9ICdib3VuZGFyeSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hcHBlcnNbdHlwZV0oc291cmNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRHJhd2FibGUocG9pbnQpIHtcblx0XHRyZXR1cm4gcG9pbnQgJiYgIXBvaW50LnNraXA7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKSB7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBidWlsZGluZyBmaXJzdCBhcmVhIGN1cnZlIChub3JtYWwpXG5cdFx0Y3R4Lm1vdmVUbyhjdXJ2ZTBbMF0ueCwgY3VydmUwWzBdLnkpO1xuXHRcdGZvciAoaSA9IDE7IGkgPCBsZW4wOyArK2kpIHtcblx0XHRcdGhlbHBlcnMuY2FudmFzLmxpbmVUbyhjdHgsIGN1cnZlMFtpIC0gMV0sIGN1cnZlMFtpXSk7XG5cdFx0fVxuXG5cdFx0Ly8gam9pbmluZyB0aGUgdHdvIGFyZWEgY3VydmVzXG5cdFx0Y3R4LmxpbmVUbyhjdXJ2ZTFbbGVuMSAtIDFdLngsIGN1cnZlMVtsZW4xIC0gMV0ueSk7XG5cblx0XHQvLyBidWlsZGluZyBvcHBvc2l0ZSBhcmVhIGN1cnZlIChyZXZlcnNlKVxuXHRcdGZvciAoaSA9IGxlbjEgLSAxOyBpID4gMDsgLS1pKSB7XG5cdFx0XHRoZWxwZXJzLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTFbaV0sIGN1cnZlMVtpIC0gMV0sIHRydWUpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgbG9vcCkge1xuXHRcdHZhciBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xuXHRcdHZhciBjdXJ2ZTAgPSBbXTtcblx0XHR2YXIgY3VydmUxID0gW107XG5cdFx0dmFyIGxlbjAgPSAwO1xuXHRcdHZhciBsZW4xID0gMDtcblx0XHR2YXIgaSwgaWxlbiwgaW5kZXgsIHAwLCBwMSwgZDAsIGQxO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjb3VudCArICEhbG9vcCk7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGluZGV4ID0gaSAlIGNvdW50O1xuXHRcdFx0cDAgPSBwb2ludHNbaW5kZXhdLl92aWV3O1xuXHRcdFx0cDEgPSBtYXBwZXIocDAsIGluZGV4LCB2aWV3KTtcblx0XHRcdGQwID0gaXNEcmF3YWJsZShwMCk7XG5cdFx0XHRkMSA9IGlzRHJhd2FibGUocDEpO1xuXG5cdFx0XHRpZiAoZDAgJiYgZDEpIHtcblx0XHRcdFx0bGVuMCA9IGN1cnZlMC5wdXNoKHAwKTtcblx0XHRcdFx0bGVuMSA9IGN1cnZlMS5wdXNoKHAxKTtcblx0XHRcdH0gZWxzZSBpZiAobGVuMCAmJiBsZW4xKSB7XG5cdFx0XHRcdGlmICghc3Bhbikge1xuXHRcdFx0XHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXHRcdFx0XHRcdGxlbjAgPSBsZW4xID0gMDtcblx0XHRcdFx0XHRjdXJ2ZTAgPSBbXTtcblx0XHRcdFx0XHRjdXJ2ZTEgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoZDApIHtcblx0XHRcdFx0XHRcdGN1cnZlMC5wdXNoKHAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGQxKSB7XG5cdFx0XHRcdFx0XHRjdXJ2ZTEucHVzaChwMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSk7XG5cblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHRcdGN0eC5maWxsKCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGlkOiAnZmlsbGVyJyxcblxuXHRcdGFmdGVyRGF0YXNldHNVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuXHRcdFx0dmFyIHByb3BhZ2F0ZSA9IG9wdGlvbnMucHJvcGFnYXRlO1xuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcblx0XHRcdHZhciBtZXRhLCBpLCBlbCwgc291cmNlO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdGVsID0gbWV0YS5kYXRhc2V0O1xuXHRcdFx0XHRzb3VyY2UgPSBudWxsO1xuXG5cdFx0XHRcdGlmIChlbCAmJiBlbC5fbW9kZWwgJiYgZWwgaW5zdGFuY2VvZiBlbGVtZW50cy5MaW5lKSB7XG5cdFx0XHRcdFx0c291cmNlID0ge1xuXHRcdFx0XHRcdFx0dmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcblx0XHRcdFx0XHRcdGZpbGw6IGRlY29kZUZpbGwoZWwsIGksIGNvdW50KSxcblx0XHRcdFx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdFx0XHRcdGVsOiBlbFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0XHRpZiAoIXNvdXJjZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c291cmNlLmZpbGwgPSByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIHByb3BhZ2F0ZSk7XG5cdFx0XHRcdHNvdXJjZS5ib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXHRcdFx0XHRzb3VyY2UubWFwcGVyID0gY3JlYXRlTWFwcGVyKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZURhdGFzZXREcmF3OiBmdW5jdGlvbihjaGFydCwgYXJncykge1xuXHRcdFx0dmFyIG1ldGEgPSBhcmdzLm1ldGEuJGZpbGxlcjtcblx0XHRcdGlmICghbWV0YSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0XHR2YXIgZWwgPSBtZXRhLmVsO1xuXHRcdFx0dmFyIHZpZXcgPSBlbC5fdmlldztcblx0XHRcdHZhciBwb2ludHMgPSBlbC5fY2hpbGRyZW4gfHwgW107XG5cdFx0XHR2YXIgbWFwcGVyID0gbWV0YS5tYXBwZXI7XG5cdFx0XHR2YXIgY29sb3IgPSB2aWV3LmJhY2tncm91bmRDb2xvciB8fCBkZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5cdFx0XHRpZiAobWFwcGVyICYmIGNvbG9yICYmIHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aGVscGVycy5jYW52YXMuY2xpcEFyZWEoY3R4LCBjaGFydC5jaGFydEFyZWEpO1xuXHRcdFx0XHRkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcblx0XHRcdFx0aGVscGVycy5jYW52YXMudW5jbGlwQXJlYShjdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjQwXCI6NDAsXCI0NVwiOjQ1fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgyNik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGxlZ2VuZDoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0cG9zaXRpb246ICd0b3AnLFxuXHRcdGZ1bGxXaWR0aDogdHJ1ZSxcblx0XHRyZXZlcnNlOiBmYWxzZSxcblx0XHR3ZWlnaHQ6IDEwMDAsXG5cblx0XHQvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcblx0XHRcdHZhciBjaSA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IGNpLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblxuXHRcdFx0Ly8gU2VlIGNvbnRyb2xsZXIuaXNEYXRhc2V0VmlzaWJsZSBjb21tZW50XG5cdFx0XHRtZXRhLmhpZGRlbiA9IG1ldGEuaGlkZGVuID09PSBudWxsID8gIWNpLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhpZGRlbiA6IG51bGw7XG5cblx0XHRcdC8vIFdlIGhpZCBhIGRhdGFzZXQgLi4uIHJlcmVuZGVyIHRoZSBjaGFydFxuXHRcdFx0Y2kudXBkYXRlKCk7XG5cdFx0fSxcblxuXHRcdG9uSG92ZXI6IG51bGwsXG5cblx0XHRsYWJlbHM6IHtcblx0XHRcdGJveFdpZHRoOiA0MCxcblx0XHRcdHBhZGRpbmc6IDEwLFxuXHRcdFx0Ly8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG5cdFx0XHQvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcblx0XHRcdC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuXHRcdFx0Ly8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuXHRcdFx0Ly8gbGluZURhc2hcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcblx0XHRcdC8vIGxpbmVKb2luIDpcblx0XHRcdC8vIGxpbmVXaWR0aCA6XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KGRhdGEuZGF0YXNldHMpID8gZGF0YS5kYXRhc2V0cy5tYXAoZnVuY3Rpb24oZGF0YXNldCwgaSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0ZXh0OiBkYXRhc2V0LmxhYmVsLFxuXHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiAoIWhlbHBlcnMuaXNBcnJheShkYXRhc2V0LmJhY2tncm91bmRDb2xvcikgPyBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA6IGRhdGFzZXQuYmFja2dyb3VuZENvbG9yWzBdKSxcblx0XHRcdFx0XHRcdGhpZGRlbjogIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG5cdFx0XHRcdFx0XHRsaW5lQ2FwOiBkYXRhc2V0LmJvcmRlckNhcFN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZURhc2g6IGRhdGFzZXQuYm9yZGVyRGFzaCxcblx0XHRcdFx0XHRcdGxpbmVEYXNoT2Zmc2V0OiBkYXRhc2V0LmJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdFx0XHRsaW5lSm9pbjogZGF0YXNldC5ib3JkZXJKb2luU3R5bGUsXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGRhdGFzZXQuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogZGF0YXNldC5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdHBvaW50U3R5bGU6IGRhdGFzZXQucG9pbnRTdHlsZSxcblxuXHRcdFx0XHRcdFx0Ly8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHNcblx0XHRcdFx0XHRcdGRhdGFzZXRJbmRleDogaVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sIHRoaXMpIDogW107XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmJhY2tncm91bmRDb2xvciArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRpZiAoY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCkge1xuXHRcdFx0XHR0ZXh0LnB1c2goY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCk7XG5cdFx0XHR9XG5cdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0fVxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgbGF5b3V0ID0gQ2hhcnQubGF5b3V0U2VydmljZTtcblx0dmFyIG5vb3AgPSBoZWxwZXJzLm5vb3A7XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJveCB3aWR0aCBiYXNlZCBvbiB0aGUgdXNlUG9pbnRTdHlsZSBvcHRpb25cblx0ICogQHBhcmFtIGxhYmVsb3B0cyB7T2JqZWN0fSB0aGUgbGFiZWwgb3B0aW9ucyBvbiB0aGUgbGVnZW5kXG5cdCAqIEBwYXJhbSBmb250U2l6ZSB7TnVtYmVyfSB0aGUgbGFiZWwgZm9udCBzaXplXG5cdCAqIEByZXR1cm4ge051bWJlcn0gd2lkdGggb2YgdGhlIGNvbG9yIGJveCBhcmVhXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKSB7XG5cdFx0cmV0dXJuIGxhYmVsT3B0cy51c2VQb2ludFN0eWxlID9cblx0XHRcdGZvbnRTaXplICogTWF0aC5TUVJUMiA6XG5cdFx0XHRsYWJlbE9wdHMuYm94V2lkdGg7XG5cdH1cblxuXHRDaGFydC5MZWdlbmQgPSBFbGVtZW50LmV4dGVuZCh7XG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdGhlbHBlcnMuZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG5cblx0XHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdFx0dGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXG5cdFx0XHQvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG5cdFx0XHR0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXHRcdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBsZWdlbmQgdHlwZXMuXG5cdFx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgbGVnZW5kIHR5cGVcblxuXHRcdGJlZm9yZVVwZGF0ZTogbm9vcCxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdFx0Ly8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG5cdFx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdFx0bWUubWFyZ2lucyA9IG1hcmdpbnM7XG5cblx0XHRcdC8vIERpbWVuc2lvbnNcblx0XHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdFx0Ly8gTGFiZWxzXG5cdFx0XHRtZS5iZWZvcmVCdWlsZExhYmVscygpO1xuXHRcdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcblxuXHRcdFx0Ly8gRml0XG5cdFx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRcdG1lLmZpdCgpO1xuXHRcdFx0bWUuYWZ0ZXJGaXQoKTtcblx0XHRcdC8vXG5cdFx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0XHRyZXR1cm4gbWUubWluU2l6ZTtcblx0XHR9LFxuXHRcdGFmdGVyVXBkYXRlOiBub29wLFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AsXG5cdFx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cblx0XHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH07XG5cdFx0fSxcblx0XHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AsXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AsXG5cdFx0YnVpbGRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcblx0XHRcdHZhciBsZWdlbmRJdGVtcyA9IGhlbHBlcnMuY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbbWUuY2hhcnRdLCBtZSkgfHwgW107XG5cblx0XHRcdGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG5cdFx0XHRcdGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCBtZS5jaGFydC5kYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcblx0XHRcdFx0bGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuXHRcdH0sXG5cdFx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVGaXQ6IG5vb3AsXG5cdFx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0XHR2YXIgZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblxuXHRcdFx0dmFyIGN0eCA9IG1lLmN0eDtcblxuXHRcdFx0dmFyIGdsb2JhbERlZmF1bHQgPSBkZWZhdWx0cy5nbG9iYWw7XG5cdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXHRcdFx0dmFyIGZvbnRTaXplID0gdmFsdWVPckRlZmF1bHQobGFiZWxPcHRzLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHR2YXIgZm9udFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGFiZWxPcHRzLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Rm9udFN0eWxlKTtcblx0XHRcdHZhciBmb250RmFtaWx5ID0gdmFsdWVPckRlZmF1bHQobGFiZWxPcHRzLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHQuZGVmYXVsdEZvbnRGYW1pbHkpO1xuXHRcdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyhmb250U2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KTtcblxuXHRcdFx0Ly8gUmVzZXQgaGl0IGJveGVzXG5cdFx0XHR2YXIgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXG5cdFx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ID8gMTAgOiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIHNpemVzIGhlcmVcblx0XHRcdGlmIChkaXNwbGF5KSB7XG5cdFx0XHRcdGN0eC5mb250ID0gbGFiZWxGb250O1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHQvLyBMYWJlbHNcblxuXHRcdFx0XHRcdC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuXHRcdFx0XHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocyA9IFswXTtcblx0XHRcdFx0XHR2YXIgdG90YWxIZWlnaHQgPSBtZS5sZWdlbmRJdGVtcy5sZW5ndGggPyBmb250U2l6ZSArIChsYWJlbE9wdHMucGFkZGluZykgOiAwO1xuXG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdFx0XHRoZWxwZXJzLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0XHRpZiAobGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+PSBtZS53aWR0aCkge1xuXHRcdFx0XHRcdFx0XHR0b3RhbEhlaWdodCArPSBmb250U2l6ZSArIChsYWJlbE9wdHMucGFkZGluZyk7XG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGhdID0gbWUubGVmdDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRcdGhpdGJveGVzW2ldID0ge1xuXHRcdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0bGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSB0b3RhbEhlaWdodDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciB2UGFkZGluZyA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdHZhciBjb2x1bW5XaWR0aHMgPSBtZS5jb2x1bW5XaWR0aHMgPSBbXTtcblx0XHRcdFx0XHR2YXIgdG90YWxXaWR0aCA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblx0XHRcdFx0XHR2YXIgaXRlbUhlaWdodCA9IGZvbnRTaXplICsgdlBhZGRpbmc7XG5cblx0XHRcdFx0XHRoZWxwZXJzLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0XHRcdFx0dmFyIGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cblx0XHRcdFx0XHRcdGlmIChjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCA+IG1pblNpemUuaGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7IC8vIHByZXZpb3VzIGNvbHVtbiB3aWR0aFxuXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IDA7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBHZXQgbWF4IHdpZHRoXG5cdFx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG5cdFx0XHRcdFx0XHRjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQ7XG5cblx0XHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG5cdFx0XHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG5cdFx0XHRcdFx0Y29sdW1uV2lkdGhzLnB1c2goY3VycmVudENvbFdpZHRoKTtcblx0XHRcdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0fSxcblx0XHRhZnRlckZpdDogbm9vcCxcblxuXHRcdC8vIFNoYXJlZCBNZXRob2RzXG5cdFx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbGx5IGRyYXcgdGhlIGxlZ2VuZCBvbiB0aGUgY2FudmFzXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xuXHRcdFx0dmFyIGdsb2JhbERlZmF1bHQgPSBkZWZhdWx0cy5nbG9iYWw7XG5cdFx0XHR2YXIgbGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0LmVsZW1lbnRzLmxpbmU7XG5cdFx0XHR2YXIgbGVnZW5kV2lkdGggPSBtZS53aWR0aDtcblx0XHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcblxuXHRcdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXHRcdFx0XHR2YXIgZm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQobGFiZWxPcHRzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdFx0dmFyIGZvbnRTaXplID0gdmFsdWVPckRlZmF1bHQobGFiZWxPcHRzLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRcdHZhciBmb250U3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsYWJlbE9wdHMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdFx0XHR2YXIgZm9udEZhbWlseSA9IHZhbHVlT3JEZWZhdWx0KGxhYmVsT3B0cy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250RmFtaWx5KTtcblx0XHRcdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyhmb250U2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KTtcblx0XHRcdFx0dmFyIGN1cnNvcjtcblxuXHRcdFx0XHQvLyBDYW52YXMgc2V0dXBcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gMC41O1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBmb250Q29sb3I7IC8vIGZvciBzdHJpa2V0aHJvdWdoIGVmZmVjdFxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQ7XG5cblx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXG5cdFx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdFx0dmFyIGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG5cdFx0XHRcdFx0aWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU2V0IHRoZSBjdHggZm9yIHRoZSBib3hcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsIGxpbmVEZWZhdWx0LmJvcmRlckNhcFN0eWxlKTtcblx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoT2Zmc2V0KTtcblx0XHRcdFx0XHRjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVKb2luLCBsaW5lRGVmYXVsdC5ib3JkZXJKb2luU3R5bGUpO1xuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgbGluZURlZmF1bHQuYm9yZGVyV2lkdGgpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGdsb2JhbERlZmF1bHQuZGVmYXVsdENvbG9yKTtcblx0XHRcdFx0XHR2YXIgaXNMaW5lV2lkdGhaZXJvID0gKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCBsaW5lRGVmYXVsdC5ib3JkZXJXaWR0aCkgPT09IDApO1xuXG5cdFx0XHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdFx0Ly8gSUUgOSBhbmQgMTAgZG8gbm90IHN1cHBvcnQgbGluZSBkYXNoXG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaCkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChvcHRzLmxhYmVscyAmJiBvcHRzLmxhYmVscy51c2VQb2ludFN0eWxlKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3Rpbmdcblx0XHRcdFx0XHRcdC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcblx0XHRcdFx0XHRcdHZhciByYWRpdXMgPSBmb250U2l6ZSAqIE1hdGguU1FSVDIgLyAyO1xuXHRcdFx0XHRcdFx0dmFyIG9mZlNldCA9IHJhZGl1cyAvIE1hdGguU1FSVDI7XG5cdFx0XHRcdFx0XHR2YXIgY2VudGVyWCA9IHggKyBvZmZTZXQ7XG5cdFx0XHRcdFx0XHR2YXIgY2VudGVyWSA9IHkgKyBvZmZTZXQ7XG5cblx0XHRcdFx0XHRcdC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdFx0XHRoZWxwZXJzLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBsZWdlbmRJdGVtLnBvaW50U3R5bGUsIHJhZGl1cywgY2VudGVyWCwgY2VudGVyWSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRcdGlmICghaXNMaW5lV2lkdGhaZXJvKSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KHgsIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpIHtcblx0XHRcdFx0XHR2YXIgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuXHRcdFx0XHRcdHZhciB4TGVmdCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgeDtcblx0XHRcdFx0XHR2YXIgeU1pZGRsZSA9IHkgKyBoYWxmRm9udFNpemU7XG5cblx0XHRcdFx0XHRjdHguZmlsbFRleHQobGVnZW5kSXRlbS50ZXh0LCB4TGVmdCwgeU1pZGRsZSk7XG5cblx0XHRcdFx0XHRpZiAobGVnZW5kSXRlbS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdC8vIFN0cmlrZXRocm91Z2ggdGhlIHRleHQgaWYgaGlkZGVuXG5cdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gMjtcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oeExlZnQsIHlNaWRkbGUpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh4TGVmdCArIHRleHRXaWR0aCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0Y3Vyc29yID0ge1xuXHRcdFx0XHRcdFx0eDogbWUubGVmdCArICgobGVnZW5kV2lkdGggLSBsaW5lV2lkdGhzWzBdKSAvIDIpLFxuXHRcdFx0XHRcdFx0eTogbWUudG9wICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0XHRsaW5lOiAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRoZWxwZXJzLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0XHR2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIHRleHRXaWR0aDtcblx0XHRcdFx0XHR2YXIgeCA9IGN1cnNvci54O1xuXHRcdFx0XHRcdHZhciB5ID0gY3Vyc29yLnk7XG5cblx0XHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0XHRpZiAoeCArIHdpZHRoID49IGxlZ2VuZFdpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdHkgPSBjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRjdXJzb3IubGluZSsrO1xuXHRcdFx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeSArIGl0ZW1IZWlnaHQgPiBtZS5ib3R0b20pIHtcblx0XHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IHggKyBtZS5jb2x1bW5XaWR0aHNbY3Vyc29yLmxpbmVdICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHR5ID0gY3Vyc29yLnkgPSBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZHJhd0xlZ2VuZEJveCh4LCB5LCBsZWdlbmRJdGVtKTtcblxuXHRcdFx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSB4O1xuXHRcdFx0XHRcdGhpdGJveGVzW2ldLnRvcCA9IHk7XG5cblx0XHRcdFx0XHQvLyBGaWxsIHRoZSBhY3R1YWwgbGFiZWxcblx0XHRcdFx0XHRmaWxsVGV4dCh4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpO1xuXG5cdFx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdFx0Y3Vyc29yLnggKz0gd2lkdGggKyAobGFiZWxPcHRzLnBhZGRpbmcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGNoYW5nZSBvY2N1cmVkXG5cdFx0ICovXG5cdFx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdHlwZSA9IGUudHlwZSA9PT0gJ21vdXNldXAnID8gJ2NsaWNrJyA6IGUudHlwZTtcblx0XHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRcdGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0XHRpZiAoIW9wdHMub25Ib3Zlcikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRcdGlmICghb3B0cy5vbkNsaWNrKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XG5cdFx0XHR2YXIgeCA9IGUueDtcblx0XHRcdHZhciB5ID0gZS55O1xuXG5cdFx0XHRpZiAoeCA+PSBtZS5sZWZ0ICYmIHggPD0gbWUucmlnaHQgJiYgeSA+PSBtZS50b3AgJiYgeSA8PSBtZS5ib3R0b20pIHtcblx0XHRcdFx0Ly8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcblx0XHRcdFx0dmFyIGxoID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHR2YXIgaGl0Qm94ID0gbGhbaV07XG5cblx0XHRcdFx0XHRpZiAoeCA+PSBoaXRCb3gubGVmdCAmJiB4IDw9IGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoICYmIHkgPj0gaGl0Qm94LnRvcCAmJiB5IDw9IGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHQvLyBUb3VjaGluZyBhbiBlbGVtZW50XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0XHRcdG9wdHMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUubGVnZW5kSXRlbXNbaV0pO1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0XHRcdFx0b3B0cy5vbkhvdmVyLmNhbGwobWUsIGUubmF0aXZlLCBtZS5sZWdlbmRJdGVtc1tpXSk7XG5cdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpIHtcblx0XHR2YXIgbGVnZW5kID0gbmV3IENoYXJ0LkxlZ2VuZCh7XG5cdFx0XHRjdHg6IGNoYXJ0LmN0eCxcblx0XHRcdG9wdGlvbnM6IGxlZ2VuZE9wdHMsXG5cdFx0XHRjaGFydDogY2hhcnRcblx0XHR9KTtcblxuXHRcdGxheW91dC5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgbGVnZW5kT3B0cyk7XG5cdFx0bGF5b3V0LmFkZEJveChjaGFydCwgbGVnZW5kKTtcblx0XHRjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGlkOiAnbGVnZW5kJyxcblxuXHRcdGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXG5cdFx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXHRcdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcblxuXHRcdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdFx0aGVscGVycy5tZXJnZUlmKGxlZ2VuZE9wdHMsIGRlZmF1bHRzLmdsb2JhbC5sZWdlbmQpO1xuXG5cdFx0XHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdFx0XHRsYXlvdXQuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHRcdGxlZ2VuZC5vcHRpb25zID0gbGVnZW5kT3B0cztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRsYXlvdXQucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdFx0XHRkZWxldGUgY2hhcnQubGVnZW5kO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcblx0XHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdFx0bGVnZW5kLmhhbmRsZUV2ZW50KGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbn0se1wiMjVcIjoyNSxcIjI2XCI6MjYsXCI0NVwiOjQ1fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgyNik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRpdGxlOiB7XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdGxpbmVIZWlnaHQ6IDEuMixcblx0XHRwYWRkaW5nOiAxMCxcblx0XHRwb3NpdGlvbjogJ3RvcCcsXG5cdFx0dGV4dDogJycsXG5cdFx0d2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBsYXlvdXQgPSBDaGFydC5sYXlvdXRTZXJ2aWNlO1xuXHR2YXIgbm9vcCA9IGhlbHBlcnMubm9vcDtcblxuXHRDaGFydC5UaXRsZSA9IEVsZW1lbnQuZXh0ZW5kKHtcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRoZWxwZXJzLmV4dGVuZChtZSwgY29uZmlnKTtcblxuXHRcdFx0Ly8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXG5cdFx0XHRtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXHRcdH0sXG5cblx0XHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXG5cdFx0YmVmb3JlVXBkYXRlOiBub29wLFxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdFx0Ly8gRGltZW5zaW9uc1xuXHRcdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cdFx0XHQvLyBMYWJlbHNcblx0XHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0XHRtZS5idWlsZExhYmVscygpO1xuXHRcdFx0bWUuYWZ0ZXJCdWlsZExhYmVscygpO1xuXG5cdFx0XHQvLyBGaXRcblx0XHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdFx0bWUuZml0KCk7XG5cdFx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdFx0Ly9cblx0XHRcdG1lLmFmdGVyVXBkYXRlKCk7XG5cblx0XHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdFx0fSxcblx0XHRhZnRlclVwZGF0ZTogbm9vcCxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wLFxuXHRcdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0XHQvLyBSZXNldCBtaW5TaXplXG5cdFx0XHRtZS5taW5TaXplID0ge1xuXHRcdFx0XHR3aWR0aDogMCxcblx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wLFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wLFxuXHRcdGJ1aWxkTGFiZWxzOiBub29wLFxuXHRcdGFmdGVyQnVpbGRMYWJlbHM6IG5vb3AsXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlRml0OiBub29wLFxuXHRcdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciBkaXNwbGF5ID0gb3B0cy5kaXNwbGF5O1xuXHRcdFx0dmFyIGZvbnRTaXplID0gdmFsdWVPckRlZmF1bHQob3B0cy5mb250U2l6ZSwgZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0XHR2YXIgbGluZUNvdW50ID0gaGVscGVycy5pc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcblx0XHRcdHZhciBsaW5lSGVpZ2h0ID0gaGVscGVycy5vcHRpb25zLnRvTGluZUhlaWdodChvcHRzLmxpbmVIZWlnaHQsIGZvbnRTaXplKTtcblx0XHRcdHZhciB0ZXh0U2l6ZSA9IGRpc3BsYXkgPyAobGluZUNvdW50ICogbGluZUhlaWdodCkgKyAob3B0cy5wYWRkaW5nICogMikgOiAwO1xuXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSB0ZXh0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUud2lkdGggPSB0ZXh0U2l6ZTtcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHRcdH1cblxuXHRcdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cblx0XHR9LFxuXHRcdGFmdGVyRml0OiBub29wLFxuXG5cdFx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0XHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbGx5IGRyYXcgdGhlIHRpdGxlIGJsb2NrIG9uIHRoZSBjYW52YXNcblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGRlZmF1bHRzLmdsb2JhbDtcblxuXHRcdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0XHR2YXIgZm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHR2YXIgZm9udFN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0cy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdFx0XHR2YXIgZm9udEZhbWlseSA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpO1xuXHRcdFx0XHR2YXIgdGl0bGVGb250ID0gaGVscGVycy5mb250U3RyaW5nKGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpO1xuXHRcdFx0XHR2YXIgbGluZUhlaWdodCA9IGhlbHBlcnMub3B0aW9ucy50b0xpbmVIZWlnaHQob3B0cy5saW5lSGVpZ2h0LCBmb250U2l6ZSk7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIG9wdHMucGFkZGluZztcblx0XHRcdFx0dmFyIHJvdGF0aW9uID0gMDtcblx0XHRcdFx0dmFyIHRvcCA9IG1lLnRvcDtcblx0XHRcdFx0dmFyIGxlZnQgPSBtZS5sZWZ0O1xuXHRcdFx0XHR2YXIgYm90dG9tID0gbWUuYm90dG9tO1xuXHRcdFx0XHR2YXIgcmlnaHQgPSBtZS5yaWdodDtcblx0XHRcdFx0dmFyIG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0cy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdFx0Y3R4LmZvbnQgPSB0aXRsZUZvbnQ7XG5cblx0XHRcdFx0Ly8gSG9yaXpvbnRhbFxuXHRcdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0XHR0aXRsZVggPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHRcdHRpdGxlWSA9IHRvcCArIG9mZnNldDtcblx0XHRcdFx0XHRtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aXRsZVggPSBvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyBsZWZ0ICsgb2Zmc2V0IDogcmlnaHQgLSBvZmZzZXQ7XG5cdFx0XHRcdFx0dGl0bGVZID0gdG9wICsgKChib3R0b20gLSB0b3ApIC8gMik7XG5cdFx0XHRcdFx0bWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG5cdFx0XHRcdFx0cm90YXRpb24gPSBNYXRoLlBJICogKG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IC0wLjUgOiAwLjUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh0aXRsZVgsIHRpdGxlWSk7XG5cdFx0XHRcdGN0eC5yb3RhdGUocm90YXRpb24pO1xuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRcdFx0XHR2YXIgdGV4dCA9IG9wdHMudGV4dDtcblx0XHRcdFx0aWYgKGhlbHBlcnMuaXNBcnJheSh0ZXh0KSkge1xuXHRcdFx0XHRcdHZhciB5ID0gMDtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0W2ldLCAwLCB5LCBtYXhXaWR0aCk7XG5cdFx0XHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwLCBtYXhXaWR0aCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XG5cdFx0dmFyIHRpdGxlID0gbmV3IENoYXJ0LlRpdGxlKHtcblx0XHRcdGN0eDogY2hhcnQuY3R4LFxuXHRcdFx0b3B0aW9uczogdGl0bGVPcHRzLFxuXHRcdFx0Y2hhcnQ6IGNoYXJ0XG5cdFx0fSk7XG5cblx0XHRsYXlvdXQuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcblx0XHRsYXlvdXQuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG5cdFx0Y2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRpZDogJ3RpdGxlJyxcblxuXHRcdGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHR2YXIgdGl0bGVPcHRzID0gY2hhcnQub3B0aW9ucy50aXRsZTtcblxuXHRcdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHR2YXIgdGl0bGVPcHRzID0gY2hhcnQub3B0aW9ucy50aXRsZTtcblx0XHRcdHZhciB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcblxuXHRcdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0XHRoZWxwZXJzLm1lcmdlSWYodGl0bGVPcHRzLCBkZWZhdWx0cy5nbG9iYWwudGl0bGUpO1xuXG5cdFx0XHRcdGlmICh0aXRsZUJsb2NrKSB7XG5cdFx0XHRcdFx0bGF5b3V0LmNvbmZpZ3VyZShjaGFydCwgdGl0bGVCbG9jaywgdGl0bGVPcHRzKTtcblx0XHRcdFx0XHR0aXRsZUJsb2NrLm9wdGlvbnMgPSB0aXRsZU9wdHM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0aXRsZUJsb2NrKSB7XG5cdFx0XHRcdENoYXJ0LmxheW91dFNlcnZpY2UucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcblx0XHRcdFx0ZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxufSx7XCIyNVwiOjI1LFwiMjZcIjoyNixcIjQ1XCI6NDV9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHQvLyBEZWZhdWx0IGNvbmZpZyBmb3IgYSBjYXRlZ29yeSBzY2FsZVxuXHR2YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0fTtcblxuXHR2YXIgRGF0YXNldFNjYWxlID0gQ2hhcnQuU2NhbGUuZXh0ZW5kKHtcblx0XHQvKipcblx0XHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBsYWJlbHMuIElmIGRhdGEueExhYmVscyBvciBkYXRhLnlMYWJlbHMgYXJlIGRlZmluZWQsIHVzZSB0aG9zZVxuXHRcdCogZWxzZSBmYWxsIGJhY2sgdG8gZGF0YS5sYWJlbHNcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRnZXRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHM7XG5cdFx0fSxcblxuXHRcdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHRcdG1lLm1pbkluZGV4ID0gMDtcblx0XHRcdG1lLm1heEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG5cdFx0XHR2YXIgZmluZEluZGV4O1xuXG5cdFx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5taW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtaW4gdmFsdWVcblx0XHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWUub3B0aW9ucy50aWNrcy5taW4pO1xuXHRcdFx0XHRtZS5taW5JbmRleCA9IGZpbmRJbmRleCAhPT0gLTEgPyBmaW5kSW5kZXggOiBtZS5taW5JbmRleDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1lLm9wdGlvbnMudGlja3MubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWF4IHZhbHVlXG5cdFx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWF4KTtcblx0XHRcdFx0bWUubWF4SW5kZXggPSBmaW5kSW5kZXggIT09IC0xID8gZmluZEluZGV4IDogbWUubWF4SW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdG1lLm1pbiA9IGxhYmVsc1ttZS5taW5JbmRleF07XG5cdFx0XHRtZS5tYXggPSBsYWJlbHNbbWUubWF4SW5kZXhdO1xuXHRcdH0sXG5cblx0XHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0XHQvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuXHRcdFx0bWUudGlja3MgPSAobWUubWluSW5kZXggPT09IDAgJiYgbWUubWF4SW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtZS5taW5JbmRleCwgbWUubWF4SW5kZXggKyAxKTtcblx0XHR9LFxuXG5cdFx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBkYXRhID0gbWUuY2hhcnQuZGF0YTtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0aWYgKGRhdGEueUxhYmVscyAmJiAhaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHJldHVybiBtZS5nZXRSaWdodFZhbHVlKGRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWUudGlja3NbaW5kZXggLSBtZS5taW5JbmRleF07XG5cdFx0fSxcblxuXHRcdC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiAgVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHRcdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHRcdC8vIDEgaXMgYWRkZWQgYmVjYXVzZSB3ZSBuZWVkIHRoZSBsZW5ndGggYnV0IHdlIGhhdmUgdGhlIGluZGV4ZXNcblx0XHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUubWF4SW5kZXggKyAxIC0gbWUubWluSW5kZXggLSAob2Zmc2V0ID8gMCA6IDEpKSwgMSk7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZGF0YSBvYmplY3QsIHRoZW4gaW5kZXggaXMgdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5LFxuXHRcdFx0Ly8gbm90IHRoZSBpbmRleCBvZiB0aGUgc2NhbGUuIFdlIG5lZWQgdG8gY2hhbmdlIHRoYXQuXG5cdFx0XHR2YXIgdmFsdWVDYXRlZ29yeTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlQ2F0ZWdvcnkgPSBtZS5pc0hvcml6b250YWwoKSA/IHZhbHVlLnggOiB2YWx1ZS55O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBpc05hTihpbmRleCkpKSB7XG5cdFx0XHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZUNhdGVnb3J5IHx8IHZhbHVlO1xuXHRcdFx0XHR2YXIgaWR4ID0gbGFiZWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0XHRpbmRleCA9IGlkeCAhPT0gLTEgPyBpZHggOiBpbmRleDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZVdpZHRoID0gbWUud2lkdGggLyBvZmZzZXRBbXQ7XG5cdFx0XHRcdHZhciB3aWR0aE9mZnNldCA9ICh2YWx1ZVdpZHRoICogKGluZGV4IC0gbWUubWluSW5kZXgpKTtcblxuXHRcdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdFx0d2lkdGhPZmZzZXQgKz0gKHZhbHVlV2lkdGggLyAyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtZS5sZWZ0ICsgTWF0aC5yb3VuZCh3aWR0aE9mZnNldCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdmFsdWVIZWlnaHQgPSBtZS5oZWlnaHQgLyBvZmZzZXRBbXQ7XG5cdFx0XHR2YXIgaGVpZ2h0T2Zmc2V0ID0gKHZhbHVlSGVpZ2h0ICogKGluZGV4IC0gbWUubWluSW5kZXgpKTtcblxuXHRcdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0XHRoZWlnaHRPZmZzZXQgKz0gKHZhbHVlSGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZS50b3AgKyBNYXRoLnJvdW5kKGhlaWdodE9mZnNldCk7XG5cdFx0fSxcblx0XHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLCBpbmRleCArIHRoaXMubWluSW5kZXgsIG51bGwpO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgb2Zmc2V0QW10ID0gTWF0aC5tYXgoKG1lLl90aWNrcy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpKSwgMSk7XG5cdFx0XHR2YXIgaG9yeiA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0dmFyIHZhbHVlRGltZW5zaW9uID0gKGhvcnogPyBtZS53aWR0aCA6IG1lLmhlaWdodCkgLyBvZmZzZXRBbXQ7XG5cblx0XHRcdHBpeGVsIC09IGhvcnogPyBtZS5sZWZ0IDogbWUudG9wO1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHBpeGVsIC09ICh2YWx1ZURpbWVuc2lvbiAvIDIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocGl4ZWwgPD0gMCkge1xuXHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQocGl4ZWwgLyB2YWx1ZURpbWVuc2lvbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSArIG1lLm1pbkluZGV4O1xuXHRcdH0sXG5cdFx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmJvdHRvbTtcblx0XHR9XG5cdH0pO1xuXG5cdENoYXJ0LnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSgnY2F0ZWdvcnknLCBEYXRhc2V0U2NhbGUsIGRlZmF1bHRDb25maWcpO1xuXG59O1xuXG59LHt9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoMjUpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKDQ1KTtcbnZhciBUaWNrcyA9IHJlcXVpcmUoMzQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGRlZmF1bHRDb25maWcgPSB7XG5cdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHR0aWNrczoge1xuXHRcdFx0Y2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0fVxuXHR9O1xuXG5cdHZhciBMaW5lYXJTY2FsZSA9IENoYXJ0LkxpbmVhclNjYWxlQmFzZS5leHRlbmQoe1xuXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0dmFyIERFRkFVTFRfTUlOID0gMDtcblx0XHRcdHZhciBERUZBVUxUX01BWCA9IDE7XG5cblx0XHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmlyc3QgQ2FsY3VsYXRlIHRoZSByYW5nZVxuXHRcdFx0bWUubWluID0gbnVsbDtcblx0XHRcdG1lLm1heCA9IG51bGw7XG5cblx0XHRcdHZhciBoYXNTdGFja3MgPSBvcHRzLnN0YWNrZWQ7XG5cdFx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0XHRpZiAoaGFzU3RhY2tzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpICYmXG5cdFx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMuc3RhY2tlZCB8fCBoYXNTdGFja3MpIHtcblx0XHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdFx0dmFyIGtleSA9IFtcblx0XHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYSBzZXBhcmF0ZSBzdGFjayBmb3Igc3RhY2s9dW5kZWZpbmVkIGRhdGFzZXRzIHdoZW4gdGhlIG9wdHMuc3RhY2tlZCBpcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdCgob3B0cy5zdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSA/IGRhdGFzZXRJbmRleCA6ICcnKSxcblx0XHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XHRdLmpvaW4oJy4nKTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZXNQZXJTdGFja1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzOiBbXSxcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXM6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZXNlIHBlciB0eXBlXG5cdFx0XHRcdFx0dmFyIHBvc2l0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5wb3NpdGl2ZVZhbHVlcztcblx0XHRcdFx0XHR2YXIgbmVnYXRpdmVWYWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldLm5lZ2F0aXZlVmFsdWVzO1xuXG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSBwb3NpdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdID0gbmVnYXRpdmVWYWx1ZXNbaW5kZXhdIHx8IDA7XG5cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMucmVsYXRpdmVQb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSAxMDA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzW2luZGV4XSArPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzRm9yVHlwZS5wb3NpdGl2ZVZhbHVlcy5jb25jYXQodmFsdWVzRm9yVHlwZS5uZWdhdGl2ZVZhbHVlcyk7XG5cdFx0XHRcdFx0dmFyIG1pblZhbCA9IGhlbHBlcnMubWluKHZhbHVlcyk7XG5cdFx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMubWF4KHZhbHVlcyk7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWluID09PSBudWxsID8gbWluVmFsIDogTWF0aC5taW4obWUubWluLCBtaW5WYWwpO1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgbWUubWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0bWUubWluID0gaXNGaW5pdGUobWUubWluKSAmJiAhaXNOYU4obWUubWluKSA/IG1lLm1pbiA6IERFRkFVTFRfTUlOO1xuXHRcdFx0bWUubWF4ID0gaXNGaW5pdGUobWUubWF4KSAmJiAhaXNOYU4obWUubWF4KSA/IG1lLm1heCA6IERFRkFVTFRfTUFYO1xuXG5cdFx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXG5cdFx0XHR0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0XHR9LFxuXHRcdGdldFRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWF4VGlja3M7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdG1heFRpY2tzID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCA/IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgOiAxMSwgTWF0aC5jZWlsKG1lLndpZHRoIC8gNTApKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFRoZSBmYWN0b3Igb2YgMiB1c2VkIHRvIHNjYWxlIHRoZSBmb250IHNpemUgaGFzIGJlZW4gZXhwZXJpbWVudGFsbHkgZGV0ZXJtaW5lZC5cblx0XHRcdFx0dmFyIHRpY2tGb250U2l6ZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFNpemUsIGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHRtYXhUaWNrcyA9IE1hdGgubWluKHRpY2tPcHRzLm1heFRpY2tzTGltaXQgPyB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IDogMTEsIE1hdGguY2VpbChtZS5oZWlnaHQgLyAoMiAqIHRpY2tGb250U2l6ZSkpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1heFRpY2tzO1xuXHRcdH0sXG5cdFx0Ly8gQ2FsbGVkIGFmdGVyIHRoZSB0aWNrcyBhcmUgYnVpbHQuIFdlIG5lZWRcblx0XHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdC8vIFdlIGFyZSBpbiBhIHZlcnRpY2FsIG9yaWVudGF0aW9uLiBUaGUgdG9wIHZhbHVlIGlzIHRoZSBoaWdoZXN0LiBTbyByZXZlcnNlIHRoZSBhcnJheVxuXHRcdFx0XHR0aGlzLnRpY2tzLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9LFxuXHRcdC8vIFV0aWxzXG5cdFx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZml0IGhhcyBiZWVuIHJ1biBzbyB0aGF0XG5cdFx0XHQvLyB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLnJpZ2h0LCBhbmQgdGhpcy5ib3R0b20gaGF2ZSBiZWVuIGRlZmluZWRcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhcnQgPSBtZS5zdGFydDtcblxuXHRcdFx0dmFyIHJpZ2h0VmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR2YXIgcGl4ZWw7XG5cdFx0XHR2YXIgcmFuZ2UgPSBtZS5lbmQgLSBzdGFydDtcblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHBpeGVsID0gbWUubGVmdCArIChtZS53aWR0aCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZChwaXhlbCk7XG5cdFx0XHR9XG5cblx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKG1lLmhlaWdodCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQocGl4ZWwpO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHR2YXIgaW5uZXJEaW1lbnNpb24gPSBpc0hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHRcdHZhciBvZmZzZXQgPSAoaXNIb3Jpem9udGFsID8gcGl4ZWwgLSBtZS5sZWZ0IDogbWUuYm90dG9tIC0gcGl4ZWwpIC8gaW5uZXJEaW1lbnNpb247XG5cdFx0XHRyZXR1cm4gbWUuc3RhcnQgKyAoKG1lLmVuZCAtIG1lLnN0YXJ0KSAqIG9mZnNldCk7XG5cdFx0fSxcblx0XHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblx0XHR9XG5cdH0pO1xuXHRDaGFydC5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUoJ2xpbmVhcicsIExpbmVhclNjYWxlLCBkZWZhdWx0Q29uZmlnKTtcblxufTtcblxufSx7XCIyNVwiOjI1LFwiMzRcIjozNCxcIjQ1XCI6NDV9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG52YXIgVGlja3MgPSByZXF1aXJlKDM0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBub29wID0gaGVscGVycy5ub29wO1xuXG5cdENoYXJ0LkxpbmVhclNjYWxlQmFzZSA9IENoYXJ0LlNjYWxlLmV4dGVuZCh7XG5cdFx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiArdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ2hhcnQuU2NhbGUucHJvdG90eXBlLmdldFJpZ2h0VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRcdC8vIElmIHdlIGFyZSBmb3JjaW5nIGl0IHRvIGJlZ2luIGF0IDAsIGJ1dCAwIHdpbGwgYWxyZWFkeSBiZSByZW5kZXJlZCBvbiB0aGUgY2hhcnQsXG5cdFx0XHQvLyBkbyBub3RoaW5nIHNpbmNlIHRoYXQgd291bGQgbWFrZSB0aGUgY2hhcnQgd2VpcmQuIElmIHRoZSB1c2VyIHJlYWxseSB3YW50cyBhIHdlaXJkIGNoYXJ0XG5cdFx0XHQvLyBheGlzLCB0aGV5IGNhbiBtYW51YWxseSBvdmVycmlkZSBpdFxuXHRcdFx0aWYgKHRpY2tPcHRzLmJlZ2luQXRaZXJvKSB7XG5cdFx0XHRcdHZhciBtaW5TaWduID0gaGVscGVycy5zaWduKG1lLm1pbik7XG5cdFx0XHRcdHZhciBtYXhTaWduID0gaGVscGVycy5zaWduKG1lLm1heCk7XG5cblx0XHRcdFx0aWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG5cdFx0XHRcdFx0Ly8gbW92ZSB0aGUgdG9wIHVwIHRvIDBcblx0XHRcdFx0XHRtZS5tYXggPSAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG5cdFx0XHRcdFx0Ly8gbW92ZSB0aGUgYm90dG9tIGRvd24gdG8gMFxuXHRcdFx0XHRcdG1lLm1pbiA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNldE1pbiA9IHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkIHx8IHRpY2tPcHRzLnN1Z2dlc3RlZE1pbiAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0dmFyIHNldE1heCA9IHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkIHx8IHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAodGlja09wdHMubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bWUubWluID0gdGlja09wdHMubWluO1xuXHRcdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0bWUubWluID0gdGlja09wdHMuc3VnZ2VzdGVkTWluO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgdGlja09wdHMuc3VnZ2VzdGVkTWluKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bWUubWF4ID0gdGlja09wdHMubWF4O1xuXHRcdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0bWUubWF4ID0gdGlja09wdHMuc3VnZ2VzdGVkTWF4O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KG1lLm1heCwgdGlja09wdHMuc3VnZ2VzdGVkTWF4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2V0TWluICE9PSBzZXRNYXgpIHtcblx0XHRcdFx0Ly8gV2Ugc2V0IHRoZSBtaW4gb3IgdGhlIG1heCBidXQgbm90IGJvdGguXG5cdFx0XHRcdC8vIFNvIGVuc3VyZSB0aGF0IG91ciByYW5nZSBpcyBnb29kXG5cdFx0XHRcdC8vIEludmVydGVkIG9yIDAgbGVuZ3RoIHJhbmdlIGNhbiBoYXBwZW4gd2hlblxuXHRcdFx0XHQvLyB0aWNrcy5taW4gaXMgc2V0LCBhbmQgbm8gZGF0YXNldHMgYXJlIHZpc2libGVcblx0XHRcdFx0aWYgKG1lLm1pbiA+PSBtZS5tYXgpIHtcblx0XHRcdFx0XHRpZiAoc2V0TWluKSB7XG5cdFx0XHRcdFx0XHRtZS5tYXggPSBtZS5taW4gKyAxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtZS5taW4gPSBtZS5tYXggLSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdFx0bWUubWF4Kys7XG5cblx0XHRcdFx0aWYgKCF0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0XHRcdG1lLm1pbi0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXRUaWNrTGltaXQ6IG5vb3AsXG5cdFx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBub29wLFxuXG5cdFx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdFx0Ly8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG5cdFx0XHQvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNTBcblx0XHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG5cdFx0XHQvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG5cdFx0XHR2YXIgbWF4VGlja3MgPSBtZS5nZXRUaWNrTGltaXQoKTtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG5cdFx0XHR2YXIgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG5cdFx0XHRcdG1heFRpY2tzOiBtYXhUaWNrcyxcblx0XHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRcdG1heDogdGlja09wdHMubWF4LFxuXHRcdFx0XHRzdGVwU2l6ZTogaGVscGVycy52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcblx0XHRcdH07XG5cdFx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IFRpY2tzLmdlbmVyYXRvcnMubGluZWFyKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBtZSk7XG5cblx0XHRcdG1lLmhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcygpO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcblx0XHRcdG1lLm1heCA9IGhlbHBlcnMubWF4KHRpY2tzKTtcblx0XHRcdG1lLm1pbiA9IGhlbHBlcnMubWluKHRpY2tzKTtcblxuXHRcdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0XHRtZS5lbmQgPSBtZS5taW47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdFx0bWUuZW5kID0gbWUubWF4O1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcblx0XHRcdG1lLnplcm9MaW5lSW5kZXggPSBtZS50aWNrcy5pbmRleE9mKDApO1xuXG5cdFx0XHRDaGFydC5TY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0se1wiMzRcIjozNCxcIjQ1XCI6NDV9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG52YXIgVGlja3MgPSByZXF1aXJlKDM0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBkZWZhdWx0Q29uZmlnID0ge1xuXHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cblx0XHQvLyBsYWJlbCBzZXR0aW5nc1xuXHRcdHRpY2tzOiB7XG5cdFx0XHRjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pY1xuXHRcdH1cblx0fTtcblxuXHR2YXIgTG9nYXJpdGhtaWNTY2FsZSA9IENoYXJ0LlNjYWxlLmV4dGVuZCh7XG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRmdW5jdGlvbiBJRE1hdGNoZXMobWV0YSkge1xuXHRcdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBSYW5nZVxuXHRcdFx0bWUubWluID0gbnVsbDtcblx0XHRcdG1lLm1heCA9IG51bGw7XG5cdFx0XHRtZS5taW5Ob3RaZXJvID0gbnVsbDtcblxuXHRcdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRcdGlmIChoYXNTdGFja3MpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRcdG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0aGFzU3RhY2tzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0XHR2YXIgdmFsdWVzUGVyU3RhY2sgPSB7fTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdFx0bWV0YS50eXBlLFxuXHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHNlcGFyYXRlIHN0YWNrIGZvciBzdGFjaz11bmRlZmluZWQgZGF0YXNldHMgd2hlbiB0aGUgb3B0cy5zdGFja2VkIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdFx0bWV0YS5zdGFja1xuXHRcdFx0XHRcdF0uam9pbignLicpO1xuXG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZXNQZXJTdGFja1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzUGVyU3RhY2tba2V5XSA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlc1BlclN0YWNrW2tleV07XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSB2YWx1ZXNbaW5kZXhdIHx8IDA7XG5cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMucmVsYXRpdmVQb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXNbaW5kZXhdID0gMTAwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIERvbid0IG5lZWQgdG8gc3BsaXQgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHNpbmNlIHRoZSBsb2cgc2NhbGUgY2FuJ3QgaGFuZGxlIGEgMCBjcm9zc2luZ1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKHZhbHVlc1BlclN0YWNrLCBmdW5jdGlvbih2YWx1ZXNGb3JUeXBlKSB7XG5cdFx0XHRcdFx0dmFyIG1pblZhbCA9IGhlbHBlcnMubWluKHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzLm1heCh2YWx1ZXNGb3JUeXBlKTtcblx0XHRcdFx0XHRtZS5taW4gPSBtZS5taW4gPT09IG51bGwgPyBtaW5WYWwgOiBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XG5cdFx0XHRcdFx0bWUubWF4ID0gbWUubWF4ID09PSBudWxsID8gbWF4VmFsIDogTWF0aC5tYXgobWUubWF4LCBtYXhWYWwpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCBtZS5taW4pIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+IG1lLm1heCkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9PSAwICYmIChtZS5taW5Ob3RaZXJvID09PSBudWxsIHx8IHZhbHVlIDwgbWUubWluTm90WmVybykpIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdG1lLm1pbiA9IHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLm1pbiwgbWUubWluKTtcblx0XHRcdG1lLm1heCA9IHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLm1heCwgbWUubWF4KTtcblxuXHRcdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRcdGlmIChtZS5taW4gIT09IDAgJiYgbWUubWluICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0bWUubWluID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChtZS5taW4pKSAtIDEpO1xuXHRcdFx0XHRcdG1lLm1heCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMubG9nMTAobWUubWF4KSkgKyAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZS5taW4gPSAxO1xuXHRcdFx0XHRcdG1lLm1heCA9IDEwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0XHR2YXIgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG5cdFx0XHRcdG1pbjogdGlja09wdHMubWluLFxuXHRcdFx0XHRtYXg6IHRpY2tPcHRzLm1heFxuXHRcdFx0fTtcblx0XHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gVGlja3MuZ2VuZXJhdG9ycy5sb2dhcml0aG1pYyhnZW5lcmF0aW9uT3B0aW9ucywgbWUpO1xuXG5cdFx0XHRpZiAoIW1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdC8vIFdlIGFyZSBpbiBhIHZlcnRpY2FsIG9yaWVudGF0aW9uLiBUaGUgdG9wIHZhbHVlIGlzIHRoZSBoaWdoZXN0LiBTbyByZXZlcnNlIHRoZSBhcnJheVxuXHRcdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcblx0XHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdFx0bWUubWF4ID0gaGVscGVycy5tYXgodGlja3MpO1xuXHRcdFx0bWUubWluID0gaGVscGVycy5taW4odGlja3MpO1xuXG5cdFx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cblx0XHRcdFx0bWUuc3RhcnQgPSBtZS5tYXg7XG5cdFx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLnN0YXJ0ID0gbWUubWluO1xuXHRcdFx0XHRtZS5lbmQgPSBtZS5tYXg7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnRpY2tWYWx1ZXMgPSB0aGlzLnRpY2tzLnNsaWNlKCk7XG5cblx0XHRcdENoYXJ0LlNjYWxlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKHRoaXMpO1xuXHRcdH0sXG5cdFx0Ly8gR2V0IHRoZSBjb3JyZWN0IHRvb2x0aXAgbGFiZWxcblx0XHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0fSxcblx0XHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja1ZhbHVlc1tpbmRleF0pO1xuXHRcdH0sXG5cdFx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhcnQgPSBtZS5zdGFydDtcblx0XHRcdHZhciBuZXdWYWwgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdFx0dmFyIGlubmVyRGltZW5zaW9uLCBwaXhlbCwgcmFuZ2U7XG5cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRyYW5nZSA9IGhlbHBlcnMubG9nMTAobWUuZW5kKSAtIGhlbHBlcnMubG9nMTAoc3RhcnQpOyAvLyB0b2RvOiBpZiBzdGFydCA9PT0gMFxuXHRcdFx0XHRpZiAobmV3VmFsID09PSAwKSB7XG5cdFx0XHRcdFx0cGl4ZWwgPSBtZS5sZWZ0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUud2lkdGg7XG5cdFx0XHRcdFx0cGl4ZWwgPSBtZS5sZWZ0ICsgKGlubmVyRGltZW5zaW9uIC8gcmFuZ2UgKiAoaGVscGVycy5sb2cxMChuZXdWYWwpIC0gaGVscGVycy5sb2cxMChzdGFydCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQm90dG9tIC0gdG9wIHNpbmNlIHBpeGVscyBpbmNyZWFzZSBkb3dud2FyZCBvbiBhIHNjcmVlblxuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdFx0aWYgKHN0YXJ0ID09PSAwICYmICF0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRcdFx0cmFuZ2UgPSBoZWxwZXJzLmxvZzEwKG1lLmVuZCkgLSBoZWxwZXJzLmxvZzEwKG1lLm1pbk5vdFplcm8pO1xuXHRcdFx0XHRcdGlmIChuZXdWYWwgPT09IHN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRwaXhlbCA9IG1lLmJvdHRvbTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5ld1ZhbCA9PT0gbWUubWluTm90WmVybykge1xuXHRcdFx0XHRcdFx0cGl4ZWwgPSBtZS5ib3R0b20gLSBpbm5lckRpbWVuc2lvbiAqIDAuMDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gaW5uZXJEaW1lbnNpb24gKiAwLjAyIC0gKGlubmVyRGltZW5zaW9uICogMC45OCAvIHJhbmdlICogKGhlbHBlcnMubG9nMTAobmV3VmFsKSAtIGhlbHBlcnMubG9nMTAobWUubWluTm90WmVybykpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAobWUuZW5kID09PSAwICYmIHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0XHRyYW5nZSA9IGhlbHBlcnMubG9nMTAobWUuc3RhcnQpIC0gaGVscGVycy5sb2cxMChtZS5taW5Ob3RaZXJvKTtcblx0XHRcdFx0XHRpZiAobmV3VmFsID09PSBtZS5lbmQpIHtcblx0XHRcdFx0XHRcdHBpeGVsID0gbWUudG9wO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobmV3VmFsID09PSBtZS5taW5Ob3RaZXJvKSB7XG5cdFx0XHRcdFx0XHRwaXhlbCA9IG1lLnRvcCArIGlubmVyRGltZW5zaW9uICogMC4wMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGl4ZWwgPSBtZS50b3AgKyBpbm5lckRpbWVuc2lvbiAqIDAuMDIgKyAoaW5uZXJEaW1lbnNpb24gKiAwLjk4IC8gcmFuZ2UgKiAoaGVscGVycy5sb2cxMChuZXdWYWwpIC0gaGVscGVycy5sb2cxMChtZS5taW5Ob3RaZXJvKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChuZXdWYWwgPT09IDApIHtcblx0XHRcdFx0XHRwaXhlbCA9IHRpY2tPcHRzLnJldmVyc2UgPyBtZS50b3AgOiBtZS5ib3R0b207XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmFuZ2UgPSBoZWxwZXJzLmxvZzEwKG1lLmVuZCkgLSBoZWxwZXJzLmxvZzEwKHN0YXJ0KTtcblx0XHRcdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdFx0XHRwaXhlbCA9IG1lLmJvdHRvbSAtIChpbm5lckRpbWVuc2lvbiAvIHJhbmdlICogKGhlbHBlcnMubG9nMTAobmV3VmFsKSAtIGhlbHBlcnMubG9nMTAoc3RhcnQpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbDtcblx0XHR9LFxuXHRcdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHJhbmdlID0gaGVscGVycy5sb2cxMChtZS5lbmQpIC0gaGVscGVycy5sb2cxMChtZS5zdGFydCk7XG5cdFx0XHR2YXIgdmFsdWUsIGlubmVyRGltZW5zaW9uO1xuXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS53aWR0aDtcblx0XHRcdFx0dmFsdWUgPSBtZS5zdGFydCAqIE1hdGgucG93KDEwLCAocGl4ZWwgLSBtZS5sZWZ0KSAqIHJhbmdlIC8gaW5uZXJEaW1lbnNpb24pO1xuXHRcdFx0fSBlbHNlIHsgLy8gdG9kbzogaWYgc3RhcnQgPT09IDBcblx0XHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS5oZWlnaHQ7XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5wb3coMTAsIChtZS5ib3R0b20gLSBwaXhlbCkgKiByYW5nZSAvIGlubmVyRGltZW5zaW9uKSAvIG1lLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSk7XG5cdENoYXJ0LnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSgnbG9nYXJpdGhtaWMnLCBMb2dhcml0aG1pY1NjYWxlLCBkZWZhdWx0Q29uZmlnKTtcblxufTtcblxufSx7XCIzNFwiOjM0LFwiNDVcIjo0NX1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgyNSk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoNDUpO1xudmFyIFRpY2tzID0gcmVxdWlyZSgzNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBkZWZhdWx0cy5nbG9iYWw7XG5cblx0dmFyIGRlZmF1bHRDb25maWcgPSB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblxuXHRcdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG5cdFx0YW5pbWF0ZTogdHJ1ZSxcblx0XHRwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG5cblx0XHRhbmdsZUxpbmVzOiB7XG5cdFx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdFx0Y29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuXHRcdFx0bGluZVdpZHRoOiAxXG5cdFx0fSxcblxuXHRcdGdyaWRMaW5lczoge1xuXHRcdFx0Y2lyY3VsYXI6IGZhbHNlXG5cdFx0fSxcblxuXHRcdC8vIGxhYmVsIHNldHRpbmdzXG5cdFx0dGlja3M6IHtcblx0XHRcdC8vIEJvb2xlYW4gLSBTaG93IGEgYmFja2Ryb3AgdG8gdGhlIHNjYWxlIGxhYmVsXG5cdFx0XHRzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuXHRcdFx0Ly8gU3RyaW5nIC0gVGhlIGNvbG91ciBvZiB0aGUgbGFiZWwgYmFja2Ryb3Bcblx0XHRcdGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNzUpJyxcblxuXHRcdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0XHRiYWNrZHJvcFBhZGRpbmdZOiAyLFxuXG5cdFx0XHQvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyB0byB0aGUgc2lkZSBvZiB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0XHRiYWNrZHJvcFBhZGRpbmdYOiAyLFxuXG5cdFx0XHRjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0XHR9LFxuXG5cdFx0cG9pbnRMYWJlbHM6IHtcblx0XHRcdC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuXHRcdFx0ZGlzcGxheTogdHJ1ZSxcblxuXHRcdFx0Ly8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xuXHRcdFx0Zm9udFNpemU6IDEwLFxuXG5cdFx0XHQvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcblx0XHRcdGNhbGxiYWNrOiBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlQ291bnQoc2NhbGUpIHtcblx0XHR2YXIgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG5cdFx0cmV0dXJuIG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSA/IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCA6IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb2ludExhYmVsRm9udE9wdGlvbnMoc2NhbGUpIHtcblx0XHR2YXIgcG9pbnRMYWJlbE9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuXHRcdHZhciBmb250U2l6ZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQocG9pbnRMYWJlbE9wdGlvbnMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0dmFyIGZvbnRTdHlsZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQocG9pbnRMYWJlbE9wdGlvbnMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKTtcblx0XHR2YXIgZm9udEZhbWlseSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQocG9pbnRMYWJlbE9wdGlvbnMuZm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpO1xuXHRcdHZhciBmb250ID0gaGVscGVycy5mb250U3RyaW5nKGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNpemU6IGZvbnRTaXplLFxuXHRcdFx0c3R5bGU6IGZvbnRTdHlsZSxcblx0XHRcdGZhbWlseTogZm9udEZhbWlseSxcblx0XHRcdGZvbnQ6IGZvbnRcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnRTaXplLCBsYWJlbCkge1xuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkobGFiZWwpKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR3OiBoZWxwZXJzLmxvbmdlc3RUZXh0KGN0eCwgY3R4LmZvbnQsIGxhYmVsKSxcblx0XHRcdFx0aDogKGxhYmVsLmxlbmd0aCAqIGZvbnRTaXplKSArICgobGFiZWwubGVuZ3RoIC0gMSkgKiAxLjUgKiBmb250U2l6ZSlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHc6IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGgsXG5cdFx0XHRoOiBmb250U2l6ZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcblx0XHRpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcblx0XHRcdFx0ZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN0YXJ0OiBwb3MgLSBzaXplIC0gNSxcblx0XHRcdFx0ZW5kOiBwb3Ncblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBwb3MsXG5cdFx0XHRlbmQ6IHBvcyArIHNpemUgKyA1XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuXHQgKi9cblx0ZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG5cdFx0Lypcblx0XHQgKiBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG5cdFx0ICogVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG5cdFx0ICpcblx0XHQgKiBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG5cdFx0ICpcblx0XHQgKiBTb2x1dGlvbjpcblx0XHQgKlxuXHRcdCAqIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuXHRcdCAqIGF0IGVhY2ggaW5kZXggd2UgY2hlY2sgaWYgdGhlIHRleHQgb3ZlcmxhcHMuXG5cdFx0ICpcblx0XHQgKiBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuXHRcdCAqXG5cdFx0ICogQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG5cdFx0ICogZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuXHRcdCAqXG5cdFx0ICogV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcblx0XHQgKiBhbG9uZyB3aXRoIGxhYmVscy5cblx0XHQgKlxuXHRcdCAqIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cblx0XHQgKiBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cblx0XHQgKlxuXHRcdCAqIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuXHRcdCAqIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG5cdFx0ICpcblx0XHQgKiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblx0XHQgKi9cblxuXHRcdHZhciBwbEZvbnQgPSBnZXRQb2ludExhYmVsRm9udE9wdGlvbnMoc2NhbGUpO1xuXG5cdFx0Ly8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXG5cdFx0Ly8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG5cdFx0dmFyIGxhcmdlc3RQb3NzaWJsZVJhZGl1cyA9IE1hdGgubWluKHNjYWxlLmhlaWdodCAvIDIsIHNjYWxlLndpZHRoIC8gMik7XG5cdFx0dmFyIGZ1cnRoZXN0TGltaXRzID0ge1xuXHRcdFx0cjogc2NhbGUud2lkdGgsXG5cdFx0XHRsOiAwLFxuXHRcdFx0dDogc2NhbGUuaGVpZ2h0LFxuXHRcdFx0YjogMFxuXHRcdH07XG5cdFx0dmFyIGZ1cnRoZXN0QW5nbGVzID0ge307XG5cdFx0dmFyIGksIHRleHRTaXplLCBwb2ludFBvc2l0aW9uO1xuXG5cdFx0c2NhbGUuY3R4LmZvbnQgPSBwbEZvbnQuZm9udDtcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzID0gW107XG5cblx0XHR2YXIgdmFsdWVDb3VudCA9IGdldFZhbHVlQ291bnQoc2NhbGUpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIGxhcmdlc3RQb3NzaWJsZVJhZGl1cyk7XG5cdFx0XHR0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQuc2l6ZSwgc2NhbGUucG9pbnRMYWJlbHNbaV0gfHwgJycpO1xuXHRcdFx0c2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuXG5cdFx0XHQvLyBBZGQgcXVhcnRlciBjaXJjbGUgdG8gbWFrZSBkZWdyZWUgMCBtZWFuIHRvcCBvZiBjaXJjbGVcblx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuXHRcdFx0dmFyIGFuZ2xlID0gaGVscGVycy50b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSAlIDM2MDtcblx0XHRcdHZhciBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG5cdFx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcblxuXHRcdFx0aWYgKGhMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy5sKSB7XG5cdFx0XHRcdGZ1cnRoZXN0TGltaXRzLmwgPSBoTGltaXRzLnN0YXJ0O1xuXHRcdFx0XHRmdXJ0aGVzdEFuZ2xlcy5sID0gYW5nbGVSYWRpYW5zO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaExpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5yKSB7XG5cdFx0XHRcdGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcblx0XHRcdFx0ZnVydGhlc3RBbmdsZXMuciA9IGFuZ2xlUmFkaWFucztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XG5cdFx0XHRcdGZ1cnRoZXN0TGltaXRzLnQgPSB2TGltaXRzLnN0YXJ0O1xuXHRcdFx0XHRmdXJ0aGVzdEFuZ2xlcy50ID0gYW5nbGVSYWRpYW5zO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodkxpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5iKSB7XG5cdFx0XHRcdGZ1cnRoZXN0TGltaXRzLmIgPSB2TGltaXRzLmVuZDtcblx0XHRcdFx0ZnVydGhlc3RBbmdsZXMuYiA9IGFuZ2xlUmFkaWFucztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzY2FsZS5zZXRSZWR1Y3Rpb25zKGxhcmdlc3RQb3NzaWJsZVJhZGl1cywgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIG5vIHBvaW50IGxhYmVsc1xuXHQgKi9cblx0ZnVuY3Rpb24gZml0KHNjYWxlKSB7XG5cdFx0dmFyIGxhcmdlc3RQb3NzaWJsZVJhZGl1cyA9IE1hdGgubWluKHNjYWxlLmhlaWdodCAvIDIsIHNjYWxlLndpZHRoIC8gMik7XG5cdFx0c2NhbGUuZHJhd2luZ0FyZWEgPSBNYXRoLnJvdW5kKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyk7XG5cdFx0c2NhbGUuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuXHRcdGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG5cdFx0XHRyZXR1cm4gJ2NlbnRlcic7XG5cdFx0fSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuXHRcdFx0cmV0dXJuICdsZWZ0Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gJ3JpZ2h0Jztcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbGxUZXh0KGN0eCwgdGV4dCwgcG9zaXRpb24sIGZvbnRTaXplKSB7XG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheSh0ZXh0KSkge1xuXHRcdFx0dmFyIHkgPSBwb3NpdGlvbi55O1xuXHRcdFx0dmFyIHNwYWNpbmcgPSAxLjUgKiBmb250U2l6ZTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0W2ldLCBwb3NpdGlvbi54LCB5KTtcblx0XHRcdFx0eSArPSBzcGFjaW5nO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguZmlsbFRleHQodGV4dCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCB0ZXh0U2l6ZSwgcG9zaXRpb24pIHtcblx0XHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcblx0XHRcdHBvc2l0aW9uLnkgLT0gKHRleHRTaXplLmggLyAyKTtcblx0XHR9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcblx0XHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0XHR2YXIgY3R4ID0gc2NhbGUuY3R4O1xuXHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cdFx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHRcdHZhciBhbmdsZUxpbmVPcHRzID0gb3B0cy5hbmdsZUxpbmVzO1xuXHRcdHZhciBwb2ludExhYmVsT3B0cyA9IG9wdHMucG9pbnRMYWJlbHM7XG5cblx0XHRjdHgubGluZVdpZHRoID0gYW5nbGVMaW5lT3B0cy5saW5lV2lkdGg7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gYW5nbGVMaW5lT3B0cy5jb2xvcjtcblxuXHRcdHZhciBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcblxuXHRcdC8vIFBvaW50IExhYmVsIEZvbnRcblx0XHR2YXIgcGxGb250ID0gZ2V0UG9pbnRMYWJlbEZvbnRPcHRpb25zKHNjYWxlKTtcblxuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdGZvciAodmFyIGkgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAoYW5nbGVMaW5lT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBvdXRlclBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIpO1xuXHRcdFx0XHRjdHgubGluZVRvKG91dGVyUG9zaXRpb24ueCwgb3V0ZXJQb3NpdGlvbi55KTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwb2ludExhYmVsT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIEV4dHJhIDNweCBvdXQgZm9yIHNvbWUgbGFiZWwgc3BhY2luZ1xuXHRcdFx0XHR2YXIgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgNSk7XG5cblx0XHRcdFx0Ly8gS2VlcCB0aGlzIGluIGxvb3Agc2luY2Ugd2UgbWF5IHN1cHBvcnQgYXJyYXkgcHJvcGVydGllcyBoZXJlXG5cdFx0XHRcdHZhciBwb2ludExhYmVsRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQocG9pbnRMYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdFx0Y3R4LmZvbnQgPSBwbEZvbnQuZm9udDtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHBvaW50TGFiZWxGb250Q29sb3I7XG5cblx0XHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XG5cdFx0XHRcdHZhciBhbmdsZSA9IGhlbHBlcnMudG9EZWdyZWVzKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG5cdFx0XHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcblx0XHRcdFx0ZmlsbFRleHQoY3R4LCBzY2FsZS5wb2ludExhYmVsc1tpXSB8fCAnJywgcG9pbnRMYWJlbFBvc2l0aW9uLCBwbEZvbnQuc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBpbmRleCkge1xuXHRcdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVPcHRzLmNvbG9yLCBpbmRleCAtIDEpO1xuXHRcdGN0eC5saW5lV2lkdGggPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZU9wdHMubGluZVdpZHRoLCBpbmRleCAtIDEpO1xuXG5cdFx0aWYgKHNjYWxlLm9wdGlvbnMuZ3JpZExpbmVzLmNpcmN1bGFyKSB7XG5cdFx0XHQvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxuXHRcdFx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblxuXHRcdFx0aWYgKHZhbHVlQ291bnQgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR2YXIgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcblx0XHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdFx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuXHRcdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuXHRcdHJldHVybiBoZWxwZXJzLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcblx0fVxuXG5cdHZhciBMaW5lYXJSYWRpYWxTY2FsZSA9IENoYXJ0LkxpbmVhclNjYWxlQmFzZS5leHRlbmQoe1xuXHRcdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblx0XHRcdG1lLnhDZW50ZXIgPSBNYXRoLnJvdW5kKG1lLndpZHRoIC8gMik7XG5cdFx0XHRtZS55Q2VudGVyID0gTWF0aC5yb3VuZChtZS5oZWlnaHQgLyAyKTtcblxuXHRcdFx0dmFyIG1pblNpemUgPSBoZWxwZXJzLm1pbihbbWUuaGVpZ2h0LCBtZS53aWR0aF0pO1xuXHRcdFx0dmFyIHRpY2tGb250U2l6ZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRtZS5kcmF3aW5nQXJlYSA9IG9wdHMuZGlzcGxheSA/IChtaW5TaXplIC8gMikgLSAodGlja0ZvbnRTaXplIC8gMiArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kpIDogKG1pblNpemUgLyAyKTtcblx0XHR9LFxuXHRcdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChjaGFydC5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSkge1xuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1pbiA9IE1hdGgubWluKHZhbHVlLCBtaW4pO1xuXHRcdFx0XHRcdFx0bWF4ID0gTWF0aC5tYXgodmFsdWUsIG1heCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcblx0XHRcdG1lLm1heCA9IChtYXggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA/IDAgOiBtYXgpO1xuXG5cdFx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXG5cdFx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdFx0fSxcblx0XHRnZXRUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXHRcdFx0dmFyIHRpY2tGb250U2l6ZSA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRyZXR1cm4gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCA/IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgOiAxMSwgTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyAoMS41ICogdGlja0ZvbnRTaXplKSkpO1xuXHRcdH0sXG5cdFx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Q2hhcnQuTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKG1lKTtcblxuXHRcdFx0Ly8gUG9pbnQgbGFiZWxzXG5cdFx0XHRtZS5wb2ludExhYmVscyA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLm1hcChtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBtZSk7XG5cdFx0fSxcblx0XHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0fSxcblx0XHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG5cdFx0XHRcdGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpdCh0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFNldCByYWRpdXMgcmVkdWN0aW9ucyBhbmQgZGV0ZXJtaW5lIG5ldyByYWRpdXMgYW5kIGNlbnRlciBwb2ludFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0c2V0UmVkdWN0aW9uczogZnVuY3Rpb24obGFyZ2VzdFBvc3NpYmxlUmFkaXVzLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uTGVmdCA9IGZ1cnRoZXN0TGltaXRzLmwgLyBNYXRoLnNpbihmdXJ0aGVzdEFuZ2xlcy5sKTtcblx0XHRcdHZhciByYWRpdXNSZWR1Y3Rpb25SaWdodCA9IE1hdGgubWF4KGZ1cnRoZXN0TGltaXRzLnIgLSBtZS53aWR0aCwgMCkgLyBNYXRoLnNpbihmdXJ0aGVzdEFuZ2xlcy5yKTtcblx0XHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Ub3AgPSAtZnVydGhlc3RMaW1pdHMudCAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLnQpO1xuXHRcdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IC1NYXRoLm1heChmdXJ0aGVzdExpbWl0cy5iIC0gbWUuaGVpZ2h0LCAwKSAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLmIpO1xuXG5cdFx0XHRyYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkxlZnQpO1xuXHRcdFx0cmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xuXHRcdFx0cmFkaXVzUmVkdWN0aW9uVG9wID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblRvcCk7XG5cdFx0XHRyYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblxuXHRcdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcblx0XHRcdFx0TWF0aC5yb3VuZChsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uTGVmdCArIHJhZGl1c1JlZHVjdGlvblJpZ2h0KSAvIDIpLFxuXHRcdFx0XHRNYXRoLnJvdW5kKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25Ub3AgKyByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pIC8gMikpO1xuXHRcdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblx0XHR9LFxuXHRcdHNldENlbnRlclBvaW50OiBmdW5jdGlvbihsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXHRcdFx0dmFyIG1heExlZnQgPSBsZWZ0TW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcblx0XHRcdHZhciBtYXhUb3AgPSB0b3BNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhO1xuXHRcdFx0dmFyIG1heEJvdHRvbSA9IG1lLmhlaWdodCAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cblx0XHRcdG1lLnhDZW50ZXIgPSBNYXRoLnJvdW5kKCgobWF4TGVmdCArIG1heFJpZ2h0KSAvIDIpICsgbWUubGVmdCk7XG5cdFx0XHRtZS55Q2VudGVyID0gTWF0aC5yb3VuZCgoKG1heFRvcCArIG1heEJvdHRvbSkgLyAyKSArIG1lLnRvcCk7XG5cdFx0fSxcblxuXHRcdGdldEluZGV4QW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHR2YXIgYW5nbGVNdWx0aXBsaWVyID0gKE1hdGguUEkgKiAyKSAvIGdldFZhbHVlQ291bnQodGhpcyk7XG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IHRoaXMuY2hhcnQub3B0aW9ucyAmJiB0aGlzLmNoYXJ0Lm9wdGlvbnMuc3RhcnRBbmdsZSA/XG5cdFx0XHRcdHRoaXMuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIDpcblx0XHRcdFx0MDtcblxuXHRcdFx0dmFyIHN0YXJ0QW5nbGVSYWRpYW5zID0gc3RhcnRBbmdsZSAqIE1hdGguUEkgKiAyIC8gMzYwO1xuXG5cdFx0XHQvLyBTdGFydCBmcm9tIHRoZSB0b3AgaW5zdGVhZCBvZiByaWdodCwgc28gcmVtb3ZlIGEgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cdFx0XHRyZXR1cm4gaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyBzdGFydEFuZ2xlUmFkaWFucztcblx0XHR9LFxuXHRcdGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiAwOyAvLyBudWxsIGFsd2F5cyBpbiBjZW50ZXJcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuXHRcdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBtZS5kcmF3aW5nQXJlYSAvIChtZS5tYXggLSBtZS5taW4pO1xuXHRcdFx0aWYgKG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xuXHRcdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHZhbHVlIC0gbWUubWluKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0fSxcblx0XHRnZXRQb2ludFBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHRoaXNBbmdsZSA9IG1lLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gKE1hdGguUEkgLyAyKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IE1hdGgucm91bmQoTWF0aC5jb3ModGhpc0FuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlcikgKyBtZS54Q2VudGVyLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKE1hdGguc2luKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIpICsgbWUueUNlbnRlclxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZTogZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdGdldEJhc2VQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHRcdHZhciBtYXggPSBtZS5tYXg7XG5cblx0XHRcdHJldHVybiBtZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCxcblx0XHRcdFx0bWUuYmVnaW5BdFplcm8gPyAwIDpcblx0XHRcdFx0bWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcblx0XHRcdFx0bWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcblx0XHRcdFx0MCk7XG5cdFx0fSxcblxuXHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXG5cdFx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHRcdHZhciBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuXG5cdFx0XHRcdC8vIFRpY2sgRm9udFxuXHRcdFx0XHR2YXIgdGlja0ZvbnRTaXplID0gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRcdHZhciB0aWNrRm9udFN0eWxlID0gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKTtcblx0XHRcdFx0dmFyIHRpY2tGb250RmFtaWx5ID0gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpO1xuXHRcdFx0XHR2YXIgdGlja0xhYmVsRm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyh0aWNrRm9udFNpemUsIHRpY2tGb250U3R5bGUsIHRpY2tGb250RmFtaWx5KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2gobWUudGlja3MsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xuXHRcdFx0XHRcdC8vIERvbid0IGRyYXcgYSBjZW50cmUgdmFsdWUgKGlmIGl0IGlzIG1pbmltdW0pXG5cdFx0XHRcdFx0aWYgKGluZGV4ID4gMCB8fCB0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgeUNlbnRlck9mZnNldCA9IG1lLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG1lLnRpY2tzQXNOdW1iZXJzW2luZGV4XSk7XG5cblx0XHRcdFx0XHRcdC8vIERyYXcgY2lyY3VsYXIgbGluZXMgYXJvdW5kIHRoZSBzY2FsZVxuXHRcdFx0XHRcdFx0aWYgKGdyaWRMaW5lT3B0cy5kaXNwbGF5ICYmIGluZGV4ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGRyYXdSYWRpdXNMaW5lKG1lLCBncmlkTGluZU9wdHMsIHlDZW50ZXJPZmZzZXQsIGluZGV4KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0XHRcdFx0XHRjdHguZm9udCA9IHRpY2tMYWJlbEZvbnQ7XG5cblx0XHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAodGlja09wdHMuc2hvd0xhYmVsQmFja2Ryb3ApIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tPcHRzLmJhY2tkcm9wQ29sb3I7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KFxuXHRcdFx0XHRcdFx0XHRcdFx0LWxhYmVsV2lkdGggLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCxcblx0XHRcdFx0XHRcdFx0XHRcdC15Q2VudGVyT2Zmc2V0IC0gdGlja0ZvbnRTaXplIC8gMiAtIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1ksXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbFdpZHRoICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCAqIDIsXG5cdFx0XHRcdFx0XHRcdFx0XHR0aWNrRm9udFNpemUgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMlxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tGb250Q29sb3I7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dChsYWJlbCwgMCwgLXlDZW50ZXJPZmZzZXQpO1xuXHRcdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0XHRcdGRyYXdQb2ludExhYmVscyhtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRDaGFydC5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUoJ3JhZGlhbExpbmVhcicsIExpbmVhclJhZGlhbFNjYWxlLCBkZWZhdWx0Q29uZmlnKTtcblxufTtcblxufSx7XCIyNVwiOjI1LFwiMzRcIjozNCxcIjQ1XCI6NDV9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBnbG9iYWwgd2luZG93OiBmYWxzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9tZW50ID0gcmVxdWlyZSgxKTtcbm1vbWVudCA9IHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyBtb21lbnQgOiB3aW5kb3cubW9tZW50O1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKDI1KTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSg0NSk7XG5cbi8vIEludGVnZXIgY29uc3RhbnRzIGFyZSBmcm9tIHRoZSBFUzYgc3BlYy5cbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxO1xudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxudmFyIElOVEVSVkFMUyA9IHtcblx0bWlsbGlzZWNvbmQ6IHtcblx0XHRtYWpvcjogdHJ1ZSxcblx0XHRzaXplOiAxLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwLCAyNTAsIDUwMF1cblx0fSxcblx0c2Vjb25kOiB7XG5cdFx0bWFqb3I6IHRydWUsXG5cdFx0c2l6ZTogMTAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAzMF1cblx0fSxcblx0bWludXRlOiB7XG5cdFx0bWFqb3I6IHRydWUsXG5cdFx0c2l6ZTogNjAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMzBdXG5cdH0sXG5cdGhvdXI6IHtcblx0XHRtYWpvcjogdHJ1ZSxcblx0XHRzaXplOiAzNjAwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgMywgNiwgMTJdXG5cdH0sXG5cdGRheToge1xuXHRcdG1ham9yOiB0cnVlLFxuXHRcdHNpemU6IDg2NDAwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNV1cblx0fSxcblx0d2Vlazoge1xuXHRcdG1ham9yOiBmYWxzZSxcblx0XHRzaXplOiA2MDQ4MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA0XVxuXHR9LFxuXHRtb250aDoge1xuXHRcdG1ham9yOiB0cnVlLFxuXHRcdHNpemU6IDIuNjI4ZTksXG5cdFx0c3RlcHM6IFsxLCAyLCAzXVxuXHR9LFxuXHRxdWFydGVyOiB7XG5cdFx0bWFqb3I6IGZhbHNlLFxuXHRcdHNpemU6IDcuODg0ZTksXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA0XVxuXHR9LFxuXHR5ZWFyOiB7XG5cdFx0bWFqb3I6IHRydWUsXG5cdFx0c2l6ZTogMy4xNTRlMTBcblx0fVxufTtcblxudmFyIFVOSVRTID0gT2JqZWN0LmtleXMoSU5URVJWQUxTKTtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcblx0cmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShpdGVtcykge1xuXHR2YXIgaGFzaCA9IHt9O1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpLCBpbGVuLCBpdGVtO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpdGVtID0gaXRlbXNbaV07XG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XG5cdFx0XHRoYXNoW2l0ZW1dID0gdHJ1ZTtcblx0XHRcdG91dC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cbiAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG4gKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcbiAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG4gKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IHRpbWVzdGFtcHMgLSB0aW1lc3RhbXBzIHNvcnRlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IGRpc3RyaWJ1dGlvbiAtIElmICdsaW5lYXInLCB0aW1lc3RhbXBzIHdpbGwgYmUgc3ByZWFkIGxpbmVhcmx5IGFsb25nIHRoZSBtaW5cbiAqIGFuZCBtYXggcmFuZ2UsIHNvIGJhc2ljYWxseSwgdGhlIHRhYmxlIHdpbGwgY29udGFpbnMgb25seSB0d28gaXRlbXM6IHttaW4sIDB9IGFuZCB7bWF4LCAxfS5cbiAqIElmICdzZXJpZXMnLCB0aW1lc3RhbXBzIHdpbGwgYmUgcG9zaXRpb25lZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIEluIHRoaXNcbiAqIGNhc2UsIG9ubHkgdGltZXN0YW1wcyB0aGF0IGJyZWFrIHRoZSB0aW1lIGxpbmVhcml0eSBhcmUgcmVnaXN0ZXJlZCwgbWVhbmluZyB0aGF0IGluIHRoZVxuICogYmVzdCBjYXNlLCBhbGwgdGltZXN0YW1wcyBhcmUgbGluZWFyLCB0aGUgdGFibGUgY29udGFpbnMgb25seSBtaW4gYW5kIG1heC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKSB7XG5cdGlmIChkaXN0cmlidXRpb24gPT09ICdsaW5lYXInIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHR7dGltZTogbWluLCBwb3M6IDB9LFxuXHRcdFx0e3RpbWU6IG1heCwgcG9zOiAxfVxuXHRcdF07XG5cdH1cblxuXHR2YXIgdGFibGUgPSBbXTtcblx0dmFyIGl0ZW1zID0gW21pbl07XG5cdHZhciBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdGlmIChjdXJyID4gbWluICYmIGN1cnIgPCBtYXgpIHtcblx0XHRcdGl0ZW1zLnB1c2goY3Vycik7XG5cdFx0fVxuXHR9XG5cblx0aXRlbXMucHVzaChtYXgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRuZXh0ID0gaXRlbXNbaSArIDFdO1xuXHRcdHByZXYgPSBpdGVtc1tpIC0gMV07XG5cdFx0Y3VyciA9IGl0ZW1zW2ldO1xuXG5cdFx0Ly8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcblx0XHRpZiAocHJldiA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09IHVuZGVmaW5lZCB8fCBNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuXHRcdFx0dGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YWJsZTtcbn1cblxuLy8gQHNlZSBhZGFwdGVkIGZyb20gaHR0cDovL3d3dy5hbnVqZ2FraGFyLmNvbS8yMDE0LzAzLzAxL2JpbmFyeS1zZWFyY2gtaW4tamF2YXNjcmlwdC9cbmZ1bmN0aW9uIGxvb2t1cCh0YWJsZSwga2V5LCB2YWx1ZSkge1xuXHR2YXIgbG8gPSAwO1xuXHR2YXIgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuXHR2YXIgbWlkLCBpMCwgaTE7XG5cblx0d2hpbGUgKGxvID49IDAgJiYgbG8gPD0gaGkpIHtcblx0XHRtaWQgPSAobG8gKyBoaSkgPj4gMTtcblx0XHRpMCA9IHRhYmxlW21pZCAtIDFdIHx8IG51bGw7XG5cdFx0aTEgPSB0YWJsZVttaWRdO1xuXG5cdFx0aWYgKCFpMCkge1xuXHRcdFx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYmVmb3JlIGZpcnN0IGl0ZW0pXG5cdFx0XHRyZXR1cm4ge2xvOiBudWxsLCBoaTogaTF9O1xuXHRcdH0gZWxzZSBpZiAoaTFba2V5XSA8IHZhbHVlKSB7XG5cdFx0XHRsbyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIGlmIChpMFtrZXldID4gdmFsdWUpIHtcblx0XHRcdGhpID0gbWlkIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHtsbzogaTAsIGhpOiBpMX07XG5cdFx0fVxuXHR9XG5cblx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYWZ0ZXIgbGFzdCBpdGVtKVxuXHRyZXR1cm4ge2xvOiBpMSwgaGk6IG51bGx9O1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWx1ZWAgdXNpbmcgdGhlIHRhYmxlIGl0ZW1zIGBza2V5YCB2YWx1ZXMgYW5kXG4gKiByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGB0a2V5YCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIDQyLCAncG9zJylcbiAqIHJldHVybnMgdGhlIHBvc2l0aW9uIGZvciBhIHRpbWVzdGFtcCBlcXVhbCB0byA0Mi4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzIGF0XG4gKiBpbmRleCBbMCwgMV0gb3IgW24gLSAxLCBuXSBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCBza2V5LCBzdmFsLCB0a2V5KSB7XG5cdHZhciByYW5nZSA9IGxvb2t1cCh0YWJsZSwgc2tleSwgc3ZhbCk7XG5cblx0Ly8gTm90ZTogdGhlIGxvb2t1cCB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgMiBpdGVtcyAobWluIGFuZCBtYXgpXG5cdHZhciBwcmV2ID0gIXJhbmdlLmxvID8gdGFibGVbMF0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAyXSA6IHJhbmdlLmxvO1xuXHR2YXIgbmV4dCA9ICFyYW5nZS5sbyA/IHRhYmxlWzFdIDogIXJhbmdlLmhpID8gdGFibGVbdGFibGUubGVuZ3RoIC0gMV0gOiByYW5nZS5oaTtcblxuXHR2YXIgc3BhbiA9IG5leHRbc2tleV0gLSBwcmV2W3NrZXldO1xuXHR2YXIgcmF0aW8gPSBzcGFuID8gKHN2YWwgLSBwcmV2W3NrZXldKSAvIHNwYW4gOiAwO1xuXHR2YXIgb2Zmc2V0ID0gKG5leHRbdGtleV0gLSBwcmV2W3RrZXldKSAqIHJhdGlvO1xuXG5cdHJldHVybiBwcmV2W3RrZXldICsgb2Zmc2V0O1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHZhbHVlIHRvIGEgbW9tZW50IG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gdGltZSBvcHRpb25zLlxuICogQHNlZSBodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL1xuICovXG5mdW5jdGlvbiBtb21lbnRpZnkodmFsdWUsIG9wdGlvbnMpIHtcblx0dmFyIHBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuXHR2YXIgZm9ybWF0ID0gb3B0aW9ucy5wYXJzZXIgfHwgb3B0aW9ucy5mb3JtYXQ7XG5cblx0aWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gcGFyc2VyKHZhbHVlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcblx0fVxuXG5cdGlmICghKHZhbHVlIGluc3RhbmNlb2YgbW9tZW50KSkge1xuXHRcdHZhbHVlID0gbW9tZW50KHZhbHVlKTtcblx0fVxuXG5cdGlmICh2YWx1ZS5pc1ZhbGlkKCkpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHQvLyBMYWJlbHMgYXJlIGluIGFuIGluY29tcGF0aWJsZSBtb21lbnQgZm9ybWF0IGFuZCBubyBgcGFyc2VyYCBoYXMgYmVlbiBwcm92aWRlZC5cblx0Ly8gVGhlIHVzZXIgbWlnaHQgc3RpbGwgdXNlIHRoZSBkZXByZWNhdGVkIGBmb3JtYXRgIG9wdGlvbiB0byBjb252ZXJ0IGhpcyBpbnB1dHMuXG5cdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBzY2FsZSkge1xuXHRpZiAoaGVscGVycy5pc051bGxPclVuZGVmKGlucHV0KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciB2YWx1ZSA9IG1vbWVudGlmeShzY2FsZS5nZXRSaWdodFZhbHVlKGlucHV0KSwgb3B0aW9ucyk7XG5cdGlmICghdmFsdWUuaXNWYWxpZCgpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAob3B0aW9ucy5yb3VuZCkge1xuXHRcdHZhbHVlLnN0YXJ0T2Yob3B0aW9ucy5yb3VuZCk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWUudmFsdWVPZigpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB1bml0IHRvIHNraXAgdG8gYmUgYWJsZSB0byBkaXNwbGF5IHVwIHRvIGBjYXBhY2l0eWAgbnVtYmVyIG9mIHRpY2tzXG4gKiBpbiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgbWluYCAvIGBtYXhgIHJhbmdlIGFuZCByZXNwZWN0aW5nIHRoZSBpbnRlcnZhbCBzdGVwcyBjb25zdHJhaW50cy5cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lU3RlcFNpemUobWluLCBtYXgsIHVuaXQsIGNhcGFjaXR5KSB7XG5cdHZhciByYW5nZSA9IG1heCAtIG1pbjtcblx0dmFyIGludGVydmFsID0gSU5URVJWQUxTW3VuaXRdO1xuXHR2YXIgbWlsbGlzZWNvbmRzID0gaW50ZXJ2YWwuc2l6ZTtcblx0dmFyIHN0ZXBzID0gaW50ZXJ2YWwuc3RlcHM7XG5cdHZhciBpLCBpbGVuLCBmYWN0b3I7XG5cblx0aWYgKCFzdGVwcykge1xuXHRcdHJldHVybiBNYXRoLmNlaWwocmFuZ2UgLyAoKGNhcGFjaXR5IHx8IDEpICogbWlsbGlzZWNvbmRzKSk7XG5cdH1cblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gc3RlcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0ZmFjdG9yID0gc3RlcHNbaV07XG5cdFx0aWYgKE1hdGguY2VpbChyYW5nZSAvIChtaWxsaXNlY29uZHMgKiBmYWN0b3IpKSA8PSBjYXBhY2l0eSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhY3Rvcjtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdChtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cdHZhciBpLCBpbnRlcnZhbCwgZmFjdG9yO1xuXG5cdGZvciAoaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG5cdFx0aW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuXHRcdGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHNbaW50ZXJ2YWwuc3RlcHMubGVuZ3RoIC0gMV0gOiBNQVhfSU5URUdFUjtcblxuXHRcdGlmIChNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKElOVEVSVkFMU1tVTklUU1tpXV0ubWFqb3IpIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuICogYG1pbm9yYCB1bml0LCBhbGlnbmVkIG9uIHRoZSBgbWFqb3JgIHVuaXQgYW5kIHVzaW5nIHRoZSBnaXZlbiBzY2FsZSB0aW1lIGBvcHRpb25zYC5cbiAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUobWluLCBtYXgsIG1pbm9yLCBtYWpvciwgY2FwYWNpdHksIG9wdGlvbnMpIHtcblx0dmFyIHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuXHR2YXIgc3RlcFNpemUgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KHRpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUpO1xuXHR2YXIgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG5cdHZhciBtYWpvclRpY2tzRW5hYmxlZCA9IG9wdGlvbnMudGlja3MubWFqb3IuZW5hYmxlZDtcblx0dmFyIGludGVydmFsID0gSU5URVJWQUxTW21pbm9yXTtcblx0dmFyIGZpcnN0ID0gbW9tZW50KG1pbik7XG5cdHZhciBsYXN0ID0gbW9tZW50KG1heCk7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHR2YXIgdGltZTtcblxuXHRpZiAoIXN0ZXBTaXplKSB7XG5cdFx0c3RlcFNpemUgPSBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgbWlub3IsIGNhcGFjaXR5KTtcblx0fVxuXG5cdC8vIEZvciAnd2VlaycgdW5pdCwgaGFuZGxlIHRoZSBmaXJzdCBkYXkgb2Ygd2VlayBvcHRpb25cblx0aWYgKHdlZWtkYXkpIHtcblx0XHRmaXJzdCA9IGZpcnN0Lmlzb1dlZWtkYXkod2Vla2RheSk7XG5cdFx0bGFzdCA9IGxhc3QuaXNvV2Vla2RheSh3ZWVrZGF5KTtcblx0fVxuXG5cdC8vIEFsaWduIGZpcnN0L2xhc3QgdGlja3Mgb24gdW5pdFxuXHRmaXJzdCA9IGZpcnN0LnN0YXJ0T2Yod2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXHRsYXN0ID0gbGFzdC5zdGFydE9mKHdlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgbGFzdCB0aWNrIGluY2x1ZGUgbWF4XG5cdGlmIChsYXN0IDwgbWF4KSB7XG5cdFx0bGFzdC5hZGQoMSwgbWlub3IpO1xuXHR9XG5cblx0dGltZSA9IG1vbWVudChmaXJzdCk7XG5cblx0aWYgKG1ham9yVGlja3NFbmFibGVkICYmIG1ham9yICYmICF3ZWVrZGF5ICYmICF0aW1lT3B0cy5yb3VuZCkge1xuXHRcdC8vIEFsaWduIHRoZSBmaXJzdCB0aWNrIG9uIHRoZSBwcmV2aW91cyBgbWlub3JgIHVuaXQgYWxpZ25lZCBvbiB0aGUgYG1ham9yYCB1bml0OlxuXHRcdC8vIHdlIGZpcnN0IGFsaWduZWQgdGltZSBvbiB0aGUgcHJldmlvdXMgYG1ham9yYCB1bml0IHRoZW4gYWRkIHRoZSBudW1iZXIgb2YgZnVsbFxuXHRcdC8vIHN0ZXBTaXplIHRoZXJlIGlzIGJldHdlZW4gZmlyc3QgYW5kIHRoZSBwcmV2aW91cyBtYWpvciB0aW1lLlxuXHRcdHRpbWUuc3RhcnRPZihtYWpvcik7XG5cdFx0dGltZS5hZGQofn4oKGZpcnN0IC0gdGltZSkgLyAoaW50ZXJ2YWwuc2l6ZSAqIHN0ZXBTaXplKSkgKiBzdGVwU2l6ZSwgbWlub3IpO1xuXHR9XG5cblx0Zm9yICg7IHRpbWUgPCBsYXN0OyB0aW1lLmFkZChzdGVwU2l6ZSwgbWlub3IpKSB7XG5cdFx0dGlja3MucHVzaCgrdGltZSk7XG5cdH1cblxuXHR0aWNrcy5wdXNoKCt0aW1lKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmlnaHQgYW5kIGxlZnQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtsZWZ0LCByaWdodH0uXG4gKiBPZmZzZXRzIGFyZSBhZGRlZCB3aGVuIHRoZSBgb2Zmc2V0YCBvcHRpb24gaXMgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU9mZnNldHModGFibGUsIHRpY2tzLCBtaW4sIG1heCwgb3B0aW9ucykge1xuXHR2YXIgbGVmdCA9IDA7XG5cdHZhciByaWdodCA9IDA7XG5cdHZhciB1cHBlciwgbG93ZXI7XG5cblx0aWYgKG9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdGlmICghb3B0aW9ucy50aW1lLm1pbikge1xuXHRcdFx0dXBwZXIgPSB0aWNrcy5sZW5ndGggPiAxID8gdGlja3NbMV0gOiBtYXg7XG5cdFx0XHRsb3dlciA9IHRpY2tzWzBdO1xuXHRcdFx0bGVmdCA9IChcblx0XHRcdFx0aW50ZXJwb2xhdGUodGFibGUsICd0aW1lJywgdXBwZXIsICdwb3MnKSAtXG5cdFx0XHRcdGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIGxvd2VyLCAncG9zJylcblx0XHRcdCkgLyAyO1xuXHRcdH1cblx0XHRpZiAoIW9wdGlvbnMudGltZS5tYXgpIHtcblx0XHRcdHVwcGVyID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV07XG5cdFx0XHRsb3dlciA9IHRpY2tzLmxlbmd0aCA+IDEgPyB0aWNrc1t0aWNrcy5sZW5ndGggLSAyXSA6IG1pbjtcblx0XHRcdHJpZ2h0ID0gKFxuXHRcdFx0XHRpbnRlcnBvbGF0ZSh0YWJsZSwgJ3RpbWUnLCB1cHBlciwgJ3BvcycpIC1cblx0XHRcdFx0aW50ZXJwb2xhdGUodGFibGUsICd0aW1lJywgbG93ZXIsICdwb3MnKVxuXHRcdFx0KSAvIDI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHR9O1xufVxuXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHZhbHVlcywgbWFqb3JVbml0KSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHR2YXIgaSwgaWxlbiwgdmFsdWUsIG1ham9yO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZXNbaV07XG5cdFx0bWFqb3IgPSBtYWpvclVuaXQgPyB2YWx1ZSA9PT0gK21vbWVudCh2YWx1ZSkuc3RhcnRPZihtYWpvclVuaXQpIDogZmFsc2U7XG5cblx0XHR0aWNrcy5wdXNoKHtcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdG1ham9yOiBtYWpvclxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGRlZmF1bHRDb25maWcgPSB7XG5cdFx0cG9zaXRpb246ICdib3R0b20nLFxuXG5cdFx0LyoqXG5cdFx0ICogRGF0YSBkaXN0cmlidXRpb24gYWxvbmcgdGhlIHNjYWxlOlxuXHRcdCAqIC0gJ2xpbmVhcic6IGRhdGEgYXJlIHNwcmVhZCBhY2NvcmRpbmcgdG8gdGhlaXIgdGltZSAoZGlzdGFuY2VzIGNhbiB2YXJ5KSxcblx0XHQgKiAtICdzZXJpZXMnOiBkYXRhIGFyZSBzcHJlYWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLlxuXHRcdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG5cdFx0ICogQHNpbmNlIDIuNy4wXG5cdFx0ICovXG5cdFx0ZGlzdHJpYnV0aW9uOiAnbGluZWFyJyxcblxuXHRcdC8qKlxuXHRcdCAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcblx0XHQgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcblx0XHQgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcblx0XHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuXHRcdCAqIEBzaW5jZSAyLjcuMFxuXHRcdCAqL1xuXHRcdGJvdW5kczogJ2RhdGEnLFxuXG5cdFx0dGltZToge1xuXHRcdFx0cGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC8gb3IgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gYSBtb21lbnRcblx0XHRcdGZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURUQgZmFsc2UgPT0gZGF0ZSBvYmplY3RzLCBtb21lbnQgb2JqZWN0LCBjYWxsYmFjayBvciBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cDovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0L1xuXHRcdFx0dW5pdDogZmFsc2UsIC8vIGZhbHNlID09IGF1dG9tYXRpYyBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG5cdFx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRcdGRpc3BsYXlGb3JtYXQ6IGZhbHNlLCAvLyBERVBSRUNBVEVEXG5cdFx0XHRpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXkgLSBzZWUgaHR0cDovL21vbWVudGpzLmNvbS9kb2NzLyMvZ2V0LXNldC9pc28td2Vla2RheS9cblx0XHRcdG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG5cblx0XHRcdC8vIGRlZmF1bHRzIHRvIHVuaXQncyBjb3JyZXNwb25kaW5nIHVuaXRGb3JtYXQgYmVsb3cgb3Igb3ZlcnJpZGUgdXNpbmcgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9kaXNwbGF5aW5nL2Zvcm1hdC9cblx0XHRcdGRpc3BsYXlGb3JtYXRzOiB7XG5cdFx0XHRcdG1pbGxpc2Vjb25kOiAnaDptbTpzcy5TU1MgYScsIC8vIDExOjIwOjAxLjEyMyBBTSxcblx0XHRcdFx0c2Vjb25kOiAnaDptbTpzcyBhJywgLy8gMTE6MjA6MDEgQU1cblx0XHRcdFx0bWludXRlOiAnaDptbSBhJywgLy8gMTE6MjAgQU1cblx0XHRcdFx0aG91cjogJ2hBJywgLy8gNVBNXG5cdFx0XHRcdGRheTogJ01NTSBEJywgLy8gU2VwIDRcblx0XHRcdFx0d2VlazogJ2xsJywgLy8gV2VlayA0Niwgb3IgbWF5YmUgXCJbV11XVyAtIFlZWVlcIiA/XG5cdFx0XHRcdG1vbnRoOiAnTU1NIFlZWVknLCAvLyBTZXB0IDIwMTVcblx0XHRcdFx0cXVhcnRlcjogJ1tRXVEgLSBZWVlZJywgLy8gUTNcblx0XHRcdFx0eWVhcjogJ1lZWVknIC8vIDIwMTVcblx0XHRcdH0sXG5cdFx0fSxcblx0XHR0aWNrczoge1xuXHRcdFx0YXV0b1NraXA6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuXHRcdFx0ICogLSAnYXV0byc6IGdlbmVyYXRlcyBcIm9wdGltYWxcIiB0aWNrcyBiYXNlZCBvbiBzY2FsZSBzaXplIGFuZCB0aW1lIG9wdGlvbnMuXG5cdFx0XHQgKiAtICdkYXRhJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gZGF0YSAoaW5jbHVkaW5nIGxhYmVscyBmcm9tIGRhdGEge3R8eHx5fSBvYmplY3RzKS5cblx0XHRcdCAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cblx0XHRcdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG5cdFx0XHQgKiBAc2luY2UgMi43LjBcblx0XHRcdCAqL1xuXHRcdFx0c291cmNlOiAnYXV0bycsXG5cblx0XHRcdG1ham9yOiB7XG5cdFx0XHRcdGVuYWJsZWQ6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBUaW1lU2NhbGUgPSBDaGFydC5TY2FsZS5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFtb21lbnQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDaGFydC5qcyAtIE1vbWVudC5qcyBjb3VsZCBub3QgYmUgZm91bmQhIFlvdSBtdXN0IGluY2x1ZGUgaXQgYmVmb3JlIENoYXJ0LmpzIHRvIHVzZSB0aGUgdGltZSBzY2FsZS4gRG93bmxvYWQgYXQgaHR0cHM6Ly9tb21lbnRqcy5jb20nKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXG5cdFx0XHRDaGFydC5TY2FsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblxuXHRcdFx0Ly8gREVQUkVDQVRJT05TOiBvdXRwdXQgYSBtZXNzYWdlIG9ubHkgb25lIHRpbWUgcGVyIHVwZGF0ZVxuXHRcdFx0aWYgKG9wdGlvbnMudGltZSAmJiBvcHRpb25zLnRpbWUuZm9ybWF0KSB7XG5cdFx0XHRcdGNvbnNvbGUud2Fybignb3B0aW9ucy50aW1lLmZvcm1hdCBpcyBkZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBvcHRpb25zLnRpbWUucGFyc2VyLicpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gQ2hhcnQuU2NhbGUucHJvdG90eXBlLnVwZGF0ZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIGRhdGEgdG8gYmUgcmVmZXJlbmNlZCB2aWEgJ3QnIGF0dHJpYnV0ZVxuXHRcdCAqL1xuXHRcdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0XHRpZiAocmF3VmFsdWUgJiYgcmF3VmFsdWUudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJhd1ZhbHVlID0gcmF3VmFsdWUudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBDaGFydC5TY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHJhd1ZhbHVlKTtcblx0XHR9LFxuXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG5cdFx0XHR2YXIgbWluID0gcGFyc2UodGltZU9wdHMubWluLCBtZSkgfHwgTUFYX0lOVEVHRVI7XG5cdFx0XHR2YXIgbWF4ID0gcGFyc2UodGltZU9wdHMubWF4LCBtZSkgfHwgTUlOX0lOVEVHRVI7XG5cdFx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdFx0dmFyIGRhdGFzZXRzID0gW107XG5cdFx0XHR2YXIgbGFiZWxzID0gW107XG5cdFx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGxhYmVscyB0byB0aW1lc3RhbXBzXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGxhYmVscy5wdXNoKHBhcnNlKGNoYXJ0LmRhdGEubGFiZWxzW2ldLCBtZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IGRhdGEgdG8gdGltZXN0YW1wc1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRkYXRhID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5kYXRhO1xuXG5cdFx0XHRcdFx0Ly8gTGV0J3MgY29uc2lkZXIgdGhhdCBhbGwgZGF0YSBoYXZlIHRoZSBzYW1lIGZvcm1hdC5cblx0XHRcdFx0XHRpZiAoaGVscGVycy5pc09iamVjdChkYXRhWzBdKSkge1xuXHRcdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdFx0XHRcdHRpbWVzdGFtcCA9IHBhcnNlKGRhdGFbal0sIG1lKTtcblx0XHRcdFx0XHRcdFx0dGltZXN0YW1wcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHRcdFx0XHRcdGRhdGFzZXRzW2ldW2pdID0gdGltZXN0YW1wO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXBzLnB1c2guYXBwbHkodGltZXN0YW1wcywgbGFiZWxzKTtcblx0XHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gbGFiZWxzLnNsaWNlKDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsYWJlbHMubGVuZ3RoKSB7XG5cdFx0XHRcdC8vIFNvcnQgbGFiZWxzICoqYWZ0ZXIqKiBkYXRhIGhhdmUgYmVlbiBjb252ZXJ0ZWRcblx0XHRcdFx0bGFiZWxzID0gYXJyYXlVbmlxdWUobGFiZWxzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKG1pbiwgbGFiZWxzWzBdKTtcblx0XHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0XHRcdHRpbWVzdGFtcHMgPSBhcnJheVVuaXF1ZSh0aW1lc3RhbXBzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKG1pbiwgdGltZXN0YW1wc1swXSk7XG5cdFx0XHRcdG1heCA9IE1hdGgubWF4KG1heCwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW4gY2FzZSB0aGVyZSBpcyBubyB2YWxpZCBtaW4vbWF4LCBsZXQncyB1c2UgdG9kYXkgbGltaXRzXG5cdFx0XHRtaW4gPSBtaW4gPT09IE1BWF9JTlRFR0VSID8gK21vbWVudCgpLnN0YXJ0T2YoJ2RheScpIDogbWluO1xuXHRcdFx0bWF4ID0gbWF4ID09PSBNSU5fSU5URUdFUiA/ICttb21lbnQoKS5lbmRPZignZGF5JykgKyAxIDogbWF4O1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgbG9va3VwIHRhYmxlKVxuXHRcdFx0bWUubWluID0gTWF0aC5taW4obWluLCBtYXgpO1xuXHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcblxuXHRcdFx0Ly8gUFJJVkFURVxuXHRcdFx0bWUuX2hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdG1lLl90YWJsZSA9IFtdO1xuXHRcdFx0bWUuX3RpbWVzdGFtcHMgPSB7XG5cdFx0XHRcdGRhdGE6IHRpbWVzdGFtcHMsXG5cdFx0XHRcdGRhdGFzZXRzOiBkYXRhc2V0cyxcblx0XHRcdFx0bGFiZWxzOiBsYWJlbHNcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuXHRcdFx0dmFyIGZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcblx0XHRcdHZhciBjYXBhY2l0eSA9IG1lLmdldExhYmVsQ2FwYWNpdHkobWluKTtcblx0XHRcdHZhciB1bml0ID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0KHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSk7XG5cdFx0XHR2YXIgbWFqb3JVbml0ID0gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpO1xuXHRcdFx0dmFyIHRpbWVzdGFtcHMgPSBbXTtcblx0XHRcdHZhciB0aWNrcyA9IFtdO1xuXHRcdFx0dmFyIGksIGlsZW4sIHRpbWVzdGFtcDtcblxuXHRcdFx0c3dpdGNoIChvcHRpb25zLnRpY2tzLnNvdXJjZSkge1xuXHRcdFx0Y2FzZSAnZGF0YSc6XG5cdFx0XHRcdHRpbWVzdGFtcHMgPSBtZS5fdGltZXN0YW1wcy5kYXRhO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2xhYmVscyc6XG5cdFx0XHRcdHRpbWVzdGFtcHMgPSBtZS5fdGltZXN0YW1wcy5sYWJlbHM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYXV0byc6XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aW1lc3RhbXBzID0gZ2VuZXJhdGUobWluLCBtYXgsIHVuaXQsIG1ham9yVW5pdCwgY2FwYWNpdHksIG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdFx0bWluID0gdGltZXN0YW1wc1swXTtcblx0XHRcdFx0bWF4ID0gdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbmZvcmNlIGxpbWl0cyB3aXRoIHVzZXIgbWluL21heCBvcHRpb25zXG5cdFx0XHRtaW4gPSBwYXJzZSh0aW1lT3B0cy5taW4sIG1lKSB8fCBtaW47XG5cdFx0XHRtYXggPSBwYXJzZSh0aW1lT3B0cy5tYXgsIG1lKSB8fCBtYXg7XG5cblx0XHRcdC8vIFJlbW92ZSB0aWNrcyBvdXRzaWRlIHRoZSBtaW4vbWF4IHJhbmdlXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0dGltZXN0YW1wID0gdGltZXN0YW1wc1tpXTtcblx0XHRcdFx0aWYgKHRpbWVzdGFtcCA+PSBtaW4gJiYgdGltZXN0YW1wIDw9IG1heCkge1xuXHRcdFx0XHRcdHRpY2tzLnB1c2godGltZXN0YW1wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRtZS5taW4gPSBtaW47XG5cdFx0XHRtZS5tYXggPSBtYXg7XG5cblx0XHRcdC8vIFBSSVZBVEVcblx0XHRcdG1lLl91bml0ID0gdW5pdDtcblx0XHRcdG1lLl9tYWpvclVuaXQgPSBtYWpvclVuaXQ7XG5cdFx0XHRtZS5fbWlub3JGb3JtYXQgPSBmb3JtYXRzW3VuaXRdO1xuXHRcdFx0bWUuX21ham9yRm9ybWF0ID0gZm9ybWF0c1ttYWpvclVuaXRdO1xuXHRcdFx0bWUuX3RhYmxlID0gYnVpbGRMb29rdXBUYWJsZShtZS5fdGltZXN0YW1wcy5kYXRhLCBtaW4sIG1heCwgb3B0aW9ucy5kaXN0cmlidXRpb24pO1xuXHRcdFx0bWUuX29mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyhtZS5fdGFibGUsIHRpY2tzLCBtaW4sIG1heCwgb3B0aW9ucyk7XG5cblx0XHRcdHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRpY2tzLCBtYWpvclVuaXQpO1xuXHRcdH0sXG5cblx0XHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGRhdGEgPSBtZS5jaGFydC5kYXRhO1xuXHRcdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdFx0dmFyIGxhYmVsID0gZGF0YS5sYWJlbHMgJiYgaW5kZXggPCBkYXRhLmxhYmVscy5sZW5ndGggPyBkYXRhLmxhYmVsc1tpbmRleF0gOiAnJztcblx0XHRcdHZhciB2YWx1ZSA9IGRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XTtcblxuXHRcdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHRcdGxhYmVsID0gbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuXHRcdFx0XHRsYWJlbCA9IG1vbWVudGlmeShsYWJlbCwgdGltZU9wdHMpLmZvcm1hdCh0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGdW5jdGlvbiB0byBmb3JtYXQgYW4gaW5kaXZpZHVhbCB0aWNrIG1hcmtcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRpY2tGb3JtYXRGdW5jdGlvbjogZnVuY3Rpb24odGljaywgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpbWUgPSB0aWNrLnZhbHVlT2YoKTtcblx0XHRcdHZhciBtYWpvclVuaXQgPSBtZS5fbWFqb3JVbml0O1xuXHRcdFx0dmFyIG1ham9yRm9ybWF0ID0gbWUuX21ham9yRm9ybWF0O1xuXHRcdFx0dmFyIG1ham9yVGltZSA9IHRpY2suY2xvbmUoKS5zdGFydE9mKG1lLl9tYWpvclVuaXQpLnZhbHVlT2YoKTtcblx0XHRcdHZhciBtYWpvclRpY2tPcHRzID0gb3B0aW9ucy50aWNrcy5tYWpvcjtcblx0XHRcdHZhciBtYWpvciA9IG1ham9yVGlja09wdHMuZW5hYmxlZCAmJiBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGltZSA9PT0gbWFqb3JUaW1lO1xuXHRcdFx0dmFyIGxhYmVsID0gdGljay5mb3JtYXQobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1lLl9taW5vckZvcm1hdCk7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBtYWpvciA/IG1ham9yVGlja09wdHMgOiBvcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdFx0dmFyIGZvcm1hdHRlciA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodGlja09wdHMuY2FsbGJhY2ssIHRpY2tPcHRzLnVzZXJDYWxsYmFjayk7XG5cblx0XHRcdHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIobGFiZWwsIGluZGV4LCB0aWNrcykgOiBsYWJlbDtcblx0XHR9LFxuXG5cdFx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0XHR2YXIgbGFiZWxzID0gW107XG5cdFx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRsYWJlbHMucHVzaCh0aGlzLnRpY2tGb3JtYXRGdW5jdGlvbihtb21lbnQodGlja3NbaV0udmFsdWUpLCBpLCB0aWNrcykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGFiZWxzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldFBpeGVsRm9yT2Zmc2V0OiBmdW5jdGlvbih0aW1lKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdFx0dmFyIHN0YXJ0ID0gbWUuX2hvcml6b250YWwgPyBtZS5sZWZ0IDogbWUudG9wO1xuXHRcdFx0dmFyIHBvcyA9IGludGVycG9sYXRlKG1lLl90YWJsZSwgJ3RpbWUnLCB0aW1lLCAncG9zJyk7XG5cblx0XHRcdHJldHVybiBzdGFydCArIHNpemUgKiAobWUuX29mZnNldHMubGVmdCArIHBvcykgLyAobWUuX29mZnNldHMubGVmdCArIDEgKyBtZS5fb2Zmc2V0cy5yaWdodCk7XG5cdFx0fSxcblxuXHRcdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHRpbWUgPSBudWxsO1xuXG5cdFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aW1lID0gbWUuX3RpbWVzdGFtcHMuZGF0YXNldHNbZGF0YXNldEluZGV4XVtpbmRleF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aW1lID09PSBudWxsKSB7XG5cdFx0XHRcdHRpbWUgPSBwYXJzZSh2YWx1ZSwgbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGltZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JPZmZzZXQodGltZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblx0XHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoID9cblx0XHRcdFx0dGhpcy5nZXRQaXhlbEZvck9mZnNldCh0aWNrc1tpbmRleF0udmFsdWUpIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9LFxuXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc2l6ZSA9IG1lLl9ob3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0XHR2YXIgc3RhcnQgPSBtZS5faG9yaXpvbnRhbCA/IG1lLmxlZnQgOiBtZS50b3A7XG5cdFx0XHR2YXIgcG9zID0gKHNpemUgPyAocGl4ZWwgLSBzdGFydCkgLyBzaXplIDogMCkgKiAobWUuX29mZnNldHMubGVmdCArIDEgKyBtZS5fb2Zmc2V0cy5sZWZ0KSAtIG1lLl9vZmZzZXRzLnJpZ2h0O1xuXHRcdFx0dmFyIHRpbWUgPSBpbnRlcnBvbGF0ZShtZS5fdGFibGUsICdwb3MnLCBwb3MsICd0aW1lJyk7XG5cblx0XHRcdHJldHVybiBtb21lbnQodGltZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHRpY2tzT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuXHRcdFx0dmFyIGFuZ2xlID0gaGVscGVycy50b1JhZGlhbnModGlja3NPcHRzLm1heFJvdGF0aW9uKTtcblx0XHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdHZhciB0aWNrRm9udFNpemUgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KHRpY2tzT3B0cy5mb250U2l6ZSwgZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cblx0XHRcdHJldHVybiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldExhYmVsQ2FwYWNpdHk6IGZ1bmN0aW9uKGV4YW1wbGVUaW1lKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRtZS5fbWlub3JGb3JtYXQgPSBtZS5vcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XHQvLyBQaWNrIHRoZSBsb25nZXN0IGZvcm1hdCBmb3IgZ3Vlc3RpbWF0aW9uXG5cblx0XHRcdHZhciBleGFtcGxlTGFiZWwgPSBtZS50aWNrRm9ybWF0RnVuY3Rpb24obW9tZW50KGV4YW1wbGVUaW1lKSwgMCwgW10pO1xuXHRcdFx0dmFyIHRpY2tMYWJlbFdpZHRoID0gbWUuZ2V0TGFiZWxXaWR0aChleGFtcGxlTGFiZWwpO1xuXHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihpbm5lcldpZHRoIC8gdGlja0xhYmVsV2lkdGgpO1xuXHRcdH1cblx0fSk7XG5cblx0Q2hhcnQuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKCd0aW1lJywgVGltZVNjYWxlLCBkZWZhdWx0Q29uZmlnKTtcbn07XG5cbn0se1wiMVwiOjEsXCIyNVwiOjI1LFwiNDVcIjo0NX1dfSx7fSxbN10pKDcpXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvZnJvbnRlbmQvanMvdmVuZG9yL2NoYXJ0LmpzIiwiLypcblR1cmJvbGlua3MgNS4xLjFcbkNvcHlyaWdodCDCqSAyMDE4IEJhc2VjYW1wLCBMTENcbiAqL1xuKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpczsoZnVuY3Rpb24oKXsoZnVuY3Rpb24oKXt0aGlzLlR1cmJvbGlua3M9e3N1cHBvcnRlZDpmdW5jdGlvbigpe3JldHVybiBudWxsIT13aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUmJm51bGwhPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJm51bGwhPXdpbmRvdy5hZGRFdmVudExpc3RlbmVyfSgpLHZpc2l0OmZ1bmN0aW9uKHQscil7cmV0dXJuIGUuY29udHJvbGxlci52aXNpdCh0LHIpfSxjbGVhckNhY2hlOmZ1bmN0aW9uKCl7cmV0dXJuIGUuY29udHJvbGxlci5jbGVhckNhY2hlKCl9LHNldFByb2dyZXNzQmFyRGVsYXk6ZnVuY3Rpb24odCl7cmV0dXJuIGUuY29udHJvbGxlci5zZXRQcm9ncmVzc0JhckRlbGF5KHQpfX19KS5jYWxsKHRoaXMpfSkuY2FsbCh0KTt2YXIgZT10LlR1cmJvbGlua3M7KGZ1bmN0aW9uKCl7KGZ1bmN0aW9uKCl7dmFyIHQscixuLG89W10uc2xpY2U7ZS5jb3B5T2JqZWN0PWZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtyPXt9O2ZvcihlIGluIHQpbj10W2VdLHJbZV09bjtyZXR1cm4gcn0sZS5jbG9zZXN0PWZ1bmN0aW9uKGUscil7cmV0dXJuIHQuY2FsbChlLHIpfSx0PWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gdD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsbnVsbCE9KGU9dC5jbG9zZXN0KT9lOmZ1bmN0aW9uKHQpe3ZhciBlO2ZvcihlPXRoaXM7ZTspe2lmKGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmci5jYWxsKGUsdCkpcmV0dXJuIGU7ZT1lLnBhcmVudE5vZGV9fX0oKSxlLmRlZmVyPWZ1bmN0aW9uKHQpe3JldHVybiBzZXRUaW1lb3V0KHQsMSl9LGUudGhyb3R0bGU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9bnVsbCxmdW5jdGlvbigpe3ZhciByO3JldHVybiByPTE8PWFyZ3VtZW50cy5sZW5ndGg/by5jYWxsKGFyZ3VtZW50cywwKTpbXSxudWxsIT1lP2U6ZT1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGU9bnVsbCx0LmFwcGx5KG4scil9fSh0aGlzKSl9fSxlLmRpc3BhdGNoPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbyxpLHMsYSx1O3JldHVybiBhPW51bGwhPWU/ZTp7fSx1PWEudGFyZ2V0LHI9YS5jYW5jZWxhYmxlLG89YS5kYXRhLGk9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudHNcIiksaS5pbml0RXZlbnQodCwhMCxyPT09ITApLGkuZGF0YT1udWxsIT1vP286e30saS5jYW5jZWxhYmxlJiYhbiYmKHM9aS5wcmV2ZW50RGVmYXVsdCxpLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZHx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJkZWZhdWx0UHJldmVudGVkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiEwfX0pLHMuY2FsbCh0aGlzKX0pLChudWxsIT11P3U6ZG9jdW1lbnQpLmRpc3BhdGNoRXZlbnQoaSksaX0sbj1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0PWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpLHQuaW5pdEV2ZW50KFwidGVzdFwiLCEwLCEwKSx0LnByZXZlbnREZWZhdWx0KCksdC5kZWZhdWx0UHJldmVudGVkfSgpLGUubWF0Y2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5jYWxsKHQsZSl9LHI9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbjtyZXR1cm4gdD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsbnVsbCE9KGU9bnVsbCE9KHI9bnVsbCE9KG49dC5tYXRjaGVzU2VsZWN0b3IpP246dC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpP3I6dC5tc01hdGNoZXNTZWxlY3Rvcik/ZTp0Lm1vek1hdGNoZXNTZWxlY3Rvcn0oKSxlLnV1aWQ9ZnVuY3Rpb24oKXt2YXIgdCxlLHI7Zm9yKHI9XCJcIix0PWU9MTszNj49ZTt0PSsrZSlyKz05PT09dHx8MTQ9PT10fHwxOT09PXR8fDI0PT09dD9cIi1cIjoxNT09PXQ/XCI0XCI6MjA9PT10PyhNYXRoLmZsb29yKDQqTWF0aC5yYW5kb20oKSkrOCkudG9TdHJpbmcoMTYpOk1hdGguZmxvb3IoMTUqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO3JldHVybiByfX0pLmNhbGwodGhpcyksZnVuY3Rpb24oKXtlLkxvY2F0aW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgZSxyO251bGw9PXQmJih0PVwiXCIpLHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIiksci5ocmVmPXQudG9TdHJpbmcoKSx0aGlzLmFic29sdXRlVVJMPXIuaHJlZixlPXIuaGFzaC5sZW5ndGgsMj5lP3RoaXMucmVxdWVzdFVSTD10aGlzLmFic29sdXRlVVJMOih0aGlzLnJlcXVlc3RVUkw9dGhpcy5hYnNvbHV0ZVVSTC5zbGljZSgwLC1lKSx0aGlzLmFuY2hvcj1yLmhhc2guc2xpY2UoMSkpfXZhciBlLHIsbixvO3JldHVybiB0LndyYXA9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzP3Q6bmV3IHRoaXModCl9LHQucHJvdG90eXBlLmdldE9yaWdpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFic29sdXRlVVJMLnNwbGl0KFwiL1wiLDMpLmpvaW4oXCIvXCIpfSx0LnByb3RvdHlwZS5nZXRQYXRoPWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gbnVsbCE9KHQ9bnVsbCE9KGU9dGhpcy5yZXF1ZXN0VVJMLm1hdGNoKC9cXC9cXC9bXlxcL10qKFxcL1tePztdKikvKSk/ZVsxXTp2b2lkIDApP3Q6XCIvXCJ9LHQucHJvdG90eXBlLmdldFBhdGhDb21wb25lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UGF0aCgpLnNwbGl0KFwiL1wiKS5zbGljZSgxKX0sdC5wcm90b3R5cGUuZ2V0TGFzdFBhdGhDb21wb25lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRQYXRoQ29tcG9uZW50cygpLnNsaWNlKC0xKVswXX0sdC5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uPWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gbnVsbCE9KHQ9bnVsbCE9KGU9dGhpcy5nZXRMYXN0UGF0aENvbXBvbmVudCgpLm1hdGNoKC9cXC5bXi5dKiQvKSk/ZVswXTp2b2lkIDApP3Q6XCJcIn0sdC5wcm90b3R5cGUuaXNIVE1MPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZW5zaW9uKCkubWF0Y2goL14oPzp8XFwuKD86aHRtfGh0bWx8eGh0bWwpKSQvKX0sdC5wcm90b3R5cGUuaXNQcmVmaXhlZEJ5PWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXIodCksdGhpcy5pc0VxdWFsVG8odCl8fG8odGhpcy5hYnNvbHV0ZVVSTCxlKX0sdC5wcm90b3R5cGUuaXNFcXVhbFRvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFic29sdXRlVVJMPT09KG51bGwhPXQ/dC5hYnNvbHV0ZVVSTDp2b2lkIDApfSx0LnByb3RvdHlwZS50b0NhY2hlS2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdFVSTH0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWJzb2x1dGVVUkx9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWJzb2x1dGVVUkx9LHQucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hYnNvbHV0ZVVSTH0scj1mdW5jdGlvbih0KXtyZXR1cm4gZSh0LmdldE9yaWdpbigpK3QuZ2V0UGF0aCgpKX0sZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0LFwiL1wiKT90OnQrXCIvXCJ9LG89ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5zbGljZSgwLGUubGVuZ3RoKT09PWV9LG49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5zbGljZSgtZS5sZW5ndGgpPT09ZX0sdH0oKX0uY2FsbCh0aGlzKSxmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX07ZS5IdHRwUmVxdWVzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHIocixuLG8pe3RoaXMuZGVsZWdhdGU9cix0aGlzLnJlcXVlc3RDYW5jZWxlZD10KHRoaXMucmVxdWVzdENhbmNlbGVkLHRoaXMpLHRoaXMucmVxdWVzdFRpbWVkT3V0PXQodGhpcy5yZXF1ZXN0VGltZWRPdXQsdGhpcyksdGhpcy5yZXF1ZXN0RmFpbGVkPXQodGhpcy5yZXF1ZXN0RmFpbGVkLHRoaXMpLHRoaXMucmVxdWVzdExvYWRlZD10KHRoaXMucmVxdWVzdExvYWRlZCx0aGlzKSx0aGlzLnJlcXVlc3RQcm9ncmVzc2VkPXQodGhpcy5yZXF1ZXN0UHJvZ3Jlc3NlZCx0aGlzKSx0aGlzLnVybD1lLkxvY2F0aW9uLndyYXAobikucmVxdWVzdFVSTCx0aGlzLnJlZmVycmVyPWUuTG9jYXRpb24ud3JhcChvKS5hYnNvbHV0ZVVSTCx0aGlzLmNyZWF0ZVhIUigpfXJldHVybiByLk5FVFdPUktfRkFJTFVSRT0wLHIuVElNRU9VVF9GQUlMVVJFPS0xLHIudGltZW91dD02MCxyLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHRoaXMueGhyJiYhdGhpcy5zZW50Pyh0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQmVmb3JlUmVxdWVzdFN0YXJ0KCksdGhpcy5zZXRQcm9ncmVzcygwKSx0aGlzLnhoci5zZW5kKCksdGhpcy5zZW50PSEwLFwiZnVuY3Rpb25cIj09dHlwZW9mKHQ9dGhpcy5kZWxlZ2F0ZSkucmVxdWVzdFN0YXJ0ZWQ/dC5yZXF1ZXN0U3RhcnRlZCgpOnZvaWQgMCk6dm9pZCAwfSxyLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54aHImJnRoaXMuc2VudD90aGlzLnhoci5hYm9ydCgpOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdFByb2dyZXNzZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoQ29tcHV0YWJsZT90aGlzLnNldFByb2dyZXNzKHQubG9hZGVkL3QudG90YWwpOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdExvYWRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZFJlcXVlc3QoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIDIwMDw9KGU9dC54aHIuc3RhdHVzKSYmMzAwPmU/dC5kZWxlZ2F0ZS5yZXF1ZXN0Q29tcGxldGVkV2l0aFJlc3BvbnNlKHQueGhyLnJlc3BvbnNlVGV4dCx0Lnhoci5nZXRSZXNwb25zZUhlYWRlcihcIlR1cmJvbGlua3MtTG9jYXRpb25cIikpOih0LmZhaWxlZD0hMCx0LmRlbGVnYXRlLnJlcXVlc3RGYWlsZWRXaXRoU3RhdHVzQ29kZSh0Lnhoci5zdGF0dXMsdC54aHIucmVzcG9uc2VUZXh0KSl9fSh0aGlzKSl9LHIucHJvdG90eXBlLnJlcXVlc3RGYWlsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmRSZXF1ZXN0KGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmZhaWxlZD0hMCx0LmRlbGVnYXRlLnJlcXVlc3RGYWlsZWRXaXRoU3RhdHVzQ29kZSh0LmNvbnN0cnVjdG9yLk5FVFdPUktfRkFJTFVSRSl9fSh0aGlzKSl9LHIucHJvdG90eXBlLnJlcXVlc3RUaW1lZE91dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZFJlcXVlc3QoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuZmFpbGVkPSEwLHQuZGVsZWdhdGUucmVxdWVzdEZhaWxlZFdpdGhTdGF0dXNDb2RlKHQuY29uc3RydWN0b3IuVElNRU9VVF9GQUlMVVJFKX19KHRoaXMpKX0sci5wcm90b3R5cGUucmVxdWVzdENhbmNlbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kUmVxdWVzdCgpfSxyLnByb3RvdHlwZS5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZVJlcXVlc3RTdGFydD1mdW5jdGlvbigpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpyZXF1ZXN0LXN0YXJ0XCIse2RhdGE6e3VybDp0aGlzLnVybCx4aHI6dGhpcy54aHJ9fSl9LHIucHJvdG90eXBlLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJSZXF1ZXN0RW5kPWZ1bmN0aW9uKCl7cmV0dXJuIGUuZGlzcGF0Y2goXCJ0dXJib2xpbmtzOnJlcXVlc3QtZW5kXCIse2RhdGE6e3VybDp0aGlzLnVybCx4aHI6dGhpcy54aHJ9fSl9LHIucHJvdG90eXBlLmNyZWF0ZVhIUj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnhocj1uZXcgWE1MSHR0cFJlcXVlc3QsdGhpcy54aHIub3BlbihcIkdFVFwiLHRoaXMudXJsLCEwKSx0aGlzLnhoci50aW1lb3V0PTFlMyp0aGlzLmNvbnN0cnVjdG9yLnRpbWVvdXQsdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLFwidGV4dC9odG1sLCBhcHBsaWNhdGlvbi94aHRtbCt4bWxcIiksdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihcIlR1cmJvbGlua3MtUmVmZXJyZXJcIix0aGlzLnJlZmVycmVyKSx0aGlzLnhoci5vbnByb2dyZXNzPXRoaXMucmVxdWVzdFByb2dyZXNzZWQsdGhpcy54aHIub25sb2FkPXRoaXMucmVxdWVzdExvYWRlZCx0aGlzLnhoci5vbmVycm9yPXRoaXMucmVxdWVzdEZhaWxlZCx0aGlzLnhoci5vbnRpbWVvdXQ9dGhpcy5yZXF1ZXN0VGltZWRPdXQsdGhpcy54aHIub25hYm9ydD10aGlzLnJlcXVlc3RDYW5jZWxlZH0sci5wcm90b3R5cGUuZW5kUmVxdWVzdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54aHI/KHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlclJlcXVlc3RFbmQoKSxudWxsIT10JiZ0LmNhbGwodGhpcyksdGhpcy5kZXN0cm95KCkpOnZvaWQgMH0sci5wcm90b3R5cGUuc2V0UHJvZ3Jlc3M9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHRoaXMucHJvZ3Jlc3M9dCxcImZ1bmN0aW9uXCI9PXR5cGVvZihlPXRoaXMuZGVsZWdhdGUpLnJlcXVlc3RQcm9ncmVzc2VkP2UucmVxdWVzdFByb2dyZXNzZWQodGhpcy5wcm9ncmVzcyk6dm9pZCAwfSxyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHRoaXMuc2V0UHJvZ3Jlc3MoMSksXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmRlbGVnYXRlKS5yZXF1ZXN0RmluaXNoZWQmJnQucmVxdWVzdEZpbmlzaGVkKCksdGhpcy5kZWxlZ2F0ZT1udWxsLHRoaXMueGhyPW51bGx9LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19O2UuUHJvZ3Jlc3NCYXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy50cmlja2xlPXQodGhpcy50cmlja2xlLHRoaXMpLHRoaXMuc3R5bGVzaGVldEVsZW1lbnQ9dGhpcy5jcmVhdGVTdHlsZXNoZWV0RWxlbWVudCgpLHRoaXMucHJvZ3Jlc3NFbGVtZW50PXRoaXMuY3JlYXRlUHJvZ3Jlc3NFbGVtZW50KCl9dmFyIHI7cmV0dXJuIHI9MzAwLGUuZGVmYXVsdENTUz1cIi50dXJib2xpbmtzLXByb2dyZXNzLWJhciB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBoZWlnaHQ6IDNweDtcXG4gIGJhY2tncm91bmQ6ICMwMDc2ZmY7XFxuICB6LWluZGV4OiA5OTk5O1xcbiAgdHJhbnNpdGlvbjogd2lkdGggXCIrcitcIm1zIGVhc2Utb3V0LCBvcGFjaXR5IFwiK3IvMitcIm1zIFwiK3IvMitcIm1zIGVhc2UtaW47XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcbn1cIixlLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlzaWJsZT92b2lkIDA6KHRoaXMudmlzaWJsZT0hMCx0aGlzLmluc3RhbGxTdHlsZXNoZWV0RWxlbWVudCgpLHRoaXMuaW5zdGFsbFByb2dyZXNzRWxlbWVudCgpLHRoaXMuc3RhcnRUcmlja2xpbmcoKSl9LGUucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aXNpYmxlJiYhdGhpcy5oaWRpbmc/KHRoaXMuaGlkaW5nPSEwLHRoaXMuZmFkZVByb2dyZXNzRWxlbWVudChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC51bmluc3RhbGxQcm9ncmVzc0VsZW1lbnQoKSx0LnN0b3BUcmlja2xpbmcoKSx0LnZpc2libGU9ITEsdC5oaWRpbmc9ITF9fSh0aGlzKSkpOnZvaWQgMH0sZS5wcm90b3R5cGUuc2V0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudmFsdWU9dCx0aGlzLnJlZnJlc2goKX0sZS5wcm90b3R5cGUuaW5zdGFsbFN0eWxlc2hlZXRFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmhlYWQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVzaGVldEVsZW1lbnQsZG9jdW1lbnQuaGVhZC5maXJzdENoaWxkKX0sZS5wcm90b3R5cGUuaW5zdGFsbFByb2dyZXNzRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZS53aWR0aD0wLHRoaXMucHJvZ3Jlc3NFbGVtZW50LnN0eWxlLm9wYWNpdHk9MSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMucHJvZ3Jlc3NFbGVtZW50LGRvY3VtZW50LmJvZHkpLHRoaXMucmVmcmVzaCgpfSxlLnByb3RvdHlwZS5mYWRlUHJvZ3Jlc3NFbGVtZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZS5vcGFjaXR5PTAsc2V0VGltZW91dCh0LDEuNSpyKX0sZS5wcm90b3R5cGUudW5pbnN0YWxsUHJvZ3Jlc3NFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NFbGVtZW50LnBhcmVudE5vZGU/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMucHJvZ3Jlc3NFbGVtZW50KTp2b2lkIDB9LGUucHJvdG90eXBlLnN0YXJ0VHJpY2tsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMudHJpY2tsZUludGVydmFsP3RoaXMudHJpY2tsZUludGVydmFsOnRoaXMudHJpY2tsZUludGVydmFsPXNldEludGVydmFsKHRoaXMudHJpY2tsZSxyKX0sZS5wcm90b3R5cGUuc3RvcFRyaWNrbGluZz1mdW5jdGlvbigpe3JldHVybiBjbGVhckludGVydmFsKHRoaXMudHJpY2tsZUludGVydmFsKSx0aGlzLnRyaWNrbGVJbnRlcnZhbD1udWxsfSxlLnByb3RvdHlwZS50cmlja2xlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZStNYXRoLnJhbmRvbSgpLzEwMCl9LGUucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LnByb2dyZXNzRWxlbWVudC5zdHlsZS53aWR0aD0xMCs5MCp0LnZhbHVlK1wiJVwifX0odGhpcykpfSxlLnByb3RvdHlwZS5jcmVhdGVTdHlsZXNoZWV0RWxlbWVudD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSx0LnR5cGU9XCJ0ZXh0L2Nzc1wiLHQudGV4dENvbnRlbnQ9dGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0Q1NTLHR9LGUucHJvdG90eXBlLmNyZWF0ZVByb2dyZXNzRWxlbWVudD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdC5jbGFzc05hbWU9XCJ0dXJib2xpbmtzLXByb2dyZXNzLWJhclwiLHR9LGV9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19O2UuQnJvd3NlckFkYXB0ZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHIpe3RoaXMuY29udHJvbGxlcj1yLHRoaXMuc2hvd1Byb2dyZXNzQmFyPXQodGhpcy5zaG93UHJvZ3Jlc3NCYXIsdGhpcyksdGhpcy5wcm9ncmVzc0Jhcj1uZXcgZS5Qcm9ncmVzc0Jhcn12YXIgbixvLGk7cmV0dXJuIGk9ZS5IdHRwUmVxdWVzdCxuPWkuTkVUV09SS19GQUlMVVJFLG89aS5USU1FT1VUX0ZBSUxVUkUsci5wcm90b3R5cGUudmlzaXRQcm9wb3NlZFRvTG9jYXRpb25XaXRoQWN0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29udHJvbGxlci5zdGFydFZpc2l0VG9Mb2NhdGlvbldpdGhBY3Rpb24odCxlKX0sci5wcm90b3R5cGUudmlzaXRTdGFydGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0Lmlzc3VlUmVxdWVzdCgpLHQuY2hhbmdlSGlzdG9yeSgpLHQubG9hZENhY2hlZFNuYXBzaG90KCl9LHIucHJvdG90eXBlLnZpc2l0UmVxdWVzdFN0YXJ0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NCYXIuc2V0VmFsdWUoMCksdC5oYXNDYWNoZWRTbmFwc2hvdCgpfHxcInJlc3RvcmVcIiE9PXQuYWN0aW9uP3RoaXMuc2hvd1Byb2dyZXNzQmFyQWZ0ZXJEZWxheSgpOnRoaXMuc2hvd1Byb2dyZXNzQmFyKCl9LHIucHJvdG90eXBlLnZpc2l0UmVxdWVzdFByb2dyZXNzZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NCYXIuc2V0VmFsdWUodC5wcm9ncmVzcyl9LHIucHJvdG90eXBlLnZpc2l0UmVxdWVzdENvbXBsZXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5sb2FkUmVzcG9uc2UoKX0sci5wcm90b3R5cGUudmlzaXRSZXF1ZXN0RmFpbGVkV2l0aFN0YXR1c0NvZGU9ZnVuY3Rpb24odCxlKXtzd2l0Y2goZSl7Y2FzZSBuOmNhc2UgbzpyZXR1cm4gdGhpcy5yZWxvYWQoKTtkZWZhdWx0OnJldHVybiB0LmxvYWRSZXNwb25zZSgpfX0sci5wcm90b3R5cGUudmlzaXRSZXF1ZXN0RmluaXNoZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGlkZVByb2dyZXNzQmFyKCl9LHIucHJvdG90eXBlLnZpc2l0Q29tcGxldGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0LmZvbGxvd1JlZGlyZWN0KCl9LHIucHJvdG90eXBlLnBhZ2VJbnZhbGlkYXRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlbG9hZCgpfSxyLnByb3RvdHlwZS5zaG93UHJvZ3Jlc3NCYXJBZnRlckRlbGF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NCYXJUaW1lb3V0PXNldFRpbWVvdXQodGhpcy5zaG93UHJvZ3Jlc3NCYXIsdGhpcy5jb250cm9sbGVyLnByb2dyZXNzQmFyRGVsYXkpfSxyLnByb3RvdHlwZS5zaG93UHJvZ3Jlc3NCYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9ncmVzc0Jhci5zaG93KCl9LHIucHJvdG90eXBlLmhpZGVQcm9ncmVzc0Jhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb2dyZXNzQmFyLmhpZGUoKSxjbGVhclRpbWVvdXQodGhpcy5wcm9ncmVzc0JhclRpbWVvdXQpfSxyLnByb3RvdHlwZS5yZWxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpfSxyfSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fTtlLkhpc3Rvcnk9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUpe3RoaXMuZGVsZWdhdGU9ZSx0aGlzLm9uUGFnZUxvYWQ9dCh0aGlzLm9uUGFnZUxvYWQsdGhpcyksdGhpcy5vblBvcFN0YXRlPXQodGhpcy5vblBvcFN0YXRlLHRoaXMpfXJldHVybiByLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0ZWQ/dm9pZCAwOihhZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIix0aGlzLm9uUG9wU3RhdGUsITEpLGFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsdGhpcy5vblBhZ2VMb2FkLCExKSx0aGlzLnN0YXJ0ZWQ9ITApfSxyLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnRlZD8ocmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsdGhpcy5vblBvcFN0YXRlLCExKSxyZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLHRoaXMub25QYWdlTG9hZCwhMSksdGhpcy5zdGFydGVkPSExKTp2b2lkIDB9LHIucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdD1lLkxvY2F0aW9uLndyYXAodCksdGhpcy51cGRhdGUoXCJwdXNoXCIsdCxyKX0sci5wcm90b3R5cGUucmVwbGFjZT1mdW5jdGlvbih0LHIpe3JldHVybiB0PWUuTG9jYXRpb24ud3JhcCh0KSx0aGlzLnVwZGF0ZShcInJlcGxhY2VcIix0LHIpfSxyLnByb3RvdHlwZS5vblBvcFN0YXRlPWZ1bmN0aW9uKHQpe3ZhciByLG4sbyxpO3JldHVybiB0aGlzLnNob3VsZEhhbmRsZVBvcFN0YXRlKCkmJihpPW51bGwhPShuPXQuc3RhdGUpP24udHVyYm9saW5rczp2b2lkIDApPyhyPWUuTG9jYXRpb24ud3JhcCh3aW5kb3cubG9jYXRpb24pLG89aS5yZXN0b3JhdGlvbklkZW50aWZpZXIsdGhpcy5kZWxlZ2F0ZS5oaXN0b3J5UG9wcGVkVG9Mb2NhdGlvbldpdGhSZXN0b3JhdGlvbklkZW50aWZpZXIocixvKSk6dm9pZCAwfSxyLnByb3RvdHlwZS5vblBhZ2VMb2FkPWZ1bmN0aW9uKHQpe3JldHVybiBlLmRlZmVyKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LnBhZ2VMb2FkZWQ9ITB9fSh0aGlzKSl9LHIucHJvdG90eXBlLnNob3VsZEhhbmRsZVBvcFN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFnZUlzTG9hZGVkKCl9LHIucHJvdG90eXBlLnBhZ2VJc0xvYWRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhZ2VMb2FkZWR8fFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGV9LHIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbih0LGUscil7dmFyIG47cmV0dXJuIG49e3R1cmJvbGlua3M6e3Jlc3RvcmF0aW9uSWRlbnRpZmllcjpyfX0saGlzdG9yeVt0K1wiU3RhdGVcIl0obixudWxsLGUpfSxyfSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7ZS5TbmFwc2hvdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGUscjtyPXQuaGVhZCxlPXQuYm9keSx0aGlzLmhlYWQ9bnVsbCE9cj9yOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIpLHRoaXMuYm9keT1udWxsIT1lP2U6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJvZHlcIil9cmV0dXJuIHQud3JhcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHRoaXM/dDp0aGlzLmZyb21IVE1MKHQpfSx0LmZyb21IVE1MPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpLGUuaW5uZXJIVE1MPXQsdGhpcy5mcm9tRWxlbWVudChlKX0sdC5mcm9tRWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHRoaXMoe2hlYWQ6dC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKSxib2R5OnQucXVlcnlTZWxlY3RvcihcImJvZHlcIil9KX0sdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHQoe2hlYWQ6dGhpcy5oZWFkLmNsb25lTm9kZSghMCksYm9keTp0aGlzLmJvZHkuY2xvbmVOb2RlKCEwKX0pfSx0LnByb3RvdHlwZS5nZXRSb290TG9jYXRpb249ZnVuY3Rpb24oKXt2YXIgdCxyO3JldHVybiByPW51bGwhPSh0PXRoaXMuZ2V0U2V0dGluZyhcInJvb3RcIikpP3Q6XCIvXCIsbmV3IGUuTG9jYXRpb24ocil9LHQucHJvdG90eXBlLmdldENhY2hlQ29udHJvbFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U2V0dGluZyhcImNhY2hlLWNvbnRyb2xcIil9LHQucHJvdG90eXBlLmdldEVsZW1lbnRGb3JBbmNob3I9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiB0aGlzLmJvZHkucXVlcnlTZWxlY3RvcihcIltpZD0nXCIrdCtcIiddLCBhW25hbWU9J1wiK3QrXCInXVwiKX1jYXRjaChlKXt9fSx0LnByb3RvdHlwZS5oYXNBbmNob3I9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXRoaXMuZ2V0RWxlbWVudEZvckFuY2hvcih0KX0sdC5wcm90b3R5cGUuaXNQcmV2aWV3YWJsZT1mdW5jdGlvbigpe3JldHVyblwibm8tcHJldmlld1wiIT09dGhpcy5nZXRDYWNoZUNvbnRyb2xWYWx1ZSgpfSx0LnByb3RvdHlwZS5pc0NhY2hlYWJsZT1mdW5jdGlvbigpe3JldHVyblwibm8tY2FjaGVcIiE9PXRoaXMuZ2V0Q2FjaGVDb250cm9sVmFsdWUoKX0sdC5wcm90b3R5cGUuaXNWaXNpdGFibGU9ZnVuY3Rpb24oKXtyZXR1cm5cInJlbG9hZFwiIT09dGhpcy5nZXRTZXR0aW5nKFwidmlzaXQtY29udHJvbFwiKX0sdC5wcm90b3R5cGUuZ2V0U2V0dGluZz1mdW5jdGlvbih0KXt2YXIgZSxyO3JldHVybiByPXRoaXMuaGVhZC5xdWVyeVNlbGVjdG9yQWxsKFwibWV0YVtuYW1lPSd0dXJib2xpbmtzLVwiK3QrXCInXVwiKSxlPXJbci5sZW5ndGgtMV0sbnVsbCE9ZT9lLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIik6dm9pZCAwfSx0fSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9W10uc2xpY2U7ZS5SZW5kZXJlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9dmFyIHI7cmV0dXJuIGUucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGUscixuLG87cmV0dXJuIG49YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLGU9Mzw9YXJndW1lbnRzLmxlbmd0aD90LmNhbGwoYXJndW1lbnRzLDIpOltdLG89ZnVuY3Rpb24odCxlLHIpe3IucHJvdG90eXBlPXQucHJvdG90eXBlO3ZhciBuPW5ldyByLG89dC5hcHBseShuLGUpO3JldHVybiBPYmplY3Qobyk9PT1vP286bn0odGhpcyxlLGZ1bmN0aW9uKCl7fSksby5kZWxlZ2F0ZT1uLG8ucmVuZGVyKHIpLG99LGUucHJvdG90eXBlLnJlbmRlclZpZXc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUudmlld1dpbGxSZW5kZXIodGhpcy5uZXdCb2R5KSx0KCksdGhpcy5kZWxlZ2F0ZS52aWV3UmVuZGVyZWQodGhpcy5uZXdCb2R5KX0sZS5wcm90b3R5cGUuaW52YWxpZGF0ZVZpZXc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZS52aWV3SW52YWxpZGF0ZWQoKX0sZS5wcm90b3R5cGUuY3JlYXRlU2NyaXB0RWxlbWVudD1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm5cImZhbHNlXCI9PT10LmdldEF0dHJpYnV0ZShcImRhdGEtdHVyYm9saW5rcy1ldmFsXCIpP3Q6KGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxlLnRleHRDb250ZW50PXQudGV4dENvbnRlbnQsZS5hc3luYz0hMSxyKGUsdCksZSl9LHI9ZnVuY3Rpb24odCxlKXt2YXIgcixuLG8saSxzLGEsdTtmb3IoaT1lLmF0dHJpYnV0ZXMsYT1bXSxyPTAsbj1pLmxlbmd0aDtuPnI7cisrKXM9aVtyXSxvPXMubmFtZSx1PXMudmFsdWUsYS5wdXNoKHQuc2V0QXR0cmlidXRlKG8sdSkpO3JldHVybiBhfSxlfSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7ZS5IZWFkRGV0YWlscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGUscixpLHMsYSx1LGw7Zm9yKHRoaXMuZWxlbWVudD10LHRoaXMuZWxlbWVudHM9e30sbD10aGlzLmVsZW1lbnQuY2hpbGROb2RlcyxzPTAsdT1sLmxlbmd0aDt1PnM7cysrKWk9bFtzXSxpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJihhPWkub3V0ZXJIVE1MLHI9bnVsbCE9KGU9dGhpcy5lbGVtZW50cylbYV0/ZVthXTplW2FdPXt0eXBlOm8oaSksdHJhY2tlZDpuKGkpLGVsZW1lbnRzOltdfSxyLmVsZW1lbnRzLnB1c2goaSkpfXZhciBlLHIsbixvO3JldHVybiB0LnByb3RvdHlwZS5oYXNFbGVtZW50V2l0aEtleT1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbiB0aGlzLmVsZW1lbnRzfSx0LnByb3RvdHlwZS5nZXRUcmFja2VkRWxlbWVudFNpZ25hdHVyZT1mdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHIsbjtyPXRoaXMuZWxlbWVudHMsbj1bXTtmb3IodCBpbiByKWU9clt0XS50cmFja2VkLGUmJm4ucHVzaCh0KTtyZXR1cm4gbn0uY2FsbCh0aGlzKS5qb2luKFwiXCIpfSx0LnByb3RvdHlwZS5nZXRTY3JpcHRFbGVtZW50c05vdEluRGV0YWlscz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRFbGVtZW50c01hdGNoaW5nVHlwZU5vdEluRGV0YWlscyhcInNjcmlwdFwiLHQpfSx0LnByb3RvdHlwZS5nZXRTdHlsZXNoZWV0RWxlbWVudHNOb3RJbkRldGFpbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNNYXRjaGluZ1R5cGVOb3RJbkRldGFpbHMoXCJzdHlsZXNoZWV0XCIsdCl9LHQucHJvdG90eXBlLmdldEVsZW1lbnRzTWF0Y2hpbmdUeXBlTm90SW5EZXRhaWxzPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixvLGkscyxhO289dGhpcy5lbGVtZW50cyxzPVtdO2ZvcihuIGluIG8paT1vW25dLGE9aS50eXBlLHI9aS5lbGVtZW50cyxhIT09dHx8ZS5oYXNFbGVtZW50V2l0aEtleShuKXx8cy5wdXNoKHJbMF0pO3JldHVybiBzfSx0LnByb3RvdHlwZS5nZXRQcm92aXNpb25hbEVsZW1lbnRzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4sbyxpLHM7cj1bXSxuPXRoaXMuZWxlbWVudHM7Zm9yKGUgaW4gbilvPW5bZV0scz1vLnR5cGUsaT1vLnRyYWNrZWQsdD1vLmVsZW1lbnRzLG51bGwhPXN8fGk/dC5sZW5ndGg+MSYmci5wdXNoLmFwcGx5KHIsdC5zbGljZSgxKSk6ci5wdXNoLmFwcGx5KHIsdCk7cmV0dXJuIHJ9LG89ZnVuY3Rpb24odCl7cmV0dXJuIGUodCk/XCJzY3JpcHRcIjpyKHQpP1wic3R5bGVzaGVldFwiOnZvaWQgMH0sbj1mdW5jdGlvbih0KXtyZXR1cm5cInJlbG9hZFwiPT09dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvbGlua3MtdHJhY2tcIil9LGU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9dC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXCJzY3JpcHRcIj09PWV9LHI9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9dC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXCJzdHlsZVwiPT09ZXx8XCJsaW5rXCI9PT1lJiZcInN0eWxlc2hlZXRcIj09PXQuZ2V0QXR0cmlidXRlKFwicmVsXCIpfSx0fSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fWZvcih2YXIgbyBpbiBlKXIuY2FsbChlLG8pJiYodFtvXT1lW29dKTtyZXR1cm4gbi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsdC5wcm90b3R5cGU9bmV3IG4sdC5fX3N1cGVyX189ZS5wcm90b3R5cGUsdH0scj17fS5oYXNPd25Qcm9wZXJ0eTtlLlNuYXBzaG90UmVuZGVyZXI9ZnVuY3Rpb24ocil7ZnVuY3Rpb24gbih0LHIsbil7dGhpcy5jdXJyZW50U25hcHNob3Q9dCx0aGlzLm5ld1NuYXBzaG90PXIsdGhpcy5pc1ByZXZpZXc9bix0aGlzLmN1cnJlbnRIZWFkRGV0YWlscz1uZXcgZS5IZWFkRGV0YWlscyh0aGlzLmN1cnJlbnRTbmFwc2hvdC5oZWFkKSx0aGlzLm5ld0hlYWREZXRhaWxzPW5ldyBlLkhlYWREZXRhaWxzKHRoaXMubmV3U25hcHNob3QuaGVhZCksdGhpcy5uZXdCb2R5PXRoaXMubmV3U25hcHNob3QuYm9keX1yZXR1cm4gdChuLHIpLG4ucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zaG91bGRSZW5kZXIoKT8odGhpcy5tZXJnZUhlYWQoKSx0aGlzLnJlbmRlclZpZXcoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUucmVwbGFjZUJvZHkoKSxlLmlzUHJldmlld3x8ZS5mb2N1c0ZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQoKSx0KCl9fSh0aGlzKSkpOnRoaXMuaW52YWxpZGF0ZVZpZXcoKX0sbi5wcm90b3R5cGUubWVyZ2VIZWFkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29weU5ld0hlYWRTdHlsZXNoZWV0RWxlbWVudHMoKSx0aGlzLmNvcHlOZXdIZWFkU2NyaXB0RWxlbWVudHMoKSx0aGlzLnJlbW92ZUN1cnJlbnRIZWFkUHJvdmlzaW9uYWxFbGVtZW50cygpLHRoaXMuY29weU5ld0hlYWRQcm92aXNpb25hbEVsZW1lbnRzKCl9LG4ucHJvdG90eXBlLnJlcGxhY2VCb2R5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWN0aXZhdGVCb2R5U2NyaXB0RWxlbWVudHMoKSx0aGlzLmltcG9ydEJvZHlQZXJtYW5lbnRFbGVtZW50cygpLHRoaXMuYXNzaWduTmV3Qm9keSgpfSxuLnByb3RvdHlwZS5zaG91bGRSZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXdTbmFwc2hvdC5pc1Zpc2l0YWJsZSgpJiZ0aGlzLnRyYWNrZWRFbGVtZW50c0FyZUlkZW50aWNhbCgpfSxuLnByb3RvdHlwZS50cmFja2VkRWxlbWVudHNBcmVJZGVudGljYWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50SGVhZERldGFpbHMuZ2V0VHJhY2tlZEVsZW1lbnRTaWduYXR1cmUoKT09PXRoaXMubmV3SGVhZERldGFpbHMuZ2V0VHJhY2tlZEVsZW1lbnRTaWduYXR1cmUoKX0sbi5wcm90b3R5cGUuY29weU5ld0hlYWRTdHlsZXNoZWV0RWxlbWVudHM9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixvO2ZvcihuPXRoaXMuZ2V0TmV3SGVhZFN0eWxlc2hlZXRFbGVtZW50cygpLG89W10sZT0wLHI9bi5sZW5ndGg7cj5lO2UrKyl0PW5bZV0sby5wdXNoKGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodCkpO3JldHVybiBvfSxuLnByb3RvdHlwZS5jb3B5TmV3SGVhZFNjcmlwdEVsZW1lbnRzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4sbztmb3Iobj10aGlzLmdldE5ld0hlYWRTY3JpcHRFbGVtZW50cygpLG89W10sZT0wLHI9bi5sZW5ndGg7cj5lO2UrKyl0PW5bZV0sby5wdXNoKGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVTY3JpcHRFbGVtZW50KHQpKSk7cmV0dXJuIG99LG4ucHJvdG90eXBlLnJlbW92ZUN1cnJlbnRIZWFkUHJvdmlzaW9uYWxFbGVtZW50cz1mdW5jdGlvbigpe3ZhciB0LGUscixuLG87Zm9yKG49dGhpcy5nZXRDdXJyZW50SGVhZFByb3Zpc2lvbmFsRWxlbWVudHMoKSxvPVtdLGU9MCxyPW4ubGVuZ3RoO3I+ZTtlKyspdD1uW2VdLG8ucHVzaChkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHQpKTtyZXR1cm4gb30sbi5wcm90b3R5cGUuY29weU5ld0hlYWRQcm92aXNpb25hbEVsZW1lbnRzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4sbztmb3Iobj10aGlzLmdldE5ld0hlYWRQcm92aXNpb25hbEVsZW1lbnRzKCksbz1bXSxlPTAscj1uLmxlbmd0aDtyPmU7ZSsrKXQ9bltlXSxvLnB1c2goZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0KSk7cmV0dXJuIG99LG4ucHJvdG90eXBlLmltcG9ydEJvZHlQZXJtYW5lbnRFbGVtZW50cz1mdW5jdGlvbigpe3ZhciB0LGUscixuLG8saTtmb3Iobj10aGlzLmdldE5ld0JvZHlQZXJtYW5lbnRFbGVtZW50cygpLGk9W10sZT0wLHI9bi5sZW5ndGg7cj5lO2UrKylvPW5bZV0sKHQ9dGhpcy5maW5kQ3VycmVudEJvZHlQZXJtYW5lbnRFbGVtZW50KG8pKT9pLnB1c2goby5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0LG8pKTppLnB1c2godm9pZCAwKTtyZXR1cm4gaX0sbi5wcm90b3R5cGUuYWN0aXZhdGVCb2R5U2NyaXB0RWxlbWVudHM9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixvLGk7Zm9yKG49dGhpcy5nZXROZXdCb2R5U2NyaXB0RWxlbWVudHMoKSxpPVtdLGU9MCxyPW4ubGVuZ3RoO3I+ZTtlKyspbz1uW2VdLHQ9dGhpcy5jcmVhdGVTY3JpcHRFbGVtZW50KG8pLGkucHVzaChvLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHQsbykpO3JldHVybiBpfSxuLnByb3RvdHlwZS5hc3NpZ25OZXdCb2R5PWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmJvZHk9dGhpcy5uZXdCb2R5fSxuLnByb3RvdHlwZS5mb2N1c0ZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbnVsbCE9KHQ9dGhpcy5maW5kRmlyc3RBdXRvZm9jdXNhYmxlRWxlbWVudCgpKT90LmZvY3VzKCk6dm9pZCAwfSxuLnByb3RvdHlwZS5nZXROZXdIZWFkU3R5bGVzaGVldEVsZW1lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV3SGVhZERldGFpbHMuZ2V0U3R5bGVzaGVldEVsZW1lbnRzTm90SW5EZXRhaWxzKHRoaXMuY3VycmVudEhlYWREZXRhaWxzKX0sbi5wcm90b3R5cGUuZ2V0TmV3SGVhZFNjcmlwdEVsZW1lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV3SGVhZERldGFpbHMuZ2V0U2NyaXB0RWxlbWVudHNOb3RJbkRldGFpbHModGhpcy5jdXJyZW50SGVhZERldGFpbHMpfSxuLnByb3RvdHlwZS5nZXRDdXJyZW50SGVhZFByb3Zpc2lvbmFsRWxlbWVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50SGVhZERldGFpbHMuZ2V0UHJvdmlzaW9uYWxFbGVtZW50cygpfSxuLnByb3RvdHlwZS5nZXROZXdIZWFkUHJvdmlzaW9uYWxFbGVtZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5ld0hlYWREZXRhaWxzLmdldFByb3Zpc2lvbmFsRWxlbWVudHMoKX0sbi5wcm90b3R5cGUuZ2V0TmV3Qm9keVBlcm1hbmVudEVsZW1lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV3Qm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkXVtkYXRhLXR1cmJvbGlua3MtcGVybWFuZW50XVwiKX0sbi5wcm90b3R5cGUuZmluZEN1cnJlbnRCb2R5UGVybWFuZW50RWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKFwiI1wiK3QuaWQrXCJbZGF0YS10dXJib2xpbmtzLXBlcm1hbmVudF1cIil9LG4ucHJvdG90eXBlLmdldE5ld0JvZHlTY3JpcHRFbGVtZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5ld0JvZHkucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFwiKX0sbi5wcm90b3R5cGUuZmluZEZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKFwiW2F1dG9mb2N1c11cIil9LG59KGUuUmVuZGVyZXIpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fWZvcih2YXIgbyBpbiBlKXIuY2FsbChlLG8pJiYodFtvXT1lW29dKTtyZXR1cm4gbi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsdC5wcm90b3R5cGU9bmV3IG4sdC5fX3N1cGVyX189ZS5wcm90b3R5cGUsdH0scj17fS5oYXNPd25Qcm9wZXJ0eTtlLkVycm9yUmVuZGVyZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcih0KXt0aGlzLmh0bWw9dH1yZXR1cm4gdChyLGUpLHIucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZW5kZXJWaWV3KGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLnJlcGxhY2VEb2N1bWVudEhUTUwoKSxlLmFjdGl2YXRlQm9keVNjcmlwdEVsZW1lbnRzKCksdCgpfX0odGhpcykpfSxyLnByb3RvdHlwZS5yZXBsYWNlRG9jdW1lbnRIVE1MPWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUw9dGhpcy5odG1sfSxyLnByb3RvdHlwZS5hY3RpdmF0ZUJvZHlTY3JpcHRFbGVtZW50cz1mdW5jdGlvbigpe3ZhciB0LGUscixuLG8saTtmb3Iobj10aGlzLmdldFNjcmlwdEVsZW1lbnRzKCksaT1bXSxlPTAscj1uLmxlbmd0aDtyPmU7ZSsrKW89bltlXSx0PXRoaXMuY3JlYXRlU2NyaXB0RWxlbWVudChvKSxpLnB1c2goby5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0LG8pKTtyZXR1cm4gaX0sci5wcm90b3R5cGUuZ2V0U2NyaXB0RWxlbWVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRcIil9LHJ9KGUuUmVuZGVyZXIpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7ZS5WaWV3PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmRlbGVnYXRlPXQsdGhpcy5lbGVtZW50PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudH1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Um9vdExvY2F0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U25hcHNob3QoKS5nZXRSb290TG9jYXRpb24oKX0sdC5wcm90b3R5cGUuZ2V0RWxlbWVudEZvckFuY2hvcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRTbmFwc2hvdCgpLmdldEVsZW1lbnRGb3JBbmNob3IodCl9LHQucHJvdG90eXBlLmdldFNuYXBzaG90PWZ1bmN0aW9uKCl7cmV0dXJuIGUuU25hcHNob3QuZnJvbUVsZW1lbnQodGhpcy5lbGVtZW50KX0sdC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixvO3JldHVybiBvPXQuc25hcHNob3Qscj10LmVycm9yLG49dC5pc1ByZXZpZXcsdGhpcy5tYXJrQXNQcmV2aWV3KG4pLG51bGwhPW8/dGhpcy5yZW5kZXJTbmFwc2hvdChvLG4sZSk6dGhpcy5yZW5kZXJFcnJvcihyLGUpfSx0LnByb3RvdHlwZS5tYXJrQXNQcmV2aWV3PWZ1bmN0aW9uKHQpe3JldHVybiB0P3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvbGlua3MtcHJldmlld1wiLFwiXCIpOnRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvbGlua3MtcHJldmlld1wiKX0sdC5wcm90b3R5cGUucmVuZGVyU25hcHNob3Q9ZnVuY3Rpb24odCxyLG4pe3JldHVybiBlLlNuYXBzaG90UmVuZGVyZXIucmVuZGVyKHRoaXMuZGVsZWdhdGUsbix0aGlzLmdldFNuYXBzaG90KCksZS5TbmFwc2hvdC53cmFwKHQpLHIpfSx0LnByb3RvdHlwZS5yZW5kZXJFcnJvcj1mdW5jdGlvbih0LHIpe3JldHVybiBlLkVycm9yUmVuZGVyZXIucmVuZGVyKHRoaXMuZGVsZWdhdGUscix0KX0sdH0oKX0uY2FsbCh0aGlzKSxmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX07ZS5TY3JvbGxNYW5hZ2VyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLmRlbGVnYXRlPXIsdGhpcy5vblNjcm9sbD10KHRoaXMub25TY3JvbGwsdGhpcyksdGhpcy5vblNjcm9sbD1lLnRocm90dGxlKHRoaXMub25TY3JvbGwpfXJldHVybiByLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0ZWQ/dm9pZCAwOihhZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbCwhMSksdGhpcy5vblNjcm9sbCgpLHRoaXMuc3RhcnRlZD0hMCl9LHIucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydGVkPyhyZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbCwhMSksdGhpcy5zdGFydGVkPSExKTp2b2lkIDB9LHIucHJvdG90eXBlLnNjcm9sbFRvRWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdC5zY3JvbGxJbnRvVmlldygpfSxyLnByb3RvdHlwZS5zY3JvbGxUb1Bvc2l0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlLHI7cmV0dXJuIGU9dC54LHI9dC55LHdpbmRvdy5zY3JvbGxUbyhlLHIpfSxyLnByb3RvdHlwZS5vblNjcm9sbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy51cGRhdGVQb3NpdGlvbih7eDp3aW5kb3cucGFnZVhPZmZzZXQseTp3aW5kb3cucGFnZVlPZmZzZXR9KX0sci5wcm90b3R5cGUudXBkYXRlUG9zaXRpb249ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHRoaXMucG9zaXRpb249dCxudWxsIT0oZT10aGlzLmRlbGVnYXRlKT9lLnNjcm9sbFBvc2l0aW9uQ2hhbmdlZCh0aGlzLnBvc2l0aW9uKTp2b2lkIDB9LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXtlLlNuYXBzaG90Q2FjaGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuc2l6ZT10LHRoaXMua2V5cz1bXSx0aGlzLnNuYXBzaG90cz17fX12YXIgcjtyZXR1cm4gdC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXIodCksZSBpbiB0aGlzLnNuYXBzaG90c30sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3ZhciBlO2lmKHRoaXMuaGFzKHQpKXJldHVybiBlPXRoaXMucmVhZCh0KSx0aGlzLnRvdWNoKHQpLGV9LHQucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLndyaXRlKHQsZSksdGhpcy50b3VjaCh0KSxlfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXIodCksdGhpcy5zbmFwc2hvdHNbZV19LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIG49cih0KSx0aGlzLnNuYXBzaG90c1tuXT1lfSx0LnByb3RvdHlwZS50b3VjaD1mdW5jdGlvbih0KXt2YXIgZSxuO3JldHVybiBuPXIodCksZT10aGlzLmtleXMuaW5kZXhPZihuKSxlPi0xJiZ0aGlzLmtleXMuc3BsaWNlKGUsMSksdGhpcy5rZXlzLnVuc2hpZnQobiksdGhpcy50cmltKCl9LHQucHJvdG90eXBlLnRyaW09ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixvO2ZvcihuPXRoaXMua2V5cy5zcGxpY2UodGhpcy5zaXplKSxvPVtdLHQ9MCxyPW4ubGVuZ3RoO3I+dDt0KyspZT1uW3RdLG8ucHVzaChkZWxldGUgdGhpcy5zbmFwc2hvdHNbZV0pO3JldHVybiBvfSxyPWZ1bmN0aW9uKHQpe3JldHVybiBlLkxvY2F0aW9uLndyYXAodCkudG9DYWNoZUtleSgpfSx0fSgpfS5jYWxsKHRoaXMpLGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fTtlLlZpc2l0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyLG4sbyl7dGhpcy5jb250cm9sbGVyPXIsdGhpcy5hY3Rpb249byx0aGlzLnBlcmZvcm1TY3JvbGw9dCh0aGlzLnBlcmZvcm1TY3JvbGwsdGhpcyksdGhpcy5pZGVudGlmaWVyPWUudXVpZCgpLHRoaXMubG9jYXRpb249ZS5Mb2NhdGlvbi53cmFwKG4pLHRoaXMuYWRhcHRlcj10aGlzLmNvbnRyb2xsZXIuYWRhcHRlcix0aGlzLnN0YXRlPVwiaW5pdGlhbGl6ZWRcIix0aGlzLnRpbWluZ01ldHJpY3M9e319dmFyIG47cmV0dXJuIHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuXCJpbml0aWFsaXplZFwiPT09dGhpcy5zdGF0ZT8odGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoXCJ2aXNpdFN0YXJ0XCIpLHRoaXMuc3RhdGU9XCJzdGFydGVkXCIsdGhpcy5hZGFwdGVyLnZpc2l0U3RhcnRlZCh0aGlzKSk6dm9pZCAwfSxyLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm5cInN0YXJ0ZWRcIj09PXRoaXMuc3RhdGU/KG51bGwhPSh0PXRoaXMucmVxdWVzdCkmJnQuY2FuY2VsKCksdGhpcy5jYW5jZWxSZW5kZXIoKSx0aGlzLnN0YXRlPVwiY2FuY2VsZWRcIik6dm9pZCAwfSxyLnByb3RvdHlwZS5jb21wbGV0ZT1mdW5jdGlvbigpe3ZhciB0O3JldHVyblwic3RhcnRlZFwiPT09dGhpcy5zdGF0ZT8odGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoXCJ2aXNpdEVuZFwiKSx0aGlzLnN0YXRlPVwiY29tcGxldGVkXCIsXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0Q29tcGxldGVkJiZ0LnZpc2l0Q29tcGxldGVkKHRoaXMpLHRoaXMuY29udHJvbGxlci52aXNpdENvbXBsZXRlZCh0aGlzKSk6dm9pZCAwfSxyLnByb3RvdHlwZS5mYWlsPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuXCJzdGFydGVkXCI9PT10aGlzLnN0YXRlPyh0aGlzLnN0YXRlPVwiZmFpbGVkXCIsXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0RmFpbGVkP3QudmlzaXRGYWlsZWQodGhpcyk6dm9pZCAwKTp2b2lkIDB9LHIucHJvdG90eXBlLmNoYW5nZUhpc3Rvcnk9ZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiB0aGlzLmhpc3RvcnlDaGFuZ2VkP3ZvaWQgMDoodD10aGlzLmxvY2F0aW9uLmlzRXF1YWxUbyh0aGlzLnJlZmVycmVyKT9cInJlcGxhY2VcIjp0aGlzLmFjdGlvbixlPW4odCksdGhpcy5jb250cm9sbGVyW2VdKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpLHRoaXMuaGlzdG9yeUNoYW5nZWQ9ITApfSxyLnByb3RvdHlwZS5pc3N1ZVJlcXVlc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaG91bGRJc3N1ZVJlcXVlc3QoKSYmbnVsbD09dGhpcy5yZXF1ZXN0Pyh0aGlzLnByb2dyZXNzPTAsdGhpcy5yZXF1ZXN0PW5ldyBlLkh0dHBSZXF1ZXN0KHRoaXMsdGhpcy5sb2NhdGlvbix0aGlzLnJlZmVycmVyKSx0aGlzLnJlcXVlc3Quc2VuZCgpKTp2b2lkIDB9LHIucHJvdG90eXBlLmdldENhY2hlZFNuYXBzaG90PWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuISh0PXRoaXMuY29udHJvbGxlci5nZXRDYWNoZWRTbmFwc2hvdEZvckxvY2F0aW9uKHRoaXMubG9jYXRpb24pKXx8bnVsbCE9dGhpcy5sb2NhdGlvbi5hbmNob3ImJiF0Lmhhc0FuY2hvcih0aGlzLmxvY2F0aW9uLmFuY2hvcil8fFwicmVzdG9yZVwiIT09dGhpcy5hY3Rpb24mJiF0LmlzUHJldmlld2FibGUoKT92b2lkIDA6dH0sci5wcm90b3R5cGUuaGFzQ2FjaGVkU25hcHNob3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRDYWNoZWRTbmFwc2hvdCgpfSxyLnByb3RvdHlwZS5sb2FkQ2FjaGVkU25hcHNob3Q9ZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybihlPXRoaXMuZ2V0Q2FjaGVkU25hcHNob3QoKSk/KHQ9dGhpcy5zaG91bGRJc3N1ZVJlcXVlc3QoKSx0aGlzLnJlbmRlcihmdW5jdGlvbigpe3ZhciByO3JldHVybiB0aGlzLmNhY2hlU25hcHNob3QoKSx0aGlzLmNvbnRyb2xsZXIucmVuZGVyKHtzbmFwc2hvdDplLGlzUHJldmlldzp0fSx0aGlzLnBlcmZvcm1TY3JvbGwpLFwiZnVuY3Rpb25cIj09dHlwZW9mKHI9dGhpcy5hZGFwdGVyKS52aXNpdFJlbmRlcmVkJiZyLnZpc2l0UmVuZGVyZWQodGhpcyksdD92b2lkIDA6dGhpcy5jb21wbGV0ZSgpfSkpOnZvaWQgMH0sci5wcm90b3R5cGUubG9hZFJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMucmVzcG9uc2U/dGhpcy5yZW5kZXIoZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiB0aGlzLmNhY2hlU25hcHNob3QoKSx0aGlzLnJlcXVlc3QuZmFpbGVkPyh0aGlzLmNvbnRyb2xsZXIucmVuZGVyKHtlcnJvcjp0aGlzLnJlc3BvbnNlfSx0aGlzLnBlcmZvcm1TY3JvbGwpLFwiZnVuY3Rpb25cIj09dHlwZW9mKHQ9dGhpcy5hZGFwdGVyKS52aXNpdFJlbmRlcmVkJiZ0LnZpc2l0UmVuZGVyZWQodGhpcyksdGhpcy5mYWlsKCkpOih0aGlzLmNvbnRyb2xsZXIucmVuZGVyKHtzbmFwc2hvdDp0aGlzLnJlc3BvbnNlfSx0aGlzLnBlcmZvcm1TY3JvbGwpLFwiZnVuY3Rpb25cIj09dHlwZW9mKGU9dGhpcy5hZGFwdGVyKS52aXNpdFJlbmRlcmVkJiZlLnZpc2l0UmVuZGVyZWQodGhpcyksdGhpcy5jb21wbGV0ZSgpKX0pOnZvaWQgMH0sci5wcm90b3R5cGUuZm9sbG93UmVkaXJlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWRpcmVjdGVkVG9Mb2NhdGlvbiYmIXRoaXMuZm9sbG93ZWRSZWRpcmVjdD8odGhpcy5sb2NhdGlvbj10aGlzLnJlZGlyZWN0ZWRUb0xvY2F0aW9uLHRoaXMuY29udHJvbGxlci5yZXBsYWNlSGlzdG9yeVdpdGhMb2NhdGlvbkFuZFJlc3RvcmF0aW9uSWRlbnRpZmllcih0aGlzLnJlZGlyZWN0ZWRUb0xvY2F0aW9uLHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyKSx0aGlzLmZvbGxvd2VkUmVkaXJlY3Q9ITApOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdFN0YXJ0ZWQ9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gdGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoXCJyZXF1ZXN0U3RhcnRcIiksXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0UmVxdWVzdFN0YXJ0ZWQ/dC52aXNpdFJlcXVlc3RTdGFydGVkKHRoaXMpOnZvaWQgMH0sci5wcm90b3R5cGUucmVxdWVzdFByb2dyZXNzZWQ9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHRoaXMucHJvZ3Jlc3M9dCxcImZ1bmN0aW9uXCI9PXR5cGVvZihlPXRoaXMuYWRhcHRlcikudmlzaXRSZXF1ZXN0UHJvZ3Jlc3NlZD9lLnZpc2l0UmVxdWVzdFByb2dyZXNzZWQodGhpcyk6dm9pZCAwfSxyLnByb3RvdHlwZS5yZXF1ZXN0Q29tcGxldGVkV2l0aFJlc3BvbnNlPWZ1bmN0aW9uKHQscil7cmV0dXJuIHRoaXMucmVzcG9uc2U9dCxudWxsIT1yJiYodGhpcy5yZWRpcmVjdGVkVG9Mb2NhdGlvbj1lLkxvY2F0aW9uLndyYXAocikpLHRoaXMuYWRhcHRlci52aXNpdFJlcXVlc3RDb21wbGV0ZWQodGhpcyl9LHIucHJvdG90eXBlLnJlcXVlc3RGYWlsZWRXaXRoU3RhdHVzQ29kZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnJlc3BvbnNlPWUsdGhpcy5hZGFwdGVyLnZpc2l0UmVxdWVzdEZhaWxlZFdpdGhTdGF0dXNDb2RlKHRoaXMsdCl9LHIucHJvdG90eXBlLnJlcXVlc3RGaW5pc2hlZD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0aGlzLnJlY29yZFRpbWluZ01ldHJpYyhcInJlcXVlc3RFbmRcIiksXCJmdW5jdGlvblwiPT10eXBlb2YodD10aGlzLmFkYXB0ZXIpLnZpc2l0UmVxdWVzdEZpbmlzaGVkP3QudmlzaXRSZXF1ZXN0RmluaXNoZWQodGhpcyk6dm9pZCAwfSxyLnByb3RvdHlwZS5wZXJmb3JtU2Nyb2xsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2Nyb2xsZWQ/dm9pZCAwOihcInJlc3RvcmVcIj09PXRoaXMuYWN0aW9uP3RoaXMuc2Nyb2xsVG9SZXN0b3JlZFBvc2l0aW9uKCl8fHRoaXMuc2Nyb2xsVG9Ub3AoKTp0aGlzLnNjcm9sbFRvQW5jaG9yKCl8fHRoaXMuc2Nyb2xsVG9Ub3AoKSx0aGlzLnNjcm9sbGVkPSEwKX0sci5wcm90b3R5cGUuc2Nyb2xsVG9SZXN0b3JlZFBvc2l0aW9uPWZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gdD1udWxsIT0oZT10aGlzLnJlc3RvcmF0aW9uRGF0YSk/ZS5zY3JvbGxQb3NpdGlvbjp2b2lkIDAsbnVsbCE9dD8odGhpcy5jb250cm9sbGVyLnNjcm9sbFRvUG9zaXRpb24odCksITApOnZvaWQgMH0sci5wcm90b3R5cGUuc2Nyb2xsVG9BbmNob3I9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5sb2NhdGlvbi5hbmNob3I/KHRoaXMuY29udHJvbGxlci5zY3JvbGxUb0FuY2hvcih0aGlzLmxvY2F0aW9uLmFuY2hvciksITApOnZvaWQgMH0sci5wcm90b3R5cGUuc2Nyb2xsVG9Ub3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250cm9sbGVyLnNjcm9sbFRvUG9zaXRpb24oe3g6MCx5OjB9KX0sci5wcm90b3R5cGUucmVjb3JkVGltaW5nTWV0cmljPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBudWxsIT0oZT10aGlzLnRpbWluZ01ldHJpY3MpW3RdP2VbdF06ZVt0XT0obmV3IERhdGUpLmdldFRpbWUoKX0sci5wcm90b3R5cGUuZ2V0VGltaW5nTWV0cmljcz1mdW5jdGlvbigpe3JldHVybiBlLmNvcHlPYmplY3QodGhpcy50aW1pbmdNZXRyaWNzKX0sbj1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwicmVwbGFjZVwiOnJldHVyblwicmVwbGFjZUhpc3RvcnlXaXRoTG9jYXRpb25BbmRSZXN0b3JhdGlvbklkZW50aWZpZXJcIjtjYXNlXCJhZHZhbmNlXCI6Y2FzZVwicmVzdG9yZVwiOnJldHVyblwicHVzaEhpc3RvcnlXaXRoTG9jYXRpb25BbmRSZXN0b3JhdGlvbklkZW50aWZpZXJcIn19LHIucHJvdG90eXBlLnNob3VsZElzc3VlUmVxdWVzdD1mdW5jdGlvbigpe3JldHVyblwicmVzdG9yZVwiPT09dGhpcy5hY3Rpb24/IXRoaXMuaGFzQ2FjaGVkU25hcHNob3QoKTohMH0sci5wcm90b3R5cGUuY2FjaGVTbmFwc2hvdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNuYXBzaG90Q2FjaGVkP3ZvaWQgMDoodGhpcy5jb250cm9sbGVyLmNhY2hlU25hcHNob3QoKSx0aGlzLnNuYXBzaG90Q2FjaGVkPSEwKX0sci5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNhbmNlbFJlbmRlcigpLHRoaXMuZnJhbWU9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmZyYW1lPW51bGwsdC5jYWxsKGUpfX0odGhpcykpfSxyLnByb3RvdHlwZS5jYW5jZWxSZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mcmFtZT9jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lKTp2b2lkIDB9LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19O2UuQ29udHJvbGxlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHIoKXt0aGlzLmNsaWNrQnViYmxlZD10KHRoaXMuY2xpY2tCdWJibGVkLHRoaXMpLHRoaXMuY2xpY2tDYXB0dXJlZD10KHRoaXMuY2xpY2tDYXB0dXJlZCx0aGlzKSx0aGlzLnBhZ2VMb2FkZWQ9dCh0aGlzLnBhZ2VMb2FkZWQsdGhpcyksdGhpcy5oaXN0b3J5PW5ldyBlLkhpc3RvcnkodGhpcyksdGhpcy52aWV3PW5ldyBlLlZpZXcodGhpcyksdGhpcy5zY3JvbGxNYW5hZ2VyPW5ldyBlLlNjcm9sbE1hbmFnZXIodGhpcyksdGhpcy5yZXN0b3JhdGlvbkRhdGE9e30sdGhpcy5jbGVhckNhY2hlKCksdGhpcy5zZXRQcm9ncmVzc0JhckRlbGF5KDUwMCl9cmV0dXJuIHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIGUuc3VwcG9ydGVkJiYhdGhpcy5zdGFydGVkPyhhZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmNsaWNrQ2FwdHVyZWQsITApLGFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsdGhpcy5wYWdlTG9hZGVkLCExKSx0aGlzLnNjcm9sbE1hbmFnZXIuc3RhcnQoKSx0aGlzLnN0YXJ0SGlzdG9yeSgpLHRoaXMuc3RhcnRlZD0hMCx0aGlzLmVuYWJsZWQ9ITApOnZvaWQgMH0sci5wcm90b3R5cGUuZGlzYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWQ9ITF9LHIucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydGVkPyhyZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmNsaWNrQ2FwdHVyZWQsITApLHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsdGhpcy5wYWdlTG9hZGVkLCExKSx0aGlzLnNjcm9sbE1hbmFnZXIuc3RvcCgpLHRoaXMuc3RvcEhpc3RvcnkoKSx0aGlzLnN0YXJ0ZWQ9ITEpOnZvaWQgMH0sci5wcm90b3R5cGUuY2xlYXJDYWNoZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhY2hlPW5ldyBlLlNuYXBzaG90Q2FjaGUoMTApfSxyLnByb3RvdHlwZS52aXNpdD1mdW5jdGlvbih0LHIpe3ZhciBuLG87cmV0dXJuIG51bGw9PXImJihyPXt9KSx0PWUuTG9jYXRpb24ud3JhcCh0KSx0aGlzLmFwcGxpY2F0aW9uQWxsb3dzVmlzaXRpbmdMb2NhdGlvbih0KT90aGlzLmxvY2F0aW9uSXNWaXNpdGFibGUodCk/KG49bnVsbCE9KG89ci5hY3Rpb24pP286XCJhZHZhbmNlXCIsdGhpcy5hZGFwdGVyLnZpc2l0UHJvcG9zZWRUb0xvY2F0aW9uV2l0aEFjdGlvbih0LG4pKTp3aW5kb3cubG9jYXRpb249dDp2b2lkIDB9LHIucHJvdG90eXBlLnN0YXJ0VmlzaXRUb0xvY2F0aW9uV2l0aEFjdGlvbj1mdW5jdGlvbih0LHIsbil7dmFyIG87cmV0dXJuIGUuc3VwcG9ydGVkPyhvPXRoaXMuZ2V0UmVzdG9yYXRpb25EYXRhRm9ySWRlbnRpZmllcihuKSx0aGlzLnN0YXJ0VmlzaXQodCxyLHtyZXN0b3JhdGlvbkRhdGE6b30pKTp3aW5kb3cubG9jYXRpb249dH0sci5wcm90b3R5cGUuc2V0UHJvZ3Jlc3NCYXJEZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wcm9ncmVzc0JhckRlbGF5PXR9LHIucHJvdG90eXBlLnN0YXJ0SGlzdG9yeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2F0aW9uPWUuTG9jYXRpb24ud3JhcCh3aW5kb3cubG9jYXRpb24pLHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyPWUudXVpZCgpLHRoaXMuaGlzdG9yeS5zdGFydCgpLHRoaXMuaGlzdG9yeS5yZXBsYWNlKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpfSxyLnByb3RvdHlwZS5zdG9wSGlzdG9yeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpc3Rvcnkuc3RvcCgpfSxyLnByb3RvdHlwZS5wdXNoSGlzdG9yeVdpdGhMb2NhdGlvbkFuZFJlc3RvcmF0aW9uSWRlbnRpZmllcj1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcj1yLHRoaXMubG9jYXRpb249ZS5Mb2NhdGlvbi53cmFwKHQpLHRoaXMuaGlzdG9yeS5wdXNoKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpfSxyLnByb3RvdHlwZS5yZXBsYWNlSGlzdG9yeVdpdGhMb2NhdGlvbkFuZFJlc3RvcmF0aW9uSWRlbnRpZmllcj1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcj1yLHRoaXMubG9jYXRpb249ZS5Mb2NhdGlvbi53cmFwKHQpLHRoaXMuaGlzdG9yeS5yZXBsYWNlKHRoaXMubG9jYXRpb24sdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXIpfSxyLnByb3RvdHlwZS5oaXN0b3J5UG9wcGVkVG9Mb2NhdGlvbldpdGhSZXN0b3JhdGlvbklkZW50aWZpZXI9ZnVuY3Rpb24odCxyKXt2YXIgbjtyZXR1cm4gdGhpcy5yZXN0b3JhdGlvbklkZW50aWZpZXI9cix0aGlzLmVuYWJsZWQ/KG49dGhpcy5nZXRSZXN0b3JhdGlvbkRhdGFGb3JJZGVudGlmaWVyKHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyKSx0aGlzLnN0YXJ0VmlzaXQodCxcInJlc3RvcmVcIix7cmVzdG9yYXRpb25JZGVudGlmaWVyOnRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyLHJlc3RvcmF0aW9uRGF0YTpuLGhpc3RvcnlDaGFuZ2VkOiEwfSksdGhpcy5sb2NhdGlvbj1lLkxvY2F0aW9uLndyYXAodCkpOnRoaXMuYWRhcHRlci5wYWdlSW52YWxpZGF0ZWQoKX0sci5wcm90b3R5cGUuZ2V0Q2FjaGVkU25hcHNob3RGb3JMb2NhdGlvbj1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT10aGlzLmNhY2hlLmdldCh0KSxlP2UuY2xvbmUoKTp2b2lkIDB9LHIucHJvdG90eXBlLnNob3VsZENhY2hlU25hcHNob3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFNuYXBzaG90KCkuaXNDYWNoZWFibGUoKX0sci5wcm90b3R5cGUuY2FjaGVTbmFwc2hvdD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiB0aGlzLnNob3VsZENhY2hlU25hcHNob3QoKT8odGhpcy5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZUNhY2hpbmdTbmFwc2hvdCgpLHQ9dGhpcy52aWV3LmdldFNuYXBzaG90KCksdGhpcy5jYWNoZS5wdXQodGhpcy5sYXN0UmVuZGVyZWRMb2NhdGlvbix0LmNsb25lKCkpKTp2b2lkIDB9LHIucHJvdG90eXBlLnNjcm9sbFRvQW5jaG9yPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybihlPXRoaXMudmlldy5nZXRFbGVtZW50Rm9yQW5jaG9yKHQpKT90aGlzLnNjcm9sbFRvRWxlbWVudChlKTp0aGlzLnNjcm9sbFRvUG9zaXRpb24oe3g6MCx5OjB9KX0sci5wcm90b3R5cGUuc2Nyb2xsVG9FbGVtZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNjcm9sbE1hbmFnZXIuc2Nyb2xsVG9FbGVtZW50KHQpfSxyLnByb3RvdHlwZS5zY3JvbGxUb1Bvc2l0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNjcm9sbE1hbmFnZXIuc2Nyb2xsVG9Qb3NpdGlvbih0KX0sci5wcm90b3R5cGUuc2Nyb2xsUG9zaXRpb25DaGFuZ2VkPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXRoaXMuZ2V0Q3VycmVudFJlc3RvcmF0aW9uRGF0YSgpLGUuc2Nyb2xsUG9zaXRpb249dH0sci5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudmlldy5yZW5kZXIodCxlKX0sci5wcm90b3R5cGUudmlld0ludmFsaWRhdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWRhcHRlci5wYWdlSW52YWxpZGF0ZWQoKX0sci5wcm90b3R5cGUudmlld1dpbGxSZW5kZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm90aWZ5QXBwbGljYXRpb25CZWZvcmVSZW5kZXIodCl9LHIucHJvdG90eXBlLnZpZXdSZW5kZXJlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxhc3RSZW5kZXJlZExvY2F0aW9uPXRoaXMuY3VycmVudFZpc2l0LmxvY2F0aW9uLHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlclJlbmRlcigpfSxyLnByb3RvdHlwZS5wYWdlTG9hZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFzdFJlbmRlcmVkTG9jYXRpb249dGhpcy5sb2NhdGlvbix0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJQYWdlTG9hZCgpfSxyLnByb3RvdHlwZS5jbGlja0NhcHR1cmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuY2xpY2tCdWJibGVkLCExKSxhZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmNsaWNrQnViYmxlZCwhMSl9LHIucHJvdG90eXBlLmNsaWNrQnViYmxlZD1mdW5jdGlvbih0KXt2YXIgZSxyLG47cmV0dXJuIHRoaXMuZW5hYmxlZCYmdGhpcy5jbGlja0V2ZW50SXNTaWduaWZpY2FudCh0KSYmKHI9dGhpcy5nZXRWaXNpdGFibGVMaW5rRm9yTm9kZSh0LnRhcmdldCkpJiYobj10aGlzLmdldFZpc2l0YWJsZUxvY2F0aW9uRm9yTGluayhyKSkmJnRoaXMuYXBwbGljYXRpb25BbGxvd3NGb2xsb3dpbmdMaW5rVG9Mb2NhdGlvbihyLG4pPyh0LnByZXZlbnREZWZhdWx0KCksZT10aGlzLmdldEFjdGlvbkZvckxpbmsociksXG50aGlzLnZpc2l0KG4se2FjdGlvbjplfSkpOnZvaWQgMH0sci5wcm90b3R5cGUuYXBwbGljYXRpb25BbGxvd3NGb2xsb3dpbmdMaW5rVG9Mb2NhdGlvbj1mdW5jdGlvbih0LGUpe3ZhciByO3JldHVybiByPXRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlckNsaWNraW5nTGlua1RvTG9jYXRpb24odCxlKSwhci5kZWZhdWx0UHJldmVudGVkfSxyLnByb3RvdHlwZS5hcHBsaWNhdGlvbkFsbG93c1Zpc2l0aW5nTG9jYXRpb249ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9dGhpcy5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZVZpc2l0aW5nTG9jYXRpb24odCksIWUuZGVmYXVsdFByZXZlbnRlZH0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25BZnRlckNsaWNraW5nTGlua1RvTG9jYXRpb249ZnVuY3Rpb24odCxyKXtyZXR1cm4gZS5kaXNwYXRjaChcInR1cmJvbGlua3M6Y2xpY2tcIix7dGFyZ2V0OnQsZGF0YTp7dXJsOnIuYWJzb2x1dGVVUkx9LGNhbmNlbGFibGU6ITB9KX0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25CZWZvcmVWaXNpdGluZ0xvY2F0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpiZWZvcmUtdmlzaXRcIix7ZGF0YTp7dXJsOnQuYWJzb2x1dGVVUkx9LGNhbmNlbGFibGU6ITB9KX0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25BZnRlclZpc2l0aW5nTG9jYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIGUuZGlzcGF0Y2goXCJ0dXJib2xpbmtzOnZpc2l0XCIse2RhdGE6e3VybDp0LmFic29sdXRlVVJMfX0pfSxyLnByb3RvdHlwZS5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZUNhY2hpbmdTbmFwc2hvdD1mdW5jdGlvbigpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpiZWZvcmUtY2FjaGVcIil9LHIucHJvdG90eXBlLm5vdGlmeUFwcGxpY2F0aW9uQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKHQpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpiZWZvcmUtcmVuZGVyXCIse2RhdGE6e25ld0JvZHk6dH19KX0sci5wcm90b3R5cGUubm90aWZ5QXBwbGljYXRpb25BZnRlclJlbmRlcj1mdW5jdGlvbigpe3JldHVybiBlLmRpc3BhdGNoKFwidHVyYm9saW5rczpyZW5kZXJcIil9LHIucHJvdG90eXBlLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJQYWdlTG9hZD1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dCYmKHQ9e30pLGUuZGlzcGF0Y2goXCJ0dXJib2xpbmtzOmxvYWRcIix7ZGF0YTp7dXJsOnRoaXMubG9jYXRpb24uYWJzb2x1dGVVUkwsdGltaW5nOnR9fSl9LHIucHJvdG90eXBlLnN0YXJ0VmlzaXQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuO3JldHVybiBudWxsIT0obj10aGlzLmN1cnJlbnRWaXNpdCkmJm4uY2FuY2VsKCksdGhpcy5jdXJyZW50VmlzaXQ9dGhpcy5jcmVhdGVWaXNpdCh0LGUsciksdGhpcy5jdXJyZW50VmlzaXQuc3RhcnQoKSx0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJWaXNpdGluZ0xvY2F0aW9uKHQpfSxyLnByb3RvdHlwZS5jcmVhdGVWaXNpdD1mdW5jdGlvbih0LHIsbil7dmFyIG8saSxzLGEsdTtyZXR1cm4gaT1udWxsIT1uP246e30sYT1pLnJlc3RvcmF0aW9uSWRlbnRpZmllcixzPWkucmVzdG9yYXRpb25EYXRhLG89aS5oaXN0b3J5Q2hhbmdlZCx1PW5ldyBlLlZpc2l0KHRoaXMsdCxyKSx1LnJlc3RvcmF0aW9uSWRlbnRpZmllcj1udWxsIT1hP2E6ZS51dWlkKCksdS5yZXN0b3JhdGlvbkRhdGE9ZS5jb3B5T2JqZWN0KHMpLHUuaGlzdG9yeUNoYW5nZWQ9byx1LnJlZmVycmVyPXRoaXMubG9jYXRpb24sdX0sci5wcm90b3R5cGUudmlzaXRDb21wbGV0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlclBhZ2VMb2FkKHQuZ2V0VGltaW5nTWV0cmljcygpKX0sci5wcm90b3R5cGUuY2xpY2tFdmVudElzU2lnbmlmaWNhbnQ9ZnVuY3Rpb24odCl7cmV0dXJuISh0LmRlZmF1bHRQcmV2ZW50ZWR8fHQudGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlfHx0LndoaWNoPjF8fHQuYWx0S2V5fHx0LmN0cmxLZXl8fHQubWV0YUtleXx8dC5zaGlmdEtleSl9LHIucHJvdG90eXBlLmdldFZpc2l0YWJsZUxpbmtGb3JOb2RlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVJc1Zpc2l0YWJsZSh0KT9lLmNsb3Nlc3QodCxcImFbaHJlZl06bm90KFt0YXJnZXRdKTpub3QoW2Rvd25sb2FkXSlcIik6dm9pZCAwfSxyLnByb3RvdHlwZS5nZXRWaXNpdGFibGVMb2NhdGlvbkZvckxpbms9ZnVuY3Rpb24odCl7dmFyIHI7cmV0dXJuIHI9bmV3IGUuTG9jYXRpb24odC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSx0aGlzLmxvY2F0aW9uSXNWaXNpdGFibGUocik/cjp2b2lkIDB9LHIucHJvdG90eXBlLmdldEFjdGlvbkZvckxpbms9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIG51bGwhPShlPXQuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJib2xpbmtzLWFjdGlvblwiKSk/ZTpcImFkdmFuY2VcIn0sci5wcm90b3R5cGUubm9kZUlzVmlzaXRhYmxlPWZ1bmN0aW9uKHQpe3ZhciByO3JldHVybihyPWUuY2xvc2VzdCh0LFwiW2RhdGEtdHVyYm9saW5rc11cIikpP1wiZmFsc2VcIiE9PXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJib2xpbmtzXCIpOiEwfSxyLnByb3RvdHlwZS5sb2NhdGlvbklzVmlzaXRhYmxlPWZ1bmN0aW9uKHQpe3JldHVybiB0LmlzUHJlZml4ZWRCeSh0aGlzLnZpZXcuZ2V0Um9vdExvY2F0aW9uKCkpJiZ0LmlzSFRNTCgpfSxyLnByb3RvdHlwZS5nZXRDdXJyZW50UmVzdG9yYXRpb25EYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UmVzdG9yYXRpb25EYXRhRm9ySWRlbnRpZmllcih0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcil9LHIucHJvdG90eXBlLmdldFJlc3RvcmF0aW9uRGF0YUZvcklkZW50aWZpZXI9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIG51bGwhPShlPXRoaXMucmVzdG9yYXRpb25EYXRhKVt0XT9lW3RdOmVbdF09e319LHJ9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXshZnVuY3Rpb24oKXt2YXIgdCxlO2lmKCh0PWU9ZG9jdW1lbnQuY3VycmVudFNjcmlwdCkmJiFlLmhhc0F0dHJpYnV0ZShcImRhdGEtdHVyYm9saW5rcy1zdXBwcmVzcy13YXJuaW5nXCIpKWZvcig7dD10LnBhcmVudE5vZGU7KWlmKHQ9PT1kb2N1bWVudC5ib2R5KXJldHVybiBjb25zb2xlLndhcm4oXCJZb3UgYXJlIGxvYWRpbmcgVHVyYm9saW5rcyBmcm9tIGEgPHNjcmlwdD4gZWxlbWVudCBpbnNpZGUgdGhlIDxib2R5PiBlbGVtZW50LiBUaGlzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHlvdSBtZWFudCB0byBkbyFcXG5cXG5Mb2FkIHlvdXIgYXBwbGljYXRpb25cXHUyMDE5cyBKYXZhU2NyaXB0IGJ1bmRsZSBpbnNpZGUgdGhlIDxoZWFkPiBlbGVtZW50IGluc3RlYWQuIDxzY3JpcHQ+IGVsZW1lbnRzIGluIDxib2R5PiBhcmUgZXZhbHVhdGVkIHdpdGggZWFjaCBwYWdlIGNoYW5nZS5cXG5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdHVyYm9saW5rcy90dXJib2xpbmtzI3dvcmtpbmctd2l0aC1zY3JpcHQtZWxlbWVudHNcXG5cXG5cXHUyMDE0XFx1MjAxNFxcblN1cHByZXNzIHRoaXMgd2FybmluZyBieSBhZGRpbmcgYSBgZGF0YS10dXJib2xpbmtzLXN1cHByZXNzLXdhcm5pbmdgIGF0dHJpYnV0ZSB0bzogJXNcIixlLm91dGVySFRNTCl9KCl9LmNhbGwodGhpcyksZnVuY3Rpb24oKXt2YXIgdCxyLG47ZS5zdGFydD1mdW5jdGlvbigpe3JldHVybiByKCk/KG51bGw9PWUuY29udHJvbGxlciYmKGUuY29udHJvbGxlcj10KCkpLGUuY29udHJvbGxlci5zdGFydCgpKTp2b2lkIDB9LHI9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09d2luZG93LlR1cmJvbGlua3MmJih3aW5kb3cuVHVyYm9saW5rcz1lKSxuKCl9LHQ9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gdD1uZXcgZS5Db250cm9sbGVyLHQuYWRhcHRlcj1uZXcgZS5Ccm93c2VyQWRhcHRlcih0KSx0fSxuPWZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5UdXJib2xpbmtzPT09ZX0sbigpJiZlLnN0YXJ0KCl9LmNhbGwodGhpcyl9KS5jYWxsKHRoaXMpLFwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWU6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoZSl9KS5jYWxsKHRoaXMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3R1cmJvbGlua3MvZGlzdC90dXJib2xpbmtzLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDciLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDciXSwic291cmNlUm9vdCI6IiJ9